
/*
RequireJS 2.1.4 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
Available via the MIT or new BSD license.
see: http://github.com/jrburke/requirejs for details
*/
var requirejs, require, define;
(function (Y) {
    function I(b) { return "[object Function]" === L.call(b) } function J(b) { return "[object Array]" === L.call(b) } function x(b, c) { if (b) { var d; for (d = 0; d < b.length && (!b[d] || !c(b[d], d, b)); d += 1); } } function M(b, c) { if (b) { var d; for (d = b.length - 1; -1 < d && (!b[d] || !c(b[d], d, b)); d -= 1); } } function r(b, c) { return da.call(b, c) } function i(b, c) { return r(b, c) && b[c] } function E(b, c) { for (var d in b) if (r(b, d) && c(b[d], d)) break } function Q(b, c, d, i) {
        c && E(c, function (c, h) {
            if (d || !r(b, h)) i && "string" !== typeof c ? (b[h] || (b[h] = {}), Q(b[h],
c, d, i)) : b[h] = c
        }); return b
    } function t(b, c) { return function () { return c.apply(b, arguments) } } function Z(b) { if (!b) return b; var c = Y; x(b.split("."), function (b) { c = c[b] }); return c } function F(b, c, d, i) { c = Error(c + "\nhttp://requirejs.org/docs/errors.html#" + b); c.requireType = b; c.requireModules = i; d && (c.originalError = d); return c } function ea(b) {
        function c(a, f, v) {
            var e, n, b, c, d, k, g, h = f && f.split("/"); e = h; var l = m.map, j = l && l["*"]; if (a && "." === a.charAt(0)) if (f) {
                e = i(m.pkgs, f) ? h = [f] : h.slice(0, h.length - 1); f = a = e.concat(a.split("/"));
                for (e = 0; f[e]; e += 1) if (n = f[e], "." === n) f.splice(e, 1), e -= 1; else if (".." === n) if (1 === e && (".." === f[2] || ".." === f[0])) break; else 0 < e && (f.splice(e - 1, 2), e -= 2); e = i(m.pkgs, f = a[0]); a = a.join("/"); e && a === f + "/" + e.main && (a = f)
            } else 0 === a.indexOf("./") && (a = a.substring(2)); if (v && (h || j) && l) {
                f = a.split("/"); for (e = f.length; 0 < e; e -= 1) { b = f.slice(0, e).join("/"); if (h) for (n = h.length; 0 < n; n -= 1) if (v = i(l, h.slice(0, n).join("/"))) if (v = i(v, b)) { c = v; d = e; break } if (c) break; !k && (j && i(j, b)) && (k = i(j, b), g = e) } !c && k && (c = k, d = g); c && (f.splice(0, d,
c), a = f.join("/"))
            } return a
        } function d(a) { z && x(document.getElementsByTagName("script"), function (f) { if (f.getAttribute("data-requiremodule") === a && f.getAttribute("data-requirecontext") === k.contextName) return f.parentNode.removeChild(f), !0 }) } function y(a) { var f = i(m.paths, a); if (f && J(f) && 1 < f.length) return d(a), f.shift(), k.require.undef(a), k.require([a]), !0 } function g(a) { var f, b = a ? a.indexOf("!") : -1; -1 < b && (f = a.substring(0, b), a = a.substring(b + 1, a.length)); return [f, a] } function h(a, f, b, e) {
            var n, u, d = null, h = f ? f.name :
null, l = a, m = !0, j = ""; a || (m = !1, a = "_@r" + (L += 1)); a = g(a); d = a[0]; a = a[1]; d && (d = c(d, h, e), u = i(p, d)); a && (d ? j = u && u.normalize ? u.normalize(a, function (a) { return c(a, h, e) }) : c(a, h, e) : (j = c(a, h, e), a = g(j), d = a[0], j = a[1], b = !0, n = k.nameToUrl(j))); b = d && !u && !b ? "_unnormalized" + (M += 1) : ""; return { prefix: d, name: j, parentMap: f, unnormalized: !!b, url: n, originalName: l, isDefine: m, id: (d ? d + "!" + j : j) + b}
        } function q(a) { var f = a.id, b = i(j, f); b || (b = j[f] = new k.Module(a)); return b } function s(a, f, b) {
            var e = a.id, n = i(j, e); if (r(p, e) && (!n || n.defineEmitComplete)) "defined" ===
f && b(p[e]); else q(a).on(f, b)
        } function A(a, f) { var b = a.requireModules, e = !1; if (f) f(a); else if (x(b, function (f) { if (f = i(j, f)) f.error = a, f.events.error && (e = !0, f.emit("error", a)) }), !e) l.onError(a) } function w() { R.length && (fa.apply(G, [G.length - 1, 0].concat(R)), R = []) } function B(a, f, b) { var e = a.map.id; a.error ? a.emit("error", a.error) : (f[e] = !0, x(a.depMaps, function (e, c) { var d = e.id, h = i(j, d); h && (!a.depMatched[c] && !b[d]) && (i(f, d) ? (a.defineDep(c, p[d]), a.check()) : B(h, f, b)) }), b[e] = !0) } function C() {
            var a, f, b, e, n = (b = 1E3 * m.waitSeconds) &&
k.startTime + b < (new Date).getTime(), c = [], h = [], g = !1, l = !0; if (!T) { T = !0; E(j, function (b) { a = b.map; f = a.id; if (b.enabled && (a.isDefine || h.push(b), !b.error)) if (!b.inited && n) y(f) ? g = e = !0 : (c.push(f), d(f)); else if (!b.inited && (b.fetched && a.isDefine) && (g = !0, !a.prefix)) return l = !1 }); if (n && c.length) return b = F("timeout", "Load timeout for modules: " + c, null, c), b.contextName = k.contextName, A(b); l && x(h, function (a) { B(a, {}, {}) }); if ((!n || e) && g) if ((z || $) && !U) U = setTimeout(function () { U = 0; C() }, 50); T = !1 } 
        } function D(a) {
            r(p, a[0]) ||
q(h(a[0], null, !0)).init(a[1], a[2])
        } function H(a) { var a = a.currentTarget || a.srcElement, b = k.onScriptLoad; a.detachEvent && !V ? a.detachEvent("onreadystatechange", b) : a.removeEventListener("load", b, !1); b = k.onScriptError; (!a.detachEvent || V) && a.removeEventListener("error", b, !1); return { node: a, id: a && a.getAttribute("data-requiremodule")} } function K() { var a; for (w(); G.length; ) { a = G.shift(); if (null === a[0]) return A(F("mismatch", "Mismatched anonymous define() module: " + a[a.length - 1])); D(a) } } var T, W, k, N, U, m = { waitSeconds: 7,
            baseUrl: "./", paths: {}, pkgs: {}, shim: {}, map: {}, config: {}
        }, j = {}, X = {}, G = [], p = {}, S = {}, L = 1, M = 1; N = { require: function (a) { return a.require ? a.require : a.require = k.makeRequire(a.map) }, exports: function (a) { a.usingExports = !0; if (a.map.isDefine) return a.exports ? a.exports : a.exports = p[a.map.id] = {} }, module: function (a) { return a.module ? a.module : a.module = { id: a.map.id, uri: a.map.url, config: function () { return m.config && i(m.config, a.map.id) || {} }, exports: p[a.map.id]} } }; W = function (a) {
            this.events = i(X, a.id) || {}; this.map = a; this.shim =
i(m.shim, a.id); this.depExports = []; this.depMaps = []; this.depMatched = []; this.pluginMaps = {}; this.depCount = 0
        }; W.prototype = { init: function (a, b, c, e) { e = e || {}; if (!this.inited) { this.factory = b; if (c) this.on("error", c); else this.events.error && (c = t(this, function (a) { this.emit("error", a) })); this.depMaps = a && a.slice(0); this.errback = c; this.inited = !0; this.ignore = e.ignore; e.enabled || this.enabled ? this.enable() : this.check() } }, defineDep: function (a, b) {
            this.depMatched[a] || (this.depMatched[a] = !0, this.depCount -= 1, this.depExports[a] =
b)
        }, fetch: function () { if (!this.fetched) { this.fetched = !0; k.startTime = (new Date).getTime(); var a = this.map; if (this.shim) k.makeRequire(this.map, { enableBuildCallback: !0 })(this.shim.deps || [], t(this, function () { return a.prefix ? this.callPlugin() : this.load() })); else return a.prefix ? this.callPlugin() : this.load() } }, load: function () { var a = this.map.url; S[a] || (S[a] = !0, k.load(this.map.id, a)) }, check: function () {
            if (this.enabled && !this.enabling) {
                var a, b, c = this.map.id; b = this.depExports; var e = this.exports, n = this.factory;
                if (this.inited) if (this.error) this.emit("error", this.error); else {
                    if (!this.defining) {
                        this.defining = !0; if (1 > this.depCount && !this.defined) {
                            if (I(n)) { if (this.events.error) try { e = k.execCb(c, n, b, e) } catch (d) { a = d } else e = k.execCb(c, n, b, e); this.map.isDefine && ((b = this.module) && void 0 !== b.exports && b.exports !== this.exports ? e = b.exports : void 0 === e && this.usingExports && (e = this.exports)); if (a) return a.requireMap = this.map, a.requireModules = [this.map.id], a.requireType = "define", A(this.error = a) } else e = n; this.exports = e; if (this.map.isDefine &&
!this.ignore && (p[c] = e, l.onResourceLoad)) l.onResourceLoad(k, this.map, this.depMaps); delete j[c]; this.defined = !0
                        } this.defining = !1; this.defined && !this.defineEmitted && (this.defineEmitted = !0, this.emit("defined", this.exports), this.defineEmitComplete = !0)
                    } 
                } else this.fetch()
            } 
        }, callPlugin: function () {
            var a = this.map, b = a.id, d = h(a.prefix); this.depMaps.push(d); s(d, "defined", t(this, function (e) {
                var n, d; d = this.map.name; var v = this.map.parentMap ? this.map.parentMap.name : null, g = k.makeRequire(a.parentMap, { enableBuildCallback: !0 });
                if (this.map.unnormalized) { if (e.normalize && (d = e.normalize(d, function (a) { return c(a, v, !0) }) || ""), e = h(a.prefix + "!" + d, this.map.parentMap), s(e, "defined", t(this, function (a) { this.init([], function () { return a }, null, { enabled: !0, ignore: !0 }) })), d = i(j, e.id)) { this.depMaps.push(e); if (this.events.error) d.on("error", t(this, function (a) { this.emit("error", a) })); d.enable() } } else n = t(this, function (a) { this.init([], function () { return a }, null, { enabled: !0 }) }), n.error = t(this, function (a) {
                    this.inited = !0; this.error = a; a.requireModules =
[b]; E(j, function (a) { 0 === a.map.id.indexOf(b + "_unnormalized") && delete j[a.map.id] }); A(a)
                }), n.fromText = t(this, function (e, c) { var d = a.name, u = h(d), v = O; c && (e = c); v && (O = !1); q(u); r(m.config, b) && (m.config[d] = m.config[b]); try { l.exec(e) } catch (j) { return A(F("fromtexteval", "fromText eval for " + b + " failed: " + j, j, [b])) } v && (O = !0); this.depMaps.push(u); k.completeLoad(d); g([d], n) }), e.load(a.name, g, n, m)
            })); k.enable(d, this); this.pluginMaps[d.id] = d
        }, enable: function () {
            this.enabling = this.enabled = !0; x(this.depMaps, t(this, function (a,
b) { var c, e; if ("string" === typeof a) { a = h(a, this.map.isDefine ? this.map : this.map.parentMap, !1, !this.skipMap); this.depMaps[b] = a; if (c = i(N, a.id)) { this.depExports[b] = c(this); return } this.depCount += 1; s(a, "defined", t(this, function (a) { this.defineDep(b, a); this.check() })); this.errback && s(a, "error", this.errback) } c = a.id; e = j[c]; !r(N, c) && (e && !e.enabled) && k.enable(a, this) })); E(this.pluginMaps, t(this, function (a) { var b = i(j, a.id); b && !b.enabled && k.enable(a, this) })); this.enabling = !1; this.check()
        }, on: function (a, b) {
            var c =
this.events[a]; c || (c = this.events[a] = []); c.push(b)
        }, emit: function (a, b) { x(this.events[a], function (a) { a(b) }); "error" === a && delete this.events[a] } 
        }; k = { config: m, contextName: b, registry: j, defined: p, urlFetched: S, defQueue: G, Module: W, makeModuleMap: h, nextTick: l.nextTick, configure: function (a) {
            a.baseUrl && "/" !== a.baseUrl.charAt(a.baseUrl.length - 1) && (a.baseUrl += "/"); var b = m.pkgs, c = m.shim, e = { paths: !0, config: !0, map: !0 }; E(a, function (a, b) { e[b] ? "map" === b ? Q(m[b], a, !0, !0) : Q(m[b], a, !0) : m[b] = a }); a.shim && (E(a.shim, function (a,
b) { J(a) && (a = { deps: a }); if ((a.exports || a.init) && !a.exportsFn) a.exportsFn = k.makeShimExports(a); c[b] = a }), m.shim = c); a.packages && (x(a.packages, function (a) { a = "string" === typeof a ? { name: a} : a; b[a.name] = { name: a.name, location: a.location || a.name, main: (a.main || "main").replace(ga, "").replace(aa, "")} }), m.pkgs = b); E(j, function (a, b) { !a.inited && !a.map.unnormalized && (a.map = h(b)) }); if (a.deps || a.callback) k.require(a.deps || [], a.callback)
        }, makeShimExports: function (a) {
            return function () {
                var b; a.init && (b = a.init.apply(Y, arguments));
                return b || a.exports && Z(a.exports)
            } 
        }, makeRequire: function (a, d) {
            function g(e, c, u) {
                var i, m; d.enableBuildCallback && (c && I(c)) && (c.__requireJsBuild = !0); if ("string" === typeof e) { if (I(c)) return A(F("requireargs", "Invalid require call"), u); if (a && r(N, e)) return N[e](j[a.id]); if (l.get) return l.get(k, e, a); i = h(e, a, !1, !0); i = i.id; return !r(p, i) ? A(F("notloaded", 'Module name "' + i + '" has not been loaded yet for context: ' + b + (a ? "" : ". Use require([])"))) : p[i] } K(); k.nextTick(function () {
                    K(); m = q(h(null, a)); m.skipMap = d.skipMap;
                    m.init(e, c, u, { enabled: !0 }); C()
                }); return g
            } d = d || {}; Q(g, { isBrowser: z, toUrl: function (b) { var d, f = b.lastIndexOf("."), h = b.split("/")[0]; if (-1 !== f && (!("." === h || ".." === h) || 1 < f)) d = b.substring(f, b.length), b = b.substring(0, f); b = k.nameToUrl(c(b, a && a.id, !0), d || ".fake"); return d ? b : b.substring(0, b.length - 5) }, defined: function (b) { return r(p, h(b, a, !1, !0).id) }, specified: function (b) { b = h(b, a, !1, !0).id; return r(p, b) || r(j, b) } }); a || (g.undef = function (b) {
                w(); var c = h(b, a, !0), d = i(j, b); delete p[b]; delete S[c.url]; delete X[b];
                d && (d.events.defined && (X[b] = d.events), delete j[b])
            }); return g
        }, enable: function (a) { i(j, a.id) && q(a).enable() }, completeLoad: function (a) { var b, c, d = i(m.shim, a) || {}, h = d.exports; for (w(); G.length; ) { c = G.shift(); if (null === c[0]) { c[0] = a; if (b) break; b = !0 } else c[0] === a && (b = !0); D(c) } c = i(j, a); if (!b && !r(p, a) && c && !c.inited) { if (m.enforceDefine && (!h || !Z(h))) return y(a) ? void 0 : A(F("nodefine", "No define call for " + a, null, [a])); D([a, d.deps || [], d.exportsFn]) } C() }, nameToUrl: function (a, b) {
            var c, d, h, g, k, j; if (l.jsExtRegExp.test(a)) g =
a + (b || ""); else { c = m.paths; d = m.pkgs; g = a.split("/"); for (k = g.length; 0 < k; k -= 1) if (j = g.slice(0, k).join("/"), h = i(d, j), j = i(c, j)) { J(j) && (j = j[0]); g.splice(0, k, j); break } else if (h) { c = a === h.name ? h.location + "/" + h.main : h.location; g.splice(0, k, c); break } g = g.join("/"); g += b || (/\?/.test(g) ? "" : ".js"); g = ("/" === g.charAt(0) || g.match(/^[\w\+\.\-]+:/) ? "" : m.baseUrl) + g } return m.urlArgs ? g + ((-1 === g.indexOf("?") ? "?" : "&") + m.urlArgs) : g
        }, load: function (a, b) { l.load(k, a, b) }, execCb: function (a, b, c, d) { return b.apply(d, c) }, onScriptLoad: function (a) {
            if ("load" ===
a.type || ha.test((a.currentTarget || a.srcElement).readyState)) P = null, a = H(a), k.completeLoad(a.id)
        }, onScriptError: function (a) { var b = H(a); if (!y(b.id)) return A(F("scripterror", "Script error", a, [b.id])) } 
        }; k.require = k.makeRequire(); return k
    } var l, w, B, D, s, H, P, K, ba, ca, ia = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg, ja = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g, aa = /\.js$/, ga = /^\.\//; w = Object.prototype; var L = w.toString, da = w.hasOwnProperty, fa = Array.prototype.splice, z = !!("undefined" !== typeof window && navigator &&
document), $ = !z && "undefined" !== typeof importScripts, ha = z && "PLAYSTATION 3" === navigator.platform ? /^complete$/ : /^(complete|loaded)$/, V = "undefined" !== typeof opera && "[object Opera]" === opera.toString(), C = {}, q = {}, R = [], O = !1; if ("undefined" === typeof define) {
        if ("undefined" !== typeof requirejs) { if (I(requirejs)) return; q = requirejs; requirejs = void 0 } "undefined" !== typeof require && !I(require) && (q = require, require = void 0); l = requirejs = function (b, c, d, y) {
            var g, h = "_"; !J(b) && "string" !== typeof b && (g = b, J(c) ? (b = c, c = d, d = y) : b = []);
            g && g.context && (h = g.context); (y = i(C, h)) || (y = C[h] = l.s.newContext(h)); g && y.configure(g); return y.require(b, c, d)
        }; l.config = function (b) { return l(b) }; l.nextTick = "undefined" !== typeof setTimeout ? function (b) { setTimeout(b, 4) } : function (b) { b() }; require || (require = l); l.version = "2.1.4"; l.jsExtRegExp = /^\/|:|\?|\.js$/; l.isBrowser = z; w = l.s = { contexts: C, newContext: ea }; l({}); x(["toUrl", "undef", "defined", "specified"], function (b) { l[b] = function () { var c = C._; return c.require[b].apply(c, arguments) } }); if (z && (B = w.head = document.getElementsByTagName("head")[0],
D = document.getElementsByTagName("base")[0])) B = w.head = D.parentNode; l.onError = function (b) { throw b; }; l.load = function (b, c, d) {
    var i = b && b.config || {}, g; if (z) return g = i.xhtml ? document.createElementNS("http://www.w3.org/1999/xhtml", "html:script") : document.createElement("script"), g.type = i.scriptType || "text/javascript", g.charset = "utf-8", g.async = !0, g.setAttribute("data-requirecontext", b.contextName), g.setAttribute("data-requiremodule", c), g.attachEvent && !(g.attachEvent.toString && 0 > g.attachEvent.toString().indexOf("[native code")) &&
!V ? (O = !0, g.attachEvent("onreadystatechange", b.onScriptLoad)) : (g.addEventListener("load", b.onScriptLoad, !1), g.addEventListener("error", b.onScriptError, !1)), g.src = d, K = g, D ? B.insertBefore(g, D) : B.appendChild(g), K = null, g; $ && (importScripts(d), b.completeLoad(c))
}; z && M(document.getElementsByTagName("script"), function (b) {
    B || (B = b.parentNode); if (s = b.getAttribute("data-main")) return q.baseUrl || (H = s.split("/"), ba = H.pop(), ca = H.length ? H.join("/") + "/" : "./", q.baseUrl = ca, s = ba), s = s.replace(aa, ""), q.deps = q.deps ? q.deps.concat(s) :
[s], !0
}); define = function (b, c, d) {
    var i, g; "string" !== typeof b && (d = c, c = b, b = null); J(c) || (d = c, c = []); !c.length && I(d) && d.length && (d.toString().replace(ia, "").replace(ja, function (b, d) { c.push(d) }), c = (1 === d.length ? ["require"] : ["require", "exports", "module"]).concat(c)); if (O) { if (!(i = K)) P && "interactive" === P.readyState || M(document.getElementsByTagName("script"), function (b) { if ("interactive" === b.readyState) return P = b }), i = P; i && (b || (b = i.getAttribute("data-requiremodule")), g = C[i.getAttribute("data-requirecontext")]) } (g ?
g.defQueue : R).push([b, c, d])
}; define.amd = { jQuery: !0 }; l.exec = function (b) { return eval(b) }; l(q)
    } 
})(this);
define("requireLib", function () { });

/*!
* jQuery JavaScript Library v1.8.3
* http://jquery.com/
*
* Includes Sizzle.js
* http://sizzlejs.com/
*
* Copyright 2012 jQuery Foundation and other contributors
* Released under the MIT license
* http://jquery.org/license
*
* Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
*/
(function (window, undefined) {
    var 
    // A central reference to the root jQuery(document)
	rootjQuery,

    // The deferred used on DOM ready
	readyList,

    // Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

    // Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

    // Map over the $ in case of overwrite
	_$ = window.$,

    // Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

    // Define a local copy of jQuery
	jQuery = function (selector, context) {
	    // The jQuery object is actually just the init constructor 'enhanced'
	    return new jQuery.fn.init(selector, context, rootjQuery);
	},

    // Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

    // Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

    // Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

    // JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

    // Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
	    return (letter + "").toUpperCase();
	},

    // The ready event handler and self cleanup method
	DOMContentLoaded = function () {
	    if (document.addEventListener) {
	        document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
	        jQuery.ready();
	    } else if (document.readyState === "complete") {
	        // we're here because readyState === "complete" in oldIE
	        // which is good enough for us to call the dom ready!
	        document.detachEvent("onreadystatechange", DOMContentLoaded);
	        jQuery.ready();
	    }
	},

    // [[Class]] -> type pairs
	class2type = {};

    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function (selector, context, rootjQuery) {
            var match, elem, ret, doc;

            // Handle $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Handle $(DOMElement)
            if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        doc = (context && context.nodeType ? context.ownerDocument || context : document);

                        // scripts is true for back-compat
                        selector = jQuery.parseHTML(match[1], doc, true);
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            this.attr.call(selector, context, true);
                        }

                        return jQuery.merge(this, selector);

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if (elem && elem.parentNode) {
                            // Handle the case where IE and Opera return items
                            // by name instead of ID
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }

                            // Otherwise, we inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (jQuery.isFunction(selector)) {
                return rootjQuery.ready(selector);
            }

            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray(selector, this);
        },

        // Start with an empty selector
        selector: "",

        // The current version of jQuery being used
        jquery: "1.8.3",

        // The default length of a jQuery object is 0
        length: 0,

        // The number of elements contained in the matched element set
        size: function () {
            return this.length;
        },

        toArray: function () {
            return core_slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {
            return num == null ?

            // Return a 'clean' array
			this.toArray() :

            // Return just the object
			(num < 0 ? this[this.length + num] : this[num]);
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems, name, selector) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            ret.context = this.context;

            if (name === "find") {
                ret.selector = this.selector + (this.selector ? " " : "") + selector;
            } else if (name) {
                ret.selector = this.selector + "." + name + "(" + selector + ")";
            }

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },

        ready: function (fn) {
            // Add the callback
            jQuery.ready.promise().done(fn);

            return this;
        },

        eq: function (i) {
            i = +i;
            return i === -1 ?
			this.slice(i) :
			this.slice(i, i + 1);
        },

        first: function () {
            return this.eq(0);
        },

        last: function () {
            return this.eq(-1);
        },

        slice: function () {
            return this.pushStack(core_slice.apply(this, arguments),
			"slice", core_slice.call(arguments).join(","));
        },

        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        end: function () {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: core_push,
        sort: [].sort,
        splice: [].splice
    };

    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;

    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if (length === i) {
            target = this;
            --i;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        noConflict: function (deep) {
            if (window.$ === jQuery) {
                window.$ = _$;
            }

            if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery;
            }

            return jQuery;
        },

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },

        // Handle when the DOM is ready
        ready: function (wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!document.body) {
                return setTimeout(jQuery.ready, 1);
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);

            // Trigger any bound ready events
            if (jQuery.fn.trigger) {
                jQuery(document).trigger("ready").off("ready");
            }
        },

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function (obj) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray || function (obj) {
            return jQuery.type(obj) === "array";
        },

        isWindow: function (obj) {
            return obj != null && obj == obj.window;
        },

        isNumeric: function (obj) {
            return !isNaN(parseFloat(obj)) && isFinite(obj);
        },

        type: function (obj) {
            return obj == null ?
			String(obj) :
			class2type[core_toString.call(obj)] || "object";
        },

        isPlainObject: function (obj) {
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }

            try {
                // Not own constructor property must be Object
                if (obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.

            var key;
            for (key in obj) { }

            return key === undefined || core_hasOwn.call(obj, key);
        },

        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        error: function (msg) {
            throw new Error(msg);
        },

        // data: string of html
        // context (optional): If specified, the fragment will be created in this context, defaults to document
        // scripts (optional): If true, will include scripts passed in the html string
        parseHTML: function (data, context, scripts) {
            var parsed;
            if (!data || typeof data !== "string") {
                return null;
            }
            if (typeof context === "boolean") {
                scripts = context;
                context = 0;
            }
            context = context || document;

            // Single tag
            if ((parsed = rsingleTag.exec(data))) {
                return [context.createElement(parsed[1])];
            }

            parsed = jQuery.buildFragment([data], context, scripts ? null : []);
            return jQuery.merge([],
			(parsed.cacheable ? jQuery.clone(parsed.fragment) : parsed.fragment).childNodes);
        },

        parseJSON: function (data) {
            if (!data || typeof data !== "string") {
                return null;
            }

            // Make sure leading/trailing whitespace is removed (IE can't handle it)
            data = jQuery.trim(data);

            // Attempt to parse using the native JSON parser first
            if (window.JSON && window.JSON.parse) {
                return window.JSON.parse(data);
            }

            // Make sure the incoming data is actual JSON
            // Logic borrowed from http://json.org/json2.js
            if (rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, ""))) {

                return (new Function("return " + data))();

            }
            jQuery.error("Invalid JSON: " + data);
        },

        // Cross-browser xml parsing
        parseXML: function (data) {
            var xml, tmp;
            if (!data || typeof data !== "string") {
                return null;
            }
            try {
                if (window.DOMParser) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } else { // IE
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }
            } catch (e) {
                xml = undefined;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                jQuery.error("Invalid XML: " + data);
            }
            return xml;
        },

        noop: function () { },

        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function (data) {
            if (data && core_rnotwhite.test(data)) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                (window.execScript || function (data) {
                    window["eval"].call(window, data);
                })(data);
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function (string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },

        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function (obj, callback, args) {
            var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction(obj);

            if (args) {
                if (isObj) {
                    for (name in obj) {
                        if (callback.apply(obj[name], args) === false) {
                            break;
                        }
                    }
                } else {
                    for (; i < length; ) {
                        if (callback.apply(obj[i++], args) === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isObj) {
                    for (name in obj) {
                        if (callback.call(obj[name], name, obj[name]) === false) {
                            break;
                        }
                    }
                } else {
                    for (; i < length; ) {
                        if (callback.call(obj[i], i, obj[i++]) === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Use native String.trim function wherever possible
        trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function (text) {
		    return text == null ?
				"" :
				core_trim.call(text);
		} :

        // Otherwise use our own trimming functionality
		function (text) {
		    return text == null ?
				"" :
				(text + "").replace(rtrim, "");
		},

        // results is for internal usage only
        makeArray: function (arr, results) {
            var type,
			ret = results || [];

            if (arr != null) {
                // The window, strings (and functions) also have 'length'
                // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                type = jQuery.type(arr);

                if (arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(arr)) {
                    core_push.call(ret, arr);
                } else {
                    jQuery.merge(ret, arr);
                }
            }

            return ret;
        },

        inArray: function (elem, arr, i) {
            var len;

            if (arr) {
                if (core_indexOf) {
                    return core_indexOf.call(arr, elem, i);
                }

                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

                for (; i < len; i++) {
                    // Skip accessing in sparse arrays
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }

            return -1;
        },

        merge: function (first, second) {
            var l = second.length,
			i = first.length,
			j = 0;

            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j];
                }

            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        grep: function (elems, callback, inv) {
            var retVal,
			ret = [],
			i = 0,
			length = elems.length;
            inv = !!inv;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                retVal = !!callback(elems[i], i);
                if (inv !== retVal) {
                    ret.push(elems[i]);
                }
            }

            return ret;
        },

        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var value, key,
			ret = [],
			i = 0,
			length = elems.length,
            // jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

            // Go through the array, translating each of the items to their
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }

                // Go through every key on the object,
            } else {
                for (key in elems) {
                    value = callback(elems[key], key, arg);

                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }
            }

            // Flatten any nested arrays
            return ret.concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function (fn, context) {
            var tmp, args, proxy;

            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }

            // Simulated bind
            args = core_slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context, args.concat(core_slice.call(arguments)));
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        // Multifunctional method to get and set values of a collection
        // The value/s can optionally be executed if it's a function
        access: function (elems, fn, key, value, chainable, emptyGet, pass) {
            var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

            // Sets many values
            if (key && typeof key === "object") {
                for (i in key) {
                    jQuery.access(elems, fn, i, key[i], 1, emptyGet, value);
                }
                chainable = 1;

                // Sets one value
            } else if (value !== undefined) {
                // Optionally, function values get executed if exec is true
                exec = pass === undefined && jQuery.isFunction(value);

                if (bulk) {
                    // Bulk operations only iterate when executing function values
                    if (exec) {
                        exec = fn;
                        fn = function (elem, key, value) {
                            return exec.call(jQuery(elem), value);
                        };

                        // Otherwise they run against the entire set
                    } else {
                        fn.call(elems, value);
                        fn = null;
                    }
                }

                if (fn) {
                    for (; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }
                }

                chainable = 1;
            }

            return chainable ?
			elems :

            // Gets
			bulk ?
				fn.call(elems) :
				length ? fn(elems[0], key) : emptyGet;
        },

        now: function () {
            return (new Date()).getTime();
        }
    });

    jQuery.ready.promise = function (obj) {
        if (!readyList) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === "complete") {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready, 1);

                // Standards-based browsers support DOMContentLoaded
            } else if (document.addEventListener) {
                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                // A fallback to window.onload, that will always work
                window.addEventListener("load", jQuery.ready, false);

                // If IE event model is used
            } else {
                // Ensure firing before onload, maybe late but safe also for iframes
                document.attachEvent("onreadystatechange", DOMContentLoaded);

                // A fallback to window.onload, that will always work
                window.attachEvent("onload", jQuery.ready);

                // If IE and not a frame
                // continually check to see if the document is ready
                var top = false;

                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) { }

                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {

                            try {
                                // Use the trick by Diego Perini
                                // http://javascript.nwbox.com/IEContentLoaded/
                                top.doScroll("left");
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }

                            // and execute any waiting functions
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise(obj);
    };

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    // All jQuery objects should point back to these
    rootjQuery = jQuery(document);
    // String to Object options format cache
    var optionsCache = {};

    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.split(core_rspace), function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
    * Create a callback list using the following parameters:
    *
    *	options: an optional list of space-separated options that will change how
    *			the callback list behaves or a more traditional option object
    *
    * By default a callback list will act like an event callback list and can be
    * "fired" multiple times.
    *
    * Possible options:
    *
    *	once:			will ensure the callback list can only be fired once (like a Deferred)
    *
    *	memory:			will keep track of previous values and will call any callback added
    *					after the list has been fired right away with the latest "memorized"
    *					values (like a Deferred)
    *
    *	unique:			will ensure a callback can only be added once (no duplicate in the list)
    *
    *	stopOnFalse:	interrupt callings when a callback returns false
    *
    */
    jQuery.Callbacks = function (options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
		(optionsCache[options] || createOptions(options)) :
		jQuery.extend({}, options);

        var // Last fire value (for non-forgettable lists)
		memory,
        // Flag to know if list was already fired
		fired,
        // Flag to know if list is currently firing
		firing,
        // First callback to fire (used internally by add and fireWith)
		firingStart,
        // End of the loop when firing
		firingLength,
        // Index of currently firing callback (modified by remove if needed)
		firingIndex,
        // Actual callback list
		list = [],
        // Stack of fire calls for repeatable lists
		stack = !options.once && [],
        // Fire callbacks
		fire = function (data) {
		    memory = options.memory && data;
		    fired = true;
		    firingIndex = firingStart || 0;
		    firingStart = 0;
		    firingLength = list.length;
		    firing = true;
		    for (; list && firingIndex < firingLength; firingIndex++) {
		        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
		            memory = false; // To prevent further calls using add
		            break;
		        }
		    }
		    firing = false;
		    if (list) {
		        if (stack) {
		            if (stack.length) {
		                fire(stack.shift());
		            }
		        } else if (memory) {
		            list = [];
		        } else {
		            self.disable();
		        }
		    }
		},
        // Actual Callbacks object
		self = {
		    // Add a callback or a collection of callbacks to the list
		    add: function () {
		        if (list) {
		            // First, we save the current length
		            var start = list.length;
		            (function add(args) {
		                jQuery.each(args, function (_, arg) {
		                    var type = jQuery.type(arg);
		                    if (type === "function") {
		                        if (!options.unique || !self.has(arg)) {
		                            list.push(arg);
		                        }
		                    } else if (arg && arg.length && type !== "string") {
		                        // Inspect recursively
		                        add(arg);
		                    }
		                });
		            })(arguments);
		            // Do we need to add the callbacks to the
		            // current firing batch?
		            if (firing) {
		                firingLength = list.length;
		                // With memory, if we're not firing then
		                // we should call right away
		            } else if (memory) {
		                firingStart = start;
		                fire(memory);
		            }
		        }
		        return this;
		    },
		    // Remove a callback from the list
		    remove: function () {
		        if (list) {
		            jQuery.each(arguments, function (_, arg) {
		                var index;
		                while ((index = jQuery.inArray(arg, list, index)) > -1) {
		                    list.splice(index, 1);
		                    // Handle firing indexes
		                    if (firing) {
		                        if (index <= firingLength) {
		                            firingLength--;
		                        }
		                        if (index <= firingIndex) {
		                            firingIndex--;
		                        }
		                    }
		                }
		            });
		        }
		        return this;
		    },
		    // Control if a given callback is in the list
		    has: function (fn) {
		        return jQuery.inArray(fn, list) > -1;
		    },
		    // Remove all callbacks from the list
		    empty: function () {
		        list = [];
		        return this;
		    },
		    // Have the list do nothing anymore
		    disable: function () {
		        list = stack = memory = undefined;
		        return this;
		    },
		    // Is it disabled?
		    disabled: function () {
		        return !list;
		    },
		    // Lock the list in its current state
		    lock: function () {
		        stack = undefined;
		        if (!memory) {
		            self.disable();
		        }
		        return this;
		    },
		    // Is it locked?
		    locked: function () {
		        return !stack;
		    },
		    // Call all callbacks with the given context and arguments
		    fireWith: function (context, args) {
		        args = args || [];
		        args = [context, args.slice ? args.slice() : args];
		        if (list && (!fired || stack)) {
		            if (firing) {
		                stack.push(args);
		            } else {
		                fire(args);
		            }
		        }
		        return this;
		    },
		    // Call all the callbacks with the given arguments
		    fire: function () {
		        self.fireWith(this, arguments);
		        return this;
		    },
		    // To know if the callbacks have already been called at least once
		    fired: function () {
		        return !!fired;
		    }
		};

        return self;
    };
    jQuery.extend({

        Deferred: function (func) {
            var tuples = [
            // action, add listener, listener list, final state
				["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
				["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
				["notify", "progress", jQuery.Callbacks("memory")]
			],
			state = "pending",
			promise = {
			    state: function () {
			        return state;
			    },
			    always: function () {
			        deferred.done(arguments).fail(arguments);
			        return this;
			    },
			    then: function ( /* fnDone, fnFail, fnProgress */) {
			        var fns = arguments;
			        return jQuery.Deferred(function (newDefer) {
			            jQuery.each(tuples, function (i, tuple) {
			                var action = tuple[0],
								fn = fns[i];
			                // deferred[ done | fail | progress ] for forwarding actions to newDefer
			                deferred[tuple[1]](jQuery.isFunction(fn) ?
								function () {
								    var returned = fn.apply(this, arguments);
								    if (returned && jQuery.isFunction(returned.promise)) {
								        returned.promise()
											.done(newDefer.resolve)
											.fail(newDefer.reject)
											.progress(newDefer.notify);
								    } else {
								        newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
								    }
								} :
								newDefer[action]
							);
			            });
			            fns = null;
			        }).promise();
			    },
			    // Get a promise for this deferred
			    // If obj is provided, the promise aspect is added to the object
			    promise: function (obj) {
			        return obj != null ? jQuery.extend(obj, promise) : promise;
			    }
			},
			deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
				stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function () {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }

                // deferred[ resolve | reject | notify ] = list.fire
                deferred[tuple[0]] = list.fire;
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (subordinate /* , ..., subordinateN */) {
            var i = 0,
			resolveValues = core_slice.call(arguments),
			length = resolveValues.length,

            // the count of uncompleted subordinates
			remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            // Update function for both resolve and progress values
			updateFunc = function (i, contexts, values) {
			    return function (value) {
			        contexts[i] = this;
			        values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
			        if (values === progressValues) {
			            deferred.notifyWith(contexts, values);
			        } else if (!(--remaining)) {
			            deferred.resolveWith(contexts, values);
			        }
			    };
			},

			progressValues, progressContexts, resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise()
						.done(updateFunc(i, resolveContexts, resolveValues))
						.fail(deferred.reject)
						.progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        }
    });
    jQuery.support = (function () {

        var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");

        // Setup
        div.setAttribute("className", "t");
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

        // Support tests won't run in some limited or non-browser environments
        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];
        if (!all || !a || !all.length) {
            return {};
        }

        // First batch of tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        a.style.cssText = "top:1px;float:left;opacity:.5";
        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.5/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Tests for enctype support on a form (#6743)
            enctype: !!document.createElement("form").enctype,

            // Makes sure cloning an html5 element does not cause problems
            // Where outerHTML is undefined, this still works
            html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

            // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
            boxModel: (document.compatMode === "CSS1Compat"),

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true,
            boxSizingReliable: true,
            pixelPosition: false
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", clickFn = function () {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
            div.detachEvent("onclick", clickFn);
        }

        // Check if a radio maintains its value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");

        // #11217 - WebKit loses check when the name is after the checked attribute
        input.setAttribute("name", "t");

        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.lastChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        fragment.removeChild(input);
        fragment.appendChild(div);

        // Technique from Juriy Zaytsev
        // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
                submit: true,
                change: true,
                focusin: true
            }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        // Run tests that need a body at doc ready
        jQuery(function () {
            var container, div, tds, marginDiv,
			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
			body = document.getElementsByTagName("body")[0];

            if (!body) {
                // Return for frameset docs that don't have a body
                return;
            }

            container = document.createElement("div");
            container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
            body.insertBefore(container, body.firstChild);

            // Construct the test element
            div = document.createElement("div");
            container.appendChild(div);

            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName("td");
            tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
            isSupported = (tds[0].offsetHeight === 0);

            tds[0].style.display = "";
            tds[1].style.display = "none";

            // Check if empty table cells still have offsetWidth/Height
            // (IE <= 8 fail this test)
            support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);

            // Check box-sizing and margin behavior
            div.innerHTML = "";
            div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
            support.boxSizing = (div.offsetWidth === 4);
            support.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== 1);

            // NOTE: To any future maintainer, we've window.getComputedStyle
            // because jsdom on node.js will break without it.
            if (window.getComputedStyle) {
                support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
                support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: "4px" }).width === "4px";

                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. For more
                // info see bug #3333
                // Fails in WebKit before Feb 2011 nightlies
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                marginDiv = document.createElement("div");
                marginDiv.style.cssText = div.style.cssText = divReset;
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                div.appendChild(marginDiv);
                support.reliableMarginRight =
				!parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
            }

            if (typeof div.style.zoom !== "undefined") {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.innerHTML = "";
                div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
                support.inlineBlockNeedsLayout = (div.offsetWidth === 3);

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "block";
                div.style.overflow = "visible";
                div.innerHTML = "<div></div>";
                div.firstChild.style.width = "5px";
                support.shrinkWrapBlocks = (div.offsetWidth !== 3);

                container.style.zoom = 1;
            }

            // Null elements to avoid leaks in IE
            body.removeChild(container);
            container = div = tds = marginDiv = null;
        });

        // Null elements to avoid leaks in IE
        fragment.removeChild(div);
        all = a = select = opt = input = fragment = div = null;

        return support;
    })();
    var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

    jQuery.extend({
        cache: {},

        deletedIds: [],

        // Remove at next major release (1.9/2.0)
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },

        data: function (elem, name, data, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[internalKey] = id = jQuery.deletedIds.pop() || jQuery.guid++;
                } else {
                    id = internalKey;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // Avoids exposing jQuery metadata on plain JS objects when the object
                // is serialized using JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id] = jQuery.extend(cache[id], name);
                } else {
                    cache[id].data = jQuery.extend(cache[id].data, name);
                }
            }

            thisCache = cache[id];

            // jQuery data() is stored in a separate object inside the object's internal data
            // cache in order to avoid key collisions between internal data and user-defined
            // data.
            if (!pvt) {
                if (!thisCache.data) {
                    thisCache.data = {};
                }

                thisCache = thisCache.data;
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if (getByName) {

                // First Try to find as-is property data
                ret = thisCache[name];

                // Test for null|undefined property data
                if (ret == null) {

                    // Try to find the camelCased property
                    ret = thisCache[jQuery.camelCase(name)];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        },

        removeData: function (elem, name, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache, i, l,

			isNode = elem.nodeType,

            // See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[jQuery.expando] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {

                thisCache = pvt ? cache[id] : cache[id].data;

                if (thisCache) {

                    // Support array or space separated string names for data keys
                    if (!jQuery.isArray(name)) {

                        // try the string as a key before any manipulation
                        if (name in thisCache) {
                            name = [name];
                        } else {

                            // split the camel cased version by spaces unless a key with the spaces exists
                            name = jQuery.camelCase(name);
                            if (name in thisCache) {
                                name = [name];
                            } else {
                                name = name.split(" ");
                            }
                        }
                    }

                    for (i = 0, l = name.length; i < l; i++) {
                        delete thisCache[name[i]];
                    }

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (!pvt) {
                delete cache[id].data;

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            // Destroy the cache
            if (isNode) {
                jQuery.cleanData([elem], true);

                // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
            } else if (jQuery.support.deleteExpando || cache != cache.window) {
                delete cache[id];

                // When all else fails, null
            } else {
                cache[id] = null;
            }
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()];

            // nodes accept data unless otherwise specified; rejection can be conditional
            return !noData || noData !== true && elem.getAttribute("classid") === noData;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);

                    if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
                        attr = elem.attributes;
                        for (l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (!name.indexOf("data-")) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(elem, name, data[name]);
                            }
                        }
                        jQuery._data(elem, "parsedAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            parts = key.split(".", 2);
            parts[1] = parts[1] ? "." + parts[1] : "";
            part = parts[1] + "!";

            return jQuery.access(this, function (value) {

                if (value === undefined) {
                    data = this.triggerHandler("getData" + part, [parts[0]]);

                    // Try to fetch any internally stored data first
                    if (data === undefined && elem) {
                        data = jQuery.data(elem, key);
                        data = dataAttr(elem, key, data);
                    }

                    return data === undefined && parts[1] ?
					this.data(parts[0]) :
					data;
                }

                parts[1] = value;
                this.each(function () {
                    var self = jQuery(this);

                    self.triggerHandler("setData" + part, parts);
                    jQuery.data(this, key, value);
                    self.triggerHandler("changeData" + part, parts);
                });
            }, null, value, arguments.length > 1, null, false);
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {

            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
                    // Only convert to a number if it doesn't change the string
				+data + "" === data ? +data :
				rbrace.test(data) ? jQuery.parseJSON(data) :
					data;
                } catch (e) { }

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // checks a cache object for emptiness
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {

            // if the public data object is empty, the private is still empty
            if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = jQuery._data(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks(elem, type),
			next = function () {
			    jQuery.dequeue(elem, type);
			};

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function (elem, type) {
            var key = type + "queueHooks";
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function () {
                    jQuery.removeData(elem, type + "queue", true);
                    jQuery.removeData(elem, key, true);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ?
			this :
			this.each(function () {
			    var queue = jQuery.queue(this, type, data);

			    // ensure a hooks for this queue
			    jQuery._queueHooks(this, type);

			    if (type === "fx" && queue[0] !== "inprogress") {
			        jQuery.dequeue(this, type);
			    }
			});
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function (next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function () {
                    clearTimeout(timeout);
                };
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, obj) {
            var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function () {
			    if (!(--count)) {
			        defer.resolveWith(elements, [elements]);
			    }
			};

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = jQuery._data(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        },

        prop: function (name, value) {
            return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) { }
            });
        },

        addClass: function (value) {
            var classNames, i, l, elem,
			setClass, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (value && typeof value === "string") {
                classNames = value.split(core_rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (setClass.indexOf(" " + classNames[c] + " ") < 0) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var removes, className, elem, c, cl, i, l;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if ((value && typeof value === "string") || value === undefined) {
                removes = (value || "").split(core_rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];
                    if (elem.nodeType === 1 && elem.className) {

                        className = (" " + elem.className + " ").replace(rclass, " ");

                        // loop over each item in the removal list
                        for (c = 0, cl = removes.length; c < cl; c++) {
                            // Remove until there is nothing to remove,
                            while (className.indexOf(" " + removes[c] + " ") >= 0) {
                                className = className.replace(" " + removes[c] + " ", " ");
                            }
                        }
                        elem.className = value ? jQuery.trim(className) : "";
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
			isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className,
					i = 0,
					self = jQuery(this),
					state = stateVal,
					classNames = value.split(core_rspace);

                    while ((className = classNames[i++])) {
                        // check each className given, space separated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ",
			i = 0,
			l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            var hooks, ret, isFunction,
			elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
					ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
					ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var val,
				self = jQuery(this);

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function (elem) {
                    var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // oldIE doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&
                        // Don't return options that are disabled or in a disabled optgroup
							(jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function (elem, value) {
                    var values = jQuery.makeArray(value);

                    jQuery(elem).find("option").each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        // Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
        attrFn: {},

        attr: function (elem, name, value, pass) {
            var ret, hooks, notxml,
			nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (pass && jQuery.isFunction(jQuery.fn[name])) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (notxml) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
				undefined :
				ret;
            }
        },

        removeAttr: function (elem, value) {
            var propName, attrNames, name, isBool,
			i = 0;

            if (value && elem.nodeType === 1) {

                attrNames = value.split(core_rspace);

                for (; i < attrNames.length; i++) {
                    name = attrNames[i];

                    if (name) {
                        propName = jQuery.propFix[name] || name;
                        isBool = rboolean.test(name);

                        // See #9699 for explanation of this approach (setting first, then removal)
                        // Do not do this for boolean attributes (see #10870)
                        if (!isBool) {
                            jQuery.attr(elem, name, "");
                        }
                        elem.removeAttribute(getSetAttribute ? name : propName);

                        // Set corresponding property to false for boolean attributes
                        if (isBool && propName in elem) {
                            elem[propName] = false;
                        }
                    }
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: function (elem, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.get(elem, name);
                    }
                    return name in elem ?
					elem.value :
					null;
                },
                set: function (elem, value, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.set(elem, value, name);
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function (elem, name, value) {
            var ret, hooks, notxml,
			nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabindex");

                    return attributeNode && attributeNode.specified ?
					parseInt(attributeNode.value, 10) :
					rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
						0 :
						undefined;
                }
            }
        }
    });

    // Hook for boolean attributes
    boolHook = {
        get: function (elem, name) {
            // Align boolean attributes with corresponding properties
            // Fall back to attribute presence where some booleans are not supported
            var attrNode,
			property = jQuery.prop(elem, name);
            return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
        },
        set: function (elem, value, name) {
            var propName;
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!getSetAttribute) {

        fixSpecified = {
            name: true,
            id: true,
            coords: true
        };

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                return ret && (fixSpecified[name] ? ret.value !== "" : ret.specified) ?
				ret.value :
				undefined;
            },
            set: function (elem, value, name) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    ret = document.createAttribute(name);
                    elem.setAttributeNode(ret);
                }
                return (ret.value = value + "");
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function (elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });

        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function (elem, value, name) {
                if (value === "") {
                    value = "false";
                }
                nodeHook.set(elem, value, name);
            }
        };
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function (elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function (elem, value) {
                return (elem.style.cssText = value + "");
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }

    // IE6/7 call enctype encoding
    if (!jQuery.support.enctype) {
        jQuery.propFix.enctype = "encoding";
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                get: function (elem) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        });
    });
    var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function (events) {
	    return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
	};

    /*
    * Helper functions for managing events -- not part of the public interface.
    * Props to Dean Edwards' addEvent library for many of the ideas.
    */
    jQuery.event = {

        add: function (elem, types, handler, data, selector) {

            var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

            // Don't attach events to noData or text/comment nodes (allow plain objects tho)
            if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            events = elemData.events;
            if (!events) {
                elemData.events = events = {};
            }
            eventHandle = elemData.handle;
            if (!eventHandle) {
                elemData.handle = eventHandle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
					undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = jQuery.trim(hoverHack(types)).split(" ");
            for (t = 0; t < types.length; t++) {

                tns = rtypenamespace.exec(types[t]) || [];
                type = tns[1];
                namespaces = (tns[2] || "").split(".").sort();

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: tns[1],
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                handlers = events[type];
                if (!handlers) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {

            var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData(elem) && jQuery._data(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = jQuery.trim(hoverHack(types || "")).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = origType = tns[1];
                namespaces = tns[2];

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                eventType = events[type] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

                // Remove matching events
                for (j = 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if ((mappedTypes || origType === handleObj.origType) &&
					 (!handler || handler.guid === handleObj.guid) &&
					 (!namespaces || namespaces.test(handleObj.namespace)) &&
					 (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        eventType.splice(j--, 1);

                        if (handleObj.selector) {
                            eventType.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (eventType.length === 0 && origCount !== eventType.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery.removeData(elem, "events", true);
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function (event, data, elem, onlyHandlers) {
            // Don't do events on text and comment nodes
            if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
                return;
            }

            // Event object or event type
            var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
            // jQuery.Event object
			event[jQuery.expando] ? event :
            // Object literal
			new jQuery.Event(type, event) :
            // Just the event type (string)
			new jQuery.Event(type);

            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Handle a global trigger
            if (!elem) {

                // TODO: Stop taunting the data cache; remove global events and always attach to document
                cache = jQuery.cache;
                for (i in cache) {
                    if (cache[i].events && cache[i].events[type]) {
                        jQuery.event.trigger(event, data, cache[i].handle.elem, true);
                    }
                }
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            eventPath = [[elem, special.bindType || type]];
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
                for (old = elem; cur; cur = cur.parentNode) {
                    eventPath.push([cur, bubbleType]);
                    old = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (old === (elem.ownerDocument || document)) {
                    eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
                }
            }

            // Fire handlers on the event path
            for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {

                cur = eventPath[i][0];
                event.type = eventPath[i][1];

                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                // Note that this is a bare JS function and not a jQuery handler
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                    event.preventDefault();
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) &&
				!(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    // IE<9 dies on focus/blur to hidden element (#1486)
                    if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        old = elem[ontype];

                        if (old) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;

                        if (old) {
                            elem[ontype] = old;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function (event) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event || window.event);

            var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ((jQuery._data(this, "events") || {})[event.type] || []),
			delegateCount = handlers.delegateCount,
			args = core_slice.call(arguments),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[event.type] || {},
			handlerQueue = [];

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers that should run if there are delegated events
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && !(event.button && event.type === "click")) {

                for (cur = event.target; cur != this; cur = cur.parentNode || this) {

                    // Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.disabled !== true || event.type !== "click") {
                        selMatch = {};
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector;

                            if (selMatch[sel] === undefined) {
                                selMatch[sel] = handleObj.needsContext ?
								jQuery(sel, this).index(cur) >= 0 :
								jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (selMatch[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({ elem: cur, matches: matches });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (handlers.length > delegateCount) {
                handlerQueue.push({ elem: this, matches: handlers.slice(delegateCount) });
            }

            // Run delegates first; they may want to stop propagation beneath us
            for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
                matched = handlerQueue[i];
                event.currentTarget = matched.elem;

                for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
                    handleObj = matched.matches[j];

                    // Triggered event must either 1) be non-exclusive and have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {

                        event.data = handleObj.data;
                        event.handleObj = handleObj;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
							.apply(matched.elem, args);

                        if (ret !== undefined) {
                            event.result = ret;
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function (event, original) {

                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (event, original) {
                var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }

                // Add relatedTarget, if necessary
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }

                return event;
            }
        },

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[event.type] || {},
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = jQuery.Event(originalEvent);

            for (i = copy.length; i; ) {
                prop = copy[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }

            // Target should not be a text node (#504, Safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
            event.metaKey = !!event.metaKey;

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },

            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        },

        simulate: function (type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
			    isSimulated: true,
			    originalEvent: {}
			}
		);
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };

    // Some plugins are using, but it's undocumented/deprecated and will be removed.
    // The 1.7 special event interface should provide all the hooks needed now.
    jQuery.event.handle = jQuery.event.dispatch;

    jQuery.removeEvent = document.removeEventListener ?
	function (elem, type, handle) {
	    if (elem.removeEventListener) {
	        elem.removeEventListener(type, handle, false);
	    }
	} :
	function (elem, type, handle) {
	    var name = "on" + type;

	    if (elem.detachEvent) {

	        // #8545, #7054, preventing memory leaks for custom events in IE6-8
	        // detachEvent needed property on element, by name of that event, to properly expose it to GC
	        if (typeof elem[name] === "undefined") {
	            elem[name] = null;
	        }

	        elem.detachEvent(name, handle);
	    }
	};

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function (event) {
                var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    // IE submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add(this, "click._submit keypress._submit", function (e) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
					form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                    if (form && !jQuery._data(form, "_submit_attached")) {
                        jQuery.event.add(form, "submit._submit", function (event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, "_submit_attached", true);
                    }
                });
                // return undefined since we don't need an event listener
            },

            postDispatch: function (event) {
                // If form was submitted by the user, bubble the event up the tree
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate("submit", this.parentNode, event, true);
                    }
                }
            },

            teardown: function () {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove(this, "._submit");
            }
        };
    }

    // IE change delegation and checkbox/radio fix
    if (!jQuery.support.changeBubbles) {

        jQuery.event.special.change = {

            setup: function () {

                if (rformElems.test(this.nodeName)) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if (this.type === "checkbox" || this.type === "radio") {
                        jQuery.event.add(this, "propertychange._change", function (event) {
                            if (event.originalEvent.propertyName === "checked") {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, "click._change", function (event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            // Allow triggered, simulated change events (#11500)
                            jQuery.event.simulate("change", this, event, true);
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add(this, "beforeactivate._change", function (e) {
                    var elem = e.target;

                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "_change_attached")) {
                        jQuery.event.add(elem, "change._change", function (event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate("change", this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, "_change_attached", true);
                    }
                });
            },

            handle: function (event) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },

            teardown: function () {
                jQuery.event.remove(this, "._change");

                return !rformElems.test(this.nodeName);
            }
        };
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0,
			handler = function (event) {
			    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
			};

            jQuery.event.special[fix] = {
                setup: function () {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function (types, selector, data, fn, /*INTERNAL*/one) {
            var origFn, type;

            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") { // && selector != null
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }

            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }

            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        live: function (types, data, fn) {
            jQuery(this.context).on(types, this.selector, data, fn);
            return this;
        },
        die: function (types, fn) {
            jQuery(this.context).off(types, this.selector || "**", fn);
            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function (event) {
			    // Figure out which function to execute
			    var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;
			    jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1);

			    // Make sure that clicks stop
			    event.preventDefault();

			    // and execute the function
			    return args[lastToggle].apply(this, arguments) || false;
			};

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }

            return this.click(toggler);
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

	    // Handle event binding
	    jQuery.fn[name] = function (data, fn) {
	        if (fn == null) {
	            fn = data;
	            data = null;
	        }

	        return arguments.length > 0 ?
			this.on(name, null, data, fn) :
			this.trigger(name);
	    };

	    if (rkeyEvent.test(name)) {
	        jQuery.event.fixHooks[name] = jQuery.event.keyHooks;
	    }

	    if (rmouseEvent.test(name)) {
	        jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;
	    }
	});
    /*!
    * Sizzle CSS Selector Engine
    * Copyright 2012 jQuery Foundation and other contributors
    * Released under the MIT license
    * http://sizzlejs.com/
    */
    (function (window, undefined) {

        var cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,
	outermostContext,

	baseHasDuplicate = true,
	strundefined = "undefined",

	expando = ("sizcache" + Math.random()).replace(".", ""),

	Token = String,
	document = window.document,
	docElem = document.documentElement,
	dirruns = 0,
	done = 0,
	pop = [].pop,
	push = [].push,
	slice = [].slice,
        // Use a stripped-down indexOf if a native one is unavailable
	indexOf = [].indexOf || function (elem) {
	    var i = 0,
			len = this.length;
	    for (; i < len; i++) {
	        if (this[i] === elem) {
	            return i;
	        }
	    }
	    return -1;
	},

        // Augment a function for special use by Sizzle
	markFunction = function (fn, value) {
	    fn[expando] = value == null || value;
	    return fn;
	},

	createCache = function () {
	    var cache = {},
			keys = [];

	    return markFunction(function (key, value) {
	        // Only keep the most recent entries
	        if (keys.push(key) > Expr.cacheLength) {
	            delete cache[keys.shift()];
	        }

	        // Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
	        return (cache[key + " "] = value);
	    }, cache);
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

        // Regex

        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

        // Loosely modeled on CSS identifier characters
        // An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace("w", "w#"),

        // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

        // Prefer arguments not in parens/brackets,
        //   then attribute selectors and non-pseudos (denoted by :),
        //   then anything else
        // These preferences are here to reduce the number of selectors
        //   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

        // For matchExpr.POS and matchExpr.needsContext
	pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
		"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

	rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
	rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
	rpseudo = new RegExp(pseudos),

        // Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
	    "ID": new RegExp("^#(" + characterEncoding + ")"),
	    "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
	    "NAME": new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
	    "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
	    "ATTR": new RegExp("^" + attributes),
	    "PSEUDO": new RegExp("^" + pseudos),
	    "POS": new RegExp(pos, "i"),
	    "CHILD": new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
	    // For use in libraries implementing .is()
	    "needsContext": new RegExp("^" + whitespace + "*[>+~]|" + pos, "i")
	},

        // Support

        // Used for testing something on an element
	assert = function (fn) {
	    var div = document.createElement("div");

	    try {
	        return fn(div);
	    } catch (e) {
	        return false;
	    } finally {
	        // release memory in IE
	        div = null;
	    }
	},

        // Check if getElementsByTagName("*") returns only elements
	assertTagNameNoComments = assert(function (div) {
	    div.appendChild(document.createComment(""));
	    return !div.getElementsByTagName("*").length;
	}),

        // Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function (div) {
	    div.innerHTML = "<a href='#'></a>";
	    return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

        // Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function (div) {
	    div.innerHTML = "<select></select>";
	    var type = typeof div.lastChild.getAttribute("multiple");
	    // IE8 returns a string for some attributes even when not present
	    return type !== "boolean" && type !== "string";
	}),

        // Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function (div) {
	    // Opera can't find a second classname (in 9.6)
	    div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
	    if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
	        return false;
	    }

	    // Safari 3.2 caches class attributes and doesn't catch changes
	    div.lastChild.className = "e";
	    return div.getElementsByClassName("e").length === 2;
	}),

        // Check if getElementById returns elements by name
        // Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function (div) {
	    // Inject content
	    div.id = expando + 0;
	    div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
	    docElem.insertBefore(div, docElem.firstChild);

	    // Test
	    var pass = document.getElementsByName &&
	    // buggy browsers will return fewer than the correct 2
			document.getElementsByName(expando).length === 2 +
	    // buggy browsers will return more than the correct 0
			document.getElementsByName(expando + 0).length;
	    assertGetIdNotName = !document.getElementById(expando);

	    // Cleanup
	    docElem.removeChild(div);

	    return pass;
	});

        // If slice is not available, provide a backup
        try {
            slice.call(docElem.childNodes, 0)[0].nodeType;
        } catch (e) {
            slice = function (i) {
                var elem,
			results = [];
                for (; (elem = this[i]); i++) {
                    results.push(elem);
                }
                return results;
            };
        }

        function Sizzle(selector, context, results, seed) {
            results = results || [];
            context = context || document;
            var match, elem, xml, m,
		nodeType = context.nodeType;

            if (!selector || typeof selector !== "string") {
                return results;
            }

            if (nodeType !== 1 && nodeType !== 9) {
                return [];
            }

            xml = isXML(context);

            if (!xml && !seed) {
                if ((match = rquickExpr.exec(selector))) {
                    // Speed-up: Sizzle("#ID")
                    if ((m = match[1])) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE, Opera, and Webkit return items
                                // by name instead of ID
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            // Context is not a document
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
						contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }

                        // Speed-up: Sizzle("TAG")
                    } else if (match[2]) {
                        push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
                        return results;

                        // Speed-up: Sizzle(".CLASS")
                    } else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) {
                        push.apply(results, slice.call(context.getElementsByClassName(m), 0));
                        return results;
                    }
                }
            }

            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
        }

        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };

        Sizzle.matchesSelector = function (elem, expr) {
            return Sizzle(expr, null, null, [elem]).length > 0;
        };

        // Returns a function to use in pseudos for input types
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }

        // Returns a function to use in pseudos for buttons
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }

        // Returns a function to use in pseudos for positionals
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j,
				matchIndexes = fn([], seed.length, argument),
				i = matchIndexes.length;

                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[(j = matchIndexes[i])]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }

        /**
        * Utility function for retrieving the text value of an array of DOM nodes
        * @param {Array|Element} elem
        */
        getText = Sizzle.getText = function (elem) {
            var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

            if (nodeType) {
                if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (see #11153)
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes
            } else {

                // If no nodeType, this is expected to be an array
                for (; (node = elem[i]); i++) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            }
            return ret;
        };

        isXML = Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        // Element contains another
        contains = Sizzle.contains = docElem.contains ?
	function (a, b) {
	    var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;
	    return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup));
	} :
	docElem.compareDocumentPosition ?
	function (a, b) {
	    return b && !!(a.compareDocumentPosition(b) & 16);
	} :
	function (a, b) {
	    while ((b = b.parentNode)) {
	        if (b === a) {
	            return true;
	        }
	    }
	    return false;
	};

        Sizzle.attr = function (elem, name) {
            var val,
		xml = isXML(elem);

            if (!xml) {
                name = name.toLowerCase();
            }
            if ((val = Expr.attrHandle[name])) {
                return val(elem);
            }
            if (xml || assertAttributes) {
                return elem.getAttribute(name);
            }
            val = elem.getAttributeNode(name);
            return val ?
		typeof elem[name] === "boolean" ?
			elem[name] ? name : null :
			val.specified ? val.value : null :
		null;
        };

        Expr = Sizzle.selectors = {

            // Can be adjusted by the user
            cacheLength: 50,

            createPseudo: markFunction,

            match: matchExpr,

            // IE6/7 return a modified href
            attrHandle: assertHrefNotNormalized ?
		{} :
		{
		    "href": function (elem) {
		        return elem.getAttribute("href", 2);
		    },
		    "type": function (elem) {
		        return elem.getAttribute("type");
		    }
		},

            find: {
                "ID": assertGetIdNotName ?
			function (id, context, xml) {
			    if (typeof context.getElementById !== strundefined && !xml) {
			        var m = context.getElementById(id);
			        // Check parentNode to catch when Blackberry 4.6 returns
			        // nodes that are no longer in the document #6963
			        return m && m.parentNode ? [m] : [];
			    }
			} :
			function (id, context, xml) {
			    if (typeof context.getElementById !== strundefined && !xml) {
			        var m = context.getElementById(id);

			        return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
			    }
			},

                "TAG": assertTagNameNoComments ?
			function (tag, context) {
			    if (typeof context.getElementsByTagName !== strundefined) {
			        return context.getElementsByTagName(tag);
			    }
			} :
			function (tag, context) {
			    var results = context.getElementsByTagName(tag);

			    // Filter out possible comments
			    if (tag === "*") {
			        var elem,
						tmp = [],
						i = 0;

			        for (; (elem = results[i]); i++) {
			            if (elem.nodeType === 1) {
			                tmp.push(elem);
			            }
			        }

			        return tmp;
			    }
			    return results;
			},

                "NAME": assertUsableName && function (tag, context) {
                    if (typeof context.getElementsByName !== strundefined) {
                        return context.getElementsByName(name);
                    }
                },

                "CLASS": assertUsableClassName && function (className, context, xml) {
                    if (typeof context.getElementsByClassName !== strundefined && !xml) {
                        return context.getElementsByClassName(className);
                    }
                }
            },

            relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
            },

            preFilter: {
                "ATTR": function (match) {
                    match[1] = match[1].replace(rbackslash, "");

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[4] || match[5] || "").replace(rbackslash, "");

                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }

                    return match.slice(0, 4);
                },

                "CHILD": function (match) {
                    /* matches from matchExpr["CHILD"]
                    1 type (only|nth|...)
                    2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                    3 xn-component of xn+y argument ([+-]?\d*n|)
                    4 sign of xn-component
                    5 x of xn-component
                    6 sign of y-component
                    7 y of y-component
                    */
                    match[1] = match[1].toLowerCase();

                    if (match[1] === "nth") {
                        // nth-child requires argument
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }

                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
                        match[4] = +((match[6] + match[7]) || match[2] === "odd");

                        // other types prohibit arguments
                    } else if (match[2]) {
                        Sizzle.error(match[0]);
                    }

                    return match;
                },

                "PSEUDO": function (match) {
                    var unquoted, excess;
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }

                    if (match[3]) {
                        match[2] = match[3];
                    } else if ((unquoted = match[4])) {
                        // Only check arguments that contain a pseudo
                        if (rpseudo.test(unquoted) &&
                        // Get excess from tokenize (recursively)
					(excess = tokenize(unquoted, true)) &&
                        // advance to the next closing parenthesis
					(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                            // excess is a negative index
                            unquoted = unquoted.slice(0, excess);
                            match[0] = match[0].slice(0, excess);
                        }
                        match[2] = unquoted;
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },

            filter: {
                "ID": assertGetIdNotName ?
			function (id) {
			    id = id.replace(rbackslash, "");
			    return function (elem) {
			        return elem.getAttribute("id") === id;
			    };
			} :
			function (id) {
			    id = id.replace(rbackslash, "");
			    return function (elem) {
			        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
			        return node && node.value === id;
			    };
			},

                "TAG": function (nodeName) {
                    if (nodeName === "*") {
                        return function () { return true; };
                    }
                    nodeName = nodeName.replace(rbackslash, "").toLowerCase();

                    return function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },

                "CLASS": function (className) {
                    var pattern = classCache[expando][className + " "];

                    return pattern ||
				(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
				classCache(className, function (elem) {
				    return pattern.test(elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "");
				});
                },

                "ATTR": function (name, operator, check) {
                    return function (elem, context) {
                        var result = Sizzle.attr(elem, name);

                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }

                        result += "";

                        return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf(check) === 0 :
					operator === "*=" ? check && result.indexOf(check) > -1 :
					operator === "$=" ? check && result.substr(result.length - check.length) === check :
					operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
					operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" :
					false;
                    };
                },

                "CHILD": function (type, argument, first, last) {

                    if (type === "nth") {
                        return function (elem) {
                            var node, diff,
						parent = elem.parentNode;

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            if (parent) {
                                diff = 0;
                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        diff++;
                                        if (elem === node) {
                                            break;
                                        }
                                    }
                                }
                            }

                            // Incorporate the offset (or cast to NaN), then check against cycle size
                            diff -= last;
                            return diff === first || (diff % first === 0 && diff / first >= 0);
                        };
                    }

                    return function (elem) {
                        var node = elem;

                        switch (type) {
                            case "only":
                            case "first":
                                while ((node = node.previousSibling)) {
                                    if (node.nodeType === 1) {
                                        return false;
                                    }
                                }

                                if (type === "first") {
                                    return true;
                                }

                                node = elem;

                                /* falls through */
                            case "last":
                                while ((node = node.nextSibling)) {
                                    if (node.nodeType === 1) {
                                        return false;
                                    }
                                }

                                return true;
                        }
                    };
                },

                "PSEUDO": function (pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args,
				fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
					Sizzle.error("unsupported pseudo: " + pseudo);

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }

                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
					markFunction(function (seed, matches) {
					    var idx,
							matched = fn(seed, argument),
							i = matched.length;
					    while (i--) {
					        idx = indexOf.call(seed, matched[i]);
					        seed[idx] = !(matches[idx] = matched[i]);
					    }
					}) :
					function (elem) {
					    return fn(elem, 0, args);
					};
                    }

                    return fn;
                }
            },

            pseudos: {
                "not": markFunction(function (selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [],
				results = [],
				matcher = compile(selector.replace(rtrim, "$1"));

                    return matcher[expando] ?
				markFunction(function (seed, matches, context, xml) {
				    var elem,
						unmatched = matcher(seed, null, xml, []),
						i = seed.length;

				    // Match elements unmatched by `matcher`
				    while (i--) {
				        if ((elem = unmatched[i])) {
				            seed[i] = !(matches[i] = elem);
				        }
				    }
				}) :
				function (elem, context, xml) {
				    input[0] = elem;
				    matcher(input, null, xml, results);
				    return !results.pop();
				};
                }),

                "has": markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),

                "contains": markFunction(function (text) {
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),

                "enabled": function (elem) {
                    return elem.disabled === false;
                },

                "disabled": function (elem) {
                    return elem.disabled === true;
                },

                "checked": function (elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                },

                "selected": function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                "parent": function (elem) {
                    return !Expr.pseudos["empty"](elem);
                },

                "empty": function (elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
                    //   not comment, processing instructions, or others
                    // Thanks to Diego Perini for the nodeName shortcut
                    //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
                    var nodeType;
                    elem = elem.firstChild;
                    while (elem) {
                        if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) {
                            return false;
                        }
                        elem = elem.nextSibling;
                    }
                    return true;
                },

                "header": function (elem) {
                    return rheader.test(elem.nodeName);
                },

                "text": function (elem) {
                    var type, attr;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type);
                },

                // Input types
                "radio": createInputPseudo("radio"),
                "checkbox": createInputPseudo("checkbox"),
                "file": createInputPseudo("file"),
                "password": createInputPseudo("password"),
                "image": createInputPseudo("image"),

                "submit": createButtonPseudo("submit"),
                "reset": createButtonPseudo("reset"),

                "button": function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },

                "input": function (elem) {
                    return rinputs.test(elem.nodeName);
                },

                "focus": function (elem) {
                    var doc = elem.ownerDocument;
                    return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },

                "active": function (elem) {
                    return elem === elem.ownerDocument.activeElement;
                },

                // Positional types
                "first": createPositionalPseudo(function () {
                    return [0];
                }),

                "last": createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),

                "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),

                "even": createPositionalPseudo(function (matchIndexes, length) {
                    for (var i = 0; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "odd": createPositionalPseudo(function (matchIndexes, length) {
                    for (var i = 1; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };

        function siblingCheck(a, b, ret) {
            if (a === b) {
                return ret;
            }

            var cur = a.nextSibling;

            while (cur) {
                if (cur === b) {
                    return -1;
                }

                cur = cur.nextSibling;
            }

            return 1;
        }

        sortOrder = docElem.compareDocumentPosition ?
	function (a, b) {
	    if (a === b) {
	        hasDuplicate = true;
	        return 0;
	    }

	    return (!a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	} :
	function (a, b) {
	    // The nodes are identical, we can exit early
	    if (a === b) {
	        hasDuplicate = true;
	        return 0;

	        // Fallback to using sourceIndex (in IE) if it's available on both nodes
	    } else if (a.sourceIndex && b.sourceIndex) {
	        return a.sourceIndex - b.sourceIndex;
	    }

	    var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

	    // If the nodes are siblings (or identical) we can do a quick check
	    if (aup === bup) {
	        return siblingCheck(a, b);

	        // If no parents were found then the nodes are disconnected
	    } else if (!aup) {
	        return -1;

	    } else if (!bup) {
	        return 1;
	    }

	    // Otherwise they're somewhere else in the tree so we need
	    // to build up a full list of the parentNodes for comparison
	    while (cur) {
	        ap.unshift(cur);
	        cur = cur.parentNode;
	    }

	    cur = bup;

	    while (cur) {
	        bp.unshift(cur);
	        cur = cur.parentNode;
	    }

	    al = ap.length;
	    bl = bp.length;

	    // Start walking down the tree looking for a discrepancy
	    for (var i = 0; i < al && i < bl; i++) {
	        if (ap[i] !== bp[i]) {
	            return siblingCheck(ap[i], bp[i]);
	        }
	    }

	    // We ended someplace up the tree so do a sibling check
	    return i === al ?
			siblingCheck(a, bp[i], -1) :
			siblingCheck(ap[i], b, 1);
	};

        // Always assume the presence of duplicates if sort doesn't
        // pass them to our comparison function (as in Google Chrome).
        [0, 0].sort(sortOrder);
        baseHasDuplicate = !hasDuplicate;

        // Document sorting and removing duplicates
        Sizzle.uniqueSort = function (results) {
            var elem,
		duplicates = [],
		i = 1,
		j = 0;

            hasDuplicate = baseHasDuplicate;
            results.sort(sortOrder);

            if (hasDuplicate) {
                for (; (elem = results[i]); i++) {
                    if (elem === results[i - 1]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }

            return results;
        };

        Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };

        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[expando][selector + " "];

            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }

            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;

            while (soFar) {

                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }

                matched = false;

                // Combinators
                if ((match = rcombinators.exec(soFar))) {
                    tokens.push(matched = new Token(match.shift()));
                    soFar = soFar.slice(matched.length);

                    // Cast descendant combinators to space
                    matched.type = match[0].replace(rtrim, " ");
                }

                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
				(match = preFilters[type](match)))) {

                        tokens.push(matched = new Token(match.shift()));
                        soFar = soFar.slice(matched.length);
                        matched.type = type;
                        matched.matches = match;
                    }
                }

                if (!matched) {
                    break;
                }
            }

            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error(selector) :
            // Cache the tokens
			tokenCache(selector, groups).slice(0);
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
		checkNonElements = base && combinator.dir === "parentNode",
		doneName = done++;

            return combinator.first ?
            // Check against closest ancestor/preceding element
		function (elem, context, xml) {
		    while ((elem = elem[dir])) {
		        if (checkNonElements || elem.nodeType === 1) {
		            return matcher(elem, context, xml);
		        }
		    }
		} :

            // Check against all ancestor/preceding elements
		function (elem, context, xml) {
		    // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
		    if (!xml) {
		        var cache,
					dirkey = dirruns + " " + doneName + " ",
					cachedkey = dirkey + cachedruns;
		        while ((elem = elem[dir])) {
		            if (checkNonElements || elem.nodeType === 1) {
		                if ((cache = elem[expando]) === cachedkey) {
		                    return elem.sizset;
		                } else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) {
		                    if (elem.sizset) {
		                        return elem;
		                    }
		                } else {
		                    elem[expando] = cachedkey;
		                    if (matcher(elem, context, xml)) {
		                        elem.sizset = true;
		                        return elem;
		                    }
		                    elem.sizset = false;
		                }
		            }
		        }
		    } else {
		        while ((elem = elem[dir])) {
		            if (checkNonElements || elem.nodeType === 1) {
		                if (matcher(elem, context, xml)) {
		                    return elem;
		                }
		            }
		        }
		    }
		};
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ?
		function (elem, context, xml) {
		    var i = matchers.length;
		    while (i--) {
		        if (!matchers[i](elem, context, xml)) {
		            return false;
		        }
		    }
		    return true;
		} :
		matchers[0];
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

            for (; i < len; i++) {
                if ((elem = unmatched[i])) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }

            return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

                // Get initial elements from seed or context
			elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                // Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && (seed || !selector) ?
				condense(elems, preMap, preFilter, context, xml) :
				elems,

			matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

                // ...intermediate processing is necessary
					[] :

                // ...otherwise use results directly
					results :
				matcherIn;

                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }

                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);

                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if ((elem = temp[i])) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }

                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i])) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push((matcherIn[i] = elem));
                                }
                            }
                            postFinder(null, (matcherOut = []), temp, xml);
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }

                    // Add elements to results, through postFinder if defined
                } else {
                    matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice(preexisting, matcherOut.length) :
					matcherOut
			);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[tokens[0].type],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

            // The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator(function (elem) {
		    return elem === checkContext;
		}, implicitRelative, true),
		matchAnyContext = addCombinator(function (elem) {
		    return indexOf.call(checkContext, elem) > -1;
		}, implicitRelative, true),
		matchers = [function (elem, context, xml) {
		    return (!leadingRelative && (xml || context !== outermostContext)) || (
				(checkContext = context).nodeType ?
					matchContext(elem, context, xml) :
					matchAnyContext(elem, context, xml));
		} ];

            for (; i < len; i++) {
                if ((matcher = Expr.relative[tokens[i].type])) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(
					i > 1 && elementMatcher(matchers),
					i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"),
					matcher,
					i < j && matcherFromTokens(tokens.slice(i, j)),
					j < len && matcherFromTokens((tokens = tokens.slice(j))),
					j < len && tokens.join("")
				);
                    }
                    matchers.push(matcher);
                }
            }

            return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function (seed, context, xml, results, expandContext) {
		    var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
		    // We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
		    // Nested matchers should use non-integer dirruns
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

		    if (outermost) {
		        outermostContext = context !== document && context;
		        cachedruns = superMatcher.el;
		    }

		    // Add elements passing elementMatchers directly to results
		    for (; (elem = elems[i]) != null; i++) {
		        if (byElement && elem) {
		            for (j = 0; (matcher = elementMatchers[j]); j++) {
		                if (matcher(elem, context, xml)) {
		                    results.push(elem);
		                    break;
		                }
		            }
		            if (outermost) {
		                dirruns = dirrunsUnique;
		                cachedruns = ++superMatcher.el;
		            }
		        }

		        // Track unmatched elements for set filters
		        if (bySet) {
		            // They will have gone through all possible matchers
		            if ((elem = !matcher && elem)) {
		                matchedCount--;
		            }

		            // Lengthen the array for every element, matched or not
		            if (seed) {
		                unmatched.push(elem);
		            }
		        }
		    }

		    // Apply set filters to unmatched elements
		    matchedCount += i;
		    if (bySet && i !== matchedCount) {
		        for (j = 0; (matcher = setMatchers[j]); j++) {
		            matcher(unmatched, setMatched, context, xml);
		        }

		        if (seed) {
		            // Reintegrate element matches to eliminate the need for sorting
		            if (matchedCount > 0) {
		                while (i--) {
		                    if (!(unmatched[i] || setMatched[i])) {
		                        setMatched[i] = pop.call(results);
		                    }
		                }
		            }

		            // Discard index placeholder values to get only actual matches
		            setMatched = condense(setMatched);
		        }

		        // Add matches to results
		        push.apply(results, setMatched);

		        // Seedless set matches succeeding multiple successful matchers stipulate sorting
		        if (outermost && !seed && setMatched.length > 0 &&
					(matchedCount + setMatchers.length) > 1) {

		            Sizzle.uniqueSort(results);
		        }
		    }

		    // Override manipulation of globals by nested matchers
		    if (outermost) {
		        dirruns = dirrunsUnique;
		        outermostContext = contextBackup;
		    }

		    return unmatched;
		};

            superMatcher.el = 0;
            return bySet ?
		markFunction(superMatcher) :
		superMatcher;
        }

        compile = Sizzle.compile = function (selector, group /* Internal Use Only */) {
            var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[expando][selector + " "];

            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!group) {
                    group = tokenize(selector);
                }
                i = group.length;
                while (i--) {
                    cached = matcherFromTokens(group[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }

                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };

        function multipleContexts(selector, contexts, results) {
            var i = 0,
		len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }

        function select(selector, context, results, seed, xml) {
            var i, tokens, token, type, find,
		match = tokenize(selector),
		j = match.length;

            if (!seed) {
                // Try to minimize operations if there is only one group
                if (match.length === 1) {

                    // Take a shortcut and set the context if the root selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !xml &&
					Expr.relative[tokens[1].type]) {

                        context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];
                        if (!context) {
                            return results;
                        }

                        selector = selector.slice(tokens.shift().length);
                    }

                    // Fetch a seed set for right-to-left matching
                    for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(
						token.matches[0].replace(rbackslash, ""),
						rsibling.test(tokens[0].type) && context.parentNode || context,
						xml
					))) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && tokens.join("");
                                if (!selector) {
                                    push.apply(results, slice.call(seed, 0));
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }
            }

            // Compile and execute a filtering function
            // Provide `match` to avoid retokenization if we modified the selector above
            compile(selector, match)(
		seed,
		context,
		xml,
		results,
		rsibling.test(selector)
	);
            return results;
        }

        if (document.querySelectorAll) {
            (function () {
                var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

                // qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
                // A support test would require too much code (would include document ready)
			rbuggyQSA = [":focus"],

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                // A support test would require too much code (would include document ready)
                // just skip matchesSelector for :active
			rbuggyMatches = [":active"],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function (div) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explictly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // http://bugs.jquery.com/ticket/12359
                    div.innerHTML = "<select><option selected=''></option></select>";

                    // IE8 - Some boolean attributes are not treated correctly
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
                    }

                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here (do not put tests after this one)
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                });

                assert(function (div) {

                    // Opera 10-12/IE9 - ^= $= *= and empty values
                    // Should not select anything
                    div.innerHTML = "<p test=''></p>";
                    if (div.querySelectorAll("[test^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
                    }

                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here (do not put tests after this one)
                    div.innerHTML = "<input type='hidden'/>";
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                });

                // rbuggyQSA always contains :focus, so no need for a length check
                rbuggyQSA = /* rbuggyQSA.length && */new RegExp(rbuggyQSA.join("|"));

                select = function (selector, context, results, seed, xml) {
                    // Only use querySelectorAll when not filtering,
                    // when this is not xml,
                    // and when no QSA bugs apply
                    if (!seed && !xml && !rbuggyQSA.test(selector)) {
                        var groups, i,
					old = true,
					nid = expando,
					newContext = context,
					newSelector = context.nodeType === 9 && selector;

                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            groups = tokenize(selector);

                            if ((old = context.getAttribute("id"))) {
                                nid = old.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", nid);
                            }
                            nid = "[id='" + nid + "'] ";

                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + groups[i].join("");
                            }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(",");
                        }

                        if (newSelector) {
                            try {
                                push.apply(results, slice.call(newContext.querySelectorAll(
							newSelector
						), 0));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (!old) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSelect(selector, context, results, seed, xml);
                };

                if (matches) {
                    assert(function (div) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        disconnectedMatch = matches.call(div, "div");

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        try {
                            matches.call(div, "[test!='']:sizzle");
                            rbuggyMatches.push("!=", pseudos);
                        } catch (e) { }
                    });

                    // rbuggyMatches always contains :active and :focus, so no need for a length check
                    rbuggyMatches = /* rbuggyMatches.length && */new RegExp(rbuggyMatches.join("|"));

                    Sizzle.matchesSelector = function (elem, expr) {
                        // Make sure that attribute selectors are quoted
                        expr = expr.replace(rattributeQuotes, "='$1']");

                        // rbuggyMatches always contains :active, so no need for an existence check
                        if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) {
                            try {
                                var ret = matches.call(elem, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9
								elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) { }
                        }

                        return Sizzle(expr, null, null, [elem]).length > 0;
                    };
                }
            })();
        }

        // Deprecated
        Expr.pseudos["nth"] = Expr.pseudos["eq"];

        // Back-compat
        function setFilters() { }
        Expr.filters = setFilters.prototype = Expr.pseudos;
        Expr.setFilters = new setFilters();

        // Override sizzle attribute retrieval
        Sizzle.attr = jQuery.attr;
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })(window);
    var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
    // methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
	    children: true,
	    contents: true,
	    next: true,
	    prev: true
	};

    jQuery.fn.extend({
        find: function (selector) {
            var i, l, length, n, r, ret,
			self = this;

            if (typeof selector !== "string") {
                return jQuery(selector).filter(function () {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }

            ret = this.pushStack("", "find", selector);

            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var i,
			targets = jQuery(target, this),
			len = targets.length;

            return this.filter(function () {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && (
			typeof selector === "string" ?
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test(selector) ?
					jQuery(selector, this.context).index(this[0]) >= 0 :
					jQuery.filter(selector, this).length > 0 :
				this.filter(selector).length > 0);
        },

        closest: function (selectors, context) {
            var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
				jQuery(selectors, context || this.context) :
				0;

            for (; i < l; i++) {
                cur = this[i];

                while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;
                    }
                    cur = cur.parentNode;
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.prevAll().length : -1;
            }

            // index in selector
            if (typeof elem === "string") {
                return jQuery.inArray(this[0], jQuery(elem));
            }

            // Locate the position of the desired element
            return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
				jQuery(selector, context) :
				jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
			all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
			all :
			jQuery.unique(all));
        },

        addBack: function (selector) {
            return this.add(selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
        }
    });

    jQuery.fn.andSelf = jQuery.fn.addBack;

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);

        return cur;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function (elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

            if (this.length > 1 && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, core_slice.call(arguments).join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
			jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [],
			cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }
    function createSafeFragment(document) {
        var list = nodeNames.split("|"),
	safeFrag = document.createDocumentFragment();

        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(
				list.pop()
			);
            }
        }
        return safeFrag;
    }

    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rcheckableType = /^(?:checkbox|radio)$/,
    // checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
	wrapMap = {
	    option: [1, "<select multiple='multiple'>", "</select>"],
	    legend: [1, "<fieldset>", "</fieldset>"],
	    thead: [1, "<table>", "</table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
	    area: [1, "<map>", "</map>"],
	    _default: [0, "", ""]
	},
	safeFragment = createSafeFragment(document),
	fragmentDiv = safeFragment.appendChild(document.createElement("div"));

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
    // unless wrapped in a div with non-breaking characters in front of it.
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "X<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (value) {
            return jQuery.access(this, function (value) {
                return value === undefined ?
				jQuery.text(this) :
				this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
				contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (!isDisconnected(this[0])) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            }

            if (arguments.length) {
                var set = jQuery.clean(arguments);
                return this.pushStack(jQuery.merge(set, this), "before", this.selector);
            }
        },

        after: function () {
            if (!isDisconnected(this[0])) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            }

            if (arguments.length) {
                var set = jQuery.clean(arguments);
                return this.pushStack(jQuery.merge(this, set), "after", this.selector);
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            var elem,
			i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            var elem,
			i = 0;

            for (; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            return jQuery.access(this, function (value) {
                var elem = this[0] || {},
				i = 0,
				l = this.length;

                if (value === undefined) {
                    return elem.nodeType === 1 ?
					elem.innerHTML.replace(rinlinejQuery, "") :
					undefined;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
				(jQuery.support.htmlSerialize || !rnoshimcache.test(value)) &&
				(jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
				!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = value.replace(rxhtmlTag, "<$1></$2>");

                    try {
                        for (; i < l; i++) {
                            // Remove element nodes and prevent memory leaks
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(elem.getElementsByTagName("*"));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) { }
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function (value) {
            if (!isDisconnected(this[0])) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling,
					parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            }

            return this.length ?
			this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
			this;
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {

            // Flatten any nested arrays
            args = [].concat.apply([], args);

            var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                results = jQuery.buildFragment(args, this, scripts);
                fragment = results.fragment;
                first = fragment.firstChild;

                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    // Fragments from the fragment cache must always be cloned and never used in place.
                    for (iNoClone = results.cacheable || l - 1; i < l; i++) {
                        callback.call(
						table && jQuery.nodeName(this[i], "table") ?
							findOrAppend(this[i], "tbody") :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone(fragment, true, true)
					);
                    }
                }

                // Fix #11809: Avoid leaking memory
                fragment = first = null;

                if (scripts.length) {
                    jQuery.each(scripts, function (i, elem) {
                        if (elem.src) {
                            if (jQuery.ajax) {
                                jQuery.ajax({
                                    url: elem.src,
                                    type: "GET",
                                    dataType: "script",
                                    async: false,
                                    global: false,
                                    "throws": true
                                });
                            } else {
                                jQuery.error("no ajax");
                            }
                        } else {
                            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, ""));
                        }

                        if (elem.parentNode) {
                            elem.parentNode.removeChild(elem);
                        }
                    });
                }
            }

            return this;
        }
    });

    function findOrAppend(elem, tag) {
        return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
    }

    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var type, i, l,
		oldData = jQuery._data(src),
		curData = jQuery._data(dest, oldData),
		events = oldData.events;

        if (events) {
            delete curData.handle;
            curData.events = {};

            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }

        // make the cloned public data object a copy from the original
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }

        nodeName = dest.nodeName.toLowerCase();

        if (nodeName === "object") {
            // IE6-10 improperly clones children of object elements using classid.
            // IE10 throws NoModificationAllowedError if parent is null, #12132.
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }

            // This path appears unavoidable for IE9. When cloning an object
            // element in IE9, the outerHTML strategy above is not sufficient.
            // If the src has innerHTML and the destination does not,
            // copy the src.innerHTML into the dest.innerHTML. #10324
            if (jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                dest.innerHTML = src.innerHTML;
            }

        } else if (nodeName === "input" && rcheckableType.test(src.type)) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set

            dest.defaultChecked = dest.checked = src.checked;

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;

            // IE blanks contents when cloning scripts
        } else if (nodeName === "script" && dest.text !== src.text) {
            dest.text = src.text;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute(jQuery.expando);
    }

    jQuery.buildFragment = function (args, context, scripts) {
        var fragment, cacheable, cachehit,
		first = args[0];

        // Set context from what may come in as undefined or a jQuery collection or a node
        // Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
        // also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
        context = context || document;
        context = !context.nodeType && context[0] || context;
        context = context.ownerDocument || context;

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
        if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
		first.charAt(0) === "<" && !rnocache.test(first) &&
		(jQuery.support.checkClone || !rchecked.test(first)) &&
		(jQuery.support.html5Clone || !rnoshimcache.test(first))) {

            // Mark cacheable and look for a hit
            cacheable = true;
            fragment = jQuery.fragments[first];
            cachehit = fragment !== undefined;
        }

        if (!fragment) {
            fragment = context.createDocumentFragment();
            jQuery.clean(args, context, fragment, scripts);

            // Update the cache, but only store false
            // unless this is a second parsing of the same content
            if (cacheable) {
                jQuery.fragments[first] = cachehit && fragment;
            }
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems,
			i = 0,
			ret = [],
			insert = jQuery(selector),
			l = insert.length,
			parent = this.length === 1 && this[0].parentNode;

            if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) {
                insert[original](this[0]);
                return this;
            } else {
                for (; i < l; i++) {
                    elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) {
        if (typeof elem.getElementsByTagName !== "undefined") {
            return elem.getElementsByTagName("*");

        } else if (typeof elem.querySelectorAll !== "undefined") {
            return elem.querySelectorAll("*");

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var srcElements,
			destElements,
			i,
			clone;

            if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
                clone = elem.cloneNode(true);

                // IE<=8 does not properly clone detached, unknown element nodes
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if (destElements[i]) {
                        cloneFixAttributes(srcElements[i], destElements[i]);
                    }
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function (elems, context, fragment, scripts) {
            var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document && safeFragment,
			ret = [];

            // Ensure that context is a document
            if (!context || typeof context.createDocumentFragment === "undefined") {
                context = document;
            }

            // Use the already-created safe fragment if context permits
            for (i = 0; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Ensure a safe container in which to render the html
                        safe = safe || createSafeFragment(context);
                        div = context.createElement("div");
                        safe.appendChild(div);

                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Go to html and back, then peel off extra wrappers
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        depth = wrap[0];
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            hasBody = rtbody.test(elem);
                            tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

                            // String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;

                        // Take out of fragment container (we need a fresh div each time)
                        div.parentNode.removeChild(div);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    jQuery.merge(ret, elem);
                }
            }

            // Fix #11356: Clear elements from safeFragment
            if (div) {
                elem = div = safe = null;
            }

            // Reset defaultChecked for any radios and checkboxes
            // about to be appended to the DOM in IE 6/7 (#8060)
            if (!jQuery.support.appendChecked) {
                for (i = 0; (elem = ret[i]) != null; i++) {
                    if (jQuery.nodeName(elem, "input")) {
                        fixDefaultChecked(elem);
                    } else if (typeof elem.getElementsByTagName !== "undefined") {
                        jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
                    }
                }
            }

            // Append elements to a provided document fragment
            if (fragment) {
                // Special handling of each script element
                handleScript = function (elem) {
                    // Check if we consider it executable
                    if (!elem.type || rscriptType.test(elem.type)) {
                        // Detach the script and store it in the scripts array (if provided) or the fragment
                        // Return truthy to indicate that it has been handled
                        return scripts ?
						scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) :
						fragment.appendChild(elem);
                    }
                };

                for (i = 0; (elem = ret[i]) != null; i++) {
                    // Check if we're done after handling an executable script
                    if (!(jQuery.nodeName(elem, "script") && handleScript(elem))) {
                        // Append to fragment and handle embedded scripts
                        fragment.appendChild(elem);
                        if (typeof elem.getElementsByTagName !== "undefined") {
                            // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
                            jsTags = jQuery.grep(jQuery.merge([], elem.getElementsByTagName("script")), handleScript);

                            // Splice the scripts into ret after their former ancestor and advance our index beyond them
                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                            i += jsTags.length;
                        }
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems, /* internal */acceptData) {
            var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

            for (; (elem = elems[i]) != null; i++) {

                if (acceptData || jQuery.acceptData(elem)) {

                    id = elem[internalKey];
                    data = id && cache[id];

                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Remove cache only if it was not already removed by jQuery.event.remove
                        if (cache[id]) {

                            delete cache[id];

                            // IE does not allow us to delete expando properties from nodes,
                            // nor does it have a removeAttribute function on Document nodes;
                            // we must handle all of these cases
                            if (deleteExpando) {
                                delete elem[internalKey];

                            } else if (elem.removeAttribute) {
                                elem.removeAttribute(internalKey);

                            } else {
                                elem[internalKey] = null;
                            }

                            jQuery.deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    // Limit scope pollution from any deprecated API
    (function () {

        var matched, browser;

        // Use of jQuery.browser is frowned upon.
        // More details: http://api.jquery.com/jQuery.browser
        // jQuery.uaMatch maintained for back-compat
        jQuery.uaMatch = function (ua) {
            ua = ua.toLowerCase();

            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
		/(webkit)[ \/]([\w.]+)/.exec(ua) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
		/(msie) ([\w.]+)/.exec(ua) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
		[];

            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };

        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};

        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }

        // Chrome is Webkit, but Webkit is also Safari.
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }

        jQuery.browser = browser;

        jQuery.sub = function () {
            function jQuerySub(selector, context) {
                return new jQuerySub.fn.init(selector, context);
            }
            jQuery.extend(true, jQuerySub, this);
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init(selector, context) {
                if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                    context = jQuerySub(context);
                }

                return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        };

    })();
    var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
	rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
	rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
	    letterSpacing: 0,
	    fontWeight: 400
	},

	cssExpand = ["Top", "Right", "Bottom", "Left"],
	cssPrefixes = ["Webkit", "O", "Moz", "ms"],

	eventsToggle = jQuery.fn.toggle;

    // return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {

        // shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }

        // check for vendor prefixed names
        var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }

        return origName;
    }

    function isHidden(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    }

    function showHide(elements, show) {
        var elem, display,
		values = [],
		index = 0,
		length = elements.length;

        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, "olddisplay");
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && elem.style.display === "none") {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = jQuery._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
                }
            } else {
                display = curCSS(elem, "display");

                if (!values[index] && display !== "none") {
                    jQuery._data(elem, "olddisplay", display);
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.fn.extend({
        css: function (name, value) {
            return jQuery.access(this, function (elem, name, value) {
                return value !== undefined ?
				jQuery.style(elem, name, value) :
				jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state, fn2) {
            var bool = typeof state === "boolean";

            if (jQuery.isFunction(state) && jQuery.isFunction(fn2)) {
                return eventsToggle.apply(this, arguments);
            }

            return this.each(function () {
                if (bool ? state : isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;

                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
			origName = jQuery.camelCase(name),
			style = elem.style;

            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that NaN and null values aren't set. See: #7116
                if (value == null || type === "number" && isNaN(value)) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, numeric, extra) {
            var val, num, hooks,
			origName = jQuery.camelCase(name);

            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name);
            }

            //convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if (numeric || extra !== undefined) {
                num = parseFloat(val);
                return numeric || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var ret, name,
			old = {};

            // Remember the old values, and insert the new ones
            for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            ret = callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }

            return ret;
        }
    });

    // NOTE: To any future maintainer, we've window.getComputedStyle
    // because jsdom on node.js will break without it.
    if (window.getComputedStyle) {
        curCSS = function (elem, name) {
            var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle(elem, null),
			style = elem.style;

            if (computed) {

                // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                ret = computed.getPropertyValue(name) || computed[name];

                if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }

                // A tribute to the "awesome hack by Dean Edwards"
                // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;

                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;

                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }

            return ret;
        };
    } else if (document.documentElement.currentStyle) {
        curCSS = function (elem, name) {
            var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[name],
			style = elem.style;

            // Avoid setting ret to empty string here
            // so we don't default to auto
            if (ret == null && style && style[name]) {
                ret = style[name];
            }

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            // but not position css attributes, as those are proportional to the parent element instead
            // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
            if (rnumnonpx.test(ret) && !rposition.test(name)) {

                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ?
			Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
			value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
        var i = extra === (isBorderBox ? "border" : "content") ?
        // If we already have the right measurement, avoid augmentation
		4 :
        // Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

        for (; i < 4; i += 2) {
            // both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                // we use jQuery.css instead of curCSS here
                // because of the reliableMarginRight CSS hook!
                val += jQuery.css(elem, extra + cssExpand[i], true);
            }

            // From this point on we use curCSS for maximum performance (relevant in animations)
            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
                }

                // at this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;

                // at this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
                }
            }
        }

        return val;
    }

    function getWidthOrHeight(elem, name, extra) {

        // Start with offset property, which is equivalent to the border-box value
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box";

        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }

            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);

            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }

        // use the active box-sizing model to add/subtract irrelevant styles
        return (val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || (isBorderBox ? "border" : "content"),
			valueIsBorderBox
		)
	) + "px";
    }


    // Try to determine the default display value of an element
    function css_defaultDisplay(nodeName) {
        if (elemdisplay[nodeName]) {
            return elemdisplay[nodeName];
        }

        var elem = jQuery("<" + nodeName + ">").appendTo(document.body),
		display = elem.css("display");
        elem.remove();

        // If the simple way fails,
        // get element's real default display by attaching it to a temp iframe
        if (display === "none" || display === "") {
            // Use the already-created iframe if possible
            iframe = document.body.appendChild(
			iframe || jQuery.extend(document.createElement("iframe"), {
			    frameBorder: 0,
			    width: 0,
			    height: 0
			})
		);

            // Create a cacheable copy of the iframe document on first call.
            // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
            // document to it; WebKit & Firefox won't allow reusing the iframe document.
            if (!iframeDoc || !iframe.createElement) {
                iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                iframeDoc.write("<!doctype html><html><body>");
                iframeDoc.close();
            }

            elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));

            display = curCSS(elem, "display");
            document.body.removeChild(iframe);
        }

        // Store the correct default display
        elemdisplay[nodeName] = display;

        return display;
    }

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) {
                        return jQuery.swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, name, extra);
                        });
                    } else {
                        return getWidthOrHeight(elem, name, extra);
                    }
                }
            },

            set: function (elem, value, extra) {
                return setPositiveNumber(elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box"
				) : 0
			);
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(0.01 * parseFloat(RegExp.$1)) + "" :
				computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "" &&
				style.removeAttribute) {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute("filter");

                    // if there there is no filter style applied in a css rule, we are done
                    if (currentStyle && !currentStyle.filter) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				filter + " " + opacity;
            }
        };
    }

    // These hooks cannot be added until DOM ready because the support test
    // for it is not run until after DOM ready
    jQuery(function () {
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    return jQuery.swap(elem, { "display": "inline-block" }, function () {
                        if (computed) {
                            return curCSS(elem, "marginRight");
                        }
                    });
                }
            };
        }

        // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
        // getComputedStyle returns percent when specified for top/left/bottom/right
        // rather than make the css module depend on the offset module, we just check for it here
        if (!jQuery.support.pixelPosition && jQuery.fn.position) {
            jQuery.each(["top", "left"], function (i, prop) {
                jQuery.cssHooks[prop] = {
                    get: function (elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, prop);
                            // if curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(ret) ? jQuery(elem).position()[prop] + "px" : ret;
                        }
                    }
                };
            });
        }

    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            return (elem.offsetWidth === 0 && elem.offsetHeight === 0) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i,

                // assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value],
				expanded = {};

                for (i = 0; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
					parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
		.filter(function () {
		    return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
		})
		.map(function (i, elem) {
		    var val = jQuery(this).val();

		    return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map(val, function (val, i) {
					    return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					}) :
					{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
		}).get();
        }
    });

    //Serialize an array of form elements or a set of
    //key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
		s = [],
		add = function (key, value) {
		    // If value is a function, invoke it and return its value
		    value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
		    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });

        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    };

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && jQuery.type(obj) === "object") {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }
    var 
    // Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

    // Keep a copy of the old load method
	_load = jQuery.fn.load,

    /* Prefilters
    * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    * 2) These are called:
    *    - BEFORE asking for a transport
    *    - AFTER param serialization (s.data is a string if s.processData is true)
    * 3) key is the dataType
    * 4) the catchall symbol "*" can be used
    * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    */
	prefilters = {},

    /* Transports bindings
    * 1) key is the dataType
    * 2) the catchall symbol "*" can be used
    * 3) selection will start with transport dataType and THEN go to "*" if needed
    */
	transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split(core_rspace),
			i = 0,
			length = dataTypes.length;

            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    // then we add to the structure accordingly
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */) {

        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};

        inspected[dataType] = true;

        var selection,
		list = structure[dataType],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = (structure === prefilters);

        for (; i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected);
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
    }

    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }

        // Don't do a request if no elements are being requested
        if (!this.length) {
            return this;
        }

        var selector, type, response,
		self = this,
		off = url.indexOf(" ");

        if (off >= 0) {
            selector = url.slice(off, url.length);
            url = url.slice(0, off);
        }

        // If it's a function
        if (jQuery.isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // Request the remote document
        jQuery.ajax({
            url: url,

            // if "type" variable is undefined, then "GET" method will be used
            type: type,
            dataType: "html",
            data: params,
            complete: function (jqXHR, status) {
                if (callback) {
                    self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                }
            }
        }).done(function (responseText) {

            // Save response for use in complete callback
            response = arguments;

            // See if a selector was specified
            self.html(selector ?

            // Create a dummy div to hold the results
			jQuery("<div>")

            // inject the contents of the document in, removing the scripts
            // to avoid any 'Permission Denied' errors in IE
				.append(responseText.replace(rscript, ""))

            // Locate the specified elements
				.find(selector) :

            // If not, just inject the full result
			responseText);

        });

        return this;
    };

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.on(o, f);
        };
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            if (settings) {
                // Building a settings object
                ajaxExtend(target, jQuery.ajaxSettings);
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend(target, settings);
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // ifModified key
			ifModifiedKey,
            // Response headers
			responseHeadersString,
			responseHeaders,
            // transport
			transport,
            // timeout handle
			timeoutTimer,
            // Cross-domain detection vars
			parts,
            // To know if global events are to be dispatched
			fireGlobals,
            // Loop variable
			i,
            // Create the final options object
			s = jQuery.ajaxSetup({}, options),
            // Callbacks context
			callbackContext = s.context || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				(callbackContext.nodeType || callbackContext instanceof jQuery) ?
						jQuery(callbackContext) : jQuery.event,
            // Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
			statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
            // The jqXHR state
			state = 0,
            // Default abort message
			strAbort = "canceled",
            // Fake xhr
			jqXHR = {

			    readyState: 0,

			    // Caches the header
			    setRequestHeader: function (name, value) {
			        if (!state) {
			            var lname = name.toLowerCase();
			            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
			            requestHeaders[name] = value;
			        }
			        return this;
			    },

			    // Raw string
			    getAllResponseHeaders: function () {
			        return state === 2 ? responseHeadersString : null;
			    },

			    // Builds headers hashtable if needed
			    getResponseHeader: function (key) {
			        var match;
			        if (state === 2) {
			            if (!responseHeaders) {
			                responseHeaders = {};
			                while ((match = rheaders.exec(responseHeadersString))) {
			                    responseHeaders[match[1].toLowerCase()] = match[2];
			                }
			            }
			            match = responseHeaders[key.toLowerCase()];
			        }
			        return match === undefined ? null : match;
			    },

			    // Overrides response content-type header
			    overrideMimeType: function (type) {
			        if (!state) {
			            s.mimeType = type;
			        }
			        return this;
			    },

			    // Cancel the request
			    abort: function (statusText) {
			        statusText = statusText || strAbort;
			        if (transport) {
			            transport.abort(statusText);
			        }
			        done(0, statusText);
			        return this;
			    }
			};

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {

                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[ifModifiedKey] = modified;
                        }
                        modified = jqXHR.getResponseHeader("Etag");
                        if (modified) {
                            jQuery.etag[ifModifiedKey] = modified;
                        }
                    }

                    // If not modified
                    if (status === 304) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        isSuccess = ajaxConvert(s, response);
                        statusText = isSuccess.state;
                        success = isSuccess.data;
                        error = isSuccess.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"),
						[jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;

            // Status-dependent callbacks
            jqXHR.statusCode = function (map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [statusCode[tmp], map[tmp]];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.always(tmp);
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(core_rspace);

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
				(parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
					(parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
						(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
			);
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                    // try replacing _= if it is there
					ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
				s.accepts["*"]
		);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already and return
                return jqXHR.abort();

            }

            // aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            return jqXHR;
        },

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
    * - sets all responseXXX fields accordingly
    * - finds the right dataType (mediates between content-type and expected dataType)
    * - returns the corresponding response
    */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

        // Fill responseXXX fields
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert(s, response) {

        var conv, conv2, current, tmp,
        // Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[0],
		converters = {},
		i = 0;

        // Apply the dataFilter if provided
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        // Convert to each sequential dataType, tolerating list modification
        for (; (current = dataTypes[++i]); ) {

            // There's only work to do if current dataType is non-auto
            if (current !== "*") {

                // Convert response if prev dataType is non-auto and differs from current
                if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] ||
								converters["* " + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.splice(i--, 0, current);
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                            }
                        }
                    }
                }

                // Update prev for next iteration
                prev = current;
            }
        }

        return { state: "success", data: response };
    }
    var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&|$)|\?\?/,
	nonce = jQuery.now();

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback && rjsonp.test(url),
		replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
			!(s.contentType || "").indexOf("application/x-www-form-urlencoded") &&
			rjsonp.test(data);

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (s.dataTypes[0] === "jsonp" || replaceInUrl || replaceInData) {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
			s.jsonpCallback() :
			s.jsonpCallback;
            overwritten = window[callbackName];

            // Insert callback into url or form data
            if (replaceInUrl) {
                s.url = url.replace(rjsonp, "$1" + callbackName);
            } else if (replaceInData) {
                s.data = data.replace(rjsonp, "$1" + callbackName);
            } else if (hasCallback) {
                s.url += (rquestion.test(url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {
                // Restore preexisting value
                window[callbackName] = overwritten;

                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {

            var script,
			head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

            return {

                send: function (_, callback) {

                    script = document.createElement("script");

                    script.async = "async";

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function (_, isAbort) {

                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });
    var xhrCallbacks,
    // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function () {
	    // Abort all pending requests
	    for (var key in xhrCallbacks) {
	        xhrCallbacks[key](0, 1);
	    }
	} : false,
	xhrId = 0;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) { }
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
    * implement the XMLHttpRequest in IE7 (can't request local files),
    * so we use the ActiveXObject when it is available
    * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
    * we need a fallback.
    */
	function () {
	    return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
    // For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

    // Determine support properties
    (function (xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ("withCredentials" in xhr)
        });
    })(jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(function (s) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                    send: function (headers, complete) {

                        // Get a new xhr
                        var handle, i,
						xhr = s.xhr();

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }

                        // Apply custom fields if provided
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) { }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((s.hasContent && s.data) || null);

                        // Listener
                        callback = function (_, isAbort) {

                            var status,
							statusText,
							responseHeaders,
							responses,
							xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occurred
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if (callback && (isAbort || xhr.readyState === 4)) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }

                                    // If it's an abort
                                    if (isAbort) {
                                        // Abort it manually if needed
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if (xml && xml.documentElement /* #4958 */) {
                                            responses.xml = xml;
                                        }

                                        // When requesting binary data, IE6-9 will throw an exception
                                        // on any attempt to access responseText (#11426)
                                        try {
                                            responses.text = xhr.responseText;
                                        } catch (e) {
                                        }

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };

                        if (!s.async) {
                            // if we're in sync mode we fire the callback
                            callback();
                        } else if (xhr.readyState === 4) {
                            // (IE6 & IE7) if it's in cache and has been
                            // retrieved directly we need to fire the callback
                            setTimeout(callback, 0);
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }
    var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
	rrun = /queueHooks$/,
	animationPrefilters = [defaultPrefilter],
	tweeners = {
	    "*": [function (prop, value) {
	        var end, unit,
				tween = this.createTween(prop, value),
				parts = rfxnum.exec(value),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

	        if (parts) {
	            end = +parts[2];
	            unit = parts[3] || (jQuery.cssNumber[prop] ? "" : "px");

	            // We need to compute starting value
	            if (unit !== "px" && start) {
	                // Iteratively approximate from a nonzero starting point
	                // Prefer the current property, because this process will be trivial if it uses the same units
	                // Fallback to end or a simple constant
	                start = jQuery.css(tween.elem, prop, true) || end || 1;

	                do {
	                    // If previous iteration zeroed out, double until we get *something*
	                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below
	                    scale = scale || ".5";

	                    // Adjust and apply
	                    start = start / scale;
	                    jQuery.style(tween.elem, prop, start + unit);

	                    // Update scale, tolerating zero or NaN from tween.cur()
	                    // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
	                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
	            }

	            tween.unit = unit;
	            tween.start = start;
	            // If a +=/-= token was provided, we're doing a relative animation
	            tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
	        }
	        return tween;
	    } ]
	};

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        }, 0);
        return (fxNow = jQuery.now());
    }

    function createTweens(animation, props) {
        jQuery.each(props, function (prop, value) {
            var collection = (tweeners[prop] || []).concat(tweeners["*"]),
			index = 0,
			length = collection.length;
            for (; index < length; index++) {
                if (collection[index].call(animation, prop, value)) {

                    // we're done with this property
                    return;
                }
            }
        });
    }

    function Animation(elem, properties, options) {
        var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always(function () {
		    // don't match elem in the :animated selector
		    delete tick.elem;
		}),
		tick = function () {
		    var currentTime = fxNow || createFxNow(),
				remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
		    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

		    for (; index < length; index++) {
		        animation.tweens[index].run(percent);
		    }

		    deferred.notifyWith(elem, [animation, percent, remaining]);

		    if (percent < 1 && length) {
		        return remaining;
		    } else {
		        deferred.resolveWith(elem, [animation]);
		        return false;
		    }
		},
		animation = deferred.promise({
		    elem: elem,
		    props: jQuery.extend({}, properties),
		    opts: jQuery.extend(true, { specialEasing: {} }, options),
		    originalProperties: properties,
		    originalOptions: options,
		    startTime: fxNow || createFxNow(),
		    duration: options.duration,
		    tweens: [],
		    createTween: function (prop, end, easing) {
		        var tween = jQuery.Tween(elem, animation.opts, prop, end,
						animation.opts.specialEasing[prop] || animation.opts.easing);
		        animation.tweens.push(tween);
		        return tween;
		    },
		    stop: function (gotoEnd) {
		        var index = 0,
		        // if we are going to the end, we want to run all the tweens
		        // otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

		        for (; index < length; index++) {
		            animation.tweens[index].run(1);
		        }

		        // resolve when we played the last frame
		        // otherwise, reject
		        if (gotoEnd) {
		            deferred.resolveWith(elem, [animation, gotoEnd]);
		        } else {
		            deferred.rejectWith(elem, [animation, gotoEnd]);
		        }
		        return this;
		    }
		}),
		props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }

        createTweens(animation, props);

        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        jQuery.fx.timer(
		jQuery.extend(tick, {
		    anim: animation,
		    queue: animation.opts.queue,
		    elem: elem
		})
	);

        // attach callbacks from options
        return animation.progress(animation.opts.progress)
		.done(animation.opts.done, animation.opts.complete)
		.fail(animation.opts.fail)
		.always(animation.opts.always);
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.split(" ");
            }

            var prop,
			index = 0,
			length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },

        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });

    function defaultPrefilter(elem, props, opts) {
        var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden(elem);

        // handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // height/width overflow pass
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE does not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            if (jQuery.css(elem, "display") === "inline" &&
				jQuery.css(elem, "float") === "none") {

                // inline-level elements accept inline-block;
                // block-level elements need to be inline with layout
                if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
                    style.display = "inline-block";

                } else {
                    style.zoom = 1;
                }
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            if (!jQuery.support.shrinkWrapBlocks) {
                anim.done(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }


        // show/hide pass
        for (index in props) {
            value = props[index];
            if (rfxtypes.exec(value)) {
                delete props[index];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    continue;
                }
                handled.push(index);
            }
        }

        length = handled.length;
        if (length) {
            dataShow = jQuery._data(elem, "fxshow") || jQuery._data(elem, "fxshow", {});
            if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
            }

            // store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                jQuery.removeData(elem, "fxshow", true);
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (index = 0; index < length; index++) {
                prop = handled[index];
                tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
                orig[prop] = dataShow[prop] || jQuery.style(elem, prop);

                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        }
    }

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ?
			hooks.get(this) :
			Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased,
			hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;

                if (tween.elem[tween.prop] != null &&
				(!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }

                // passing any value as a 4th parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css(tween.elem, tween.prop, false, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function (tween) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Remove in 2.0 - this supports IE8's panic based approach
    // to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ||
            // special check for .toggle( handler, handler, ... )
			(!i && jQuery.isFunction(speed) && jQuery.isFunction(easing)) ?
			cssFn.apply(this, arguments) :
			this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {

            // show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show()

            // animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
			optall = jQuery.speed(speed, easing, callback),
			doAnimation = function () {
			    // Operate on a copy of prop so per-property easing won't be lost
			    var anim = Animation(this, jQuery.extend({}, prop), optall);

			    // Empty animations resolve immediately
			    if (empty) {
			        anim.stop(true);
			    }
			};

            return empty || optall.queue === false ?
			this.each(doAnimation) :
			this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        }
    });

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
		attrs = { height: type },
		i = 0;

        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing ||
			jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

        // normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };

    jQuery.timers = [];
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.tick = function () {
        var timer,
		timers = jQuery.timers,
		i = 0;

        fxNow = jQuery.now();

        for (; i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        if (timer() && jQuery.timers.push(timer) && !timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };

    // Back Compat <1.8 extension point
    jQuery.fx.step = {};

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }
    var rroot = /^(?:body|html)$/i;

    jQuery.fn.offset = function (options) {
        if (arguments.length) {
            return options === undefined ?
			this :
			this.each(function (i) {
			    jQuery.offset.setOffset(this, options, i);
			});
        }

        var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
		box = { top: 0, left: 0 },
		elem = this[0],
		doc = elem && elem.ownerDocument;

        if (!doc) {
            return;
        }

        if ((body = doc.body) === elem) {
            return jQuery.offset.bodyOffset(elem);
        }

        docElem = doc.documentElement;

        // Make sure it's not a disconnected DOM node
        if (!jQuery.contains(docElem, elem)) {
            return box;
        }

        // If we don't have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if (typeof elem.getBoundingClientRect !== "undefined") {
            box = elem.getBoundingClientRect();
        }
        win = getWindow(doc);
        clientTop = docElem.clientTop || body.clientTop || 0;
        clientLeft = docElem.clientLeft || body.clientLeft || 0;
        scrollTop = win.pageYOffset || docElem.scrollTop;
        scrollLeft = win.pageXOffset || docElem.scrollLeft;
        return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
        };
    };

    jQuery.offset = {

        bodyOffset: function (body) {
            var top = body.offsetTop,
			left = body.offsetLeft;

            if (jQuery.support.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css(elem, "top"),
			curCSSLeft = jQuery.css(elem, "left"),
			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({

        position: function () {
            if (!this[0]) {
                return;
            }

            var elem = this[0],

            // Get *real* offsetParent
		offsetParent = this.offsetParent(),

            // Get correct offsets
		offset = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0} : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || document.body;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
        var top = /Y/.test(prop);

        jQuery.fn[method] = function (val) {
            return jQuery.access(this, function (elem, method, val) {
                var win = getWindow(elem);

                if (val === undefined) {
                    return win ? (prop in win) ? win[prop] :
					win.document.documentElement[method] :
					elem[method];
                }

                if (win) {
                    win.scrollTo(
					!top ? val : jQuery(win).scrollLeft(),
					 top ? val : jQuery(win).scrollTop()
				);

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
    }
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
        jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                return jQuery.access(this, function (elem, type, value) {
                    var doc;

                    if (jQuery.isWindow(elem)) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }

                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                        // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                        return Math.max(
						elem.body["scroll" + name], doc["scroll" + name],
						elem.body["offset" + name], doc["offset" + name],
						doc["client" + name]
					);
                    }

                    return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, value, extra) :

                    // Set width or height on the element
					jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;

    // Expose jQuery as an AMD module, but only for AMD loaders that
    // understand the issues with loading multiple versions of jQuery
    // in a page that all might call define(). The loader will indicate
    // they have special allowances for multiple jQuery versions by
    // specifying define.amd.jQuery = true. Register as a named module,
    // since jQuery can be concatenated with other files that may use define,
    // but not use a proper concatenation script that understands anonymous
    // AMD modules. A named AMD is safest and most robust way to register.
    // Lowercase jquery is used because AMD module names are derived from
    // file names, and jQuery is normally delivered in a lowercase file name.
    // Do this after creating the global so that if an AMD module wants to call
    // noConflict to hide this version of jQuery, it will work.
    if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define("jquery", [], function () { return jQuery; });
    }

})(window);

define('pjs', [], function () {

    var P = (function (prototype, ownProperty, undefined) {
        // helper functions that also help minification
        function isObject(o) { return typeof o === 'object'; }
        function isFunction(f) { return typeof f === 'function'; }

        function P(_superclass /* = Object */, definition) {
            // handle the case where no superclass is given
            if (definition === undefined) {
                definition = _superclass;
                _superclass = Object;
            }

            // C is the class to be returned.
            // There are three ways C will be called:
            //
            // 1) We call `new C` to create a new uninitialized object.
            //    The behavior is similar to Object.create, where the prototype
            //    relationship is set up, but the ::init method is not run.
            //    Note that in this case we have `this instanceof C`, so we don't
            //    spring the first trap. Also, `args` is undefined, so the initializer
            //    doesn't get run.
            //
            // 2) A user will simply call C(a, b, c, ...) to create a new object with
            //    initialization.  This allows the user to create objects without `new`,
            //    and in particular to initialize objects with variable arguments, which
            //    is impossible with the `new` keyword.  Note that in this case,
            //    !(this instanceof C) springs the return trap at the beginning, and
            //    C is called with the `new` keyword and one argument, which is the
            //    Arguments object passed in.
            //
            // 3) For internal use only, if new C(args) is called, where args is an
            //    Arguments object.  In this case, the presence of `new` means the
            //    return trap is not sprung, but the initializer is called if present.
            //
            //    You can also call `new C([a, b, c])`, which is equivalent to `C(a, b, c)`.
            //
            //  TODO: the Chrome inspector shows all created objects as `C` rather than `Object`.
            //        Setting the .name property seems to have no effect.  Is there a way to override
            //        this behavior?
            function C(args) {
                var self = this;
                if (!(self instanceof C)) return new C(arguments);
                if (args && isFunction(self.init)) self.init.apply(self, args);
            }

            // set up the prototype of the new class
            // note that this resolves to `new Object`
            // if the superclass isn't given
            var proto = C[prototype] = C.fn = new _superclass();

            // other variables, as a minifier optimization
            var _super = _superclass[prototype];
            var extensions;

            // set the constructor property on the prototype, for convenience
            proto.constructor = C;

            C.mixin = function (def) {
                C[prototype] = P(C, def)[prototype];
                return C;
            }

            return (C.open = function (def) {
                extensions = {};

                if (isFunction(def)) {
                    // call the defining function with all the arguments you need
                    // extensions captures the return value.
                    extensions = def.call(C, proto, _super, C, _superclass);
                }
                else if (isObject(def)) {
                    // if you passed an object instead, we'll take it
                    extensions = def;
                }

                // ...and extend it
                if (isObject(extensions)) {
                    for (var ext in extensions) {
                        if (ownProperty.call(extensions, ext)) {
                            proto[ext] = extensions[ext];
                        }
                    }
                }

                // if there's no init, we assume we're inheriting a non-pjs class, so
                // we default to applying the superclass's constructor.
                if (!isFunction(proto.init)) {
                    proto.init = function () { _superclass.apply(this, arguments); };
                }

                return C;
            })(definition);
        }

        // ship it
        return P;

        // as a minifier optimization, we've closured in a few helper functions
        // and the string 'prototype' (C[p] is much shorter than C.prototype)
    })('prototype', ({}).hasOwnProperty);

    return P;
});

define('math/evalframe', ['require', 'pjs'], function (require) {
    var P = require('pjs');

    var EvalFrame = P(function (frame) {
        frame.init = function (parentFrame) {
            if (parentFrame instanceof EvalFrame) {
                this.parentFrame = parentFrame;
            }
            else {
                this.parentFrame = null;
            }
            this.variables = {};
            this.functions = {};
            this.evalStrings = {};
            if (this.parentFrame) {
                for (var variable in this.parentFrame.evalStrings) {
                    this.evalStrings[variable] = this.parentFrame.getEvalStrings(variable);
                }
            }
        };

        frame.setVariable = function (name, value) {
            this.variables[name] = value;
        };

        frame.getVariable = function (name) {
            if (this.variables.hasOwnProperty(name)) {
                return this.variables[name];
            }

            if (this.parentFrame) {
                return this.parentFrame.getVariable(name);
            }

            throw ("Variable '" + name + "' not defined");
        };

        frame.setFunction = function (name, arity, body, tree, args, source) {
            this.functions[name] = { arity: arity, body: body, tree: tree, source: source, args: args };
        };

        frame.hasFunction = function (name) {
            if (this.functions.hasOwnProperty(name)) {
                return true;
            }
            if (this.parentFrame) {
                return this.parentFrame.hasFunction(name);
            }
            return false;
        };

        frame.hasFunctionWithArity = function (name, arity) {
            if (this.functions.hasOwnProperty(name) && this.functions[name].arity == arity) {
                return true;
            }
            if (this.parentFrame) {
                return this.parentFrame.hasFunction(name);
            }
            return false;
        };

        frame.hasVariable = function (name) {
            if (this.variables.hasOwnProperty(name)) {
                return true;
            }
            if (this.parentFrame) {
                return this.parentFrame.hasVariable(name);
            }
            return false;
        };

        frame.getFunctionTree = function (name) {
            if (this.functions.hasOwnProperty(name)) {
                var f = this.functions[name];
                return f.tree;
            }

            if (this.parentFrame) return this.parentFrame.getFunctionTree(name);

            throw ("Function '" + name + "' not defined");
        };

        frame.callFunction = function (name, args) {
            if (this.functions.hasOwnProperty(name)) {
                var f = this.functions[name];
                if (f.arity == args.length) {
                    return f.body.apply(null, args);
                }
                throw ("Function " + name + " expects " + f.arity + " arguments, but was called with " + args.length);
            }

            if (this.parentFrame) {
                return this.parentFrame.callFunction(name, args);
            }

            throw ("Function '" + name + "' not defined");
        };

        frame.defines = function (name) {
            return this.hasVariable(name) || this.hasFunction(name);
        };

        frame.arity = function (name) {
            if (this.hasVariable(name)) return 0;
            if (this.hasFunction(name)) return this.functions[name].arity;
            if (this.parentFrame) {
                return this.parentFrame.arity(name);
            }
        };

        //Needed for compilation.  Have different semantics (don't go up scope chain) for now.  Don't know if that's right
        frame.setEvalStrings = function (name, s) {
            this.evalStrings[name] = s;
        };

        frame.getEvalStrings = function (name) {
            if (this.evalStrings.hasOwnProperty(name)) {
                return this.evalStrings[name];
            }
            else {
                return { expression: name, statements: '' };
            }
        };

        frame.functionMap = function () {
            var allFunctions = {};
            if (this.parentFrame) {
                allFunctions = this.parentFrame.functionMap();
            }
            for (var name in this.functions) {
                if (this.functions.hasOwnProperty(name)) {
                    allFunctions[name] = this.functions[name].body;
                }
            }
            return allFunctions;
        };

        frame.functionSourceMap = function () {
            var compiledFunctions = {};
            if (this.parentFrame) {
                compiledFunctions = this.parentFrame.functionSourceMap();
            }
            for (var name in this.functions) {
                if (this.functions.hasOwnProperty(name) && this.functions[name].source) {
                    compiledFunctions[name] = {
                        args: this.functions[name].args,
                        source: this.functions[name].source
                    };
                }
            }
            return compiledFunctions;
        };
    });

    return EvalFrame;

});

//Use this table to get rid of all the string comparisons used to interpret comparators
define('math/comparators', ['require'], function (require) {

    var ComparatorTable = {
        '<': { inclusive: false, direction: -1 },
        '!=': { inclusive: false, direction: 0 },
        '>': { inclusive: false, direction: 1 },
        '<=': { inclusive: true, direction: -1 },
        '=': { inclusive: true, direction: 0 },
        '>=': { inclusive: true, direction: 1 }
    };

    var getComparator = function (inclusive, direction) {
        switch (direction) {
            case -1:
                return (inclusive ? '<=' : '<');
            case 0:
                return (inclusive ? '=' : '!=');
            case 1:
                return (inclusive ? '>=' : '>');
            default:
                throw "Programming error.  Comparators must have a direction of -1, 0, or 1";
        }
    };

    return {
        table: ComparatorTable,
        get: getComparator
    };

});

define('parser', [], function () {
    var parser = { trace: function trace() { },
        yy: {},
        symbols_: { "error": 2, "sentence": 3, "expr": 4, "EOF": 5, "assignment": 6, "equation": 7, "function_declaration": 8, "ordered_pair_list": 9, "double_inequality": 10, "boolean": 11, "identifier": 12, "=": 13, "FUNCTION_PROTOTYPE": 14, ",": 15, "comparator": 16, "IDENTIFIER_BASE": 17, "ordered_pair_list_elements": 18, "ordered_pair": 19, "[": 20, "]": 21, "(": 22, ")": 23, "expr_sum": 24, "<": 25, ">": 26, ">=": 27, "<=": 28, "+": 29, "expr_product": 30, "-": 31, "expr_atom_impmul": 32, "*": 33, "expr_atom": 34, "/": 35, "exponent": 36, "^N": 37, "^I": 38, "^": 39, "{": 40, "}": 41, "function_call": 42, "function_call_unary": 43, "trig_function_call": 44, "log_function_call": 45, "left|": 46, "right|": 47, "FRAC": 48, "SQRT": 49, "!": 50, "repeated_operator": 51, "DERIVATIVE": 52, "expr_piecewise": 53, "constant": 54, "NUMBER": 55, "repeated_operator_symbol": 56, "SUM": 57, "PROD": 58, "_": 59, "{_visible": 60, "piecewise_list": 61, "}_visible": 62, "incomplete_piecewise_list": 63, "piecewise_element": 64, ":": 65, "trig_function": 66, "TRIG_FUNCTION": 67, "log_prefix": 68, "LN": 69, "LOG": 70, "LOG_BASE_N": 71, "function_argument_list": 72, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 13: "=", 14: "FUNCTION_PROTOTYPE", 15: ",", 17: "IDENTIFIER_BASE", 20: "[", 21: "]", 22: "(", 23: ")", 25: "<", 26: ">", 27: ">=", 28: "<=", 29: "+", 31: "-", 33: "*", 35: "/", 37: "^N", 38: "^I", 39: "^", 40: "{", 41: "}", 46: "left|", 47: "right|", 48: "FRAC", 49: "SQRT", 50: "!", 52: "DERIVATIVE", 55: "NUMBER", 57: "SUM", 58: "PROD", 59: "_", 60: "{_visible", 62: "}_visible", 65: ":", 67: "TRIG_FUNCTION", 69: "LN", 70: "LOG", 71: "LOG_BASE_N" },
        productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 3], [3, 2], [3, 4], [6, 3], [6, 3], [7, 3], [10, 5], [12, 1], [9, 1], [18, 1], [18, 3], [19, 5], [19, 5], [4, 1], [16, 1], [16, 1], [16, 1], [16, 1], [11, 3], [11, 3], [11, 5], [24, 3], [24, 3], [24, 1], [30, 2], [30, 3], [30, 3], [30, 1], [36, 1], [36, 1], [36, 4], [32, 1], [32, 1], [32, 1], [32, 1], [32, 1], [32, 3], [32, 3], [32, 3], [32, 2], [32, 7], [32, 4], [32, 7], [32, 2], [32, 1], [32, 2], [32, 1], [34, 1], [34, 3], [34, 2], [34, 2], [34, 2], [34, 1], [56, 1], [56, 1], [51, 9], [53, 3], [61, 3], [61, 1], [63, 3], [63, 1], [64, 3], [64, 1], [54, 1], [54, 2], [43, 5], [43, 4], [66, 1], [44, 4], [44, 2], [44, 7], [44, 9], [44, 3], [44, 5], [68, 1], [68, 1], [68, 1], [68, 3], [68, 5], [45, 4], [45, 2], [45, 5], [45, 3], [42, 4], [72, 3], [72, 3], [8, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1: return $$[$0 - 1];
                    break;
                case 2: return $$[$0 - 1];
                    break;
                case 3: return $$[$0 - 1];
                    break;
                case 4: return $$[$0 - 1];
                    break;
                case 5: return $$[$0 - 1];
                    break;
                case 6: return $$[$0 - 1];
                    break;
                case 7: return $$[$0 - 1];
                    break;
                case 8: return yy.ErrorNode("What do you want variable \'" + $$[$0 - 2].identifier + "\' to equal?");
                    break;
                case 9: var val = yy.parseFunctionDeclaration($$[$0 - 1]);
                    return yy.ErrorNode("What do you want function \'" + val.identifier.identifier + "\' to equal?");

                    break;
                case 10: return yy.ErrorNode("Points are written like this: (1, 2)");
                    break;
                case 11: this.$ = yy.AssignmentNode($$[$0 - 2], $$[$0]);
                    break;
                case 12: this.$ = yy.AssignmentNode($$[$0 - 2], yy.ErrorNode);
                    break;
                case 13: this.$ = yy.EquationNode($$[$0 - 2], $$[$0]);
                    break;
                case 14: this.$ = yy.DoubleInequalityNode($$[$0 - 4], $$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0]);
                    break;
                case 15: this.$ = yy.IdentifierNode(yytext);
                    yy.setInput(this.$, this._$);

                    break;
                case 16: this.$ = yy.OrderedPairListNode($$[$0]);
                    break;
                case 17: this.$ = [($$[$0])];
                    break;
                case 18: $$[$0 - 2].push($$[$0]); this.$ = $$[$0 - 2]
                    break;
                case 19: this.$ = yy.OrderedPairNode($$[$0 - 3], $$[$0 - 1]);
                    break;
                case 20: this.$ = yy.OrderedPairNode($$[$0 - 3], $$[$0 - 1]);
                    break;
                case 21: this.$ = $$[$0];
                    yy.setInput(this.$, this._$);

                    break;
                case 22: this.$ = '<'
                    break;
                case 23: this.$ = '>'
                    break;
                case 24: this.$ = '>='
                    break;
                case 25: this.$ = '<='
                    break;
                case 26: this.$ = yy.ComparatorNode($$[$0 - 1], $$[$0 - 2], $$[$0]);
                    break;
                case 27: this.$ = yy.ComparatorNode('===', $$[$0 - 2], $$[$0]);
                    break;
                case 28: this.$ = yy.ChainedComparatorNode([$$[$0 - 3], $$[$0 - 1]], [$$[$0 - 4], $$[$0 - 2], $$[$0]]);
                    break;
                case 29: this.$ = yy.BinaryOperatorNode('+', $$[$0 - 2], $$[$0]);
                    break;
                case 30: this.$ = yy.BinaryOperatorNode('-', $$[$0 - 2], $$[$0]);
                    break;
                case 31: this.$ = $$[$0]
                    break;
                case 32: this.$ = yy.BinaryOperatorNode('*', $$[$0 - 1], $$[$0]);
                    break;
                case 33: this.$ = yy.BinaryOperatorNode('*', $$[$0 - 2], $$[$0]);
                    break;
                case 34: this.$ = yy.BinaryOperatorNode('/', $$[$0 - 2], $$[$0]);
                    break;
                case 35: this.$ = $$[$0];
                    break;
                case 36: this.$ = yy.ConstantNode(Number($$[$0]));
                    break;
                case 37: this.$ = yy.IdentifierNode($$[$0]);
                    break;
                case 38: this.$ = $$[$0 - 1];
                    break;
                case 39: this.$ = $$[$0];
                    break;
                case 40: this.$ = $$[$0];
                    break;
                case 41: this.$ = $$[$0];
                    break;
                case 42: this.$ = $$[$0];
                    break;
                case 43: this.$ = $$[$0];
                    break;
                case 44: this.$ = $$[$0 - 1];
                    break;
                case 45: this.$ = $$[$0 - 1];
                    break;
                case 46: this.$ = yy.FunctionNode(yy.IdentifierNode('\\abs'), [$$[$0 - 1]]);
                    break;
                case 47: this.$ = yy.BinaryOperatorNode('^', $$[$0 - 1], $$[$0]);
                    break;
                case 48: this.$ = yy.BinaryOperatorNode('/', $$[$0 - 4], $$[$0 - 1]);
                    break;
                case 49: this.$ = yy.FunctionNode(yy.IdentifierNode('\\sqrt'), [$$[$0 - 1]]);
                    break;
                case 50: this.$ = yy.FunctionNode(yy.IdentifierNode('\\nthroot'), [$$[$0 - 1], $$[$0 - 4]]);
                    break;
                case 51: this.$ = yy.FunctionNode(yy.IdentifierNode('\\factorial'), [$$[$0 - 1]])
                    break;
                case 52: this.$ = $$[$0];
                    break;
                case 53: this.$ = yy.DerivativeNode(yy.IdentifierNode($$[$0 - 1]), $$[$0]);
                    break;
                case 54: this.$ = $$[$0]
                    break;
                case 55: this.$ = $$[$0];
                    break;
                case 56: this.$ = yy.NegationNode(yy.BinaryOperatorNode('^', yy.ConstantNode(Number($$[$0 - 1])), $$[$0]));
                    break;
                case 57: this.$ = yy.BinaryOperatorNode('^', $$[$0 - 1], $$[$0]);
                    break;
                case 58: this.$ = yy.FunctionNode(yy.IdentifierNode('\\factorial'), [$$[$0 - 1]])
                    break;
                case 59: this.$ = yy.NegationNode($$[$0])
                    break;
                case 60: this.$ = $$[$0]
                    break;
                case 61: this.$ = yy.SummationNode;
                    break;
                case 62: this.$ = yy.ProductNode;
                    break;
                case 63: this.$ = $$[$0 - 8]($$[$0 - 5], $$[$0 - 3], $$[$0 - 1], $$[$0]);
                    break;
                case 64: this.$ = $$[$0 - 1];
                    break;
                case 65: this.$ = $$[$0 - 2].append_else(yy.PiecewiseNode(yy.ConstantNode(true), $$[$0]));
                    break;
                case 66: this.$ = $$[$0];
                    break;
                case 67: this.$ = $$[$0 - 2].append_else($$[$0]);
                    break;
                case 68: this.$ = $$[$0];
                    break;
                case 69: this.$ = yy.PiecewiseNode($$[$0 - 2], $$[$0]);
                    break;
                case 70: this.$ = yy.PiecewiseNode($$[$0], yy.ConstantNode(1));
                    break;
                case 71: this.$ = yy.ConstantNode(Number(yytext));
                    break;
                case 72: this.$ = yy.ConstantNode(-$$[$0])
                    break;
                case 73: this.$ = yy.FunctionCallExponentNode($$[$0 - 4], $$[$0 - 2], $$[$0]);
                    break;
                case 74: this.$ = yy.FunctionNode($$[$0 - 3], [$$[$0 - 1]]);
                    break;
                case 75: this.$ = yy.IdentifierNode(yytext);
                    break;
                case 76: this.$ = yy.FunctionNode($$[$0 - 3], [$$[$0 - 1]]);
                    break;
                case 77:
                    if (!$$[$0].okForImplicitFunction()) { throw 'Too complicated.  Use parens' };
                    this.$ = yy.FunctionNode($$[$0 - 1], [$$[$0]]);

                    break;
                case 78:
                    if (!$$[$0].okForImplicitFunction()) { throw 'Too complicated.  Use parens' };
                    if ($$[$0 - 2].value != 1) { throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens' };
                    this.$ = yy.FunctionNode(yy.IdentifierNode(yy.inverses[$$[$0 - 6].identifier]), [$$[$0]]);

                    break;
                case 79:
                    if ($$[$0 - 4].value != 1) { throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens' };
                    this.$ = yy.FunctionNode(yy.IdentifierNode(yy.inverses[$$[$0 - 8].identifier]), [$$[$0 - 1]]);

                    break;
                case 80:
                    if (!$$[$0].okForImplicitFunction()) { throw 'Too complicated.  Use parens' };
                    if ($$[$0 - 1] != "2") { throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens' };
                    this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode($$[$0 - 2], [$$[$0]]), yy.ConstantNode(2));

                    break;
                case 81:
                    if ($$[$0 - 3] != "2") { throw 'Only sin^2 and sin^-1 are supported.  Otherwise, use parens' };
                    this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode($$[$0 - 4], [$$[$0 - 1]]), yy.ConstantNode(2));

                    break;
                case 82: this.$ = yy.ConstantNode(Math.E)
                    break;
                case 83: this.$ = yy.ConstantNode(10)
                    break;
                case 84: this.$ = yy.ConstantNode(Number(yytext));
                    break;
                case 85: this.$ = $$[$0]
                    break;
                case 86: this.$ = $$[$0 - 1]
                    break;
                case 87: this.$ = yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0 - 1], $$[$0 - 3]])
                    break;
                case 88:
                    if (!$$[$0].okForImplicitFunction()) { throw 'Too complicated.  Use parens' };
                    this.$ = yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0], $$[$0 - 1]])

                    break;
                case 89:
                    if ($$[$0 - 3] != "2") { throw 'Only log^2 is supported.  Use parens' }
                    this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0 - 1], $$[$0 - 4]]), yy.ConstantNode(2))

                    break;
                case 90:
                    if (!$$[$0].okForImplicitFunction()) { throw 'Too complicated.  Use parens' };
                    if ($$[$0 - 1] != "2") { throw 'Only log^2 is supported.  Use parens' }
                    this.$ = yy.BinaryOperatorNode('^', yy.FunctionNode(yy.IdentifierNode('log'), [$$[$0], $$[$0 - 2]]), yy.ConstantNode(2))

                    break;
                case 91: this.$ = yy.FunctionNode($$[$0 - 3], $$[$0 - 1]);
                    break;
                case 92: this.$ = $$[$0 - 2].concat([$$[$0]]);
                    break;
                case 93: this.$ = [$$[$0 - 2], $$[$0]];
                    break;
                case 94: var val = yy.parseFunctionDeclaration($$[$0 - 1]); this.$ = yy.FunctionDeclarationNode(val.identifier, val.args, $$[$0]);
                    this.$.setInputString(val.input_string);

                    break;
            }
        },
        table: [{ 3: 1, 4: 2, 6: 3, 7: 4, 8: 5, 9: 6, 10: 7, 11: 8, 12: 9, 14: [1, 10], 17: [1, 13], 18: 12, 19: 15, 20: [1, 17], 22: [1, 18], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 1: [3] }, { 5: [1, 44], 13: [1, 46], 15: [1, 45], 16: 47, 25: [1, 48], 26: [1, 49], 27: [1, 50], 28: [1, 51] }, { 5: [1, 52] }, { 5: [1, 53] }, { 5: [1, 54] }, { 5: [1, 55] }, { 5: [1, 56] }, { 5: [1, 57] }, { 5: [2, 39], 13: [1, 58], 15: [2, 39], 17: [2, 39], 22: [1, 59], 25: [2, 39], 26: [2, 39], 27: [2, 39], 28: [2, 39], 29: [2, 39], 31: [2, 39], 33: [2, 39], 35: [2, 39], 37: [2, 39], 38: [2, 39], 39: [2, 39], 40: [2, 39], 46: [2, 39], 48: [2, 39], 49: [2, 39], 50: [2, 39], 52: [2, 39], 57: [2, 39], 58: [2, 39], 60: [2, 39], 67: [2, 39], 69: [2, 39], 70: [2, 39], 71: [2, 39] }, { 4: 61, 5: [1, 60], 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 21], 13: [2, 21], 15: [2, 21], 17: [2, 21], 21: [2, 21], 22: [2, 21], 23: [2, 21], 25: [2, 21], 26: [2, 21], 27: [2, 21], 28: [2, 21], 29: [1, 64], 31: [1, 65], 33: [2, 21], 35: [2, 21], 37: [2, 21], 38: [2, 21], 39: [2, 21], 40: [2, 21], 41: [2, 21], 46: [2, 21], 47: [2, 21], 48: [2, 21], 49: [2, 21], 50: [2, 21], 52: [2, 21], 57: [2, 21], 58: [2, 21], 60: [2, 21], 62: [2, 21], 65: [2, 21], 67: [2, 21], 69: [2, 21], 70: [2, 21], 71: [2, 21] }, { 5: [2, 16], 15: [1, 66] }, { 5: [2, 15], 13: [2, 15], 15: [2, 15], 17: [2, 15], 21: [2, 15], 22: [2, 15], 23: [2, 15], 25: [2, 15], 26: [2, 15], 27: [2, 15], 28: [2, 15], 29: [2, 15], 31: [2, 15], 33: [2, 15], 35: [2, 15], 37: [2, 15], 38: [2, 15], 39: [2, 15], 40: [2, 15], 41: [2, 15], 46: [2, 15], 47: [2, 15], 48: [2, 15], 49: [2, 15], 50: [2, 15], 52: [2, 15], 55: [2, 15], 57: [2, 15], 58: [2, 15], 60: [2, 15], 62: [2, 15], 65: [2, 15], 67: [2, 15], 69: [2, 15], 70: [2, 15], 71: [2, 15] }, { 5: [2, 31], 12: 62, 13: [2, 31], 15: [2, 31], 17: [1, 13], 21: [2, 31], 22: [1, 63], 23: [2, 31], 25: [2, 31], 26: [2, 31], 27: [2, 31], 28: [2, 31], 29: [2, 31], 31: [2, 31], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 31], 38: [2, 31], 39: [2, 31], 40: [1, 27], 41: [2, 31], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 31], 48: [1, 29], 49: [1, 30], 50: [2, 31], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 31], 65: [2, 31], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 17], 15: [2, 17] }, { 5: [2, 35], 13: [2, 35], 15: [2, 35], 17: [2, 35], 21: [2, 35], 22: [2, 35], 23: [2, 35], 25: [2, 35], 26: [2, 35], 27: [2, 35], 28: [2, 35], 29: [2, 35], 31: [2, 35], 33: [2, 35], 35: [2, 35], 36: 70, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 35], 41: [2, 35], 46: [2, 35], 47: [2, 35], 48: [2, 35], 49: [2, 35], 50: [1, 71], 52: [2, 35], 57: [2, 35], 58: [2, 35], 60: [2, 35], 62: [2, 35], 65: [2, 35], 67: [2, 35], 69: [2, 35], 70: [2, 35], 71: [2, 35] }, { 4: 75, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 76, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 55], 13: [2, 55], 15: [2, 55], 17: [2, 55], 21: [2, 55], 22: [2, 55], 23: [2, 55], 25: [2, 55], 26: [2, 55], 27: [2, 55], 28: [2, 55], 29: [2, 55], 31: [2, 55], 33: [2, 55], 35: [2, 55], 37: [2, 55], 38: [2, 55], 39: [2, 55], 40: [2, 55], 41: [2, 55], 46: [2, 55], 47: [2, 55], 48: [2, 55], 49: [2, 55], 50: [2, 55], 52: [2, 55], 57: [2, 55], 58: [2, 55], 60: [2, 55], 62: [2, 55], 65: [2, 55], 67: [2, 55], 69: [2, 55], 70: [2, 55], 71: [2, 55] }, { 12: 62, 17: [1, 13], 22: [1, 63], 31: [1, 20], 32: 21, 34: 78, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 77], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 60], 13: [2, 60], 15: [2, 60], 17: [2, 60], 21: [2, 60], 22: [2, 60], 23: [2, 60], 25: [2, 60], 26: [2, 60], 27: [2, 60], 28: [2, 60], 29: [2, 60], 31: [2, 60], 33: [2, 60], 35: [2, 60], 36: 79, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 60], 41: [2, 60], 46: [2, 60], 47: [2, 60], 48: [2, 60], 49: [2, 60], 50: [1, 80], 52: [2, 60], 57: [2, 60], 58: [2, 60], 60: [2, 60], 62: [2, 60], 65: [2, 60], 67: [2, 60], 69: [2, 60], 70: [2, 60], 71: [2, 60] }, { 5: [2, 71], 13: [2, 71], 15: [2, 71], 17: [2, 71], 21: [2, 71], 22: [2, 71], 23: [2, 71], 25: [2, 71], 26: [2, 71], 27: [2, 71], 28: [2, 71], 29: [2, 71], 31: [2, 71], 33: [2, 71], 35: [2, 71], 37: [2, 71], 38: [2, 71], 39: [2, 71], 40: [2, 71], 41: [2, 71], 46: [2, 71], 47: [2, 71], 48: [2, 71], 49: [2, 71], 50: [2, 71], 52: [2, 71], 57: [2, 71], 58: [2, 71], 60: [2, 71], 62: [2, 71], 65: [2, 71], 67: [2, 71], 69: [2, 71], 70: [2, 71], 71: [2, 71] }, { 5: [2, 40], 13: [2, 40], 15: [2, 40], 17: [2, 40], 21: [2, 40], 22: [2, 40], 23: [2, 40], 25: [2, 40], 26: [2, 40], 27: [2, 40], 28: [2, 40], 29: [2, 40], 31: [2, 40], 33: [2, 40], 35: [2, 40], 37: [2, 40], 38: [2, 40], 39: [2, 40], 40: [2, 40], 41: [2, 40], 46: [2, 40], 47: [2, 40], 48: [2, 40], 49: [2, 40], 50: [2, 40], 52: [2, 40], 57: [2, 40], 58: [2, 40], 60: [2, 40], 62: [2, 40], 65: [2, 40], 67: [2, 40], 69: [2, 40], 70: [2, 40], 71: [2, 40] }, { 5: [2, 41], 13: [2, 41], 15: [2, 41], 17: [2, 41], 21: [2, 41], 22: [2, 41], 23: [2, 41], 25: [2, 41], 26: [2, 41], 27: [2, 41], 28: [2, 41], 29: [2, 41], 31: [2, 41], 33: [2, 41], 35: [2, 41], 37: [2, 41], 38: [2, 41], 39: [2, 41], 40: [2, 41], 41: [2, 41], 46: [2, 41], 47: [2, 41], 48: [2, 41], 49: [2, 41], 50: [2, 41], 52: [2, 41], 57: [2, 41], 58: [2, 41], 60: [2, 41], 62: [2, 41], 65: [2, 41], 67: [2, 41], 69: [2, 41], 70: [2, 41], 71: [2, 41] }, { 5: [2, 42], 13: [2, 42], 15: [2, 42], 17: [2, 42], 21: [2, 42], 22: [2, 42], 23: [2, 42], 25: [2, 42], 26: [2, 42], 27: [2, 42], 28: [2, 42], 29: [2, 42], 31: [2, 42], 33: [2, 42], 35: [2, 42], 37: [2, 42], 38: [2, 42], 39: [2, 42], 40: [2, 42], 41: [2, 42], 46: [2, 42], 47: [2, 42], 48: [2, 42], 49: [2, 42], 50: [2, 42], 52: [2, 42], 57: [2, 42], 58: [2, 42], 60: [2, 42], 62: [2, 42], 65: [2, 42], 67: [2, 42], 69: [2, 42], 70: [2, 42], 71: [2, 42] }, { 5: [2, 43], 13: [2, 43], 15: [2, 43], 17: [2, 43], 21: [2, 43], 22: [2, 43], 23: [2, 43], 25: [2, 43], 26: [2, 43], 27: [2, 43], 28: [2, 43], 29: [2, 43], 31: [2, 43], 33: [2, 43], 35: [2, 43], 37: [2, 43], 38: [2, 43], 39: [2, 43], 40: [2, 43], 41: [2, 43], 46: [2, 43], 47: [2, 43], 48: [2, 43], 49: [2, 43], 50: [2, 43], 52: [2, 43], 57: [2, 43], 58: [2, 43], 60: [2, 43], 62: [2, 43], 65: [2, 43], 67: [2, 43], 69: [2, 43], 70: [2, 43], 71: [2, 43] }, { 4: 81, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 82, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 40: [1, 83] }, { 20: [1, 85], 40: [1, 84] }, { 5: [2, 52], 13: [2, 52], 15: [2, 52], 17: [2, 52], 21: [2, 52], 22: [2, 52], 23: [2, 52], 25: [2, 52], 26: [2, 52], 27: [2, 52], 28: [2, 52], 29: [2, 52], 31: [2, 52], 33: [2, 52], 35: [2, 52], 37: [2, 52], 38: [2, 52], 39: [2, 52], 40: [2, 52], 41: [2, 52], 46: [2, 52], 47: [2, 52], 48: [2, 52], 49: [2, 52], 50: [2, 52], 52: [2, 52], 57: [2, 52], 58: [2, 52], 60: [2, 52], 62: [2, 52], 65: [2, 52], 67: [2, 52], 69: [2, 52], 70: [2, 52], 71: [2, 52] }, { 12: 62, 17: [1, 13], 22: [1, 63], 30: 86, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 54], 13: [2, 54], 15: [2, 54], 17: [2, 54], 21: [2, 54], 22: [2, 54], 23: [2, 54], 25: [2, 54], 26: [2, 54], 27: [2, 54], 28: [2, 54], 29: [2, 54], 31: [2, 54], 33: [2, 54], 35: [2, 54], 37: [2, 54], 38: [2, 54], 39: [2, 54], 40: [2, 54], 41: [2, 54], 46: [2, 54], 47: [2, 54], 48: [2, 54], 49: [2, 54], 50: [2, 54], 52: [2, 54], 57: [2, 54], 58: [2, 54], 60: [2, 54], 62: [2, 54], 65: [2, 54], 67: [2, 54], 69: [2, 54], 70: [2, 54], 71: [2, 54] }, { 12: 62, 17: [1, 13], 22: [1, 87], 30: 88, 31: [1, 20], 32: 21, 34: 16, 37: [1, 90], 39: [1, 89], 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 12: 62, 17: [1, 13], 22: [1, 91], 30: 92, 31: [1, 20], 32: 21, 34: 16, 37: [1, 93], 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 59: [1, 94] }, { 4: 99, 11: 98, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 61: 95, 63: 96, 64: 97, 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 17: [2, 75], 22: [2, 75], 31: [2, 75], 37: [2, 75], 39: [2, 75], 40: [2, 75], 46: [2, 75], 48: [2, 75], 49: [2, 75], 52: [2, 75], 55: [2, 75], 57: [2, 75], 58: [2, 75], 60: [2, 75], 67: [2, 75], 69: [2, 75], 70: [2, 75], 71: [2, 75] }, { 17: [2, 82], 22: [2, 82], 31: [2, 82], 37: [2, 82], 40: [2, 82], 46: [2, 82], 48: [2, 82], 49: [2, 82], 52: [2, 82], 55: [2, 82], 57: [2, 82], 58: [2, 82], 60: [2, 82], 67: [2, 82], 69: [2, 82], 70: [2, 82], 71: [2, 82] }, { 17: [2, 83], 22: [2, 83], 31: [2, 83], 37: [2, 83], 40: [2, 83], 46: [2, 83], 48: [2, 83], 49: [2, 83], 52: [2, 83], 55: [2, 83], 57: [2, 83], 58: [2, 83], 59: [1, 100], 60: [2, 83], 67: [2, 83], 69: [2, 83], 70: [2, 83], 71: [2, 83] }, { 17: [2, 84], 22: [2, 84], 31: [2, 84], 37: [2, 84], 40: [2, 84], 46: [2, 84], 48: [2, 84], 49: [2, 84], 52: [2, 84], 55: [2, 84], 57: [2, 84], 58: [2, 84], 60: [2, 84], 67: [2, 84], 69: [2, 84], 70: [2, 84], 71: [2, 84] }, { 59: [2, 61] }, { 59: [2, 62] }, { 1: [2, 1] }, { 4: 101, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 102, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 104, 12: 103, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 17: [2, 22], 22: [2, 22], 31: [2, 22], 40: [2, 22], 46: [2, 22], 48: [2, 22], 49: [2, 22], 52: [2, 22], 55: [2, 22], 57: [2, 22], 58: [2, 22], 60: [2, 22], 67: [2, 22], 69: [2, 22], 70: [2, 22], 71: [2, 22] }, { 17: [2, 23], 22: [2, 23], 31: [2, 23], 40: [2, 23], 46: [2, 23], 48: [2, 23], 49: [2, 23], 52: [2, 23], 55: [2, 23], 57: [2, 23], 58: [2, 23], 60: [2, 23], 67: [2, 23], 69: [2, 23], 70: [2, 23], 71: [2, 23] }, { 17: [2, 24], 22: [2, 24], 31: [2, 24], 40: [2, 24], 46: [2, 24], 48: [2, 24], 49: [2, 24], 52: [2, 24], 55: [2, 24], 57: [2, 24], 58: [2, 24], 60: [2, 24], 67: [2, 24], 69: [2, 24], 70: [2, 24], 71: [2, 24] }, { 17: [2, 25], 22: [2, 25], 31: [2, 25], 40: [2, 25], 46: [2, 25], 48: [2, 25], 49: [2, 25], 52: [2, 25], 55: [2, 25], 57: [2, 25], 58: [2, 25], 60: [2, 25], 67: [2, 25], 69: [2, 25], 70: [2, 25], 71: [2, 25] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 2: [1, 107], 4: 106, 5: [1, 105], 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 109, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41], 72: 108 }, { 1: [2, 9] }, { 5: [2, 94] }, { 5: [2, 39], 13: [2, 39], 15: [2, 39], 17: [2, 39], 21: [2, 39], 22: [1, 59], 23: [2, 39], 25: [2, 39], 26: [2, 39], 27: [2, 39], 28: [2, 39], 29: [2, 39], 31: [2, 39], 33: [2, 39], 35: [2, 39], 37: [2, 39], 38: [2, 39], 39: [2, 39], 40: [2, 39], 41: [2, 39], 46: [2, 39], 47: [2, 39], 48: [2, 39], 49: [2, 39], 50: [2, 39], 52: [2, 39], 57: [2, 39], 58: [2, 39], 60: [2, 39], 62: [2, 39], 65: [2, 39], 67: [2, 39], 69: [2, 39], 70: [2, 39], 71: [2, 39] }, { 4: 110, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 12: 62, 17: [1, 13], 22: [1, 63], 30: 111, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 12: 62, 17: [1, 13], 22: [1, 63], 30: 112, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 19: 113, 20: [1, 17], 22: [1, 114] }, { 5: [2, 32], 13: [2, 32], 15: [2, 32], 17: [2, 32], 21: [2, 32], 22: [2, 32], 23: [2, 32], 25: [2, 32], 26: [2, 32], 27: [2, 32], 28: [2, 32], 29: [2, 32], 31: [2, 32], 33: [2, 32], 35: [2, 32], 36: 79, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 32], 41: [2, 32], 46: [2, 32], 47: [2, 32], 48: [2, 32], 49: [2, 32], 50: [1, 80], 52: [2, 32], 57: [2, 32], 58: [2, 32], 60: [2, 32], 62: [2, 32], 65: [2, 32], 67: [2, 32], 69: [2, 32], 70: [2, 32], 71: [2, 32] }, { 12: 62, 17: [1, 13], 22: [1, 63], 31: [1, 20], 32: 21, 34: 115, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 12: 62, 17: [1, 13], 22: [1, 63], 31: [1, 20], 32: 21, 34: 116, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 57], 13: [2, 57], 15: [2, 57], 17: [2, 57], 21: [2, 57], 22: [2, 57], 23: [2, 57], 25: [2, 57], 26: [2, 57], 27: [2, 57], 28: [2, 57], 29: [2, 57], 31: [2, 57], 33: [2, 57], 35: [2, 57], 37: [2, 57], 38: [2, 57], 39: [2, 57], 40: [2, 57], 41: [2, 57], 46: [2, 57], 47: [2, 57], 48: [2, 57], 49: [2, 57], 50: [2, 57], 52: [2, 57], 57: [2, 57], 58: [2, 57], 60: [2, 57], 62: [2, 57], 65: [2, 57], 67: [2, 57], 69: [2, 57], 70: [2, 57], 71: [2, 57] }, { 5: [2, 58], 13: [2, 58], 15: [2, 58], 17: [2, 58], 21: [2, 58], 22: [2, 58], 23: [2, 58], 25: [2, 58], 26: [2, 58], 27: [2, 58], 28: [2, 58], 29: [2, 58], 31: [2, 58], 33: [2, 58], 35: [2, 58], 37: [2, 58], 38: [2, 58], 39: [2, 58], 40: [2, 58], 41: [2, 58], 46: [2, 58], 47: [2, 58], 48: [2, 58], 49: [2, 58], 50: [2, 58], 52: [2, 58], 57: [2, 58], 58: [2, 58], 60: [2, 58], 62: [2, 58], 65: [2, 58], 67: [2, 58], 69: [2, 58], 70: [2, 58], 71: [2, 58] }, { 5: [2, 36], 13: [2, 36], 15: [2, 36], 17: [2, 36], 21: [2, 36], 22: [2, 36], 23: [2, 36], 25: [2, 36], 26: [2, 36], 27: [2, 36], 28: [2, 36], 29: [2, 36], 31: [2, 36], 33: [2, 36], 35: [2, 36], 37: [2, 36], 38: [2, 36], 39: [2, 36], 40: [2, 36], 41: [2, 36], 46: [2, 36], 47: [2, 36], 48: [2, 36], 49: [2, 36], 50: [2, 36], 52: [2, 36], 55: [2, 36], 57: [2, 36], 58: [2, 36], 60: [2, 36], 62: [2, 36], 65: [2, 36], 67: [2, 36], 69: [2, 36], 70: [2, 36], 71: [2, 36] }, { 5: [2, 37], 13: [2, 37], 15: [2, 37], 17: [2, 37], 21: [2, 37], 22: [2, 37], 23: [2, 37], 25: [2, 37], 26: [2, 37], 27: [2, 37], 28: [2, 37], 29: [2, 37], 31: [2, 37], 33: [2, 37], 35: [2, 37], 37: [2, 37], 38: [2, 37], 39: [2, 37], 40: [2, 37], 41: [2, 37], 46: [2, 37], 47: [2, 37], 48: [2, 37], 49: [2, 37], 50: [2, 37], 52: [2, 37], 55: [2, 37], 57: [2, 37], 58: [2, 37], 60: [2, 37], 62: [2, 37], 65: [2, 37], 67: [2, 37], 69: [2, 37], 70: [2, 37], 71: [2, 37] }, { 40: [1, 117] }, { 15: [1, 118] }, { 15: [1, 119], 23: [1, 120] }, { 5: [2, 72], 13: [2, 72], 15: [2, 72], 17: [2, 72], 21: [2, 72], 22: [2, 72], 23: [2, 72], 25: [2, 72], 26: [2, 72], 27: [2, 72], 28: [2, 72], 29: [2, 72], 31: [2, 72], 33: [2, 72], 35: [2, 72], 36: 121, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 72], 41: [2, 72], 46: [2, 72], 47: [2, 72], 48: [2, 72], 49: [2, 72], 50: [2, 72], 52: [2, 72], 57: [2, 72], 58: [2, 72], 60: [2, 72], 62: [2, 72], 65: [2, 72], 67: [2, 72], 69: [2, 72], 70: [2, 72], 71: [2, 72] }, { 5: [2, 59], 13: [2, 59], 15: [2, 59], 17: [2, 59], 21: [2, 59], 22: [2, 59], 23: [2, 59], 25: [2, 59], 26: [2, 59], 27: [2, 59], 28: [2, 59], 29: [2, 59], 31: [2, 59], 33: [2, 59], 35: [2, 59], 36: 70, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 59], 41: [2, 59], 46: [2, 59], 47: [2, 59], 48: [2, 59], 49: [2, 59], 50: [1, 71], 52: [2, 59], 57: [2, 59], 58: [2, 59], 60: [2, 59], 62: [2, 59], 65: [2, 59], 67: [2, 59], 69: [2, 59], 70: [2, 59], 71: [2, 59] }, { 5: [2, 47], 13: [2, 47], 15: [2, 47], 17: [2, 47], 21: [2, 47], 22: [2, 47], 23: [2, 47], 25: [2, 47], 26: [2, 47], 27: [2, 47], 28: [2, 47], 29: [2, 47], 31: [2, 47], 33: [2, 47], 35: [2, 47], 37: [2, 47], 38: [2, 47], 39: [2, 47], 40: [2, 47], 41: [2, 47], 46: [2, 47], 47: [2, 47], 48: [2, 47], 49: [2, 47], 50: [2, 47], 52: [2, 47], 57: [2, 47], 58: [2, 47], 60: [2, 47], 62: [2, 47], 65: [2, 47], 67: [2, 47], 69: [2, 47], 70: [2, 47], 71: [2, 47] }, { 5: [2, 51], 13: [2, 51], 15: [2, 51], 17: [2, 51], 21: [2, 51], 22: [2, 51], 23: [2, 51], 25: [2, 51], 26: [2, 51], 27: [2, 51], 28: [2, 51], 29: [2, 51], 31: [2, 51], 33: [2, 51], 35: [2, 51], 37: [2, 51], 38: [2, 51], 39: [2, 51], 40: [2, 51], 41: [2, 51], 46: [2, 51], 47: [2, 51], 48: [2, 51], 49: [2, 51], 50: [2, 51], 52: [2, 51], 57: [2, 51], 58: [2, 51], 60: [2, 51], 62: [2, 51], 65: [2, 51], 67: [2, 51], 69: [2, 51], 70: [2, 51], 71: [2, 51] }, { 41: [1, 122] }, { 47: [1, 123] }, { 4: 124, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 125, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 126, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 53], 12: 62, 13: [2, 53], 15: [2, 53], 17: [1, 13], 21: [2, 53], 22: [1, 63], 23: [2, 53], 25: [2, 53], 26: [2, 53], 27: [2, 53], 28: [2, 53], 29: [2, 53], 31: [2, 53], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 53], 38: [2, 53], 39: [2, 53], 40: [1, 27], 41: [2, 53], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 53], 48: [1, 29], 49: [1, 30], 50: [2, 53], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 53], 65: [2, 53], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 127, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 77], 12: 62, 13: [2, 77], 15: [2, 77], 17: [1, 13], 21: [2, 77], 22: [1, 63], 23: [2, 77], 25: [2, 77], 26: [2, 77], 27: [2, 77], 28: [2, 77], 29: [2, 77], 31: [2, 77], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 77], 38: [2, 77], 39: [2, 77], 40: [1, 27], 41: [2, 77], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 77], 48: [1, 29], 49: [1, 30], 50: [2, 77], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 77], 65: [2, 77], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 40: [1, 128] }, { 12: 62, 17: [1, 13], 22: [1, 130], 30: 129, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 131, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 88], 12: 62, 13: [2, 88], 15: [2, 88], 17: [1, 13], 21: [2, 88], 22: [1, 63], 23: [2, 88], 25: [2, 88], 26: [2, 88], 27: [2, 88], 28: [2, 88], 29: [2, 88], 31: [2, 88], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 88], 38: [2, 88], 39: [2, 88], 40: [1, 27], 41: [2, 88], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 88], 48: [1, 29], 49: [1, 30], 50: [2, 88], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 88], 65: [2, 88], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 12: 62, 17: [1, 13], 22: [1, 132], 30: 133, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 40: [1, 134] }, { 62: [1, 135] }, { 15: [1, 136], 62: [2, 66] }, { 15: [2, 68], 62: [2, 68] }, { 15: [2, 70], 62: [2, 70], 65: [1, 137] }, { 13: [1, 139], 16: 138, 25: [1, 48], 26: [1, 49], 27: [1, 50], 28: [1, 51] }, { 12: 140, 17: [1, 13], 40: [1, 141] }, { 5: [1, 142] }, { 5: [2, 13] }, { 5: [2, 39], 16: 143, 17: [2, 39], 22: [1, 59], 25: [1, 48], 26: [1, 49], 27: [1, 50], 28: [1, 51], 29: [2, 39], 31: [2, 39], 33: [2, 39], 35: [2, 39], 37: [2, 39], 38: [2, 39], 39: [2, 39], 40: [2, 39], 46: [2, 39], 48: [2, 39], 49: [2, 39], 50: [2, 39], 52: [2, 39], 57: [2, 39], 58: [2, 39], 60: [2, 39], 67: [2, 39], 69: [2, 39], 70: [2, 39], 71: [2, 39] }, { 5: [2, 26], 15: [2, 26], 16: 144, 25: [1, 48], 26: [1, 49], 27: [1, 50], 28: [1, 51], 62: [2, 26], 65: [2, 26] }, { 1: [2, 8] }, { 5: [2, 11] }, { 5: [2, 12] }, { 15: [1, 146], 23: [1, 145] }, { 15: [1, 148], 23: [1, 147] }, { 23: [1, 120] }, { 5: [2, 29], 12: 62, 13: [2, 29], 15: [2, 29], 17: [1, 13], 21: [2, 29], 22: [1, 63], 23: [2, 29], 25: [2, 29], 26: [2, 29], 27: [2, 29], 28: [2, 29], 29: [2, 29], 31: [2, 29], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 29], 38: [2, 29], 39: [2, 29], 40: [1, 27], 41: [2, 29], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 29], 48: [1, 29], 49: [1, 30], 50: [2, 29], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 29], 65: [2, 29], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 30], 12: 62, 13: [2, 30], 15: [2, 30], 17: [1, 13], 21: [2, 30], 22: [1, 63], 23: [2, 30], 25: [2, 30], 26: [2, 30], 27: [2, 30], 28: [2, 30], 29: [2, 30], 31: [2, 30], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 30], 38: [2, 30], 39: [2, 30], 40: [1, 27], 41: [2, 30], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 30], 48: [1, 29], 49: [1, 30], 50: [2, 30], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 30], 65: [2, 30], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 18], 15: [2, 18] }, { 4: 149, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 33], 13: [2, 33], 15: [2, 33], 17: [2, 33], 21: [2, 33], 22: [2, 33], 23: [2, 33], 25: [2, 33], 26: [2, 33], 27: [2, 33], 28: [2, 33], 29: [2, 33], 31: [2, 33], 33: [2, 33], 35: [2, 33], 36: 70, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 33], 41: [2, 33], 46: [2, 33], 47: [2, 33], 48: [2, 33], 49: [2, 33], 50: [1, 71], 52: [2, 33], 57: [2, 33], 58: [2, 33], 60: [2, 33], 62: [2, 33], 65: [2, 33], 67: [2, 33], 69: [2, 33], 70: [2, 33], 71: [2, 33] }, { 5: [2, 34], 13: [2, 34], 15: [2, 34], 17: [2, 34], 21: [2, 34], 22: [2, 34], 23: [2, 34], 25: [2, 34], 26: [2, 34], 27: [2, 34], 28: [2, 34], 29: [2, 34], 31: [2, 34], 33: [2, 34], 35: [2, 34], 36: 70, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 34], 41: [2, 34], 46: [2, 34], 47: [2, 34], 48: [2, 34], 49: [2, 34], 50: [1, 71], 52: [2, 34], 57: [2, 34], 58: [2, 34], 60: [2, 34], 62: [2, 34], 65: [2, 34], 67: [2, 34], 69: [2, 34], 70: [2, 34], 71: [2, 34] }, { 4: 150, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 151, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 152, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 44], 13: [2, 44], 15: [2, 44], 17: [2, 44], 21: [2, 44], 22: [2, 44], 23: [2, 44], 25: [2, 44], 26: [2, 44], 27: [2, 44], 28: [2, 44], 29: [2, 44], 31: [2, 44], 33: [2, 44], 35: [2, 44], 37: [2, 44], 38: [2, 44], 39: [2, 44], 40: [2, 44], 41: [2, 44], 46: [2, 44], 47: [2, 44], 48: [2, 44], 49: [2, 44], 50: [2, 44], 52: [2, 44], 57: [2, 44], 58: [2, 44], 60: [2, 44], 62: [2, 44], 65: [2, 44], 67: [2, 44], 69: [2, 44], 70: [2, 44], 71: [2, 44] }, { 5: [2, 56], 13: [2, 56], 15: [2, 56], 17: [2, 56], 21: [2, 56], 22: [2, 56], 23: [2, 56], 25: [2, 56], 26: [2, 56], 27: [2, 56], 28: [2, 56], 29: [2, 56], 31: [2, 56], 33: [2, 56], 35: [2, 56], 37: [2, 56], 38: [2, 56], 39: [2, 56], 40: [2, 56], 41: [2, 56], 46: [2, 56], 47: [2, 56], 48: [2, 56], 49: [2, 56], 50: [2, 56], 52: [2, 56], 57: [2, 56], 58: [2, 56], 60: [2, 56], 62: [2, 56], 65: [2, 56], 67: [2, 56], 69: [2, 56], 70: [2, 56], 71: [2, 56] }, { 5: [2, 45], 13: [2, 45], 15: [2, 45], 17: [2, 45], 21: [2, 45], 22: [2, 45], 23: [2, 45], 25: [2, 45], 26: [2, 45], 27: [2, 45], 28: [2, 45], 29: [2, 45], 31: [2, 45], 33: [2, 45], 35: [2, 45], 37: [2, 45], 38: [2, 45], 39: [2, 45], 40: [2, 45], 41: [2, 45], 46: [2, 45], 47: [2, 45], 48: [2, 45], 49: [2, 45], 50: [2, 45], 52: [2, 45], 57: [2, 45], 58: [2, 45], 60: [2, 45], 62: [2, 45], 65: [2, 45], 67: [2, 45], 69: [2, 45], 70: [2, 45], 71: [2, 45] }, { 5: [2, 46], 13: [2, 46], 15: [2, 46], 17: [2, 46], 21: [2, 46], 22: [2, 46], 23: [2, 46], 25: [2, 46], 26: [2, 46], 27: [2, 46], 28: [2, 46], 29: [2, 46], 31: [2, 46], 33: [2, 46], 35: [2, 46], 37: [2, 46], 38: [2, 46], 39: [2, 46], 40: [2, 46], 41: [2, 46], 46: [2, 46], 47: [2, 46], 48: [2, 46], 49: [2, 46], 50: [2, 46], 52: [2, 46], 57: [2, 46], 58: [2, 46], 60: [2, 46], 62: [2, 46], 65: [2, 46], 67: [2, 46], 69: [2, 46], 70: [2, 46], 71: [2, 46] }, { 41: [1, 153] }, { 41: [1, 154] }, { 21: [1, 155] }, { 23: [1, 156] }, { 31: [1, 157] }, { 5: [2, 80], 12: 62, 13: [2, 80], 15: [2, 80], 17: [1, 13], 21: [2, 80], 22: [1, 63], 23: [2, 80], 25: [2, 80], 26: [2, 80], 27: [2, 80], 28: [2, 80], 29: [2, 80], 31: [2, 80], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 80], 38: [2, 80], 39: [2, 80], 40: [1, 27], 41: [2, 80], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 80], 48: [1, 29], 49: [1, 30], 50: [2, 80], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 80], 65: [2, 80], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 158, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 23: [1, 159] }, { 4: 160, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 90], 12: 62, 13: [2, 90], 15: [2, 90], 17: [1, 13], 21: [2, 90], 22: [1, 63], 23: [2, 90], 25: [2, 90], 26: [2, 90], 27: [2, 90], 28: [2, 90], 29: [2, 90], 31: [2, 90], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 90], 38: [2, 90], 39: [2, 90], 40: [1, 27], 41: [2, 90], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 90], 48: [1, 29], 49: [1, 30], 50: [2, 90], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 90], 65: [2, 90], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 12: 161, 17: [1, 13] }, { 5: [2, 64], 13: [2, 64], 15: [2, 64], 17: [2, 64], 21: [2, 64], 22: [2, 64], 23: [2, 64], 25: [2, 64], 26: [2, 64], 27: [2, 64], 28: [2, 64], 29: [2, 64], 31: [2, 64], 33: [2, 64], 35: [2, 64], 37: [2, 64], 38: [2, 64], 39: [2, 64], 40: [2, 64], 41: [2, 64], 46: [2, 64], 47: [2, 64], 48: [2, 64], 49: [2, 64], 50: [2, 64], 52: [2, 64], 57: [2, 64], 58: [2, 64], 60: [2, 64], 62: [2, 64], 65: [2, 64], 67: [2, 64], 69: [2, 64], 70: [2, 64], 71: [2, 64] }, { 4: 162, 11: 98, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 64: 163, 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 164, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 104, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 165, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 17: [2, 85], 22: [2, 85], 31: [2, 85], 37: [2, 85], 40: [2, 85], 46: [2, 85], 48: [2, 85], 49: [2, 85], 52: [2, 85], 55: [2, 85], 57: [2, 85], 58: [2, 85], 60: [2, 85], 67: [2, 85], 69: [2, 85], 70: [2, 85], 71: [2, 85] }, { 4: 166, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 1: [2, 10] }, { 4: 167, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 168, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 91], 13: [2, 91], 15: [2, 91], 17: [2, 91], 21: [2, 91], 22: [2, 91], 23: [2, 91], 25: [2, 91], 26: [2, 91], 27: [2, 91], 28: [2, 91], 29: [2, 91], 31: [2, 91], 33: [2, 91], 35: [2, 91], 37: [2, 91], 38: [2, 91], 39: [2, 91], 40: [2, 91], 41: [2, 91], 46: [2, 91], 47: [2, 91], 48: [2, 91], 49: [2, 91], 50: [2, 91], 52: [2, 91], 57: [2, 91], 58: [2, 91], 60: [2, 91], 62: [2, 91], 65: [2, 91], 67: [2, 91], 69: [2, 91], 70: [2, 91], 71: [2, 91] }, { 4: 169, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 74], 13: [2, 74], 15: [2, 74], 17: [2, 74], 21: [2, 74], 22: [2, 74], 23: [2, 74], 25: [2, 74], 26: [2, 74], 27: [2, 74], 28: [2, 74], 29: [2, 74], 31: [2, 74], 33: [2, 74], 35: [2, 74], 36: 170, 37: [1, 72], 38: [1, 73], 39: [1, 74], 40: [2, 74], 41: [2, 74], 46: [2, 74], 47: [2, 74], 48: [2, 74], 49: [2, 74], 50: [2, 74], 52: [2, 74], 57: [2, 74], 58: [2, 74], 60: [2, 74], 62: [2, 74], 65: [2, 74], 67: [2, 74], 69: [2, 74], 70: [2, 74], 71: [2, 74] }, { 4: 171, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 15: [1, 119] }, { 41: [1, 172] }, { 21: [1, 173] }, { 23: [1, 174] }, { 40: [1, 175] }, { 5: [2, 49], 13: [2, 49], 15: [2, 49], 17: [2, 49], 21: [2, 49], 22: [2, 49], 23: [2, 49], 25: [2, 49], 26: [2, 49], 27: [2, 49], 28: [2, 49], 29: [2, 49], 31: [2, 49], 33: [2, 49], 35: [2, 49], 37: [2, 49], 38: [2, 49], 39: [2, 49], 40: [2, 49], 41: [2, 49], 46: [2, 49], 47: [2, 49], 48: [2, 49], 49: [2, 49], 50: [2, 49], 52: [2, 49], 57: [2, 49], 58: [2, 49], 60: [2, 49], 62: [2, 49], 65: [2, 49], 67: [2, 49], 69: [2, 49], 70: [2, 49], 71: [2, 49] }, { 40: [1, 176] }, { 5: [2, 76], 13: [2, 76], 15: [2, 76], 17: [2, 76], 21: [2, 76], 22: [2, 76], 23: [2, 76], 25: [2, 76], 26: [2, 76], 27: [2, 76], 28: [2, 76], 29: [2, 76], 31: [2, 76], 33: [2, 76], 35: [2, 76], 37: [2, 76], 38: [2, 76], 39: [2, 76], 40: [2, 76], 41: [2, 76], 46: [2, 76], 47: [2, 76], 48: [2, 76], 49: [2, 76], 50: [2, 76], 52: [2, 76], 57: [2, 76], 58: [2, 76], 60: [2, 76], 62: [2, 76], 65: [2, 76], 67: [2, 76], 69: [2, 76], 70: [2, 76], 71: [2, 76] }, { 31: [1, 178], 54: 177, 55: [1, 22] }, { 23: [1, 179] }, { 5: [2, 87], 13: [2, 87], 15: [2, 87], 17: [2, 87], 21: [2, 87], 22: [2, 87], 23: [2, 87], 25: [2, 87], 26: [2, 87], 27: [2, 87], 28: [2, 87], 29: [2, 87], 31: [2, 87], 33: [2, 87], 35: [2, 87], 37: [2, 87], 38: [2, 87], 39: [2, 87], 40: [2, 87], 41: [2, 87], 46: [2, 87], 47: [2, 87], 48: [2, 87], 49: [2, 87], 50: [2, 87], 52: [2, 87], 57: [2, 87], 58: [2, 87], 60: [2, 87], 62: [2, 87], 65: [2, 87], 67: [2, 87], 69: [2, 87], 70: [2, 87], 71: [2, 87] }, { 23: [1, 180] }, { 13: [1, 181] }, { 13: [1, 139], 16: 138, 25: [1, 48], 26: [1, 49], 27: [1, 50], 28: [1, 51], 62: [2, 65] }, { 15: [2, 67], 62: [2, 67] }, { 15: [2, 69], 62: [2, 69] }, { 15: [2, 27], 62: [2, 27], 65: [2, 27] }, { 41: [1, 182] }, { 5: [2, 14] }, { 5: [2, 28], 15: [2, 28], 62: [2, 28], 65: [2, 28] }, { 15: [2, 92], 23: [2, 92] }, { 5: [2, 73], 13: [2, 73], 15: [2, 73], 17: [2, 73], 21: [2, 73], 22: [2, 73], 23: [2, 73], 25: [2, 73], 26: [2, 73], 27: [2, 73], 28: [2, 73], 29: [2, 73], 31: [2, 73], 33: [2, 73], 35: [2, 73], 37: [2, 73], 38: [2, 73], 39: [2, 73], 40: [2, 73], 41: [2, 73], 46: [2, 73], 47: [2, 73], 48: [2, 73], 49: [2, 73], 50: [2, 73], 52: [2, 73], 57: [2, 73], 58: [2, 73], 60: [2, 73], 62: [2, 73], 65: [2, 73], 67: [2, 73], 69: [2, 73], 70: [2, 73], 71: [2, 73] }, { 15: [2, 93], 23: [2, 93] }, { 5: [2, 38], 13: [2, 38], 15: [2, 38], 17: [2, 38], 21: [2, 38], 22: [2, 38], 23: [2, 38], 25: [2, 38], 26: [2, 38], 27: [2, 38], 28: [2, 38], 29: [2, 38], 31: [2, 38], 33: [2, 38], 35: [2, 38], 37: [2, 38], 38: [2, 38], 39: [2, 38], 40: [2, 38], 41: [2, 38], 46: [2, 38], 47: [2, 38], 48: [2, 38], 49: [2, 38], 50: [2, 38], 52: [2, 38], 55: [2, 38], 57: [2, 38], 58: [2, 38], 60: [2, 38], 62: [2, 38], 65: [2, 38], 67: [2, 38], 69: [2, 38], 70: [2, 38], 71: [2, 38] }, { 5: [2, 19], 15: [2, 19] }, { 5: [2, 20], 15: [2, 20] }, { 4: 183, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 184, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 41: [1, 185] }, { 55: [1, 186] }, { 5: [2, 81], 13: [2, 81], 15: [2, 81], 17: [2, 81], 21: [2, 81], 22: [2, 81], 23: [2, 81], 25: [2, 81], 26: [2, 81], 27: [2, 81], 28: [2, 81], 29: [2, 81], 31: [2, 81], 33: [2, 81], 35: [2, 81], 37: [2, 81], 38: [2, 81], 39: [2, 81], 40: [2, 81], 41: [2, 81], 46: [2, 81], 47: [2, 81], 48: [2, 81], 49: [2, 81], 50: [2, 81], 52: [2, 81], 57: [2, 81], 58: [2, 81], 60: [2, 81], 62: [2, 81], 65: [2, 81], 67: [2, 81], 69: [2, 81], 70: [2, 81], 71: [2, 81] }, { 5: [2, 89], 13: [2, 89], 15: [2, 89], 17: [2, 89], 21: [2, 89], 22: [2, 89], 23: [2, 89], 25: [2, 89], 26: [2, 89], 27: [2, 89], 28: [2, 89], 29: [2, 89], 31: [2, 89], 33: [2, 89], 35: [2, 89], 37: [2, 89], 38: [2, 89], 39: [2, 89], 40: [2, 89], 41: [2, 89], 46: [2, 89], 47: [2, 89], 48: [2, 89], 49: [2, 89], 50: [2, 89], 52: [2, 89], 57: [2, 89], 58: [2, 89], 60: [2, 89], 62: [2, 89], 65: [2, 89], 67: [2, 89], 69: [2, 89], 70: [2, 89], 71: [2, 89] }, { 4: 187, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 17: [2, 86], 22: [2, 86], 31: [2, 86], 37: [2, 86], 40: [2, 86], 46: [2, 86], 48: [2, 86], 49: [2, 86], 52: [2, 86], 55: [2, 86], 57: [2, 86], 58: [2, 86], 60: [2, 86], 67: [2, 86], 69: [2, 86], 70: [2, 86], 71: [2, 86] }, { 41: [1, 188] }, { 41: [1, 189] }, { 12: 62, 17: [1, 13], 22: [1, 191], 30: 190, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 41: [2, 72] }, { 41: [1, 192] }, { 5: [2, 48], 13: [2, 48], 15: [2, 48], 17: [2, 48], 21: [2, 48], 22: [2, 48], 23: [2, 48], 25: [2, 48], 26: [2, 48], 27: [2, 48], 28: [2, 48], 29: [2, 48], 31: [2, 48], 33: [2, 48], 35: [2, 48], 37: [2, 48], 38: [2, 48], 39: [2, 48], 40: [2, 48], 41: [2, 48], 46: [2, 48], 47: [2, 48], 48: [2, 48], 49: [2, 48], 50: [2, 48], 52: [2, 48], 57: [2, 48], 58: [2, 48], 60: [2, 48], 62: [2, 48], 65: [2, 48], 67: [2, 48], 69: [2, 48], 70: [2, 48], 71: [2, 48] }, { 5: [2, 50], 13: [2, 50], 15: [2, 50], 17: [2, 50], 21: [2, 50], 22: [2, 50], 23: [2, 50], 25: [2, 50], 26: [2, 50], 27: [2, 50], 28: [2, 50], 29: [2, 50], 31: [2, 50], 33: [2, 50], 35: [2, 50], 37: [2, 50], 38: [2, 50], 39: [2, 50], 40: [2, 50], 41: [2, 50], 46: [2, 50], 47: [2, 50], 48: [2, 50], 49: [2, 50], 50: [2, 50], 52: [2, 50], 57: [2, 50], 58: [2, 50], 60: [2, 50], 62: [2, 50], 65: [2, 50], 67: [2, 50], 69: [2, 50], 70: [2, 50], 71: [2, 50] }, { 5: [2, 78], 12: 62, 13: [2, 78], 15: [2, 78], 17: [1, 13], 21: [2, 78], 22: [1, 63], 23: [2, 78], 25: [2, 78], 26: [2, 78], 27: [2, 78], 28: [2, 78], 29: [2, 78], 31: [2, 78], 32: 67, 33: [1, 68], 35: [1, 69], 37: [2, 78], 38: [2, 78], 39: [2, 78], 40: [1, 27], 41: [2, 78], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 47: [2, 78], 48: [1, 29], 49: [1, 30], 50: [2, 78], 51: 31, 52: [1, 32], 53: 33, 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 62: [2, 78], 65: [2, 78], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 4: 193, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 36: 194, 37: [1, 72], 38: [1, 73], 39: [1, 74] }, { 23: [1, 195] }, { 4: 196, 12: 62, 17: [1, 13], 22: [1, 63], 24: 11, 30: 14, 31: [1, 20], 32: 21, 34: 16, 40: [1, 27], 42: 23, 43: 24, 44: 25, 45: 26, 46: [1, 28], 48: [1, 29], 49: [1, 30], 51: 31, 52: [1, 32], 53: 33, 54: 19, 55: [1, 22], 56: 36, 57: [1, 42], 58: [1, 43], 60: [1, 37], 66: 34, 67: [1, 38], 68: 35, 69: [1, 39], 70: [1, 40], 71: [1, 41] }, { 5: [2, 79], 13: [2, 79], 15: [2, 79], 17: [2, 79], 21: [2, 79], 22: [2, 79], 23: [2, 79], 25: [2, 79], 26: [2, 79], 27: [2, 79], 28: [2, 79], 29: [2, 79], 31: [2, 79], 33: [2, 79], 35: [2, 79], 37: [2, 79], 38: [2, 79], 39: [2, 79], 40: [2, 79], 41: [2, 79], 46: [2, 79], 47: [2, 79], 48: [2, 79], 49: [2, 79], 50: [2, 79], 52: [2, 79], 57: [2, 79], 58: [2, 79], 60: [2, 79], 62: [2, 79], 65: [2, 79], 67: [2, 79], 69: [2, 79], 70: [2, 79], 71: [2, 79] }, { 5: [2, 63], 13: [2, 63], 15: [2, 63], 17: [2, 63], 21: [2, 63], 22: [2, 63], 23: [2, 63], 25: [2, 63], 26: [2, 63], 27: [2, 63], 28: [2, 63], 29: [2, 63], 31: [2, 63], 33: [2, 63], 35: [2, 63], 37: [2, 63], 38: [2, 63], 39: [2, 63], 40: [2, 63], 41: [2, 63], 46: [2, 63], 47: [2, 63], 48: [2, 63], 49: [2, 63], 50: [2, 63], 52: [2, 63], 57: [2, 63], 58: [2, 63], 60: [2, 63], 62: [2, 63], 65: [2, 63], 67: [2, 63], 69: [2, 63], 70: [2, 63], 71: [2, 63]}],
        defaultActions: { 42: [2, 61], 43: [2, 62], 44: [2, 1], 52: [2, 2], 53: [2, 3], 54: [2, 4], 55: [2, 5], 56: [2, 6], 57: [2, 7], 60: [2, 9], 61: [2, 94], 102: [2, 13], 105: [2, 8], 106: [2, 11], 107: [2, 12], 142: [2, 10], 167: [2, 14], 186: [2, 72] },
        parseError: function parseError(str, hash) {
            throw new Error(str);
        },
        parse: function parse(input) {
            var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

            //this.reductionCount = this.shiftCount = 0;

            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == 'undefined')
                this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);

            var ranges = this.lexer.options && this.lexer.options.ranges;

            if (typeof this.yy.parseError === 'function')
                this.parseError = this.yy.parseError;

            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }

            function lex() {
                var token;
                token = self.lexer.lex() || 1; // $end = 1
                // if token isn't its numeric value, convert
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            }

            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
                // retreive state number from top of stack
                state = stack[stack.length - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == 'undefined') {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    action = table[state] && table[state][symbol];
                }

                // handle parse error
                _handle_error:
                if (typeof action === 'undefined' || !action.length || !action[0]) {

                    var errStr = '';
                    if (!recovering) {
                        // Report error
                        expected = [];
                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
                            expected.push("'" + this.terminals_[p] + "'");
                        }
                        if (this.lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " +
                                  (symbol == 1 /*EOF*/ ? "end of input" :
                                              ("'" + (this.terminals_[symbol] || symbol) + "'"));
                        }
                        this.parseError(errStr,
                    { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                    }

                    // just recovered from another error
                    if (recovering == 3) {
                        if (symbol == EOF) {
                            throw new Error(errStr || 'Parsing halted.');
                        }

                        // discard current lookahead and grab another
                        yyleng = this.lexer.yyleng;
                        yytext = this.lexer.yytext;
                        yylineno = this.lexer.yylineno;
                        yyloc = this.lexer.yylloc;
                        symbol = lex();
                    }

                    // try to recover from error
                    while (1) {
                        // check for error recovery rule in this state
                        if ((TERROR.toString()) in table[state]) {
                            break;
                        }
                        if (state === 0) {
                            throw new Error(errStr || 'Parsing halted.');
                        }
                        popStack(1);
                        state = stack[stack.length - 1];
                    }

                    preErrorSymbol = symbol == 2 ? null : symbol; // save the lookahead token
                    symbol = TERROR;         // insert generic error symbol as new lookahead
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
                }

                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                }

                switch (action[0]) {

                    case 1: // shift
                        //this.shiftCount++;

                        stack.push(symbol);
                        vstack.push(this.lexer.yytext);
                        lstack.push(this.lexer.yylloc);
                        stack.push(action[1]); // push state
                        symbol = null;
                        if (!preErrorSymbol) { // normal execution/no error
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            if (recovering > 0)
                                recovering--;
                        } else { // error just occurred, resume old lookahead f/ before error
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;

                    case 2: // reduce
                        //this.reductionCount++;

                        len = this.productions_[action[1]][1];

                        // perform semantic action
                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                        // default location, uses first token for firsts, last for lasts
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

                        if (typeof r !== 'undefined') {
                            return r;
                        }

                        // pop off stack
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }

                        stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;

                    case 3: // accept
                        return true;
                }

            }

            return true;
        } 
    };
    /* Jison generated lexer */
    var lexer = (function () {
        var lexer = ({ EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            setInput: function (input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                if (this.options.ranges) this.yylloc.range = [0, 0];
                this.offset = 0;
                return this;
            },
            input: function () {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) this.yylloc.range[1]++;

                this._input = this._input.slice(1);
                return ch;
            },
            unput: function (ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) this.yylineno -= lines.length - 1;
                var r = this.yylloc.range;

                this.yylloc = { first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ?
              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                return this;
            },
            more: function () {
                this._more = true;
                return this;
            },
            less: function (n) {
                this.unput(this.match.slice(n));
            },
            pastInput: function () {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function () {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },
            showPosition: function () {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function () {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) this.done = true;

                var token,
            match,
            tempMatch,
            index,
            col,
            lines;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = { first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) this.done = false;
                    if (token) return token;
                    else return;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(),
                    { text: "", token: null, line: this.yylineno });
                }
            },
            lex: function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                    return r;
                } else {
                    return this.lex();
                }
            },
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            popState: function popState() {
                return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function () {
                return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
                this.begin(condition);
            } 
        });
        lexer.options = {};
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

            var YYSTATE = YY_START
            switch ($avoiding_name_collisions) {
                case 0: /* skip whitespace */
                    break;
                case 1: return 40
                    break;
                case 2: return 41
                    break;
                case 3: return 'MATH_SHIFT'
                    break;
                case 4: yy_.yytext = this.matches[this.matches.length - 1]; return 37
                    break;
                case 5: yy_.yytext = this.matches[this.matches.length - 1]; return 38
                    break;
                case 6: return 39
                    break;
                case 7: return 55
                    break;
                case 8: return 33
                    break;
                case 9: return 35
                    break;
                case 10: yy_.yytext = this.matches[3]; return 52
                    break;
                case 11: yy_.yytext = this.matches[this.matches.length - 1]; return 71
                    break;
                case 12: return 69
                    break;
                case 13: return 70
                    break;
                case 14: return 48
                    break;
                case 15: return 49
                    break;
                case 16: return 57
                    break;
                case 17: return 58
                    break;
                case 18: return 46  /* rely on mathquill */
                    break;
                case 19: return 47 /* for pairing */
                    break;
                case 20: return 31
                    break;
                case 21: return 29
                    break;
                case 22: return 13
                    break;
                case 23: return 59
                    break;
                case 24: return 50
                    break;
                case 25: return 5
                    break;
                case 26: return 22
                    break;
                case 27: return 23
                    break;
                case 28: return 20
                    break;
                case 29: return 21
                    break;
                case 30: return 60
                    break;
                case 31: return 62
                    break;
                case 32: return 65
                    break;
                case 33: return 27
                    break;
                case 34: return 28
                    break;
                case 35: return 26
                    break;
                case 36: return 25
                    break;
                case 37: return 15
                    break;
                case 38: return 14
                    break;
                case 39: return 67        /* sin, cos, sinh, ln*/
                    break;
                case 40: return 17          /* Predefined functions, as well as user-defined variables.  Doesn't include subscripts */
                    break;
                case 41: /* skip LINE_START if it's not needed for something else */
                    break;
                case 42: return 'UNRECOGNIZED'
                    break;
            }
        };
        lexer.rules = [/^(?:(\\space|\\:|\s)+)/, /^(?:\{)/, /^(?:\})/, /^(?:\$)/, /^(?:\^([0-9]))/, /^(?:\^([a-zA-Z]))/, /^(?:\^)/, /^(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))/, /^(?:\*|(\\cdot))/, /^(?:\/)/, /^(?:(\\frac((?:\s|\\space|\\:)*)\{d\}\{d(((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))\}))/, /^(?:(\\log)((?:\s|\\space|\\:)*)*_([0-9]))/, /^(?:(\\ln))/, /^(?:(\\log))/, /^(?:(\\frac))/, /^(?:(\\sqrt))/, /^(?:(\\sum))/, /^(?:(\\prod))/, /^(?:\\left\|)/, /^(?:\\right\|)/, /^(?:-)/, /^(?:\+)/, /^(?:=)/, /^(?:[_])/, /^(?:!)/, /^(?:$)/, /^(?:(\()|\\left\()/, /^(?:(\))|\\right\))/, /^(?:(\[)|\\left\[)/, /^(?:(\])|\\right\])/, /^(?:(\\\{)|\\left\\\{)/, /^(?:(\\\})|\\right\\\})/, /^(?::)/, /^(?:(\\ge|>=))/, /^(?:(\\le|<=))/, /^(?:(\\gt|>))/, /^(?:(\\lt|<))/, /^(?:,)/, /^(?:(###)(((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*)(\\left\(|\()((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)(((?:\s|\\space|\\:)*),((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*))*((?:\s|\\space|\\:)*)(\\right\)|\))((?:\s|\\space|\\:)*)=))/, /^(?:(\\(arc)?(sin|cos|tan|cot|sec|csc)h?))/, /^(?:((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))/, /^(?:(###))/, /^(?:.)/];
        lexer.conditions = { "conditional": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], "inclusive": true }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], "inclusive": true} };
        return lexer;
    })()
    parser.lexer = lexer;
    return parser;
});
var define_enum_constant;
var enum_strings = {};
var debuggable_enums = true;

if (debuggable_enums) {
    define_enum_constant = function (s) {
        this[s] = s;
    };
}
else {
    var next_enum = 1000;
    define_enum_constant = function (s) {
        enum_strings[next_enum] = s;
        this[s] = next_enum++;
    };
}

//Statement types (determined entirely from the root element of the parse tree)
define_enum_constant("DOES_NOT_EXIST");              //expression does not exist
define_enum_constant("EXPRESSION");              //a+1 or 1+1
define_enum_constant("FUNCTION_DEFINITION");     //f(x)=???
define_enum_constant("VARIABLE_DEFINITION");     //a=???
define_enum_constant("ORDERED_PAIR_LIST");     // (?, ?), (?, ?).  Support lists of points, but only single parametrics
define_enum_constant("DOUBLE_INEQUALITY");       // expr < y < expr, shade-between
define_enum_constant("COMPARATOR");       // expr < expr - unsolved inequality
define_enum_constant("CHAINED_COMPARATOR");       // a < ??? - not a conditional as an expression
define_enum_constant("EQUATION");         // expr = expr
define_enum_constant("CONSTANT");
define_enum_constant("IDENTIFIER");

//Statement statuses (determined in the context of all other equations)
define_enum_constant("ERROR");       //any type
define_enum_constant("WARNING");     //any type
define_enum_constant("EVALUABLE");   //expression or variable definition
define_enum_constant("GRAPHABLE");     //any type
define_enum_constant("SILENT");
define_enum_constant("XYPOINT");     //any type

//GLOBAL DEFINITIONS
define_enum_constant('GRAPHMODE_X');
define_enum_constant('GRAPHMODE_Y');
define_enum_constant('GRAPHMODE_XYPOINT');
define_enum_constant('GRAPHMODE_PARAMETRIC');
define_enum_constant('GRAPHMODE_POLAR');
define_enum_constant('GRAPHMODE_POLYGONFILL');

define_enum_constant('POI_INTERSECTION');
define_enum_constant('POI_ZERO');
define_enum_constant('POI_INTERCEPT');
define_enum_constant('POI_EXTREMUM');
define_enum_constant('POI_EDGE');


define("math/enums", function () { });

define('math/inverses', [], function () {
    var inverses = {};

    // Functions with an inverse spelled arcname
    var arcNames = [
    'sin',
    'cos',
    'tan',
    'cot',
    'sec',
    'csc',
    'sinh',
    'cosh',
    'tanh',
    'coth',
    'sech',
    'csch'
  ];

    arcNames.forEach(function (name) {
        inverses[name] = 'arc' + name;
        inverses['arc' + name] = name;
    });

    return inverses;
});
//Create a single fn_map object for all compiled functions to hang off of.
//Functions which should be "globally" visible will be defined here (as a mapping from name to function)
//Compiled functions are bound to this object before use, so that they can access these functions using "this.name"

define('math/functions', [], function () {
    var fn_map = {};

    var compile = function (args, evalString) {
        /*jshint evil:true*/
        var fn = new Function(args, evalString);
        return _.bind(fn, fn_map);
    };

    var register = function (name, fn) {
        fn_map[name] = fn;
    };

    return {
        compile: compile,
        register: register
    };
});

define('math/parser_util', ['require', 'pjs', './evalframe', './comparators', 'parser', './enums', './inverses', './functions'], function (require) {
    var P = require('pjs');
    var EvalFrame = require('./evalframe');
    var Comparators = require('./comparators');
    var latex = require('parser');
    var enums = require('./enums');
    var inverses = require('./inverses');
    var functions = require('./functions');

    var exports = {};

    latex.yy.inverses = inverses;

    var ParseNode = exports.ParseNode = P(function (node) {
        node.init = function () {
            this._dependencies = {};
            this._referencedSymbols = {};
        };
        //TODO - consider just storing ranges, and linking them to the latex string at request time
        node.setInputString = function (s) {
            this._inputString = s;
        };
        node.getInputString = function () {
            return this._inputString;
        };
        node.statementType = EXPRESSION;
        node.assigns = null;
        node.valid = true;
        node.exportDefinitionsTo = function (frame) { };
        node.evaluateOnce = function (frame) { return "Unable to evaluate" };
        node.addDependency = function (identifier, arity) {
            //_dependency stores the identifiers which are depended on, as well as their required arity/type
            //0 => variable
            //1 => ambiguous between unary function and implicit multiplication
            //n>1 => function of arity n
            this.referenceSymbol(identifier);

            if (!this._dependencies.hasOwnProperty(identifier)) { //New dependency
                this._dependencies[identifier] = arity;
                return;
            }

            //We already depend on this, need to make sure new and old dependencies are consistent
            var prior_arity = this._dependencies[identifier];

            if (arity === prior_arity) { return } //Consistent - no change to dependency structure

            if (arity === 1 && prior_arity === 0) { return } //New ambiguous entry is consistent with prior variable definition

            if (arity === 0 && prior_arity === 1) {
                this._dependencies[identifier] = arity;  //Dependency on identifier as a variable resolves previous ambiguity
                return;
            }

            if (arity === 0 || prior_arity === 0) {
                throw ("You're referencing '" + identifier + "' as both a function and a variable. Make up your mind!");
            } else {
                throw ("You're referencing '" + identifier + "' as both a " + prior_arity + "-variable and a " + arity + "-variable function. Make up your mind!");
            }
        };

        node.referenceSymbol = function (identifier) {
            this._referencedSymbols[identifier] = true;
        };

        node.shadowVariable = function (identifier) {
            this.referenceSymbol(identifier);
            if (!this._dependencies.hasOwnProperty(identifier)) return;

            var prior_arity = this._dependencies[identifier];
            if (prior_arity <= 1) {
                delete this._dependencies[identifier];
                return;
            }
            throw ("Cannot redefine function " + identifier + " as a variable");
        };

        node.addDependencies = function (dependencies) {
            for (var identifier in dependencies) {
                if (!dependencies.hasOwnProperty(identifier)) continue;

                var arity = dependencies[identifier];
                this.addDependency(identifier, arity);
            }
        };

        //Used to determine re-computation dependencies
        //Needs to be different than dependencies, because f(a)=a doesn't depend on a, but throws an error when a is defined
        node.references = function (identifier) {
            if (this._referencedSymbols[identifier]) return true; //For shadowed varibles, etc.
        };

        node.dependencies = function () {
            return this._dependencies;
        };

        node.getEvalStrings = function () {
            throw ("Cannot call getEvalStrings on base ParseNode");
        };

        node.polynomialOrder = function () {
            return Infinity;
        };

        //Generate non-colliding names
        //To play it safe, we want to never re-use temp variables;
        //This shouldn't wrap around until 2^52.  2^52 microseconds is 142 years.
        //All variables will be of the form tmp123, which we don't allow as a real variable name
        node.uid_counter = [0]; //Same reference for everyone
        node.tmp = function () {
            return 'tmp' + this.uid_counter[0]++;
        };

        node.okForImplicitFunction = function () {
            return false;
        };

    });

    var AssignmentNode = exports.AssignmentNode = P(ParseNode, function (node, _super) {
        node.init = function (identifier, expression) {
            _super.init.call(this);
            this.assigns = identifier;
            this.referenceSymbol(this.assigns.identifier);
            this.arity = 0;
            this.expression = expression;
            this.addDependencies(expression.dependencies());
            this.lhs = identifier; //masquerade as equation
            this.rhs = expression; //masquerade as equation
            //Decide if we should act as an assignment or an equation
            //TODO - may want this policy to live somewhere else
            //Current policy is just whether we have a circular dependency
            if (this.dependencies().hasOwnProperty(this.assigns.identifier)) {
                this.statementType = EQUATION;
            }
        };
        node.statementType = VARIABLE_DEFINITION;
        node.evaluateOnce = function (frame) {
            return this.expression.evaluateOnce(frame);
        };
        node.exportDefinitionsTo = function (frame) {  //Uses the same frame as evaluation context
            if (this.statementType === EQUATION) return;
            try {
                var constant_value = this.expression.evaluateOnce(frame);
                var constant_node = ConstantNode(constant_value);
                frame.setVariable(this.assigns.identifier, constant_node);
                frame.setEvalStrings(this.assigns.identifier, constant_node.getEvalStrings(frame));
            }
            catch (e) {
                frame.setVariable(this.assigns.identifier, this.expression);
                frame.setEvalStrings(this.assigns.identifier, this.expression.getEvalStrings(frame));
            }
        };
        node.getEvalStrings = function (frame) {
            if (this.statementType === EQUATION) return _super.getEvalStrings(frame);
            return this.expression.getEvalStrings(frame);
        };

        node.toString = function () {
            return this.assigns + ' = ' + this.expression;
        };
    });

    var DoubleInequalityNode = exports.DoubleInequalityNode = P(ParseNode, function (node, _super) {
        node.init = function (expression1, comparator1, expressionm, comparator2, expression2) {
            _super.init.call(this);
            this._inequalities = [];

            if (Comparators.table[comparator1].direction != Comparators.table[comparator2].direction) {
                throw "Double inequalities must both go the same way, e.g. 1 < y < 2"; //TODO - need better error message
            }

            this.direction = Comparators.table[comparator1].direction;
            this.inclusive = (
        Comparators.table[comparator1].inclusive &&
        Comparators.table[comparator2].inclusive
    );
            var validity_comparator = Comparators.get(this.inclusive, this.direction);

            var valid_predicate = ComparatorNode(validity_comparator, expression1, expression2);
            var expression1_valid = PiecewiseNode(valid_predicate, expression1);
            var expression2_valid = PiecewiseNode(valid_predicate, expression2);

            this._inequalities.push(ComparatorNode(comparator1, expressionm, expression1_valid)); //TODO - invert comparator
            this._inequalities.push(ComparatorNode(comparator2, expressionm, expression2_valid));


            this.addDependencies(expressionm.dependencies());
            this.addDependencies(expression1.dependencies());
            this.addDependencies(expression2.dependencies());

            node.statementType = DOUBLE_INEQUALITY;
        };

        node.getInequality = function (i) {
            return this._inequalities[i];
        };
    });

    var EquationNode = exports.EquationNode = P(ParseNode, function (node, _super) {
        node.init = function (lhs, rhs) {
            _super.init.call(this);
            this.lhs = lhs;
            this.rhs = rhs;
            this.addDependencies(lhs.dependencies());
            this.addDependencies(rhs.dependencies());
        };

        node.statementType = EQUATION;

        node.toString = function () { return this.lhs + ' = ' + this.rhs; };
    });

    //Represents if-else
    var PiecewiseNode = exports.PiecewiseNode = P(ParseNode, function (node, _super) {
        node.init = function (condition, if_expr, else_expr) {
            _super.init.call(this);
            this.condition = condition;
            this.if_expr = if_expr;
            this.frozen = false;
            if (else_expr) {
                this.else_expr = else_expr;
                this.addDependencies(this.else_expr._partial_dependencies());
            }
            this.addDependencies(condition.dependencies());
            this.addDependencies(if_expr.dependencies());
            //TODO - add dependencies
        };

        //Don't want to freeze dependencies while building the if-else chain
        //Only want to freeze once someone else asks about our dependencies, since they won't update in response to changes
        node._partial_dependencies = function () {
            return _super.dependencies;
        };

        //Chained if-else nodes (from {a:b, c:d, e} notation) are created by passing each subsequent clause down the parse tree, updating dependencies as it goes.
        //This is only valid when used "correctly" (e.g. start passing in the from the top node, and only pass during construction, not after use)
        node.append_else = function (else_expr) {
            if (this.frozen) throw ("Programming Error - please treat me as immutable.  Cannot change PiecewiseNode after getting dependencies");
            if (this.else_expr) {
                this.else_expr.append_else(else_expr);
            }
            else {
                this.else_expr = else_expr;
            }
            this.addDependencies(else_expr.dependencies());  //Needs to be added to everyone all the way down the if-else chain to have correct dependencies for the whole tree.
            return this;
        };

        node.evaluateOnce = function (frame) {
            this.frozen = true;
            if (this.condition.evaluateOnce(frame)) {
                return this.if_expr.evaluateOnce(frame);
            }
            else if (this.else_expr) {
                return this.else_expr.evaluateOnce(frame);
            }
            return undefined;
        };

        node.getEvalStrings = function (frame) {
            var condition_strings = this.condition.getEvalStrings(frame);
            var if_strings = this.if_expr.getEvalStrings(frame);
            var else_strings;

            if (this.else_expr) {
                else_strings = this.else_expr.getEvalStrings(frame);
            }
            else {
                else_strings = { statements: '', expression: 'undefined' };
            }

            var result = this.tmp();
            var statements = 'var ' + result + ';' + condition_strings.statements +
                     'if(' + condition_strings.expression + ') {' +
                      if_strings.statements + result + '=' + if_strings.expression +
                     ';}else{' +
                      else_strings.statements + result + '=' + else_strings.expression + ';}';
            return { expression: result, statements: statements };
        };

        node.polynomialOrder = function (frame, variable) {
            if (this.dependencies().hasOwnProperty(variable)) {
                return Infinity;
            }
            else {
                return 0;
            }
        };

        node.quadraticCoefficients = function (frame, variable) {
            return [0, 0, this.evaluateOnce(frame)];
        };

        node.polynomialEvalStrings = function (frame, variable, arg) {
            var eval_strings = this.getEvalStrings(frame);
            return { statements: eval_strings.statements, expressions: [eval_strings.expression] };
        };

        node.toString = function () {

            if (!this.else_expr) {
                return '\\left\\{' +
        this.condition + ': ' + this.if_expr +
        '\\right\\}';
            }

            // Can't reparse literal true, so use special form.
            var elseString;
            if (this.else_expr.condition && this.else_expr.condition.value === true) {
                elseString = String(this.else_expr.if_expr);
            } else {
                // Unwind elses
                elseString = String(this.else_expr).replace(/^\\left\\\{(.*)\\right\\\}$/, '$1');
            }

            return '\\left\\{' +
      this.condition + ': ' + this.if_expr + ', ' + elseString +
      '\\right\\}';
        };

    });

    var OrderedPairNode = exports.OrderedPairNode = P(ParseNode, function (node, _super) {
        node.init = function (first, second) {
            _super.init.call(this);
            this.children = [first, second];
            this.addDependencies(first.dependencies());
            this.addDependencies(second.dependencies());
        };

        node.getEvalStrings = function (frame) {
            var first_strings = this.children[0].getEvalStrings(frame);
            var second_strings = this.children[1].getEvalStrings(frame);
            var statements = first_strings.statements + second_strings.statements;
            var expression = '[' + first_strings.expression + ',' + second_strings.expression + ']';
            return { statements: statements, expression: expression };
        };

        node.evaluateOnce = function (frame) {
            return [this.children[0].evaluateOnce(frame), this.children[1].evaluateOnce(frame)];
        };

        this.toString = function () {
            return '\\left(' + first + ', ' + second + '\\right)';
        };
    });

    var ErrorNode = exports.ErrorNode = P(ParseNode, function (node, _super) {
        node.init = function (msg) {
            _super.init.call(this);
            this.error_msg = msg;
        };
        node.valid = false;

        this.evaluateOnce = function (frame) {
            return this.error_msg;
        };
    });

    var ConstantNode = exports.ConstantNode = P(ParseNode, function (node, _super) {
        node.init = function (value) {
            _super.init.call(this);
            this.value = value;
        };
        node.evaluateOnce = function (frame) {
            return this.value;
        };
        node.getEvalStrings = function () {
            var statements = '';
            var expression = (this.value < 0 ? '(' + String(this.value) + ')' : String(this.value));
            return { expression: expression, statements: statements };
        };
        node.quadraticCoefficients = function (frame, variable) {
            return [0, 0, this.value];
        };
        node.polynomialEvalStrings = function (frame, variable, arg) {
            return { statements: '', expressions: ['(' + String(this.value) + ')'] };
        };

        node.polynomialOrder = function (frame, variable) {
            return 0;
        };

        node.okForImplicitFunction = function () {
            return true;
        };

        node.toString = function () { return String(this.value); };

        node.statementType = CONSTANT;
    });

    var NegationNode = exports.NegationNode = P(ParseNode, function (node, _super) {
        node.init = function (expression) {
            _super.init.call(this);
            this.expression = expression;
            this.addDependencies(this.expression.dependencies());
        };
        node.evaluateOnce = function (frame) {
            return -(this.expression.evaluateOnce(frame));
        };
        node.quadraticCoefficients = function (frame, variable) {
            var coeffs = this.expression.quadraticCoefficients(frame, variable);
            return [-coeffs[0], -coeffs[1], -coeffs[2]];
        };
        node.polynomialEvalStrings = function (frame, variable, arg) {
            var strings = this.expression.polynomialEvalStrings(frame, variable, arg);
            for (var i = 0; i < strings.expressions.length; i++) {
                strings.expressions[i] = '(-' + strings.expressions[i] + ')';
            }
            return strings;
        };
        node.polynomialOrder = function (frame, variable) {
            return this.expression.polynomialOrder(frame, variable);
        };
        node.getEvalStrings = function (frame) {
            var evalStrings = this.expression.getEvalStrings(frame);
            return { expression: '(-' + evalStrings.expression + ')', statements: evalStrings.statements };
        };
        node.toString = function () { return '-' + this.expression; };

    });

    var IdentifierNode = exports.IdentifierNode = P(ParseNode, function (node, _super) {
        node.init = function (identifier) {
            _super.init.call(this);
            identifier = identifier.replace('\\', ''); //TODO - want to verify this remapping
            identifier = identifier.replace('{', '');
            identifier = identifier.replace('}', '');
            this.identifier = identifier;
            this.addDependency(this.identifier, 0);
        };
        node.evaluateOnce = function (frame) {
            return frame.getVariable(this.identifier).evaluateOnce(frame);
        };
        node.getEvalStrings = function (frame) {
            return frame.getEvalStrings(this.identifier);
        };
        node.quadraticCoefficients = function (frame, variable) {
            if (variable === this.identifier) {
                return [0, 1, 0];
            }
            else {
                var tree = frame.getVariable(this.identifier);
                return tree.quadraticCoefficients(frame, variable);
            }
        };
        node.polynomialEvalStrings = function (frame, variable, arg) {
            if (variable === this.identifier) {
                return { statements: '', expressions: ['0', '1'] };
            }
            else if (arg === this.identifier) {
                return { statements: '', expressions: [this.identifier] };
            }
            else {
                var tree = frame.getVariable(this.identifier);
                return tree.polynomialEvalStrings(frame, variable, arg);
            }
        };
        node.polynomialOrder = function (frame, variable) {
            if (variable === this.identifier) return 1;
            if (!frame.hasVariable(this.identifier)) return 0;
            var tree = frame.getVariable(this.identifier);
            return tree.polynomialOrder(frame, variable);
        };
        node.okForImplicitFunction = function () {
            return true;
        };

        node.toString = function () {
            var m = this.identifier.match(/^([^_]+)(_(.*))?$/);
            var base = m[1];
            var subscript = m[3];

            if (base.length > 1) base = '\\' + base;
            if (!subscript) return base;
            return base + '_{' + subscript + '}';
        };

        node.statementType = IDENTIFIER;
    });

    var ChainedComparatorNode = exports.ChainedComparatorNode = P(ParseNode, function (node, _super) {
        node.init = function (comparators, args) {
            _super.init.call(this);
            if (!(comparators.length === 2 && args.length === 3)) throw "Can't chain more than 2 comparators";

            this.comparators = comparators;
            this.args = args;


            for (var i = 0; i < 3; i++) {
                this.addDependencies(args[i].dependencies());
            }

            this.node1 = ComparatorNode(this.comparators[0], this.args[0], this.args[1]);
            this.node2 = ComparatorNode(this.comparators[1], this.args[1], this.args[2]);
        };

        node.evaluateOnce = function (frame) {
            return this.node1.evaluateOnce(frame) && this.node2.evaluateOnce(frame);
        };

        //TODO - stop double-evaluating middle value
        node.getEvalStrings = function (frame) {
            var s1 = this.node1.getEvalStrings(frame);
            var s2 = this.node2.getEvalStrings(frame);
            var statements = s1.statements + s2.statements;
            var expression = "(" + s1.expression + "&&" + s2.expression + ")";
            return { expression: expression, statements: statements };
        };

        node.toString = function () {
            return [
      this.args[0],
      this.comparators[0],
      this.args[1],
      this.comparators[1],
      this.args[2]
    ].join(' ');
        };

        node.statementType = CHAINED_COMPARATOR;
    });

    var BinaryOperatorTable = {
        '+': 'arg1+arg2',
        '-': 'arg1-arg2',
        '*': 'arg1*arg2',
        '/': 'arg1/arg2',
        '^': 'this.pow(arg1,arg2)', //Must be bund to functions object
        '>': 'arg1>arg2',
        '<': 'arg1<arg2',
        '>=': 'arg1>=arg2',
        '<=': 'arg1<=arg2',
        '===': 'arg1===arg2'
    };


    var BinaryOperatorFunctionTable = {};
    for (var operator in BinaryOperatorTable) {
        if (BinaryOperatorTable.hasOwnProperty(operator)) {
            var fn = functions.compile(['arg1', 'arg2'], 'return ' + BinaryOperatorTable[operator]);
            BinaryOperatorFunctionTable[operator] = fn;
        }
    }

    var BinaryOperatorNode = exports.BinaryOperatorNode = P(ParseNode, function (node, _super) {
        node.init = function (operator, x1, x2) {
            _super.init.call(this);
            this.args = [x1, x2];
            this.operator = operator;
            this.evaluator = BinaryOperatorFunctionTable[operator];
            this.addDependencies(this.args[0].dependencies());
            this.addDependencies(this.args[1].dependencies());
        };

        node.evaluateOnce = function (frame) {
            return this.evaluator(this.args[0].evaluateOnce(frame), this.args[1].evaluateOnce(frame));
        };

        node.getEvalStrings = function (frame) {
            var s0 = this.args[0].getEvalStrings(frame);
            var s1 = this.args[1].getEvalStrings(frame);
            var template = BinaryOperatorTable[this.operator];
            var expression = '(' +
      template.replace('arg1', s0.expression)
      .replace('arg2', s1.expression) +
    ')';
            var statements = s0.statements + s1.statements;
            return { expression: expression, statements: statements };
        };

        node.quadraticCoefficients = function (frame, variable) {
            var coeffs0 = this.args[0].quadraticCoefficients(frame, variable);
            var coeffs1 = this.args[1].quadraticCoefficients(frame, variable);

            switch (this.operator) {
                case '+':
                    return [coeffs0[0] + coeffs1[0], coeffs0[1] + coeffs1[1], coeffs0[2] + coeffs1[2]];

                case '-':
                    return [coeffs0[0] - coeffs1[0], coeffs0[1] - coeffs1[1], coeffs0[2] - coeffs1[2]];

                case '*':
                    var new_coeffs = [0, 0, 0, 0, 0];
                    for (var i = 0; i <= 2; i++) {
                        for (var j = 0; j <= 2; j++) {
                            new_coeffs[i + j] += coeffs0[i] * coeffs1[j];
                        }
                    }
                    var invalid_coeffs = new_coeffs.splice(0, 2);  //invalid_coeffs gets first 2 coeffs.  Last 3 stay in new_coeffs.
                    if (invalid_coeffs[0] !== 0 || invalid_coeffs[1] !== 0) return [NaN, NaN, NaN]; //throw "Greater than quadratic";
                    return new_coeffs;

                case '/':
                    if (coeffs1[0] !== 0 || coeffs1[1] !== 0) return [NaN, NaN, NaN]; //throw "Can't solve with x in the denominator";
                    return [coeffs0[0] / coeffs1[2], coeffs0[1] / coeffs1[2], coeffs0[2] / coeffs1[2]];

                case '^':
                    // Exponent can't depend on variable
                    if (coeffs1[0] !== 0 || coeffs1[1] !== 0) return [NaN, NaN, NaN]; //throw "Can't solve with x in the exponent";

                    //If we don't depend on x, return [0, 0, evalOnce];
                    if (coeffs0[0] === 0 && coeffs0[1] === 0) {
                        return [0, 0, this.evaluator(coeffs0[2], coeffs1[2])]; //optimization for this.evaluateOnce(frame), since we already have our arguments.
                        //This.evaluator is currently BuiltIn.pow()
                    }

                    //Otherwise, only return if exponent is small constant positive integer
                    if (coeffs1[2] === 1) return coeffs0;
                    if (coeffs1[2] === 2) {
                        if (coeffs0[0] !== 0) return [NaN, NaN, NaN]; //throw "Greater than quadratic";
                        return [coeffs0[1] * coeffs0[1], 2 * coeffs0[1] * coeffs0[2], coeffs0[2] * coeffs0[2]];
                    }
            }
            return [NaN, NaN, NaN];
        };

        node.polynomialEvalStrings = function (frame, variable, arg) {
            var coeffs0 = this.args[0].polynomialEvalStrings(frame, variable, arg);
            var coeffs1 = this.args[1].polynomialEvalStrings(frame, variable, arg);
            var order0 = coeffs0.expressions.length - 1;
            var order1 = coeffs1.expressions.length - 1;
            var statements = coeffs0.statements + coeffs1.statements;
            var expressions = [];
            var i, j, term;

            switch (this.operator) {
                case '+':
                case '-':
                    for (i = 0; i <= Math.min(order0, order1); i++) {
                        expressions[i] = '(' + coeffs0.expressions[i] + this.operator + coeffs1.expressions[i] + ')';
                    }
                    for (i = Math.min(order0, order1) + 1; i <= Math.max(order0, order1); i++) {
                        if (this.operator === '+') {
                            expressions[i] = (order0 > order1 ? coeffs0.expressions[i] : coeffs1.expressions[i]);
                        }
                        if (this.operator === '-') {
                            expressions[i] = (order0 > order1 ? coeffs0.expressions[i] : '(-' + coeffs1.expressions[i] + ')');
                        }
                    }
                    return { statements: statements, expressions: expressions };

                case '*':
                    for (i = 0; i <= order0; i++) {
                        for (j = 0; j <= order1; j++) {
                            term = '(' + coeffs0.expressions[i] + '*' + coeffs1.expressions[j] + ')';
                            if (expressions[i + j] === undefined) {
                                expressions[i + j] = term;
                            }
                            else {
                                expressions[i + j] += '+' + term;
                            }
                        }
                    }
                    for (i = 0; i < expressions.length; i++) {
                        expressions[i] = '(' + expressions[i] + ')';
                    }
                    return { statements: statements, expressions: expressions };
                case '/':
                    if (order1 >= 1) throw "can't solve for variable in denominator";
                    for (i = 0; i <= order0; i++) {
                        expressions[i] = '((' + coeffs0.expressions[i] + ')' + '/' + '(' + coeffs1.expressions[0] + '))';
                    }
                    return { statements: statements, expressions: expressions };
                case '^':
                    if (order1 >= 1) throw "can't solve for variable in exponent";
                    //Compute it if the base doesn't depend on the variable
                    if (order0 === 0) return { statements: statements, expressions: ['this.pow(' + coeffs0.expressions[0] + ',' + coeffs1.expressions[0] + ')'] };
                    //Only continue if the exponent is a small, constant, integer.  Figure this out with tree.evaluateOnce(frame).
                    //If we can't evaluate, this will throw and solving will fail
                    var exponent = this.args[1].evaluateOnce(frame);
                    switch (exponent) {
                        case 0:
                            return { statements: '', expressions: ['1'] };
                        case 1:
                            return coeffs1;
                        case 2:
                            for (i = 0; i <= order0; i++) {
                                for (j = 0; j <= order0; j++) {
                                    term = '(' + coeffs0.expressions[i] + '*' + coeffs0.expressions[j] + ')';
                                    if (expressions[i + j] === undefined) {
                                        expressions[i + j] = term;
                                    }
                                    else {
                                        expressions[i + j] += '+' + term;
                                    }
                                }
                            }
                            for (i = 0; i < expressions.length; i++) {
                                expressions[i] = '(' + expressions[i] + ')';
                            }
                            return { statements: statements, expressions: expressions };
                    }
            }
            throw "Unable to compile polyomial representation of BinaryOperatorNode";
        };

        node.polynomialOrder = function (frame, variable) {
            var order0 = this.args[0].polynomialOrder(frame, variable);
            var order1 = this.args[1].polynomialOrder(frame, variable);
            switch (this.operator) {
                case '+':
                case '-':
                    return Math.max(order0, order1);
                case '*':
                    return order0 + order1;
                case '/':
                    if (order1 > 0) return Infinity;
                    return order0;
                case '^':
                    try {
                        var exponent = this.args[1].evaluateOnce(frame);
                        if (exponent !== Math.round(exponent)) return Infinity;
                        if (exponent < 0) return Infinity;
                        return exponent * order0;
                    }
                    catch (e) {
                        return Infinity; //Exponent depends on free variables
                    }
            }
            return Infinity;
        };

        node.okForImplicitFunction = function () {
            return this.args[0].okForImplicitFunction() && this.args[1].okForImplicitFunction();
        };

        var powString = function (base, exponent) {
            var baseString = base.toString();
            var exponentString = exponent.toString();
            if (base instanceof BinaryOperatorNode) {
                baseString = '(' + baseString + ')';
            }
            if (exponent instanceof BinaryOperatorNode) {
                exponentString = '{' + exponentString + '}';
            }
            return baseString + '^' + exponentString;
        };

        var timesString = function (arg1, arg2) {
            var s1 = String(arg1);
            var s2 = String(arg2);
            if (
      arg1 instanceof BinaryOperatorNode &&
      (arg1.operator === '+' || arg1.operator === '-')
    ) {
                s1 = '(' + s1 + ')';
            }
            if (
      arg2 instanceof BinaryOperatorNode &&
      (arg2.operator === '+' || arg2.operator === '-')
    ) {
                s2 = '(' + s2 + ')';
            }
            return s1 + '*' + s2;
        };

        node.toString = function () {
            var base, exponent;
            if (this.operator === '^') return powString(this.args[0], this.args[1]);
            if (this.operator === '/') {
                return '\\frac{' + this.args[0] + '}{' + this.args[1] + '}';
            }
            if (this.operator === '*') return timesString(this.args[0], this.args[1]);
            return this.args[0] + ' ' + this.operator + ' ' + this.args[1];
        };

    });

    var ComparatorNode = exports.ComparatorNode = P(BinaryOperatorNode, function (node, _super) {
        node.init = function (operator, x1, x2) {
            _super.init.call(this, operator, x1, x2);
        };

        node.polynomialOrder = function (frame, variable) {
            var order0 = this.args[0].polynomialOrder(frame, variable);
            var order1 = this.args[1].polynomialOrder(frame, variable);
            return Math.max(order0, order1);
        };

        node.quadraticCoefficients = function (frame, variable) {
            return [NaN, NaN, NaN]; //TODO Not implemented
        };

        node.statementType = COMPARATOR;

    });

    var FunctionNode = exports.FunctionNode = P(ParseNode, function (node, _super) {
        node.init = function (identifier, args) {
            _super.init.call(this);
            this.identifier = identifier;
            this.args = args;
            this.arity = this.args.length;
            this.addDependency(this.identifier.identifier, this.arity);
            for (var i = 0; i < args.length; i++) {
                this.addDependencies(args[i].dependencies());
            }
        };

        node.evaluateOnce = function (frame) {
            if (this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
                return frame.callFunction(this.identifier.identifier,
                                this.args.map(function (arg) { return arg.evaluateOnce(frame) }));
            }
            //We don't have a function.  This could be implicit multiplication instead.
            if (this.args.length === 1 && frame.hasVariable(this.identifier.identifier)) {
                return this.args[0].evaluateOnce(frame) * frame.getVariable(this.identifier.identifier).evaluateOnce(frame);
            }
        };

        node.getEvalStrings = function (frame) {
            if (this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
                var arg_eval_strings = this.args.map(function (a) { return a.getEvalStrings(frame) });
                var arg_expressions = arg_eval_strings.map(function (a) { return a.expression });
                var arg_statements = arg_eval_strings.map(function (a) { return a.statements });
                var statements = arg_statements.join('');
                var expression = 'this.' + this.identifier.identifier + '(' + arg_expressions.join(',') + ')';
                return { expression: expression, statements: statements };
            }
            else {
                var variable_node = IdentifierNode(this.identifier.identifier);
                var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
                return multiplication_node.getEvalStrings(frame);
            }
        };

        node.quadraticCoefficients = function (frame, variable) {
            if (this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
                /*Find polynomial order for each function argument*/
                var arg_orders = this.args.map(function (a) { return a.polynomialOrder(frame, variable) });
                var max_order = Math.max.apply(null, arg_orders);

                //Return static value if no arguments depend on X
                if (max_order === 0) {
                    return [0, 0, this.evaluateOnce(frame)];
                }

                //Return infinity if arguments depend on X, and can't be analyzed
                var fn = frame.getFunctionTree(this.identifier.identifier);
                if (!fn) throw ("Can't solve equations with " + this.identifier.identifier);

                //Create local frame and ask function expression for polynomial order
                var local_frame = EvalFrame(frame);
                for (var i = 0; i < fn.arity; i++) {
                    local_frame.setVariable(fn.args[i].identifier, this.args[i]);
                }
                return fn.expression.quadraticCoefficients(local_frame, variable);
            }
            else { //Implicit multiplication
                var variable_node = IdentifierNode(this.identifier.identifier);
                var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
                return multiplication_node.quadraticCoefficients(frame, variable);
            }
        };

        node.polynomialEvalStrings = function (frame, variable, arg) {
            if (this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
                var arg_strings = this.args.map(function (a) { return a.polynomialEvalStrings(frame, variable, arg) });
                var arg_orders = arg_strings.map(function (x) { return x.expressions.length - 1; });
                var max_order = Math.max.apply(null, arg_orders);

                if (max_order === 0) {
                    var eval_strings = this.getEvalStrings(frame);
                    return { statements: eval_strings.statements, expressions: [eval_strings.expression] };
                }
                //If order is infinity, this shouldn't get called?
                //TODO - deal wih "create local frame" logic from polynomialOrder
            }
            else { //Implicit multiplication
                var variable_node = IdentifierNode(this.identifier.identifier);
                var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
                return multiplication_node.polynomialEvalStrings(frame, variable, arg);
            }
        };

        node.polynomialOrder = function (frame, variable) {
            if (this.arity > 1 || frame.hasFunction(this.identifier.identifier)) {
                /*Find polynomial order for each function argument*/
                var arg_orders = this.args.map(function (a) { return a.polynomialOrder(frame, variable) });
                var max_order = Math.max.apply(null, arg_orders);

                //Return 0 if no arguments depend on X
                if (max_order === 0) {
                    return 0;
                }

                //Return infinity if arguments depend on X, and can't be analyzed
                var fn = frame.getFunctionTree(this.identifier.identifier);
                if (!fn) return Infinity;

                //Create local frame and ask function expression for polynomial order
                //TODO - may not actually support this well yet
                var local_frame = EvalFrame(frame);
                for (var i = 0; i < fn.arity; i++) {
                    local_frame.setVariable(fn.args[i].identifier, this.args[i]);
                }
                return fn.expression.polynomialOrder(local_frame, variable);
            }
            else { //Implicit multiplication
                var variable_node = IdentifierNode(this.identifier.identifier);
                var multiplication_node = BinaryOperatorNode('*', variable_node, this.args[0]);
                return multiplication_node.polynomialOrder(frame, variable);
            }
        };

        node.toString = function () {
            if (this.identifier.identifier === 'sqrt') {
                return this.identifier + '{' + this.args[0] + '}';
            }
            return this.identifier + '(' + this.args.join(', ') + ')';
        };
    });

    var FunctionCallExponentNode = exports.FunctionCallExponentNode = P(ParseNode, function (node, _super) {
        node.init = function (identifier, arg, exponent) {
            _super.init.call(this);
            this.identifier = identifier;
            this.arg = arg;
            this.exponent = exponent;
            this.as_function_node = BinaryOperatorNode('^', FunctionNode(this.identifier, [this.arg]), this.exponent);
            this.as_multiplication_node = BinaryOperatorNode('*', this.identifier, BinaryOperatorNode('^', this.arg, this.exponent));

            this.addDependency(this.identifier.identifier, 1);  //Ambiguous (see note in addDependency)
            this.addDependencies(this.arg.dependencies());
            this.addDependencies(this.exponent.dependencies());
        };

        node.getEquivalentNode = function (frame) {
            if (frame.hasFunction(this.identifier.identifier)) return this.as_function_node;
            return this.as_multiplication_node;
        };

        node.evaluateOnce = function (frame) {
            return this.getEquivalentNode(frame).evaluateOnce(frame);
        };

        node.getEvalStrings = function (frame) {
            return this.getEquivalentNode(frame).getEvalStrings(frame);
        };

        node.polynomialOrder = function (frame, variable) {
            return this.getEquivalentNode(frame).polynomialOrder(frame, variable);
        };

        node.quadraticCoefficients = function (frame, variable) {
            return this.getEquivalentNode(frame).quadraticCoefficients(frame, variable);
        };

        node.polynomialEvalStrings = function (frame, variable, arg) {
            return this.getEquivalentNode(frame).polynomialEvalStrings(frame, variable, arg);
        };

        node.toString = function () {
            return BinaryOperatorNode('^', this.identifier, this.exponent) +
      '\\left(' + this.arg + '\\right)';
        };
    });

    var FunctionDeclarationNode = exports.FunctionDeclarationNode = P(ParseNode, function (node, _super) {
        node.init = function (identifier, args, expression) {
            _super.init.call(this);
            this.assigns = identifier;
            this.referenceSymbol(this.assigns.identifier);
            this.args = args;
            this.arity = this.args.length;
            this.expression = expression;
            this.passed_variables = this.args.map(function (arg) { return arg.identifier });
            var possible_dependencies = this.expression.dependencies();
            for (var id in possible_dependencies) {
                if (!possible_dependencies.hasOwnProperty(id)) { continue; }

                var arity = possible_dependencies[id];
                if (this.passed_variables.indexOf(id) >= 0) {
                    //Identifier is shadowed by arguments.  Make sure it's ok being a variable
                    if (arity > 1) { throw ("Cannot call argument " + id + " as a function") }
                    //Otherwise, don't need to do anything.  It's shadowed, so it's not a dependency
                }
                else {
                    //Not shadowed - becomes a dependency
                    this.addDependency(id, arity);
                }
            }
        };
        node.statementType = FUNCTION_DEFINITION;
        node.exportDefinitionsTo = function (frame) {
            var self = this;
            /*
            frame.setFunction(self.assigns.identifier, self.args.length, function (args, f) {
            var shadow_frame = EvalFrame(frame)
            for (var i = 0; i < self.args.length; i++) {
            shadow_frame.setVariable(self.args[i].identifier, ConstantNode(args[i]));
            }
            return self.expression.evaluateOnce(shadow_frame);
            });
            */
            var evalStrings = self.expression.getEvalStrings(frame);
            var function_source = evalStrings.statements + "return " + evalStrings.expression;
            var function_args = self.args.map(function (a) { return a.identifier });
            var fn = functions.compile(function_args, function_source);
            frame.setFunction(self.assigns.identifier, self.args.length, fn, self, function_args, function_source);
        };

        node.passedVariables = function () {
            return this.passed_variables; //TODO - deleteme
        };

        node.evaluateOnce = function (frame) {
            return "Defines function " + this.assigns.identifier;
        };

        node.getEvalStrings = function (frame) {
            return this.expression.getEvalStrings(frame);
        };

        node.toString = function () {
            return this.assigns + '\\left(' + this.args.join(', ') + '\\right)' +
      ' = ' + this.expression;
        };
    });

    var DerivativeNode = exports.DerivativeNode = P(ParseNode, function (node, _super) {
        node.init = function (variable, expression) {
            _super.init.call(this);
            this.derivative_variable = variable;
            this.expression = expression;
            this.addDependencies(expression.dependencies());
            this.addDependency(variable.identifier, 0);
        };

        node.evaluateOnce = function (frame) {
            var variable = this.derivative_variable;
            var dtree = this.expression.takeDerivative(frame, variable);

            if (!(dtree instanceof DerivativeNode)) {
                return dtree.evaluateOnce(frame);
            }

            var center_point = frame.getVariable(variable.identifier).evaluateOnce(frame);
            var local_frame = EvalFrame(frame);
            var epsilon = 5e-5;

            //Evaluate slightly below
            local_frame.setVariable(variable.identifier, ConstantNode(center_point - epsilon));
            var val0 = this.expression.evaluateOnce(local_frame);
            //Evaluate slightly above
            local_frame.setVariable(variable.identifier, ConstantNode(center_point + epsilon));
            var val1 = this.expression.evaluateOnce(local_frame);
            //Divide by dx and return
            return (val1 - val0) / (2 * epsilon);
        };

        node.getEvalStrings = function (frame) {
            var variable = this.derivative_variable;
            var dtree = this.expression.takeDerivative(frame, variable);

            if (!(dtree instanceof DerivativeNode)) {
                return dtree.getEvalStrings(frame);
            }

            var derivative = this.tmp();
            var variable_value = this.tmp();
            var epsilon = '(5e-5)';
            var high_value = this.tmp();
            var low_value = this.tmp();

            //Get and store value of the differentiation variable
            var variable_value_strings = variable.getEvalStrings(frame);
            var initialize = variable_value_strings.statements + 'var ' + variable_value + '=' + variable_value_strings.expression + ';';

            //Compile expression
            var expression_strings = this.expression.getEvalStrings(frame);

            var sample_low = variable.identifier + '=' + variable_value + '-' + epsilon + ';' +
                      expression_strings.statements +
                      'var ' + low_value + '=' + expression_strings.expression + ';';

            var sample_high = variable.identifier + '=' + variable_value + '+' + epsilon + ';' +
                      expression_strings.statements +
                      'var ' + high_value + '=' + expression_strings.expression + ';';

            //Compute the derivative from that
            var divide = 'var ' + derivative + '=(' + high_value + '-' + low_value + ')/(2*' + epsilon + ');';

            //Reset the value of the initial variable, in case someone was using it
            var cleanup = variable.identifier + '=' + variable_value + ';';

            var statements = initialize + sample_low + sample_high + divide + cleanup;
            return { expression: derivative, statements: statements };
        };

        node.toString = function () {
            return '\\frac{d}{d' + this.derivative_variable + '}' +
      '\\left(' + this.expression + '\\right)';
        };
    });

    var RepeatedOperatorNode = exports.RepeatedOperatorNode = P(ParseNode, function (node, _super) {
        node.init = function (index, lower_bound, upper_bound, summand) {
            _super.init.call(this);
            this.index = index;
            this.lower_bound = lower_bound;
            this.upper_bound = upper_bound;
            this.summand = summand;
            this.addDependencies(this.lower_bound.dependencies());
            this.addDependencies(this.upper_bound.dependencies());
            this.addDependencies(this.summand.dependencies());
            this.shadowVariable(this.index.identifier); //TODO - make sure we're tracking this the same we we track assignments
        };

        node.evaluateOnce = function (frame) {
            var local_frame = EvalFrame(frame);
            var lower = Math.round(this.lower_bound.evaluateOnce(frame));
            var upper = Math.round(this.upper_bound.evaluateOnce(frame));
            var total = this.starting_value;
            if (!isFinite(upper - lower)) {
                total = (upper < lower ? this.starting_value : NaN);
            }
            else {
                for (var i = lower; i <= upper; i++) {
                    local_frame.setVariable(this.index.identifier, ConstantNode(i));
                    total = this.fn(total, this.summand.evaluateOnce(local_frame)); //Addition or multiplication
                }
            }
            return total;
        };

        node.getEvalStrings = function (frame) {
            var sum = this.tmp();
            var index = this.index.identifier;
            var lower_bound = this.tmp();
            var upper_bound = this.tmp();

            var lower_bound_strings = this.lower_bound.getEvalStrings(frame);
            var upper_bound_strings = this.upper_bound.getEvalStrings(frame);
            var summand_strings = this.summand.getEvalStrings(frame);

            var set_lower_bound = lower_bound_strings.statements + 'var ' + lower_bound + ' = Math.round(' + lower_bound_strings.expression + ');';
            var set_upper_bound = upper_bound_strings.statements + 'var ' + upper_bound + ' = Math.round(' + upper_bound_strings.expression + ');';
            var initialize_sum = 'var ' + sum + '=' + this.starting_value + ';';
            var loop = 'for (var ' + index + '=' + lower_bound + ';' + index + '<=' + upper_bound + ';' + index + '++) {' + summand_strings.statements + sum + this.in_place_operator + summand_strings.expression + '};';

            var protected_loop = 'if(!isFinite(' + upper_bound + '-' + lower_bound + ')) {' + sum + '=(' + upper_bound + '<' + lower_bound + '?' + this.starting_value + ':NaN);}else{' + loop + '}';

            return { expression: sum, statements: set_lower_bound + set_upper_bound + initialize_sum + protected_loop };
        };

    });

    var SummationNode = exports.SummationNode = P(RepeatedOperatorNode, function (node, _super) {
        node.init = function (index, lower_bound, upper_bound, summand) {
            _super.init.call(this, index, lower_bound, upper_bound, summand);
        };

        node.starting_value = 0;
        node.in_place_operator = '+=';
        node.fn = function (a, b) { return a + b; };

        node.toString = function () {
            return '\\sum_{' + this.index + '=' + this.lower_bound + '}' +
      '^{' + this.upper_bound + '} ' + this.summand;
        };
    });

    var ProductNode = exports.ProductNode = P(RepeatedOperatorNode, function (node, _super) {
        node.init = function (index, lower_bound, upper_bound, summand) {
            _super.init.call(this, index, lower_bound, upper_bound, summand);
        };

        node.starting_value = 1;
        node.in_place_operator = '*=';
        node.fn = function (a, b) { return a * b; };

        node.toString = function () {
            return '\\prod_{' + this.index + '=' + this.lower_bound + '}' +
      '^{' + this.upper_bound + '} ' + this.summand;
        };
    });

    var OrderedPairListNode = exports.OrderedPairListNode = P(ParseNode, function (node, _super) {
        node.init = function (elements) {
            _super.init.call(this);
            this.elements = elements;

            for (var i = 0; i < elements.length; i++) {
                this.addDependencies(elements[i].dependencies());
            }
        };

        node.evaluateOnce = function (frame) {
            return this.elements.map(function (x) { return x.evaluateOnce(frame) });
        };

        node.getEvalStrings = function (frame) {
            var statements = '';
            var expression = '[';
            for (var i = 0; i < this.elements.length; i++) {
                var element_strings = this.elements[i].getEvalStrings(frame);
                statements += element_strings.statements;
                expression += element_strings.expression;
                if (i < this.elements.length - 1) this.expression += ',';
            }
            expression += ']';
            return { statements: statements, expression: expression };
        };

        node.toString = function () {
            return '\\left(' + this.elements.join(', ') + '\\right)';
        };

        node.statementType = ORDERED_PAIR_LIST;
    });

    //Copy all ParseNodes from exports onto yy.latex
    for (var node in exports) {
        if (exports.hasOwnProperty(node)) latex.yy[node] = exports[node];
    }

    /* This function takes the entire function declaration as a single lexed token and parses with a regexp,
    * to keep the overall grammar context-free and LALR(1)-parseable.
    * TODO - generate this once, not every time we parse a function declaration */
    latex.yy.parseFunctionDeclaration = function (declaration_string) {
        declaration_string = declaration_string.replace('###', '');  //Strip off start-of-line marker
        var whitespace_pattern =  //Non-capturing latex whitespace pattern
     "(?:\\s|\\\\space|\\\\\\:)*";
        //   \s   \\space  \\ \ :
        var id_body_pattern = //Non-capturing latex identifier pattern
     "(?:[a-zA-Z]|\\\\[a-zA-Z]+)";
        var id_subscript_pattern = //Non-capturing latex subscript pattern
     "(?:_[a-zA-Z0-9]|_{[a-zA-Z0-9]+})?";
        var id_pattern = id_body_pattern + id_subscript_pattern;

        var arglist_pattern = //Non-capturing comma-separated list of identifiers in whitespace-free string
    "(?:" + id_pattern + "(?:\\," + id_pattern + ")*)";

        var declaration_pattern = //Captures function name as first group, and arglist as second group
    "(" + id_pattern + ")" + "(?:\\\\left)?\\((" + arglist_pattern + ")(?:\\\\right)?\\)=";

        var declaration_regexp = new RegExp(declaration_pattern);
        var whitespace_regexp = new RegExp(whitespace_pattern, "g"); //Want "g" flag to ensure global capturing of whitespace
        declaration_string = declaration_string.replace(whitespace_regexp, '');
        var match = declaration_regexp.exec(declaration_string);

        return {
            identifier: IdentifierNode(match[1]),
            args: match[2].split(',').map(IdentifierNode), //match[1] is the argument list.  Split it on commas, and create an IdentifierNode from each one
            input_string: declaration_string.split('=')[0]        //input_string is used for constructing function tables.  We want to strip the equality off the end
        };
    };

    //This code over-rides latex.parse with a version that prepends a line-start marker
    exports.parse = function (input) {
        return latex.parse("###" + input);
    };

    exports.tryParse = function (input) {
        try {
            var tree = exports.parse(input);
            return tree;
        }
        catch (e) {
            return ErrorNode(e);
        }
    };

    latex.yy.setInput = function (node, range) {
        node.setInputString(latex.yy.lexer.matched.slice(Math.max(3, range.first_column), range.last_column)); //Don't ever show the '###' mark we insert to mark the start of the string
    };

    latex.yy.parseError = function (err, hash) {
        throw ("Sorry - I don't understand.  Maybe try something simpler or check the help?");
    };

    return exports;
});

//Definition of built-in functions and variables

define('math/builtin', ['require', './evalframe', './parser_util', './inverses', './functions'], function (require) {
    var EvalFrame = require('./evalframe');
    var Parser = require('./parser_util');
    var inverses = require('./inverses');
    var functions = require('./functions');


    var ConstantNode = Parser.ConstantNode;

    var BuiltIn = {
        getFrame: function () {
            if (BuiltIn.frame) {
                return BuiltIn.frame;
            }

            BuiltIn.frame = EvalFrame();

            BuiltIn.frame.setVariable('pi', ConstantNode(Math.PI));
            BuiltIn.frame.setEvalStrings('pi', { expression: String(Math.PI), statements: '' });
            BuiltIn.frame.setVariable('tau', ConstantNode(2 * Math.PI));
            BuiltIn.frame.setEvalStrings('tau', { expression: String(2 * Math.PI), statements: '' });
            BuiltIn.frame.setVariable('e', ConstantNode(Math.E));
            BuiltIn.frame.setEvalStrings('e', { expression: String(Math.E), statements: '' });

            //Trig functions
            BuiltIn.registerTrig('sin', BuiltIn.sin, Math.asin);
            BuiltIn.registerTrig('cos', BuiltIn.cos, Math.acos);
            BuiltIn.registerTrig('tan', BuiltIn.tan, Math.atan);
            BuiltIn.registerTrig('cot', BuiltIn.cot, BuiltIn.acot);
            BuiltIn.registerTrig('sec', BuiltIn.sec, BuiltIn.asec);
            BuiltIn.registerTrig('csc', BuiltIn.csc, BuiltIn.acsc);

            //Hyperbolic trig functions
            BuiltIn.registerHyperbolicTrig('sinh', BuiltIn.sinh, BuiltIn.asinh);
            BuiltIn.registerHyperbolicTrig('cosh', BuiltIn.cosh, BuiltIn.acosh);
            BuiltIn.registerHyperbolicTrig('tanh', BuiltIn.tanh, BuiltIn.atanh);
            BuiltIn.registerHyperbolicTrig('coth', BuiltIn.coth, BuiltIn.acoth);
            BuiltIn.registerHyperbolicTrig('sech', BuiltIn.sech, BuiltIn.asech);
            BuiltIn.registerHyperbolicTrig('csch', BuiltIn.csch, BuiltIn.acsch);

            BuiltIn.frame.setFunction('pow', 2, BuiltIn.pow);
            BuiltIn.frame.setFunction('sqrt', 1, Math.sqrt);
            BuiltIn.frame.setFunction('nthroot', 2, BuiltIn.nthroot);
            BuiltIn.frame.setFunction('log', 2, BuiltIn.log_base);
            BuiltIn.frame.setFunction('exp', 1, Math.exp);

            BuiltIn.frame.setFunction('floor', 1, Math.floor);
            BuiltIn.frame.setFunction('ceil', 1, Math.ceil);
            BuiltIn.frame.setFunction('round', 1, Math.round);
            BuiltIn.frame.setFunction('abs', 1, Math.abs);
            BuiltIn.frame.setFunction('mod', 2, BuiltIn.mod);
            BuiltIn.frame.setFunction('max', 2, BuiltIn.max);
            BuiltIn.frame.setFunction('min', 2, BuiltIn.min);
            BuiltIn.frame.setFunction('sign', 1, BuiltIn.sign);

            BuiltIn.frame.setFunction('lcm', 2, BuiltIn.lcm);
            BuiltIn.frame.setFunction('gcd', 2, BuiltIn.gcd);
            BuiltIn.frame.setFunction('nCr', 2, BuiltIn.nCr);
            BuiltIn.frame.setFunction('nPr', 2, BuiltIn.nPr);
            BuiltIn.frame.setFunction('factorial', 1, BuiltIn.factorial);
            BuiltIn.frame.setFunction('polyGamma', 2, BuiltIn.polyGamma);

            var fn_map = BuiltIn.frame.functionMap();
            for (var name in fn_map) {
                if (fn_map.hasOwnProperty(name)) functions.register(name, fn_map[name]);
            }

            return BuiltIn.frame;
        },

        angleMultiplier: 1,

        setDegreeMode: function (on) {
            BuiltIn.angleMultiplier = (on ? (2 * Math.PI / 360.0) : 1);
        },

        //Register forward and inverse trig functions
        registerTrig: function (name, fn, fn_inverse) {
            BuiltIn.frame.setFunction(name, 1, function (x) { return fn(x * BuiltIn.angleMultiplier) });
            BuiltIn.frame.setFunction(inverses[name], 1, function (x) { return fn_inverse(x) / BuiltIn.angleMultiplier });
        },

        //Register forward and inverse hyperbolic trig functions
        registerHyperbolicTrig: function (name, fn, fn_inverse) {
            BuiltIn.frame.setFunction(name, 1, fn);
            BuiltIn.frame.setFunction(inverses[name], 1, fn_inverse);
        }

    };

    BuiltIn.mod = function (a, b) {
        return a - b * Math.floor(a / b);
    };

    BuiltIn.min = function (a, b) {
        return (a < b) ? a : b;
    };

    BuiltIn.max = function (a, b) {
        return (a > b) ? a : b;
    };

    BuiltIn.sign = function (x) {
        if (x === 0) return 0;
        if (x > 0) return 1;
        if (x < 0) return -1;
        return NaN;
    };

    BuiltIn.lcm = function (a, b) {
        a = BuiltIn.smartTruncate(a);
        b = BuiltIn.smartTruncate(b);
        var gcd = BuiltIn.getGCD(a, b);
        return Math.abs(a * b / gcd);
    };

    BuiltIn.gcd = function (a, b) {
        return BuiltIn.getGCD(a, b);
    };

    BuiltIn.nCr = function (n, r) {
        n = BuiltIn.smartTruncate(n);
        r = BuiltIn.smartTruncate(r);

        //Error conditions
        if (r > n || n < 0 || r < 0) {
            return 0;
        }

        var total = 1;
        for (var i = 0; i < r; i++) {
            total *= (n - i) / (i + 1);
        }
        return total;
    };

    BuiltIn.nPr = function (n, r) {
        n = BuiltIn.smartTruncate(n);
        r = BuiltIn.smartTruncate(r);

        //Error conditions
        if (r > n || n < 0 || r < 0) {
            return 0;
        }

        var total = 1;
        for (var i = 0; i < r; i++) {
            total *= (n - i);
        }
        return total;
    };

    BuiltIn.factorial = function (x) {
        return BuiltIn.gamma(x + 1);
    };

    BuiltIn._integerFactorial = function (n) {
        if (n !== Math.floor(n)) return NaN;
        if (n < 0) return NaN;
        if (n > 170) return NaN; // Overflows double point floats
        if (n === 0 || n === 1) return 1;

        var output = 1;
        for (var i = 2; i <= n; i++) output *= i;

        return output;
    };

    BuiltIn.gamma = function (x) {
        if (x === Math.floor(x)) return BuiltIn._integerFactorial(x - 1);
        // Euler's reflection formula
        if (x < 0) return Math.PI / (Math.sin(Math.PI * x) * BuiltIn.gamma(1 - x));
        return Math.exp(BuiltIn.lnGamma(x));
    };

    BuiltIn.lnGamma = function (x) {
        if (x < 0) return NaN; // Alternates between real and complex on integers.

        // 15 term rational approximation of lnGamma, valid for positive numbers.
        // Original source not known, but verified by JM using Mathematica to give
        // at least 14 correct digits of gamma = Math.exp(Math.lnGamma(x)) for
        // integers and half integers between 0 and 60, and at least 12 correct
        // digits up to 170.
        var cof = [
    57.1562356658629235,
    -59.5979603554754912,
    14.1360979747417471,
    -0.491913816097620199,
    0.339946499848118887e-4,
    0.465236289270485756e-4,
    -0.983744753048795646e-4,
    0.158088703224912494e-3,
    -0.210264441724104883e-3,
    0.217439618115212643e-3,
    -0.164318106536763890e-3,
    0.844182239838527433e-4,
    -0.261908384015814087e-4,
    0.368991826595316234e-5
  ];

        var s = 0.999999999999997092;
        for (var i = 0; i < 14; i++) s += cof[i] / (x + i + 1);

        var t = x + 5.24218750000000000;

        return (x + 0.5) * Math.log(t) - t + Math.log(2.5066282746310005 * s / x);
    };

    // BernoulliB_{2k} for k=1..14
    BuiltIn.bernoulliTable = [
  1 / 6, -1 / 30, 1 / 42, -1 / 30, 5 / 66, -691 / 2730, 7 / 6, -3617 / 510,
  43867 / 798, -174611 / 330, 854513 / 138, -236364091 / 2730, 8553103 / 6,
  -23749461029 / 870
];

    // mth derivative of cot(x)
    //
    // Used in evaluating reflection formula for polygamma
    //
    // Uses fact that (d/dx)^m cot(x) = p_m(cos(x))/sin(x)^{m+1} where p_m(x) is a
    // polynomial with coefficents that obey the following recursion relation:
    //
    // a_{m+1, n} = -((m - n + 2) a_{m, n-1} + (n+1) a_{m, n+1})
    //            = -(            t1         +        t2       )
    // a_{0, 0} = 0, a_{0, 1} = 1
    //
    // Could improve performance by taking advantage of fact that p is even/odd
    // when m is odd/even. Didn't feel worth the added trickiness.
    BuiltIn.cotDerivative = function (m, x) {
        if (m !== Math.floor(m)) return NaN;
        if (m < 0) return NaN;

        if (m === 0) return 1 / BuiltIn.tan(x);

        var sinx = BuiltIn.sin(x);
        if (m === 1) return -1 / (sinx * sinx);

        var cosx = BuiltIn.cos(x);
        if (m === 2) return 2 * cosx / (sinx * sinx * sinx);

        var aprev = [0, 2];
        var a;
        var mp, n;
        var t1, t2;
        for (mp = 3; mp <= m; mp++) {
            a = [];
            for (n = 0; n < mp; n++) {
                t1 = 0;
                t2 = 0;
                if (n > 0) t1 = (mp - n + 1) * aprev[n - 1];
                if (n + 2 < mp) t2 = (n + 1) * aprev[n + 1];
                a.push(-(t1 + t2));
            }
            aprev = a;
        }

        var s = 0;
        // Horner's method for polynomial evaluation
        for (n = m - 1; n >= 0; n--) s = a[n] + cosx * s;

        return s / Math.pow(sinx, m + 1);
    };

    // polyGamma(m, n) is the (m+1)th derivative of lnGamma(n)
    //
    // Implemented by differentiating Stirling's approximation:
    //
    // d/dn ln(Gamma(n)) = -\left(
    //         ln(n) + 1/2n + \sum_{k=1}^{\infty} B_{2k}/(2k n^{2k})
    //       /right)
    //
    // d^{m+1}/dn^{m+1} ln(Gamma(n)) =
    //      m! (-1)^{m + 1} \left(
    //        1/(m n^m) - 1/(2 n^{1+m}) +
    //        \sum_{k=1}^{\infty} B_{2k} (2k + m - 1)!/(m!(2k)!n^{2k+m})
    //      \right)
    //
    // B_{2k} are the Bernoulli numbers.
    //
    // Uses recurrence relation to bring arguments above 10, and reflection
    // formula for negative n. In this case, 14 term sum gives results accurate to // machine precision for values of m between 0 and at least 8.
    //
    // Only get 8 digits for polyGamma(100, 30)
    //
    // Recurrence relation:
    //
    // polyGamma(m, n) = polyGamma(m, n + 1) + (-1)^m m!/n^{m+1}
    //
    // Reflection formula:
    //
    // polyGamma(m, n) = (-1)^{m}polyGamma(m, 1 - n) - pi d^m/dn^m cot(pi*n)
    //
    // Can lose some accuracy in reflection formula for large m because of large
    // powers of trig functions.
    BuiltIn.polyGamma = function (m, n) {
        if (m < 0) return NaN;
        if (m !== Math.floor(m)) return NaN;
        var sign = (m % 2 === 0) ? -1 : 1;
        // Use reflection formula for negative n
        if (n < 0) {
            return -sign * BuiltIn.polyGamma(m, 1 - n) -
      Math.pow(Math.PI, m + 1) * BuiltIn.cotDerivative(m, Math.PI * n);
        }

        var mfac = BuiltIn.factorial(m);

        // Use recurrence relation to bring n above 10
        var s = 0;
        var npmm = Math.pow(n, -(m + 1));
        while (n < 10) {
            s += npmm;
            n++;
            npmm = Math.pow(n, -(m + 1));
        }

        s += (m === 0) ? -Math.log(n) : npmm * n / m;
        s += 0.5 * npmm;

        var bt = BuiltIn.bernoulliTable;
        var num = m + 1;
        var denom = 2;
        var pre = npmm * n * num / denom;
        var nsqinv = 1 / (n * n);
        for (var k = 1; k <= 14; k++) {
            pre *= nsqinv;
            s += pre * bt[k - 1];
            num++; denom++;
            pre *= num / denom;
            num++; denom++;
            pre *= num / denom;
        }
        return mfac * sign * s;
    };

    BuiltIn.getGCD = function (x, y) {
        //Only defined over integers
        var a = BuiltIn.smartTruncate(x);
        var b = BuiltIn.smartTruncate(y);

        // Positive values only
        if (a < 0)
            a = -a;
        if (b < 0)
            b = -b;

        // Reverse order if necessary.
        // b should be smaller than a
        if (b > a) {
            var temp = b;
            b = a;
            a = temp;
        }

        //GCD(0, x) = x
        if (b === 0) {
            return a;
        }

        var m = a % b;

        while (m > 0) {
            a = b;
            b = m;
            m = a % b;
        }

        return b;
    };

    // Returns a reduced fraction approximation of x with denominator less than
    // maxDenominator. maxDenominator defaults to 1e6.
    BuiltIn.toFraction = function (x, maxDenominator) {

        if (x === Infinity) return { n: Infinity, d: 1 };
        if (x === -Infinity) return { n: -Infinity, d: 1 };
        if (!isFinite(x)) return { n: NaN, d: 1 };

        var whole, n0 = 0, n1 = 1, d0 = 1, d1 = 0, n, d;
        if (!maxDenominator) maxDenominator = 1e6;
        while (true) {
            whole = Math.floor(x);
            n = whole * n1 + n0;
            d = whole * d1 + d0;
            if (d > maxDenominator) break;
            n0 = n1;
            d0 = d1;
            n1 = n;
            d1 = d;
            if (x === whole) break;
            x = 1 / (x - whole);
        }
        return { n: n1, d: d1 };
    };

    // Check if two values are equal to within the given number of bits of
    // precision. For numbers smaller than one, compares the difference in the
    // numbers to 1 instead of the larger of the numbers. This makes calculations like
    // BuiltIn.approx(Math.sin(Math.Pi), 0) work out.
    BuiltIn.approx = function (x1, x2, bits) {
        var m = Math.max(Math.max(Math.abs(x1), Math.abs(x2)), 1);
        var d = (bits === undefined) ? 0.5 : Math.pow(0.5, bits);
        return m === m + d * Math.abs(x2 - x1);
    };

    BuiltIn.smartTruncate = function (x) {
        if (x < 0) {
            return Math.ceil(x);
        } else {
            return Math.floor(x);
        }
    };

    BuiltIn.log_base = function (n, base) { return Math.log(n) / Math.log(base) };

    BuiltIn.pow = function (x, n) {
        if (x >= 0 || n === Math.floor(n)) return Math.pow(x, n);
        var frac = BuiltIn.toFraction(n, 100);
        if (frac.n / frac.d === n && frac.d % 2 === 1) return (frac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, n);
        return NaN;
    };
    BuiltIn.nthroot = function (x, n) { return BuiltIn.pow(x, 1 / n) };

    var PI_INV = 1 / Math.PI;

    //Trig functions
    BuiltIn.sin = function (x) {
        if (2 * PI_INV * x % 2 === 0) return 0;
        return Math.sin(x);
    };

    BuiltIn.cos = function (x) {
        if (Math.abs(2 * PI_INV * x % 2) === 1) return 0;
        return Math.cos(x);
    };

    BuiltIn.tan = function (x) {
        if (2 * PI_INV * x % 2 === 0) return 0;
        if (Math.abs(2 * PI_INV * x % 2) === 1) return Infinity;
        return Math.tan(x);
    };

    BuiltIn.sec = function (x) {
        if (Math.abs(2 * PI_INV * x % 2) === 1) return Infinity;
        return 1 / Math.cos(x);
    };

    BuiltIn.csc = function (x) {
        if (2 * PI_INV * x % 2 === 0) return Infinity;
        return 1 / Math.sin(x);
    };

    BuiltIn.cot = function (x) {
        if (2 * PI_INV * x % 2 === 0) return Infinity;
        if (Math.abs(2 * PI_INV * x % 2) === 1) return 0;
        return 1 / Math.tan(x);
    };

    //Inverse trig functions
    BuiltIn.acot = function (x) { return Math.PI / 2 - Math.atan(x) };
    BuiltIn.acsc = function (x) { return Math.asin(1 / x) };
    BuiltIn.asec = function (x) { return Math.acos(1 / x) };

    //Hyperbolic trig functions
    BuiltIn.sinh = function (x) { return (Math.exp(x) - Math.exp(-x)) / 2 };
    BuiltIn.cosh = function (x) { return (Math.exp(x) + Math.exp(-x)) / 2 };
    BuiltIn.tanh = function (x) {
        // This definition avoids overflow of sinh and cosh for large x
        if (x > 0) {
            return (1 - Math.exp(-2 * x)) / (1 + Math.exp(-2 * x));
        } else {
            return (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
        }
    };

    BuiltIn.sech = function (x) { return 1 / BuiltIn.cosh(x) };
    BuiltIn.csch = function (x) { return 1 / BuiltIn.sinh(x) };
    BuiltIn.coth = function (x) { return 1 / BuiltIn.tanh(x) };

    //Inverse hyperbolic trig functions
    BuiltIn.asinh = function (x) { return Math.log(x + Math.sqrt(x * x + 1)) };
    BuiltIn.acosh = function (x) { return Math.log(x + Math.sqrt(x + 1) * Math.sqrt(x - 1)) };
    BuiltIn.atanh = function (x) { return 0.5 * Math.log((1 + x) / (1 - x)) };

    BuiltIn.asech = function (x) { return Math.log(1 / x + Math.sqrt((1 / x + 1)) * Math.sqrt((1 / x - 1))) };
    BuiltIn.acsch = function (x) { return Math.log(1 / x + Math.sqrt((1 / (x * x) + 1))) };
    BuiltIn.acoth = function (x) { return 0.5 * Math.log((x + 1) / (x - 1)) };

    BuiltIn.getFrame();

    return BuiltIn;
});

define('graphing/poi', [], function () {

    // This is a very coupled class. It should be used along side GraphSketch.
    function POI(x, y, type, sketch, branch) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.sketch = sketch;
        this.branch = branch;
    }

    POI.prototype.getGraphMode = function () {
        return this.sketch.branches[this.branch].graphMode;
    };

    POI.prototype.getCompiledFunction = function () {
        return this.sketch.branches[this.branch].compiled.fn;
    };

    POI.prototype.isOpen = function () {
        return this.sketch.openPOI.indexOf(this) >= 0;
    };

    POI.prototype.close = function () {
        var index = this.sketch.openPOI.indexOf(this);
        if (index === -1) return false;

        this.sketch.openPOI.splice(index, 1);
        return true;
    };

    POI.prototype.open = function () {
        if (this.isOpen()) return false;

        this.sketch.openPOI.push(this);
        return true;
    };

    return POI;
});

// Helper functions for computing distance.
//
// The name of this should probably be changed, once we learn what other
// kinds of things we're including here.

define('math/distance', ['require'], function (require) {

    var Distance = {
        // sqrt(x^2 + y^2), computed to avoid overflow and underflow.
        // http://en.wikipedia.org/wiki/Hypot
        hypot: function (x, y) {
            if (x === 0 && y === 0) {
                return 0;
            }
            if (Math.abs(x) > Math.abs(y)) {
                return Math.abs(x) * Math.sqrt((y / x) * (y / x) + 1);
            } else {
                return Math.abs(y) * Math.sqrt((x / y) * (x / y) + 1);
            }
        },

        // (x1 + x2)/2, computed to avoid overflow.
        mean: function (x1, x2) {
            return ((x1 > 0) === (x2 > 0)) ? x1 + 0.5 * (x2 - x1) : 0.5 * (x1 + x2);
        },

        dot: function (x1, y1, x2, y2) {
            return x1 * x2 + y1 * y2;
        },

        // Consider the line extending the segment, parameterized as
        // v1 + t (v2 - v1), where p, v1, and v2 are (xp, yp), (x1, y1), and
        // (x2, y2) respectively.
        //
        // Return the value of the parameter t for the projected point of p onto
        // the line through the segment.
        //
        // It falls where t = [(p-v) . (w-v)] / |w-v|^2
        //
        // Returns 0 in the degenerate case where v1 === v2.
        pointToSegmentParameter: function (xp, yp, x1, y1, x2, y2) {
            var line_length = this.hypot(x2 - x1, y2 - y1);

            // Degenerate case of a point to a point
            if (line_length === 0) return 0;

            var t = this.dot(
      (xp - x1) / line_length,
      (yp - y1) / line_length,
      (x2 - x1) / line_length,
      (y2 - y1) / line_length
    );

            return t;
        },

        closestPointOnSegment: function (xp, yp, x1, y1, x2, y2) {
            var t = this.pointToSegmentParameter(xp, yp, x1, y1, x2, y2);

            if (t <= 0) return [x1, y1];
            if (t >= 1) return [x2, y2];
            return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
        },

        // Shortest distance from a point to a line segment
        // http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
        pointToSegment: function (xp, yp, x1, y1, x2, y2) {
            var p = this.closestPointOnSegment(xp, yp, x1, y1, x2, y2);
            return this.hypot(xp - p[0], yp - p[1]);
        }
    };

    return Distance;
});

define('graphing/graphsketch', ['./poi', 'math/enums', 'math/distance'], function (POI, enums, Distance) {

    function GraphSketch(branches, color, visible, showPOI, showHighlight) {

        // mutable properties
        this.color = color !== undefined ? color : '#000000';
        this.visible = visible !== undefined ? visible : true;
        this.showPOI = showPOI !== undefined ? showPOI : false;
        this.showHighlight = showHighlight !== undefined ? showHighlight : false;
        this.openPOI = []; // the points that are opened and visible
        this.hiddenOpenPOI = []; // the points that were opened previously,
        // but not mapped to screen any longer.
        // immutable properties
        this.branches = branches !== undefined ? branches : [];
    }

    // looks inside the branches and finds POI. Only needs to do this
    // once because branches are immutable. This caches the results. Also
    // note that this implementation postpones the conversion from one
    // large array of numbers to array of objects until someone actually
    // cares about this graphsketch's poi.
    GraphSketch.prototype.getPOI = function () {

        if (this.__cachedPOI) return this.__cachedPOI;

        var branch, graphMode;
        this.__cachedPOI = [];
        for (var i = 0; i < this.branches.length; i++) {
            branch = this.branches[i];
            graphMode = branch.graphMode;
            if (!(graphMode === GRAPHMODE_X || graphMode === GRAPHMODE_Y)) continue;

            var pois = branch.poi;
            this._pushPOI(pois.zeros, i, POI_ZERO);
            this._pushPOI(pois.intercept, i, POI_INTERCEPT);
            this._pushPOI(pois.extrema, i, POI_EXTREMUM);
            if (pois.intersections) {
                this._pushPOI(pois.intersections, i, POI_INTERSECTION);
            }
        }

        return this.__cachedPOI;
    };

    GraphSketch.prototype._pushPOI = function (pois, i, type) {
        for (var j = 0, plen = pois.x.length; j < plen; j++) {

            var poi = new POI();
            poi.type = type;
            poi.x = pois.x[j];
            poi.y = pois.y[j];
            poi.branch = i;
            poi.sketch = this;
            if (pois.intersects) poi.intersects = pois.intersects[j];

            this.__cachedPOI.push(poi);
        }
    };

    GraphSketch.prototype.updateIntersections = function (intersections) {
        for (var i = 0, ilen = this.branches.length; i < ilen; i++) {
            this.branches[i].poi.intersections = intersections[i];
        }
        this.__cachedPOI = undefined;
        this.getPOI();
        this.reopenPOIFrom(this);
    };

    GraphSketch.prototype.updateFrom = function (sketch) {
        if (!sketch) return;

        this.visible = true;

        if (sketch.openPOI.length || sketch.hiddenOpenPOI.length) {
            this.reopenPOIFrom(sketch);
        }

        this.showPOI = sketch.showPOI;
        this.showHighlight = sketch.showHighlight;
    };

    // TODO - change all the cryptic variable names to meaningful names
    GraphSketch.prototype.reopenPOIFrom = function (sketch) {
        var openPOI = [];
        var hiddenOpenPOI = [];
        var pois, new_dom, new_pt, n_pts, min, n_j, n_p, o_pt, n_pt;
        var i_poi, o_poi, t_poi, poi, poi_type;
        var i, j;

        var newPoints = {};
        var oldPoints = {};

        // categorize all new poi
        pois = this.getPOI();

        for (i = 0; i < pois.length; i++) {
            poi = pois[i];
            poi_type = poi.type;

            if (!newPoints[poi_type]) {
                newPoints[poi_type] = [poi];
            } else {
                newPoints[poi_type].push(poi);
            }

        }

        // categorize all old poi
        pois = sketch.openPOI.concat(sketch.hiddenOpenPOI);
        for (i = 0; i < pois.length; i++) {
            poi = pois[i];
            poi_type = poi.type;

            if (!oldPoints[poi_type]) {
                oldPoints[poi_type] = [poi];
            } else {
                oldPoints[poi_type].push(poi);
            }

        }

        // reopen the new points that were closest to the old opened points
        for (var type in oldPoints) {
            t_poi = oldPoints[type];
            n_pts = newPoints[type] || [];

            for (i = t_poi.length - 1; i >= 0; i--) {
                o_pt = t_poi[i];
                min = Infinity;
                n_j = -1;

                for (j = n_pts.length - 1; j >= 0; j--) {
                    n_pt = n_pts[j];
                    if (!n_pt) continue;
                    // Don't allow intersections to jump between functions.
                    if (n_pt.intersects !== o_pt.intersects) continue;

                    dis = Distance.hypot(o_pt.x - n_pt.x, o_pt.y - n_pt.y);
                    if (dis < min) {
                        n_j = j;
                        min = dis;
                    }
                }

                if (n_j != -1) {
                    openPOI.push(n_pts[n_j]); // open the poi again
                    n_pts[n_j] = null;
                } else {
                    hiddenOpenPOI.push(o_pt); // mark point as opened but not mapped to screen
                }
            }
        }

        this.openPOI = openPOI;
        this.hiddenOpenPOI = hiddenOpenPOI;
    };

    return GraphSketch;
});

// Utilites for finding and refining points of interest in samled functions.
//
// bisect* are low level functions take endpoints and a function, and return
// a single [x, f(x)] pair, where f is the function that was passed in, or
// null if a non-finite value of the function is encountered during
// evaluation. These methods have preconditions on the endpoints that callers
// are expected to enforce (because they are called recursively). They bisect
// to machine precision.
//
// find* are higher level. They take an array of segments and a function.
// Each segment is an array of points representing a polyline that
// approximates the function over a range where the function is expected to be
// continuous. No more than one zero and one extremum will be returned between
// individual point pairs in the segments list.
//
// findPOIs collects the results of all the find* methods together.


define('math/poi', ['require', './distance', './builtin'], function (require) {
    var Distance = require('./distance');
    var BuiltIn = require('./builtin');

    // floatMiddle is a helper function for bisecting floats. Necessary because
    // floats are denser near 0 than they are elsewhere, so using a normal mean
    // results in slow bisection to 0.
    //
    // This function returns the arithmetic mean if both numbers have
    // magnitude larger than 1e-2, 0 if the numbers are small and have opposite
    // signs, and the signed geometric mean if the numbers have the same sign. The
    // geometric mean bisects the exponent instead of the mantissa, which is what
    // we want near 0.

    function floatMiddle(a, b) {
        var tmp;
        if (a > b) {
            tmp = a; a = b; b = tmp;
        }
        var aPos = a > 0;
        var bPos = b > 0;
        var aLarge = Math.abs(a) > 1e-2;
        var bLarge = Math.abs(b) > 1e-2;
        if (aLarge || bLarge) return Distance.mean(a, b);
        if (a === 0) return b * Math.abs(b);
        if (b === 0) return a * Math.abs(a);
        if (aPos !== bPos) return 0;
        var gMean = (aPos) ? Math.sqrt(a * b) : -Math.sqrt(a * b);
        // Check if the geometric mean actually lies between the numbers (it might
        // not because of floating point rounding). If it does not, return the
        // normal mean, which is computed in a way that guarantees it will be
        // between the inputs.
        return ((gMean >= a) && (b >= gMean)) ? gMean : Distance.mean(a, b);
    }

    function bisectZero(x0, y0, x2, y2, fn) {
        // Preconditions:
        // 1. y0 and y2 are finite and non-zero and have opposite sign
        if (!(isFinite(y0) && isFinite(y2) && (y0 < 0) !== (y2 < 0))) {
            console.log('bisectZero called with bad y values', [y0, y2]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);

            if (!isFinite(y1)) return null;

            // We can't bisect any further; return x for side with y closer to 0.
            if (x1 === x0 || x1 === x2) {
                return Math.abs(y0) <= Math.abs(y2) ? [x0, y0] : [x2, y2];
            }

            // Found a 0 early. Check if we're on a flat, and return the center of it.
            if (y1 === 0) return flatCenter(x0, y0, x1, y1, x2, y2, fn);

            // Bisect on side that brackets zero
            if ((y0 < 0) !== (y1 < 0)) {
                x2 = x1; y2 = y1;
            } else {
                x0 = x1; y0 = y1;
            }
        }
    }

    // Returns the center of a possibly flat region with constant value y1
    function flatCenter(x0, y0, x1, y1, x2, y2, fn) {
        // Preconditions:
        // 1. x0 < x1 < x2

        var edge;
        if (!isFinite(y1)) return;

        if (!isFinite(y0)) {
            edge = bisectFinite(x0, y0, x1, y1, fn);
            x0 = edge[0];
            y0 = edge[1];
        }

        if (!isFinite(y2)) {
            edge = bisectFinite(x1, y1, x2, y2, fn);
            x2 = edge[0];
            y2 = edge[1];
        }

        var flatLeft, flatRight;

        if (y0 === y1) {
            flatLeft = [x0, y0];
        } else {
            flatLeft = bisectConstant(x0, y0, x1, y1, fn, y1);
        }

        if (y2 === y1) {
            flatRight = [x2, y2];
        } else {
            flatRight = bisectConstant(x1, y1, x2, y2, fn, y1);
        }

        var xc = floatMiddle(flatLeft[0], flatRight[0]);
        return [xc, fn(xc)];
    }

    function bisectFinite(x0, y0, x2, y2, fn) {
        // Preconditions:
        // 1. isFinite(y0) !== isFinite(y2)
        if (isFinite(y0) === isFinite(y2)) {
            console.log('bisectFinite called with bad y values', [y0, y2]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);

            // We can't bisect any further; return [x, y] pair for side that is finite.
            if (x1 === x0 || x1 === x2) return isFinite(y0) ? [x0, y0] : [x2, y2];

            // Bisect on side that brackets zero
            if (isFinite(y1) !== isFinite(y0)) {
                x2 = x1; y2 = y1;
            } else {
                x0 = x1; y0 = y1;
            }
        }
    }

    function bisectConstant(x0, y0, x2, y2, fn, constant) {
        // Preconditions:
        // 1. (y0 === constant) !== (y2 === constant)
        if ((y0 === constant) === (y2 === constant)) {
            console.log('bisectConstant called with bad y values', [y0, y2, constant]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);

            // We can't bisect any further; return [x, y] pair for side with
            // y === constant
            if (x1 === x0 || x1 === x2) return (y0 === constant) ? [x0, y0] : [x2, y2];

            if ((y1 === constant) !== (y0 === constant)) {
                x2 = x1; y2 = y1;
            } else {
                x0 = x1; y0 = y1;
            }
        }
    }

    function bisectExtremum(x0, y0, x2, y2, x4, y4, fn) {
        // Preconditions:
        // 1. x0 < x2 < x4
        // 2. y0, y2, and y4 are finite, non-equal, and y2 > y0 === y2 > y4.
        if (!(x0 < x2 && x2 < x4)) {
            console.log('bisectExtremum called with bad x values', [x0, x2, x4]);
            return;
        }
        if (!(
    (isFinite(y0) && isFinite(y2) && isFinite(y4)) &&
    (y0 !== y2 && y2 !== y4) &&
    (y2 > y0) === (y2 > y4)
  )) {
            console.log('bisectExtremum called with bad y values', [y0, y2, y4]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);
            var x3 = floatMiddle(x2, x4);
            var y3 = fn(x3);

            if (!isFinite(y1) || !isFinite(y3)) return null;

            // We can't bisect any further; return x and y for most extreme value
            if (x1 === x0 || x1 === x2 || x3 === x2 || x3 === x4) {
                if ((y1 > y2) === (y2 > y0)) return [x1, y1];
                if ((y3 > y2) === (y2 > y0)) return [x3, y3];
                return [x2, y2];
            }

            // We've hit a flat. Find its edges and return x and y for its center.
            if (y1 === y2 || y3 === y2) {
                return flatCenter(x0, y0, x2, y2, x4, y4, fn);
            }

            // Bisect on side that brackets zero
            if ((y1 > y0) === (y2 > y0) && (y1 > y0) === (y1 > y2)) {
                x4 = x2; y4 = y2; x2 = x1; y2 = y1;
            } else if ((y3 > y4) === (y2 > y4) && (y3 > y2) === (y3 > y4)) {
                x0 = x2; y0 = y2; x2 = x3; y2 = y3;
            } else {
                x0 = x1; y0 = y1; x4 = x3; y4 = y3;
            }
        }
    }

    // Returns larget jump among 4 points. Used in final step of bisectJump
    function largestJump(x0, y0, x1, y1, x2, y2, x3, y3) {
        // Preconditions:
        // 1. y0, y1, y2, and y3 are all finite
        var d1 = Math.abs(y1 - y0);
        var d2 = Math.abs(y2 - y1);
        var d3 = Math.abs(y3 - y2);

        if (d1 > d2 && d1 > d3) return [[x0, y0], [x1, y1]];
        if (d3 > d2 && d3 > d1) return [[x2, y2], [x3, y3]];
        return [[x1, y1], [x2, y2]];
    }

    // Tries to find the largest jump in an interval. Returns left side and right
    // side of jump as [[xl, yl], [xr, yr]], or null if no jump was found.
    // Tolerance is allowed to be 0, and this works for some smooth functions,
    // but returns false positives for others.
    function bisectJump(x0, y0, x2, y2, x4, y4, fn, tolerance) {
        // Preconditions:
        // 1. x0 < x2 < x4
        // 2. y0, y2, and y4 are all finite.
        // Also expect x2 - x0 ~= x4 - x2
        if (!(x0 < x2 && x2 < x4)) {
            console.log('bisectJump called with bad x values', [x0, x2, x4]);
            return;
        }
        if (!(isFinite(y0) && isFinite(y2) && isFinite(y4))) {
            console.log('bisectJump called with bad y values', [y0, y2, y4]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);
            var x3 = floatMiddle(x2, x4);
            var y3 = fn(x3);
            var dy1 = Math.abs(y1 - Distance.mean(y0, y2));
            var dy3 = Math.abs(y3 - Distance.mean(y2, y4));
            var left;
            var right;
            if (!tolerance) tolerance = 0;

            if (dy1 <= tolerance && dy3 <= tolerance) return null;

            // An undefined region counts as a jump.
            if (!isFinite(y1)) {
                left = bisectFinite(x0, y0, x1, y1, fn);
                right = bisectFinite(x1, y1, x4, y4, fn);
                return [left, right];
            }

            if (!isFinite(y3)) {
                left = bisectFinite(x0, y0, x3, y3, fn);
                right = bisectFinite(x3, y3, x4, y4, fn);
                return [left, right];
            }

            if ((x1 === x0 || x1 === x2) && (x3 === x2 || x3 === x4)) {
                if (Math.abs(y2 - y0) > Math.abs(y4 - y2)) {
                    left = [x0, y0];
                    right = [x2, y2];
                } else {
                    left = [x2, y2];
                    right = [x4, y4];
                }
                return [left, right];
            } else if (x1 === x0 || x1 === x2) {
                return largestJump(x0, y0, x2, y2, x3, y3, x4, y4);
            } else if (x3 === x2 || x3 === x4) {
                return largestJump(x0, y0, x1, y1, x2, y2, x4, y4);
            }

            if (dy1 > dy3) {
                x4 = x2; y4 = y2; x2 = x1; y2 = y1;
            } else {
                x0 = x2; y0 = y2; x2 = x3; y2 = y3;
            }
        }
    }

    function findZeros(segments, fn) {
        var segment;
        var accumulator = { x: [], y: [] };
        var x0;
        var y0;
        var x2;
        var y2;
        var zero;
        var flatLeft;
        for (var i = 0, li = segments.length; i < li; i++) {
            segment = segments[i];
            flatLeft = undefined;
            if (segment[1] === 0) flatLeft = [segment[0], segment[1]];
            for (var j = 0, lj = segment.length; j < lj - 2; j = j + 2) {
                x0 = segment[j];
                y0 = segment[j + 1];
                x2 = segment[j + 2];
                y2 = segment[j + 3];

                if (!flatLeft) {
                    if (y2 === 0) {
                        // Entering left side of a potential flat. Save its position.
                        flatLeft = [x0, y0];
                    } else if ((y0 < 0) !== (y2 < 0)) {
                        zero = bisectZero(x0, y0, x2, y2, fn);
                        if (zero) {
                            accumulator.x.push(zero[0]);
                            accumulator.y.push(zero[1]);
                        }
                    }
                } else {
                    if (y2 !== 0) {
                        // Leaving right side of a flat. Add its center as a root.
                        // Don't label zeros that start on segment boundaries.
                        if (flatLeft[0] !== segment[0]) {
                            zero = flatCenter(flatLeft[0], flatLeft[1], x0, y0, x2, y2, fn);
                            accumulator.x.push(zero[0]);
                            accumulator.y.push(zero[1]);
                        }
                        flatLeft = undefined;
                    }
                    // Otherwise we're in the middle of the flat; do nothing
                }
            }
            // Don't label zero that ends on a segment boundary.
        }

        return accumulator;
    }

    function findExtrema(segments, fn) {
        var segment;
        var accumulator = { x: [], y: [] };
        var x0;
        var y0;
        var x2;
        var y2;
        var x4;
        var y4;
        var extremum;
        var flatLeft;
        var type;
        for (var i = 0, li = segments.length; i < li; i++) {
            segment = segments[i];
            for (var j = 0, lj = segment.length; j < lj - 4; j = j + 2) {
                x0 = segment[j];
                y0 = segment[j + 1];
                x2 = segment[j + 2];
                y2 = segment[j + 3];
                x4 = segment[j + 4];
                y4 = segment[j + 5];

                //TODO handle extremal endpoints.
                if (!(isFinite(y0) && isFinite(y2) && isFinite(y4))) continue;

                if (y0 !== y2 && y2 === y4) {
                    // Entering left side of a flat. Save its position.
                    flatLeft = [x0, y0];
                } else if (y0 === y2 && y2 !== y4 && flatLeft) {
                    // Leaving right side of a flat.
                    if ((y2 > flatLeft[1]) === (y2 > y4)) {
                        // Flat is an extremum. Push it's center.
                        extremum = flatCenter(flatLeft[0], flatLeft[1], x2, y2, x4, y4, fn);
                        accumulator.x.push(extremum[0]);
                        accumulator.y.push(extremum[1]);
                    }
                    flatLeft = undefined;
                } else if (y0 === y2 && y2 === y4) {
                    // Middle of a flat, do nothing
                } else if ((y2 > y0) === (y2 > y4)) {
                    if (fn.derivative) {
                        // If we have derivative information, find zeros of the derivative
                        // to find extrema. This gives greater accuracy in the argmax/argmin
                        // because the original function is flat at the extrema, but its
                        // derivative is (usually) not.

                        // Make sure we satisfy prereqs of bisectZero
                        if ((fn.derivative(x0) > 0) === (fn.derivative(x4) > 0)) continue;
                        extremum = bisectZero(
            x0, fn.derivative(x0),
            x4, fn.derivative(x4),
            fn.derivative
          );
                        // Currently treat maxima and minima the same
                        if (extremum) {
                            accumulator.x.push(extremum[0]);
                            accumulator.y.push(fn(extremum[0]));
                        }
                    } else {
                        extremum = bisectExtremum(x0, y0, x2, y2, x4, y4, fn);
                        // Currently treat maxima and minima the same
                        if (extremum) {
                            accumulator.x.push(extremum[0]);
                            accumulator.y.push(extremum[1]);
                        }
                    }
                }
            }
        }
        return accumulator;
    }

    function findIntercept(segments, fn) {
        var intercept = fn(0);
        if (!isFinite(intercept)) return { x: [], y: [] };
        return { x: [0], y: [fn(0)] };
    }

    function findEdges(segments, fn) {
        var slen = segments.length;
        var accumulator = { x: [], y: [] };
        //TODO work out robust system for labeling holes so that we can label all
        // edges.
        //
        // For now, only label edges that are close to zero as zeros.

        for (var i = 0; i < slen; i++) {
            var segment = segments[i];
            if (parseFloat(segment[1].toFixed(7)) === 0) {
                accumulator.x.push(segment[0]);
                accumulator.y.push(segment[1]);
            }

            if (parseFloat(segment[segment.length - 1].toFixed(7)) === 0) {
                accumulator.x.push(segment[segment.length - 2]);
                accumulator.y.push(segment[segment.length - 1]);
            }
        }
        return accumulator;
    }

    // Note: findIntersections has a different signature than findZeros and findExtrema--it finds its own segments rather than having them passed in as an argument.
    var findIntersections = function (domain, fn1, fn2) {
        var differenceFn = function (x) { return fn2(x) - fn1(x); };
        var sampledDifference = Plotter.sampleXY(differenceFn, domain);
        var zeros = findZeros(sampledDifference, differenceFn);
        var i;

        // Find tangent intersections.
        var extrema = findExtrema(sampledDifference, differenceFn);
        for (i = 0, elen = extrema.x.length; i < elen; i++) {
            if (BuiltIn.approx(extrema.y[i], 0)) {
                zeros.x.push(extrema.x[i]);
                zeros.y.push(extrema.y[i]);
            }
        }

        // Find original function intersection y values.
        for (i = 0, zlen = zeros.x.length; i < zlen; i++) {
            zeros.y[i] = fn1(zeros.x[i]);
        }
        return zeros;
    };

    function findPOIs(segments, fn) {
        var zeros = findZeros(segments, fn);
        var edges = findEdges(segments, fn);

        // Not displaying edges right now; combine them with zeros.
        zeros.x.push.apply(zeros.x, edges.x);
        zeros.y.push.apply(zeros.y, edges.y);

        return {
            zeros: zeros,
            intercept: findIntercept(segments, fn),
            extrema: findExtrema(segments, fn)
        };
    }

    return {
        bisectJump: bisectJump,
        bisectExtremum: bisectExtremum,
        bisectFinite: bisectFinite,
        bisectZero: bisectZero,
        findZeros: findZeros,
        findPOIs: findPOIs,
        findIntersections: findIntersections
    };
});

define('math/plotter', ['require', './distance', './poi'], function (require) {
    var Distance = require('./distance');
    var POI = require('./poi');

    Plotter = {

        //Accumulates a list of segments
        Accumulator: function (domain) {
            var xtolerance, ytolerance;

            if (domain) {
                xtolerance = domain.xtolerance || domain.tolerance || 0;
                ytolerance = domain.ytolerance || domain.tolerance || 0;
            } else {
                xtolerance = ytolerance = 0;
            }

            var colinear = function (p0, p1, p2, xtolerance, ytolerance) {

                if (domain && domain.map) {
                    p0 = domain.map(p0);
                    p1 = domain.map(p1);
                    p2 = domain.map(p2);
                }

                var t = Distance.pointToSegmentParameter(
        p2[0], p2[1],
        p0[0], p0[1],
        p1[0], p1[1]
      );

                var closestPoint = [
        p0[0] + t * (p1[0] - p0[0]),
        p0[1] + t * (p1[1] - p0[1])
      ];

                return (
        Math.abs(p2[0] - closestPoint[0]) <= xtolerance &&
        Math.abs(p2[1] - closestPoint[1]) <= ytolerance
      );
            };

            return {
                xtolerance: xtolerance,
                ytolerance: ytolerance,
                segments: [],
                segment: null,

                // Second point added to colinear set; defines line direction
                pivotPoint: null,
                // Most recent point in colinear set
                pendingPoint: null,

                addPoint: function (p) {
                    this.n += 1;
                    var pivotPoint = this.pivotPoint;

                    if (!this.segment) {
                        this.segment = [p[0], p[1]];  //First point of the segment
                        return;
                    }

                    if (xtolerance < 0 && ytolerance < 0) {
                        this.segment.push(p[0], p[1]);
                        return;
                    }

                    if (!pivotPoint) {
                        this.pivotPoint = p;
                        this.pendingPoint = p;
                        return;
                    }

                    // Check if the new point lies on the line segment defined by the
                    // last flushed point and the pivot point. If not, flush the pending
                    // point and start a new linear section.
                    var lastPoint = [
          this.segment[this.segment.length - 2],
          this.segment[this.segment.length - 1]
        ];

                    if (!colinear(lastPoint, pivotPoint, p, xtolerance, ytolerance)) {
                        this.flushPending();
                        this.pivotPoint = p;
                    }

                    this.pendingPoint = p;
                },

                flushPending: function () {
                    if (this.pendingPoint) { //Only happens when we have a segment
                        this.segment.push(this.pendingPoint[0], this.pendingPoint[1]);
                        this.pivotPoint = null;
                        this.pendingPoint = null;
                    }
                },

                breakSegment: function () {
                    this.flushPending();

                    if (this.segment) {
                        if (this.segment.length > 2) {
                            this.segments.push(this.segment);
                        }
                        this.segment = null;
                    }
                },

                getSegments: function () {
                    this.breakSegment();
                    return this.segments;
                }
            };
        },

        //Simple sampling of a [x(t), y(t)] function.
        //Domain is provided in terms of the independent variable
        //PARAMETERS
        //fn(int) => [x, y]
        //domain = {min, max, step}
        //RETURNS
        //Unclipped list of segments which can be passed directly into onGraph
        sampleParametricNaive: function (fn, domain) {
            var accumulator = Plotter.Accumulator();
            var point;
            for (var independent = domain.min; independent <= domain.max; independent += domain.step) {
                point = fn(independent);
                if (isFinite(point[0]) && isFinite(point[1])) {
                    accumulator.addPoint(point);
                }
                else {
                    accumulator.breakSegment();
                }
            }
            return accumulator.getSegments();
        },

        //Simple sampling of a y(x) function.
        //PARAMETERS
        //fn(int) => y
        //domain = {min, max, step}
        //RETURNS
        //Unclipped list of segments which can be passed directly into onGraph
        sampleXYNaive: function (fn, domain) {
            var accumulator = Plotter.Accumulator(domain);
            var y;
            for (var x = domain.min; x <= domain.max; x += domain.step) {
                y = fn(x);
                if (isFinite(y)) {
                    accumulator.addPoint([x, y]);
                } else {
                    accumulator.breakSegment();
                }
            }
            return accumulator.getSegments();
        },

        sampleXY: function (fn, domain) {

            var accumulator = Plotter.Accumulator(domain);
            var edge;
            var x = domain.min;
            var y = fn(x);
            var previousPoint = [x, y];
            var jumpTolerance;

            if (domain) jumpTolerance = domain.ytolerance || domain.tolerance;

            var handleJump = function (previousPoint, point) {
                if (!isFinite(jumpTolerance) || (jumpTolerance <= 0)) return;
                var jump;
                var xc;
                xc = Distance.mean(previousPoint[0], point[0]);
                jump = POI.bisectJump(
        previousPoint[0], previousPoint[1],
        xc, fn(xc),
        point[0], point[1],
        fn, jumpTolerance
      );
                if (jump) {
                    accumulator.addPoint(jump[0]);
                    accumulator.breakSegment();
                    accumulator.addPoint(jump[1]);
                }
            };

            if (isFinite(y)) accumulator.addPoint([x, y]);
            for (x += domain.step; x <= domain.max; x += domain.step) {
                y = fn(x);
                if (isFinite(y) && isFinite(previousPoint[1])) {
                    handleJump(previousPoint, [x, y]);
                    accumulator.addPoint([x, y]);
                } else if (isFinite(y) && !isFinite(previousPoint[1])) {
                    // left edge
                    edge = POI.bisectFinite(previousPoint[0], previousPoint[1], x, y, fn);
                    if (edge[0] !== x) accumulator.addPoint(edge);
                    handleJump(edge, [x, y]);
                    accumulator.addPoint([x, y]);
                } else if (!isFinite(y) && isFinite(previousPoint[1])) {
                    // right edge
                    edge = POI.bisectFinite(previousPoint[0], previousPoint[1], x, y, fn);
                    handleJump(previousPoint, edge);
                    if (edge[0] !== previousPoint[0]) accumulator.addPoint(edge);
                    accumulator.breakSegment();
                }
                previousPoint = [x, y];
            }
            return accumulator.getSegments();
        },

        findPiPeriod: function (fn, domain, allowAntiperiods) {
            // If the function is periodic by a multiple of 2*pi, or antiperiodic by
            // a multiple of pi within the domain, return the period.
            //
            // Can optionally pass true to find antiperiods if they exist.
            var min = domain.min;
            var range = domain.max - domain.min;
            var tolerance = (domain.xtolerance && domain.ytolerance) ?
      Math.min(domain.xtolerance, domain.ytolerance) :
      domain.tolerance;
            var piRange = Math.floor(range / Math.PI);
            var n, m, period;

            function isPeriod(fn, n) {
                var sign = (n % 2 === 0) ? 1 : -1;
                if (!allowAntiperiods && sign === -1) return false;
                var nPI = n * Math.PI;
                var vals = [min, min + 1, min + 2, min + 3];

                for (var i = 0, ilen = vals.length; i < ilen; i++) {
                    if (
          isFinite(fn(vals[i])) !== isFinite(fn(vals[i] + nPI)) ||
          Math.abs(fn(vals[i]) - sign * fn(vals[i] + nPI)) > tolerance
        ) {
                        return false;
                    }
                }

                return true;
            }

            for (n = 1; n <= piRange; n++) {
                if (isPeriod(fn, n)) {
                    period = n;
                    // Check if integer multiples of the period are also periods
                    for (m = 2; m * n <= piRange; m++) {
                        if (!isPeriod(fn, m * n)) period = undefined;
                    }
                    if (period) break;
                }
            }

            if (!period) return null;

            return period * Math.PI;
        },

        mapPolar: function (p) {
            return [p[1] * Math.cos(p[0]), p[1] * Math.sin(p[0])];
        },

        samplePolar: function (fn, domain) {
            // Don't allow line coallescing, since linear segments of a polar
            // equation don't map to lines on the graph paper.
            domain.map = this.mapPolar;
            return this.sampleXY(fn, domain);
        },

        // Helper for calling a function at steps along a range that makes sure we
        // hit start and endpoints exactly.
        //
        // TODO, use this in sampling xy also. Not
        // doing that for now because I don't want to step on Eric's toes with
        // extrema interleaving system that is being concurrently developed.
        eachStep: function (domain, fn) {
            var min = domain.min;
            var max = domain.max;
            var step = domain.step;
            var range = max - min;
            var nsteps = Math.ceil(range / step);
            var newStep = range / nsteps;
            for (n = 0; n < nsteps; n++) {
                fn(min + n * newStep);
            }
            fn(max);
        },

        sampleParametricRecursive: function (fn, domain) {
            if (domain.max < domain.min) { return [] }

            var accumulator = Plotter.Accumulator(domain);
            var xtolerance, ytolerance;
            if (domain) {
                xtolerance = domain.xtolerance || domain.tolerance || 0;
                ytolerance = domain.ytolerance || domain.tolerance || 0;
            } else {
                xtolerance = ytolerance = 0;
            }

            //Sampling parameters
            var subdivision_levels = 10;

            //Initialize for first pass through loop
            var t0 = domain.min;
            var p0 = fn(t0);
            if (isFinite(p0[0]) && isFinite(p0[1])) {
                accumulator.addPoint(p0);
            }

            var p1;
            // Note, processes first point twice; but that's okay.
            this.eachStep(domain, function (t1) {
                p1 = fn(t1);
                Plotter.subsampleParametricRecursive(fn, t0, p0, t1, p1, subdivision_levels, accumulator, xtolerance, ytolerance);
                t0 = t1;
                p0 = p1;
            });

            return accumulator.getSegments();
        },

        subsampleParametricRecursive: function (fn, t0, p0, t1, p1, subdivision_levels_left, accumulator, xtolerance, ytolerance) {

            if (t1 === t0) return; // Nothing new to add, but don't need to break;

            var t_mid = Distance.mean(t0, t1);
            var p_mid = fn(t_mid, true);

            var p0_valid = isFinite(p0[0]) && isFinite(p0[1]);
            var p1_valid = isFinite(p1[0]) && isFinite(p1[1]);
            var p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);

            if (subdivision_levels_left === 0 || t_mid === t0 || t_mid === t1) {
                accumulator.breakSegment(); //Didn't converge.
                if (p1_valid) accumulator.addPoint(p1);
                return;
            }

            if (!p0_valid && !p1_valid) return; //Don't need to break segment, since p0 should already have been processed.

            if (p0_valid != p1_valid) {
                //We're at the edge of where the function is defined.  Subdivide until we find where edge point to machine precision
                var original_t0 = t0;
                var original_t1 = t1;
                var original_p0 = p0;
                var original_p1 = p1;

                while (t0 !== t_mid && t_mid !== t1) {

                    if (p_mid_valid == p0_valid) {
                        t0 = t_mid;
                        p0 = p_mid;
                        p0_valid = p_mid_valid;
                    }
                    else {
                        t1 = t_mid;
                        p1 = p_mid;
                        p1_valid = p_mid_valid;
                    }

                    t_mid = t0 + (t1 - t0) / 2;
                    p_mid = fn(t_mid, true);
                    p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);
                } //When this loop terminates, t_mid equals either t0 or t1

                if (p0_valid) {
                    Plotter.subsampleParametricRecursive(fn, original_t0, original_p0, t0, p0, subdivision_levels_left - 1, accumulator, xtolerance, ytolerance);
                    accumulator.breakSegment();
                }
                else {
                    accumulator.breakSegment();
                    accumulator.addPoint(p1);
                    Plotter.subsampleParametricRecursive(fn, t1, p1, original_t1, original_p1, subdivision_levels_left - 1, accumulator, xtolerance, ytolerance);
                }
                return;
            }

            if (p0_valid && p_mid_valid && p1_valid) {

                var t = Distance.pointToSegmentParameter(
        p_mid[0],
        p_mid[1],
        p0[0],
        p0[1],
        p1[0],
        p1[1]
      );

                // If the new point lies betwen 20 % and 80 % of the way between the
                // outer points, and the distance from the segment to the new point is
                // less than tolerance, add the rightmost point, and stop recursing.
                if (
        t > 0.2 &&
        t < 0.8 &&
        Math.abs(p_mid[0] - (p0[0] + t * (p1[0] - p0[0]))) <= xtolerance &&
        Math.abs(p_mid[1] - (p0[1] + t * (p1[1] - p0[1]))) <= ytolerance
      ) {
                    accumulator.addPoint(p1);
                    return;
                }
            }

            // If we didn't stop, recurse. Don't recurse between two points that are
            // equal, since this will make us do a lot of work if our point becomes
            // independent of t over some range.
            if (!(p0[0] === p_mid[0] && p0[1] === p_mid[1])) {
                Plotter.subsampleParametricRecursive(fn, t0, p0, t_mid, p_mid, subdivision_levels_left - 1, accumulator, xtolerance, ytolerance);
            }
            if (!(p1[0] === p_mid[0] && p1[1] === p_mid[1])) {
                Plotter.subsampleParametricRecursive(fn, t_mid, p_mid, t1, p1, subdivision_levels_left - 1, accumulator, xtolerance, ytolerance);
            }
        },

        computeDomain: function (viewState, graph_info, fn) {
            var xmin = viewState.viewport.xmin;
            var xmax = viewState.viewport.xmax;
            var ymin = viewState.viewport.ymin;
            var ymax = viewState.viewport.ymax;
            var xtolerance = 0.25 * (xmax - xmin) / viewState.screen.width;
            var ytolerance = 0.25 * (ymax - ymin) / viewState.screen.height;

            var domain;
            switch (graph_info.graphMode) {
                case GRAPHMODE_X:
                    domain = {
                        min: ymin,
                        max: ymax,
                        xtolerance: ytolerance, // Note, switched
                        ytolerance: xtolerance,
                        step: ytolerance
                    };
                    break;
                case GRAPHMODE_Y:
                    domain = {
                        min: xmin,
                        max: xmax,
                        xtolerance: xtolerance,
                        ytolerance: ytolerance,
                        step: xtolerance
                    };
                    break;
                case GRAPHMODE_POLAR:
                    domain = {
                        min: 0,
                        max: Math.PI * 2 * 6,
                        step: (Math.PI * 2) / 1000,
                        tolerance: Math.min(xtolerance, ytolerance)
                    };
                    var period = Plotter.findPiPeriod(fn, domain, graph_info.operator === '=');
                    if (period) domain.max = domain.min + period;
                    break;
                case GRAPHMODE_PARAMETRIC:
                    domain = {
                        min: graph_info.domain.min,
                        max: graph_info.domain.max,
                        step: graph_info.domain.step,
                        xtolerance: xtolerance,
                        ytolerance: ytolerance
                    };
                    break;
            }
            return domain;
        },

        //Computes domain, decides what function to use, and returns answer
        computeGraphData: function (viewState, graph_info, fn) {
            var domain = Plotter.computeDomain(viewState, graph_info, fn);
            var segments;
            switch (graph_info.graphMode) {
                case GRAPHMODE_X:
                case GRAPHMODE_Y:
                    segments = Plotter.sampleXY(fn, domain);
                    break;
                case GRAPHMODE_POLAR:
                    segments = Plotter.samplePolar(fn, domain);
                    break;
                case GRAPHMODE_PARAMETRIC:
                    if (!domain.step) domain.step = (domain.max - domain.min) / 1000;
                    segments = Plotter.sampleParametricRecursive(fn, domain);
            }

            var poi = [];
            if (graph_info.graphMode !== GRAPHMODE_PARAMETRIC) {
                poi = POI.findPOIs(segments, fn);
                segments = Plotter.interleaveExtrema(segments, poi);
            }

            // Flip POI representation if necessary
            if (graph_info.graphMode === GRAPHMODE_X) {
                for (var type in poi) {
                    if (!poi.hasOwnProperty(type)) continue;
                    tmp = poi[type].y;
                    poi[type].y = poi[type].x;
                    poi[type].x = tmp;
                }
            }

            datum = {
                segments: segments,
                graphMode: graph_info.graphMode,
                color: graph_info.color,
                operator: graph_info.operator,
                poi: poi,
                expr: null //compiled.fn
            };
            return [datum];
        },

        interleaveExtrema: function (segments, poi) {
            var nsegments = segments.length;
            var segment;
            var newSegments = Array(nsegments);
            var newSegment;
            var slen;
            var extrema = poi.extrema;
            var j = 0;
            var elen = extrema.x.length;

            for (var n = 0; n < nsegments; n++) {
                segment = segments[n];
                slen = segment.length;
                newSegment = [];
                for (i = 0; i < slen; i = i + 2) {
                    // push extrema between last point and current point onto
                    // accumulator.
                    while (j < elen && extrema.x[j] <= segment[i]) {
                        // Don't push the same point twice
                        if (extrema.x[j] !== segment[i]) {
                            newSegment.push(extrema.x[j], extrema.y[j]);
                        }
                        j++;
                    }
                    // push current point onto accumulator.
                    newSegment.push(segment[i], segment[i + 1]);
                }
                newSegments[n] = newSegment;
            }
            return newSegments;
        },

        polygonsFromSegments: function (bottom_segments, top_segments, graphMode) {
            var last_x = function (segments) {
                var last_segment = segments[segments.length - 1];
                return last_segment[last_segment.length - 2];
            };

            var polygons = [];
            //Until we have pulled the last segment:
            //Continue to pull segments from the top and the bottom until we find two which end at the same point.
            //When that happens, close the polygon, and start another one.
            var i_top = 0;
            var i_bottom = 0;
            var current_bottom = [];
            var current_top = [];
            var top_x = -Infinity;
            var bottom_x = -Infinity;

            while (true) {

                if (top_x <= bottom_x) {
                    if (i_top >= top_segments.length) break;
                    current_top.push(top_segments[i_top++]);
                }
                if (bottom_x <= top_x) {
                    if (i_bottom >= bottom_segments.length) break;
                    current_bottom.push(bottom_segments[i_bottom++]);
                }
                top_x = last_x(current_top);
                bottom_x = last_x(current_bottom);

                if (top_x == bottom_x) {
                    polygons.push(Plotter.polygonFromSegments(current_bottom, current_top, graphMode));
                    current_top = [];
                    current_bottom = [];
                }
            }
            return polygons;
        },

        polygonFromSegments: function (bottom_segments, top_segments, graphMode) {
            //TODO - respect graphMode (by pushing in proper order)
            var i, j, p, segment;
            polygon = [];
            var map;
            switch (graphMode) {
                case GRAPHMODE_POLAR:
                    map = this.mapPolar;
                    break;
                case GRAPHMODE_X:
                    map = function (p) { return [p[1], p[0]]; };
                    break;
            }
            for (i = 0; i < bottom_segments.length; i++) {
                segment = bottom_segments[i];
                for (j = 0; j < segment.length; j += 2) {
                    p = [segment[j], segment[j + 1]];
                    if (map)
                        p = map(p);
                    polygon.push(p[0], p[1]);
                }
            }
            for (i = top_segments.length - 1; i >= 0; i--) {
                segment = top_segments[i];
                for (j = segment.length - 2; j >= 0; j -= 2) {
                    p = [segment[j], segment[j + 1]];
                    if (map)
                        p = map(p);
                    polygon.push(p[0], p[1]);
                }
            }
            return polygon;
        }
    };

    return Plotter;
});

define('math/quadratic', [], function () {

    Quadratic = {
        formula: function (coeffs, rootNumber) {
            if (coeffs.length != 3) throw 'Where did you learn the quadratic formula?';
            var a = coeffs[0];
            var b = coeffs[1];
            var c = coeffs[2];

            if (a === 0) {
                return [-c / b, -c / b];  //Linear case
            }

            var radical = Math.sqrt(b * b - 4 * a * c);
            var root0 = (-b + radical) / (2 * a);
            var root1 = (-b - radical) / (2 * a);

            //Optional argument rootNumber specifies which root to return.  If not specified, returns list of all roots
            if (rootNumber === 0) return root0;
            if (rootNumber === 1) return root1;
            return [root0, root1];
        },

        // For a quadratic inequality of the form a*x^2 + b*x + c > 0, returns
        // regions for which the inequality is satisfied in the form [ lower, mid0,
        // mid1, upper ]. The inequality is satisfied for:
        //
        //   x < lower ||
        //   (x > mid0 && x < mid1) ||
        //   x > upper
        //
        // Values can be NaN to signal that no inequality of the given type is
        // satisfied. At least two of the return values will always be NaN.
        inequalityRegions: function (coeffs) {
            // Would ideally like large === Infinity, but it's convenient to feed
            // these results through the line coalescing/jump detection/poi finding
            // pipeline, and none of that is set up to deal with Infinity correctly.
            var large = 1e305;

            a = coeffs[0];
            b = coeffs[1];
            c = coeffs[2];

            if (a === 0 && b === 0) {
                return (c > 0) ?
        [NaN, -large, large, NaN] :
        [NaN, NaN, NaN, NaN]
      ;
            }
            if (a === 0) {
                return (b > 0) ?
        [NaN, NaN, NaN, -c / b] :
        [-c / b, NaN, NaN, NaN]
      ;
            }
            var discriminant = Math.sqrt(b * b - 4 * a * c);
            if (!isFinite(discriminant)) {
                return (a > 0) ?
        [NaN, -large, large, NaN] :
        [NaN, NaN, NaN, NaN]
      ;
            }
            var upper = (-b + discriminant) / (2 * a);
            var lower = (-b - discriminant) / (2 * a);
            return (a > 0) ?
      [lower, NaN, NaN, upper] :
      [NaN, upper, lower, NaN] // upper/lower switched because a < 0
    ;
        },

        formulaEvalStrings: function (strings) {
            var function_1, function_2;
            switch (strings.expressions.length) {
                case 2:
                    function_1 = strings.statements + 'return ' + '-' + strings.expressions[0] + '/' + strings.expressions[1];
                    return [function_1];
                case 3:
                    var statements =
        strings.statements +
        'var coeffs = [' + strings.expressions[2] + ',' +
                           strings.expressions[1] + ',' +
                           strings.expressions[0] + '];';
                    function_1 = statements + 'return Quadratic.formula(coeffs, 0);';
                    function_2 = statements + 'return Quadratic.formula(coeffs, 1);';
                    return [function_1, function_2];
            }
        },

        inequalityRegionEvalStrings: function (strings) {
            // Prepend zeros onto coefficient strings that are too short.
            var expressions = strings.expressions.slice();
            while (expressions.length < 3) expressions.push('0');

            var statements = strings.statements +
      'var coeffs = [' + expressions[2] + ',' +
                         expressions[1] + ',' +
                         expressions[0] + '];';
            // TODO, send in correct operator
            return [
      statements + 'return Quadratic.inequalityRegions(coeffs)[0]',
      statements + 'return Quadratic.inequalityRegions(coeffs)[1]',
      statements + 'return Quadratic.inequalityRegions(coeffs)[2]',
      statements + 'return Quadratic.inequalityRegions(coeffs)[3]'
    ];
        }
    };

    return Quadratic;
});

define('math/derivative', ['require', './parser_util', './evalframe'], function (require) {
    var Parser = require('./parser_util');
    var EvalFrame = require('./evalframe');

    //TODO - will need to bring ParseNode and friends out of parse_util namespace



    var DerivativeNode = Parser.DerivativeNode;
    var ConstantNode = Parser.ConstantNode;
    var NegationNode = Parser.NegationNode;
    var ParseNode = Parser.ParseNode;
    var BinaryOperatorNode = Parser.BinaryOperatorNode;
    var FunctionNode = Parser.FunctionNode;
    var FunctionDeclarationNode = Parser.FunctionDeclarationNode;
    var FunctionCallExponentNode = Parser.FunctionCallExponentNode;
    var IdentifierNode = Parser.IdentifierNode;
    var RepeatedOperatorNode = Parser.RepeatedOperatorNode;
    var SummationNode = Parser.SummationNode;
    var ProductNode = Parser.ProductNode;
    var AssigmentNode = Parser.AssignmentNode;
    var ChainedComparatorNode = Parser.ChainedComparatorNode;
    var PiecewiseNode = Parser.PiecewiseNode;
    var AssignmentNode = Parser.AssignmentNode;

    DerivativeNode.open(function (node) {
        node.takeDerivative = function (frame, variable) {
            if (this.freeOf(frame, variable)) return ConstantNode(0);

            var dtree = this.expression.takeDerivative(
      frame,
      this.derivative_variable
    );

            // If root of the derivative tree is a Derivative node, then we don't know
            // how to symbolically differentiate this tree. Just wrap it in another
            // DerivativeNode.
            if (dtree instanceof DerivativeNode) {
                return Parser.DerivativeNode(variable, dtree);
            }

            return dtree.takeDerivative(frame, variable);
        };

        node.freeOf = function (frame, variable) {
            return this.expression.freeOf(frame, variable);
        };

        node.substitute = function (frame) {
            var dtree = this.expression.takeDerivative(
      frame,
      this.derivative_variable
    );

            if (dtree instanceof DerivativeNode) {
                if (frame.hasVariable(this.derivative_variable.identifier)) {
                    throw "Can't substitute for derivative variable if derivative can't be taken symbolically";
                }

                return DerivativeNode(this.derivative_variable, this.expression);
            }

            return dtree.substitute(frame);
        };
    });

    ParseNode.open(function (node) {
        // Fallback. If we don't know how to take the derivative of a node
        // symbolically, wrap it in a DerivativeNode, and the evaluator will
        // evaluate the derivative numerically.
        node.takeDerivative = function (frame, variable) {
            return DerivativeNode(variable, this);
        };

        node.freeOf = function (frame, variable) { return false; };
    });

    var DerivativeHelpers = {};

    // Helper for implementing the chain rule. For f(a), tree is f'(a), and
    // arg is a. Returns f'(a)*da/dx, but checks whether a is free of x, in which
    // case we just return a ConstantNode(0). This is important when f'(a) is
    // undefined, since 0*NaN is NaN, but we want the output to be zero.
    DerivativeHelpers.chain = function (frame, variable, tree, arg) {
        if (arg.freeOf(frame, variable)) return ConstantNode(0);
        return BinaryOperatorNode.reduce(
    '*',
    tree,
    arg.takeDerivative(frame, variable)
  );
    };

    // Helper that parses a latex string and returns a function that replaces
    // a_{i} identifiers with the trees in an array. e.g.
    //
    //   substituteFn('a_1*\\sin(a_0)')([Parser.parse('x^2'), Parser.parse('y')])
    //
    // returns a tree equivalent to
    //
    //   Parser.parse('y*\\sin(x^2)')
    ; (function () {

        var tmps = [];
        var argRegExps = [];

        // 9 arguments should be enough for anyone...
        for (var i = 0; i < 9; i++) {
            tmps.push(IdentifierNode('a_{' + i + ParseNode.prototype.tmp() + '}'));
            argRegExps.push(RegExp('a_' + i, 'g'));
        }

        // Do things lexically like this because the latexStrings are known
        // statically, and because we don't yet have all the substitute machinery
        // defined.
        //
        // Note, this code is a little more delicate than it looks. the tmps could
        // almost be straight strings, but I'm making them IdentifierNodes and using
        // .toString and .identifier to finesse the issue that a_{i} parses into an
        // expression with identifier a_i.
        var replaceArgs = function (latexString) {
            for (var i = 0; i < tmps.length; i++) {
                latexString = latexString.replace(argRegExps[i], tmps[i].toString());
            }
            return latexString;
        };

        DerivativeHelpers.substituteFn = function (latexString) {
            var parsed = Parser.parse(replaceArgs(latexString));
            var frame = EvalFrame();

            return function (args) {
                var length = args.length;
                for (var i = 0; i < args.length; i++) {
                    frame.setVariable(tmps[i].identifier, args[i]);
                }
                return parsed.substitute(frame);
            };
        };
    })();


    // Factory method for creating binary operator nodes that folds constants.
    // Note, we don't simplify 0*a because a could be NaN or Infinity.
    BinaryOperatorNode.reduce = function (operator, arg1, arg2) {
        switch (operator) {
            case '+':
                if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
                    return ConstantNode(arg1.value + arg2.value);
                }
                if (arg1 instanceof ConstantNode && arg1.value === 0) {
                    return arg2;
                }
                if (arg2 instanceof ConstantNode && arg2.value === 0) {
                    return arg1;
                }
                break;
            case '-':
                if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
                    return ConstantNode(arg1.value - arg2.value);
                }
                if (arg2 instanceof ConstantNode && arg2.value === 0) {
                    return arg1;
                }
                break;
            case '*':
                if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
                    return ConstantNode(arg1.value * arg2.value);
                }
                if (arg1 instanceof ConstantNode && arg1.value === 1) {
                    return arg2;
                }
                if (arg2 instanceof ConstantNode && arg2.value === 1) {
                    return arg1;
                }
                break;
            case '/':
                if (arg2 instanceof ConstantNode && arg2.value === 1) {
                    return arg1;
                }
                if (arg1 instanceof ConstantNode && arg2 instanceof ConstantNode) {
                    return ConstantNode(arg1 / arg2);
                }
                break;
            case '^':
                if (arg2 instanceof ConstantNode && arg2.value === 1) {
                    return arg1;
                }
                break;
        }
        return BinaryOperatorNode(operator, arg1, arg2);
    };

    NegationNode.reduce = function (expression) {
        if (expression instanceof ConstantNode) {
            return ConstantNode(-expression.value);
        }
        if (expression instanceof NegationNode) return expression.expression;
        return NegationNode(expression);
    };

    BinaryOperatorNode.open(function (node, _super) {

        // substitution functions for taking derivatives of powers:
        // d/dxf(x)^{g(x)} = g(x)*f(x)^{g(x) - 1}*f'(x) + f(x)^{g(x)}*ln(f(x))*g'(x)
        //                =         bprime*f'(x)        +         eprime*g'(x)
        var bprime = DerivativeHelpers.substituteFn('a_1*a_0^{a_1 - 1}');
        var eprime = DerivativeHelpers.substituteFn('a_0^{a_1}*\\ln(a_0)');

        node.takeDerivative = function (frame, variable) {
            if (this.freeOf(frame, variable)) return ConstantNode(0);

            var a0 = this.args[0];
            var a1 = this.args[1];
            switch (this.operator) {
                case '+':
                    return BinaryOperatorNode.reduce(
          '+',
          a0.takeDerivative(frame, variable),
          a1.takeDerivative(frame, variable)
        );
                case '-':
                    return BinaryOperatorNode.reduce(
          '-',
          a0.takeDerivative(frame, variable),
          a1.takeDerivative(frame, variable)
        );
                case '*':
                    return BinaryOperatorNode.reduce(
          '+',
          DerivativeHelpers.chain(frame, variable, a1, a0),
          DerivativeHelpers.chain(frame, variable, a0, a1)
        );
                case '/':
                    return BinaryOperatorNode.reduce(
          '/',
          BinaryOperatorNode.reduce(
            '-',
            DerivativeHelpers.chain(frame, variable, a1, a0),
            DerivativeHelpers.chain(frame, variable, a0, a1)
          ),
          BinaryOperatorNode.reduce('^', a1, ConstantNode(2))
        );
                case '^':
                    return BinaryOperatorNode.reduce(
          '+',
          DerivativeHelpers.chain(frame, variable, bprime(this.args), a0),
          DerivativeHelpers.chain(frame, variable, eprime(this.args), a1)
        );
                default:
                    return _super.takeDerivative.call(this, frame, variable);
            }
        };

        node.freeOf = function (frame, variable) {
            return this.args[0].freeOf(frame, variable) &&
      this.args[1].freeOf(frame, variable);
        };

        node.substitute = function (frame) {
            return BinaryOperatorNode.reduce(
      this.operator,
      this.args[0].substitute(frame),
      this.args[1].substitute(frame)
    );
        };
    });

    ChainedComparatorNode.open(function (node) {
        node.freeOf = function (frame, variable) {
            return this.args.every(function (arg) {
                return arg.freeOf(frame, variable);
            });
        };

        node.substitute = function (frame) {
            return ChainedComparatorNode(
      this.comparators,
      this.args.map(function (arg) {
          return arg.substitute(frame);
      })
    );
        };
    });

    ConstantNode.open(function (node) {
        node.takeDerivative = function () { return ConstantNode(0); };

        node.freeOf = function (frame, variable) { return true; };

        node.substitute = function (frame) { return this; };
    });

    FunctionNode.open(function (node, _super) {
        var derivativeStrings = {
            exp: ['\\exp(a_0)'],
            sqrt: ['\\frac{1}{2*\\sqrt{a_0}}'],
            sin: ['\\cos(a_0)'],
            cos: ['-\\sin(a_0)'],
            tan: ['(\\sec(a_0))^2'],
            arcsin: ['\\frac{1}{\\sqrt{1 - a_0^2}}'],
            arccos: ['\\frac{-1}{\\sqrt{1 - a_0^2}}'],
            arctan: ['\\frac{1}{1 + a_0^2}'],
            sinh: ['\\cosh(a_0)'],
            cosh: ['\\sinh(a_0)'],
            tanh: ['(\\sech(a_0))^2'],
            arcsinh: ['\\frac{1}{\\sqrt{a_0^2 + 1}}'],
            arccosh: ['\\frac{1}{\\sqrt{a_0^2 - 1}}'],
            arctanh: ['\\frac{1}{1 - a_0^2}'],
            factorial: ['(a_0)!*\\polyGamma(0, a_0 + 1)'],
            floor: ['\\left\\{ \\mod(a_0, 1) > 0: 0 \\right\\}'],
            ceil: ['\\left\\{ \\mod(a_0, 1) > 0: 0 \\right\\}'],
            round: [
      '\\left\\{ \\abs(\\mod(a_0, 1) - 0.5) > 0: 0 \\right\\}'
    ],
            abs: ['\\left\\{ \\abs(a_0) > 0: \\sign(a_0) \\right\\}'],
            sign: ['\\left\\{ \\abs(a_0) > 0: 0 \\right\\}'],
            log: [
            // d/dx ln(x) is actually real for negative x, too, but showing the
            // derivative in places where we don't show the function is confusing,
            // so restrict to x > 0.
      '\\left\\{a_0 > 0: \\frac{1}{a_0*\\ln(a_1)}\\right\\}',
      '\\frac{-\\log_{a_1}(a_0)}{a_1*\\ln(a_1)}'
    ],
            pow: [
      'a_1*a_0^{a_1 - 1}',
      'a_0^{a_1}*\\ln(a_0)'
    ],
            nthroot: [
      'a_0^{1/a_1 - 1}/a_1',
      '-\\frac{a_0^{1/a_1}*\\ln(a_0)}{a_1^2}'
    ],
            polyGamma: [
      '0/0',
      '\\polyGamma(1 + a_0, a_1)'
    ],
            // Taking care to leave the derivative undefined for min(x, c) when x == c
            // Not sure how to make the case of d/dx min(x, x) = 1 work right
            min: [
      '\\left\\{ a_0 < a_1 : 1, a_0 > a_1 : 0 \\right\\}',
      '\\left\\{ a_1 < a_0 : 1, a_1 > a_0 : 0 \\right\\}'
    ],
            max: [
      '\\left\\{ a_0 > a_1 : 1, a_0 < a_1 : 0 \\right\\}',
      '\\left\\{ a_1 > a_0 : 1, a_1 < a_0 : 0 \\right\\}'
    ],
            mod: [
      '\\left\\{ \\abs(\\mod(a_0, a_1)) > 0: 1 \\right\\}',
            // Check whether division results in an integer directly instead
            // of computing mod of the args because division sometimes results
            // in an integer when modulus does not result in 0, e.g.
            //
            // 3.8 % -0.7599999999999999 -> 3.3306690738754696e-16, but
            // 3.8 / -0.7599999999999999 -> -5
            //
            // This can confuse the jump detector, resulting in spurious
            // connections.
            //
            //TODO still have some spurious connections near 0 in d/dx mod(3,x).
            // Why?
      '\\left\\{ \\mod(a_0/a_1, 1) > 0: -\\floor(a_0/a_1) \\right\\}'
    ]
        };

        var derivativeTable = {};

        // Turn derivativeStrings into substitution functions by mapping
        // substituteFn. Extra scope is to keep 'identifier' from leaking.
        ; (function () {
            var ds = derivativeStrings;
            var dt = derivativeTable;
            var substituteFn = DerivativeHelpers.substituteFn;
            for (var identifier in ds) {
                if (!ds.hasOwnProperty(identifier)) continue;
                dt[identifier] = ds[identifier].map(substituteFn);
            }
        })();

        var registerReciprocalDerivative = function (symbol, reciprocal) {
            derivativeTable[reciprocal] = [function (args) {
                return NegationNode.reduce(BinaryOperatorNode.reduce(
        '/',
        derivativeTable[symbol][0](args),
        BinaryOperatorNode.reduce(
          '^',
          FunctionNode(IdentifierNode(symbol), args),
          ConstantNode(2)
        )
      ));
            } ];
        };

        [
    ['sin', 'csc'],
    ['cos', 'sec'],
    ['tan', 'cot'],
    ['sinh', 'csch'],
    ['cosh', 'sech'],
    ['tanh', 'coth']
  ].forEach(function (pair) {
      registerReciprocalDerivative(pair[0], pair[1]);
  });

        var registerInverseReciprocalDerivative = function (symbol, reciprocal) {
            derivativeTable[reciprocal] = [function (args) {
                return NegationNode.reduce(BinaryOperatorNode.reduce(
        '/',
        derivativeTable[symbol][0]([
          BinaryOperatorNode.reduce('/', ConstantNode(1), args[0])
        ]),
        BinaryOperatorNode.reduce('^', args[0], ConstantNode(2))
      ));
            } ];
        };

        [
    ['arcsin', 'arccsc'],
    ['arccos', 'arcsec'],
    ['arctan', 'arccot'],
    ['arcsinh', 'arccsch'],
    ['arccosh', 'arcsech'],
    ['arctanh', 'arccoth']
  ].forEach(function (pair) {
      registerInverseReciprocalDerivative(pair[0], pair[1]);
  });

        var undefinedFn = function () { return ConstantNode(NaN); };

        // Assumes arity 2
        var registerUndefinedDerivative = function (symbol) {
            derivativeTable[symbol] = [undefinedFn, undefinedFn];
        };

        // We actually round arguments for these functions, so to be consistent,
        // these could be defined as 0 except at integers where they're undefined,
        // but that is not a standard definition.
        //
        // Can also define continuous nCr and nPr using gamma function.
        //
        //TODO useful error messages for these?
        ['lcm', 'gcd', 'nCr', 'nPr'].forEach(registerUndefinedDerivative);

        node.takeDerivative = function (frame, variable) {
            if (this.freeOf(frame, variable)) return ConstantNode(0);

            var identifier = this.identifier.identifier;

            var args = this.args;
            var partials;
            var tree;
            if (derivativeTable.hasOwnProperty(identifier)) {
                partials = derivativeTable[identifier];
            } else if (frame.hasFunction(identifier)) {
                partials = frame.getFunctionTree(identifier).computePartials(frame);
            } else if (this.args.length === 1 && frame.hasVariable(identifier)) {
                // Treat as implicit multiplication
                return BinaryOperatorNode(
        '*',
        this.identifier,
        this.args[0]
      ).takeDerivative(frame, variable);
            } else {
                return _super.takeDerivative.call(this, frame, variable);
            }

            var nargs = args.length;

            var firstTerm = DerivativeHelpers.chain(
      frame,
      variable,
      partials[nargs - 1](args),
      args[nargs - 1]
    );

            // Implements the chain rule for multi-argument functions. Called
            // recursively to build up a sum using BinaryOperatorNode('+', ...)
            function sumPartials(sumSoFar, n) {
                if (n < 0) return sumSoFar;

                return sumPartials(BinaryOperatorNode.reduce(
        '+',
        sumSoFar,
        DerivativeHelpers.chain(
          frame,
          variable,
          partials[n](args),
          args[n]
        )
      ), n - 1);
            }

            return sumPartials(firstTerm, this.args.length - 2);
        };

        node.freeOf = function (frame, variable) {
            return this.args.every(function (arg) {
                return arg.freeOf(frame, variable);
            }) && this.identifier.freeOf(frame, variable);
        };

        node.substitute = function (frame) {
            return FunctionNode(
      this.identifier,
      this.args.map(function (arg) {
          return arg.substitute(frame);
      })
    );
        };
    });

    FunctionDeclarationNode.open(function (node) {
        node.computePartials = function (frame) {
            var self = this;
            return self.args.map(function (arg) {
                var dtree = self.expression.takeDerivative(frame, arg);
                return function (args) {
                    var argFrame = EvalFrame(frame);
                    var valFrame = EvalFrame(frame);
                    for (var i = 0; i < self.args.length; i++) {
                        tmp = IdentifierNode(self.tmp());
                        argFrame.setVariable(self.args[i].identifier, tmp);
                        valFrame.setVariable(tmp.identifier, args[i]);
                    }
                    // Use temporary identifiers to avoid putting self-referencing
                    // substitutions in the same frame, i.e. x->2x, since substitute
                    // works recursively.
                    return dtree.substitute(argFrame).substitute(valFrame);
                };
            });
        };
    });

    FunctionCallExponentNode.open(function (node) {
        node.takeDerivative = function (frame, variable) {
            return this.getEquivalentNode(frame).takeDerivative(frame, variable);
        };

        node.freeOf = function (frame, variable) {
            return this.getEquivalentNode(frame).freeOf(frame, variable);
        };

        node.substitute = function (frame) {
            return this.getEquivalentNode(frame).substitute(frame);
        };
    });

    IdentifierNode.open(function (node) {
        node.takeDerivative = function (frame, variable) {
            if (variable.identifier === this.identifier) return ConstantNode(1);
            if (!frame.hasVariable(this.identifier)) return ConstantNode(0);
            return frame.getVariable(this.identifier).takeDerivative(frame, variable);
        };

        node.freeOf = function (frame, variable) {
            if (variable.identifier === this.identifier) return false;
            if (!frame.hasVariable(this.identifier)) return true;
            return frame.getVariable(this.identifier).freeOf(frame, variable);
        };

        node.substitute = function (frame) {
            if (!frame.hasVariable(this.identifier)) return this;

            return frame.getVariable(this.identifier).substitute(frame);
        };

    });

    NegationNode.open(function (node) {
        node.takeDerivative = function (frame, variable) {
            if (this.freeOf(frame, variable)) return ConstantNode(0);
            return NegationNode.reduce(this.expression.takeDerivative(frame, variable));
        };

        node.freeOf = function (frame, variable) {
            return this.expression.freeOf(frame, variable);
        };

        node.substitute = function (frame) {
            return NegationNode.reduce(this.expression.substitute(frame));
        };
    });

    PiecewiseNode.open(function (node) {
        //NOTE doesn't differentiate the condition (expect this to only produce
        // delta functions)
        node.takeDerivative = function (frame, variable) {
            if (this.freeOf(frame, variable)) return ConstantNode(0);

            var pn = PiecewiseNode(
      this.condition,
      this.if_expr.takeDerivative(frame, variable)
    );

            if (this.else_expr) {
                pn.append_else(this.else_expr.takeDerivative(frame, variable));
            }

            return pn;
        };

        //TODO ignores the condition for now. Only want to traverse nodes that
        // derivative traverses.
        node.freeOf = function (frame, variable) {
            if (!this.else_expr) {
                return (
        this.condition.freeOf(frame, variable) &&
        this.if_expr.freeOf(frame, variable)
      );
            }
            return (
      this.condition.freeOf(frame, variable) &&
      this.if_expr.freeOf(frame, variable) &&
      this.else_expr.freeOf(frame, variable)
    );
        };

        node.substitute = function (frame) {
            var pn = PiecewiseNode(
      this.condition.substitute(frame),
      this.if_expr.substitute(frame)
    );

            if (this.else_expr) pn.append_else(this.else_expr.substitute(frame));

            return pn;
        };
    });

    RepeatedOperatorNode.open(function (node) {
        node.freeOf = function (frame, variable) {
            return (
      this.index.freeOf(frame, variable) &&
      this.lower_bound.freeOf(frame, variable) &&
      this.upper_bound.freeOf(frame, variable) &&
      this.summand.freeOf(frame, variable)
    );
        };

        node.substitute = function (frame) {
            // If the index is in the substitution map, replace it before substituting
            //TODO is this necessary?
            var index = this.index;
            var newFrame = EvalFrame(frame);
            var newIndex;
            if (frame.hasVariable(index)) {
                newIndex = IdentifierNode(this.tmp());
                newFrame.setVariable(index.identifier, newIndex);
            } else {
                newIndex = index;
            }

            // Note, can't call this.constructor(...) directly because it's a pjs
            // corner case. See https://github.com/jayferd/pjs/issues/9
            var constructor = this.constructor;
            return constructor(
      newIndex,
      this.lower_bound.substitute(frame),
      this.upper_bound.substitute(frame),
      this.summand.substitute(newFrame)
    );
        };
    });

    SummationNode.open(function (node) {
        node.takeDerivative = function (frame, variable) {
            if (this.freeOf(frame, variable)) return ConstantNode(0);

            return SummationNode(
      this.index,
      this.lower_bound,
      this.upper_bound,
      this.summand.takeDerivative(frame, variable)
    );
        };
    });

    //TODO ProductNode not implemented. The easy way to write this involves
    // divisions of terms that could be zero
    // node.takeDerivative = function (frame, variable)


    // Nodes that can be graphed need to be able to return the derivative of
    // the expression they graph for extremum finding. For example, if we have
    // y = sin(x), the sin(x) part is graphed, so we need to be able to find the
    // derivative of it.
    //
    // Call this 'expressionDerivative' instead of 'takeDerivative' because it
    // isn't really the derivative of the whole node.
    ; (function () {
        var expressionDerivative = function (frame, variable) {
            return this.expression.takeDerivative(frame, variable);
        };

        AssignmentNode.open(function (node) {
            node.substitute = function (frame) {
                return AssignmentNode(this.assigns, this.expression.substitute(frame));
            };

            node.expressionDerivative = expressionDerivative;
        });

        FunctionDeclarationNode.open(function (node) {
            node.substitute = function (frame) {
                return FunctionDeclarationNode(this.assigns, this.args, this.expression.substitute(frame));
            };

            node.expressionDerivative = expressionDerivative;
        });
    })();

    return; //Just re-opens ParseNodes, doesn't return anything

});

//Basically temporary shim to support the API of the current formula object and allow integration into the rest of the system.
//API here is just a direct copy, funny naming and all

define('math/evaluationstate', ['require', 'pjs'], function (require) {
    var P = require('pjs');

    var EvaluationState = P(function (state) {
        state.init = function (analysis, context, statement) {
            this.analysis = analysis;
            this.context = context;
            this.statement = statement;

            this.error = analysis.error;
            this.is_graphable = analysis.status === GRAPHABLE;
            this.is_evaluable = analysis.status === EVALUABLE;
            if (this.is_evaluable) {
                this.zero_values = statement.getZeroValues();
            }
            this.is_point_list = this.is_graphable && this.analysis.graph_info.graphMode === GRAPHMODE_XYPOINT;
            this.is_parametric = this.is_graphable && this.analysis.graph_info.graphMode === GRAPHMODE_PARAMETRIC;
            this.is_shade_between = this.is_graphable && !!statement.shade_between;
            if (this.is_shade_between) {
                this.shade_between_operators = statement.getOperators();
            }
            if (statement) {
                this.operator = statement.getOperator();
                this.assignment = statement.getAssignedVariable();
                this.variables = statement.getSlidableVariables();
                this.simple_constant = statement.getSliderValue();
            } else {
                this.variables = [];
            }
            this.is_slidable = !!analysis.slider;  //Internally true or undefined, nicer to pass true/false to others
            this.is_tableable = this.is_graphable && !this.is_parametric && this.operator === '=';
            if (this.is_tableable) {
                this.table_info = statement.getTableInfo();
            }

            delete this.analysis;
            delete this.context;
            delete this.statement;
        };

        state.computeTableInfo = function () {
            var info = {};
            info.independent_variable = this.analysis.graph_info.independent;

            if (this.analysis.type === VARIABLE_DEFINITION) {
                if (this.context.assignmentForbidden(this.analysis.tree.assigns.identifier)) {  //TODO - doesn't account for multiple definitions yet
                    info.dependent_column = this.statement._tree.expression.getInputString();
                    info.by_reference = false;
                }
                else {
                    info.dependent_column = this.statement._tree.assigns.getInputString();
                    info.by_reference = true;
                }
            }
            else if (this.analysis.type === FUNCTION_DEFINITION) {
                if (this.context.assignmentForbidden(this.statement._tree.assigns.identifier)) {
                    info.dependent_column = this.statement._tree.expression.getInputString();
                    info.by_reference = false;
                }
                else {
                    info.dependent_column = this.statement._tree.getInputString();
                    info.by_reference = true;
                }
            }
            else if (this.analysis.type === ORDERED_PAIR_LIST) {
                info.dependent_column = "\\UNIMPLEMENTED"; //TODO - convert the list of points to a scatter-plot
                info.by_reference = true;
            }
            else {
                info.dependent_column = this.statement._tree.getInputString();
                info.by_reference = false;
            }
            return info;
        };
    });
    return EvaluationState;
});

define('math/evaluatorobject', ['require', 'pjs', './parser_util', './plotter', './comparators', './evalframe', './quadratic', './derivative', './functions', './evaluationstate'], function (require) {
    var P = require('pjs');
    var Parser = require('./parser_util');
    var Plotter = require('./plotter');
    var Comparators = require('./comparators');
    var EvalFrame = require('./evalframe');
    var Quadratic = require('./quadratic');
    var derivative = require('./derivative');
    var functions = require('./functions');
    var EvaluationState = require('./evaluationstate');

    //TODO - need to export Nodes from parse_util into namespace
    var AnalysisClass = {}; //Map object type to analysis class

    var ConstantNode = Parser.ConstantNode;
    var IdentifierNode = Parser.IdentifierNode;
    var ErrorNode = Parser.ErrorNode;
    var BinaryOperatorNode = Parser.BinaryOperatorNode;

    var AnalysisObject = P(function (obj) {
        obj.init = function (context) {
            this._context = context;
            this._analysis = null;
        };

        obj.exportDefinitionsTo = function (frame) {
        };

        obj.getAllIds = function () {
            return [];
        };

        obj.cleanupId = function (id) {
            throw "base analysis object can't cleanup ID";
        };

        obj.invalidate = function () {
            this._analysis = null;
        };

        obj.getAnalysis = function () {
            if (!this._analysis) this._context.updateAnalysis();
            return this._analysis;
        };

        obj.setAnalysis = function (analysis) {
            this._analysis = analysis;
        };

        obj.shouldIntersect = function () {
            return false;
        };

        obj.graphModeFromVariables = function (independent, dependent) {
            if (dependent === 'x' || independent === 'y') return GRAPHMODE_X;
            if ((dependent === 'r' && independent === 'theta') ||
       (dependent === 'r' && independent === undefined) ||
       (dependent === undefined && independent === 'theta')) {
                return GRAPHMODE_POLAR;
            }
            return GRAPHMODE_Y;
        };


        obj.setGraphMode = function (mode, independent, dependent) {
            if (dependent === 'y' && !independent) independent = 'x';
            if (dependent === 'x' && !independent) independent = 'y';
            if (dependent === 'r' && !independent) independent = 'theta';

            if (!mode) {
                mode = this.graphModeFromVariables(independent, dependent);
            }
            this._analysis.graph_info = {
                color: this._statement.color,
                graphMode: mode,
                independent: independent,
                dependent: dependent,
                operator: this.getOperator(),
                domain: this._statement.domain //Only defined for parametric.  One day for polar also
            };
            return GRAPHABLE;
        };

        obj.computeGraphData = function (viewport) {
        };

        obj.getStatus = function () {
            return this.getAnalysis().status;
        };

        obj.getAssignedVariable = function () {
            return null; //TODO - override for variable definitions and equations
        };

        obj.compile = function () {
            return undefined;
        };

        obj.getSlidableVariables = function () {
            return [];
        };

        obj.getSliderValue = function () {
            return NaN;
        };

        obj.getZeroValues = function () {
            return [];
        };

        obj.addFreeVariables = function (variables) {
            for (var i = 0; i < variables.length; i++) {
                var variable = variables[i];
                if (this._analysis.free_variables.indexOf(variable) > -1) continue;
                this._analysis.free_variables.push(variable);
            }
        };

    });

    var StatementAnalysis = P(AnalysisObject, function (obj, _super) {
        obj.init = function (context, statement, tree) {
            _super.init.call(this, context);
            this._statement = statement;
            this._tree = tree;
            this.id = statement.id;

            //TODO - get rid of these copies.  They're here to make the transition easier
            this.shouldGraph = statement.shouldGraph;
            this.color = statement.color;
            this.domain = statement.domain;
        };

        obj.getAllIds = function () {
            return [this.id];
        };

        obj.getGraphInfo = function () {
            return this._analysis.graph_info;
        };

        obj.shouldIntersect = function () {
            if (!this.shouldGraph) return false;
            if (this.getStatus() !== GRAPHABLE) return false;
            var graphMode = this.getGraphInfo().graphMode;
            return (graphMode === GRAPHMODE_Y || graphMode === GRAPHMODE_X);
        };

        obj.computeGraphData = function (viewState) {
            var graphData = {};

            //Compile
            var frame = this._context.getFrame();
            var compiled = this.compile(frame);
            compiled.fn.derivative = this.compileDerivative(frame).fn;

            //Figure out graphMode
            var graph_info = this._analysis.graph_info;

            //Actually fill out graphData
            graphData[this.id] = Plotter.computeGraphData(viewState, graph_info, compiled.fn);
            graphData[this.id][0].compiled = compiled;

            return graphData;
        };

        obj.getEvaluationState = function () {
            return EvaluationState(this._analysis, this._context, this);
        };

        obj.computeStatus = function () {
            return this.markError("Unimplemented status check");
        };

        obj.getZeroValues = function () {
            return [{ val: this._tree.evaluateOnce(this._context.getFrame()), operator: '='}];
        };

        obj.referencesSymbol = function (symbol) {
            return this._tree.references(symbol);
        };

        obj.referencedSymbols = function (symbol) {
            return this._tree._referencedSymbols;
        };

        obj.getSlidableVariables = function () {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length < 2) return [];
            var variables = [];
            for (var i = 0; i < free_variables.length; i++) {
                var variable = free_variables[i];
                if (this._context.assignmentForbidden(variable)) continue;
                variables.push(variable);
            }
            return variables;
        };

        obj.exportedSymbols = function () {
            //assignment or function declaration
            var exported = {};
            if (this._tree.assigns)
                exported[this._tree.assigns.identifier] = this._tree.arity;
            return exported;
        };

        obj.exportDefinitionsTo = function (frame) {
            if (!this._tree.assigns) return;
            var symbol = this._tree.assigns.identifier;
            if (this._context.assignmentForbidden(symbol)) return;
            this._tree.exportDefinitionsTo(frame);

            //Export definitions for compilation
            try {
                var evalString = this._tree.getEvalStrings(frame);
                frame.setEvalStrings(this.exported, evalStrings);
            }
            catch (e) {
            }
        };

        obj.shadowedSymbols = function () {
            return [];
        };

        obj.getDependencies = function () {
            return this._tree.dependencies();
        };

        obj.getType = function () {
            return this._tree.statementType;
        };

        obj.freeVariablesError = function (free_variables) {
            for (var i = 0; i < free_variables.length; i++) {
                if (this._context.assignmentForbidden(free_variables[i])) continue;
                var msg = "Too many free variables to graph.  Try defining '" + free_variables[i] + "'.";
                return this.markError(msg);
            }
            return this.markError("Too many free variables.  I don't know what to do with this");
        };

        obj.getParseError = function () {
            if (this._tree.valid) return undefined;
            return this._tree.error_msg;
        };

        obj.markError = function (msg) {
            this._analysis.error = msg;
            this._analysis.status = ERROR;
            return ERROR;
        };

        obj.evaluateOnce = function (frame) {
            return this._tree.evaluateOnce(frame);
        };

        obj.evalStrings = function (frame) {
            return this._tree.getEvalStrings(frame);
        };

        obj.compileAllBranches = function (frame) {
            return [this.compile(frame)];
        };

        obj.compile = function (frame) {
            var source = this.compile_to_strings(frame, this.independent_variable());
            source.fn = functions.compile(source.args, source.function_string);
            return source;
        };

        obj.compileDerivative = function (frame) {
            var independent_variable = this.independent_variable();
            var identifier = IdentifierNode(independent_variable);
            var derivative_tree;
            if (this._tree.expressionDerivative) {
                derivative_tree = this._tree.expressionDerivative(frame, identifier);
            } else {
                derivative_tree = this._tree.takeDerivative(frame, identifier);
            }

            //TODO CLEANUP Making a new object like this is a bit of a hack. Consider
            // changing interface of compile functions so we don't need to pass as
            // much stuff.
            var derivativeObject = StatementAnalysis(
      this._context,
      this._statement,
      derivative_tree
    );
            var source = derivativeObject.compile_to_strings(frame,
      independent_variable);
            source.fn = functions.compile(source.args, source.function_string);
            return source;
        };

        obj.independent_variable = function () {
            if (this._analysis.status === GRAPHABLE) {
                return this._analysis.graph_info.independent;
            } else if (this._analysis.free_variables.length === 1) {
                return this._analysis.free_variables[0];
            }
        };

        obj.compile_to_strings = function (frame, independent_variable) {
            var eval_strings = this._tree.getEvalStrings(frame);

            var function_string = eval_strings.statements + 'return ' + eval_strings.expression;
            return {
                args: [independent_variable],
                function_string: function_string
            };
        };

        obj.getOperator = function () {
            return '=';
        };

        obj.getTableInfo = function () {
            return undefined;
        };

        obj.getTableInfo = function () {
            return {
                independent_variable: this._analysis.graph_info.independent,
                dependent_column: this._tree.getInputString(),
                by_reference: false
            };
        };

    });

    AnalysisClass[EXPRESSION] = P(StatementAnalysis, function (obj, _super) {
        obj.computeStatus = function (frame) {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length === 0) return EVALUABLE;
            if (free_variables.length === 1) {
                switch (free_variables[0]) {
                    case 'x': return this.setGraphMode(GRAPHMODE_Y, 'x');
                    case 'y': return this.markError("Maybe you wanted to plot x as a function of y?");
                    case 'r':     //Fall through to theta
                    case 'theta': return this.markError("Maybe you wanted to plot r as a function of 胃?");
                    default: return this.markError("Maybe you wanted to plot x or y as a function of " + free_variables[0] + "?");
                }
            }
            return this.freeVariablesError(free_variables);
        };
    });

    AnalysisClass[FUNCTION_DEFINITION] = P(StatementAnalysis, function (obj, _super) {
        obj.init = function (context, statement, tree) {
            _super.init.call(this, context, statement, tree);
            this.arity = this._tree.arity;
        };

        obj.shadowedSymbols = function () {
            return this._tree.passed_variables;
        };

        obj.computeStatus = function (frame) {
            if (this._tree.arity === 1) {
                if (this._tree.assigns.identifier === this._tree.passed_variables[0]) {
                    return this.markError("You can't use " + s.tree.assigns.identifier + " as both the function name and the argument");
                }
                if (this._analysis.free_variables.length > 0) { //f(x) = a with a undefined shouldn't plot vs. a
                    return this.markError("Every variable you use in the function must be defined.  Either define '" + this._analysis.free_variables[0] + "' or pass it in as an argument");
                }
                return this.setGraphMode(undefined, this._tree.passed_variables[0], this._tree.assigns.identifier);
            }
            if (this._tree.arity > 1) return WARNING; //TODO - need to handle these warnings in the UI
        };

        obj.addFreeVariables = function (variables) {
            var passed_variables = this._tree.passedVariables();
            for (var i = 0; i < variables.length; i++) {
                var variable = variables[i];
                if (passed_variables.indexOf(variable) > -1) continue;
                if (this._analysis.free_variables.indexOf(variable) > -1) continue;
                this.markError("Every variable you use in the function must be defined.  Either define '" + variable + "' or pass it in as an argument");
                this._analysis.free_variables.push(variable);
            }
        };

        obj.conflictError = function (symbol) {
            var msg = '"' + symbol + '" is already defined, so you can\'t reuse it as one of the parameters of this function';
            return this.markError(msg);
        };

        obj.getTableInfo = function () {
            if (this._context.assignmentForbidden(this._tree.assigns.identifier)) {
                return {
                    independent_variable: this._analysis.graph_info.independent,
                    dependent_column: this._tree.expression.getInputString(),
                    by_reference: false
                };
            } else {
                return {
                    independent_variable: this._analysis.graph_info.independent,
                    dependent_column: this._tree.getInputString(),
                    by_reference: true
                };
            }
        };

        obj.getSlidableVariables = function () {
            var free_variables = this._analysis.free_variables;
            var variables = [];
            for (var i = 0; i < free_variables.length; i++) {
                var variable = free_variables[i];
                if (this._context.assignmentForbidden(variable)) continue;
                variables.push(variable);
            }
            return variables;
        };

    });


    AnalysisClass[VARIABLE_DEFINITION] = P(StatementAnalysis, function (obj, _super) {
        obj.computeStatus = function (frame) {
            var variable = this._tree.assigns.identifier;
            var free_variables = this._analysis.free_variables;
            if (variable === 'theta') {
                //TODO - support this
                return this.markError("Sorry - can't graph 胃 as a function of anything yet");
            }
            if (free_variables.length === 0) {
                var should_slide = (this._tree.expression instanceof ConstantNode);
                if (should_slide) this._analysis.slider = true;

                if ('xyr'.indexOf(variable) !== -1) return this.setGraphMode(undefined, undefined, variable);
                return should_slide ? SILENT : EVALUABLE;  //Don't display the value next to a slider
            }
            if (free_variables.length === 1) {
                if (free_variables[0] === variable) {
                    //TODO - needs better message (at least)
                    return this.markError('Cannot define ' + free_variables[0] + ' in terms of itself.');
                }
                if (free_variables[0] === 'r') {
                    return this.markError('Maybe you wanted to plot r as a function of 胃?');
                }
                return this.setGraphMode(undefined, free_variables[0], variable);
            }
            return this.freeVariablesError(free_variables);
        };

        obj.getAssignedVariable = function () {
            return this._tree.assigns.identifier;
        };

        obj.getSliderValue = function () {
            if (this._tree.expression instanceof ConstantNode) {
                return this._tree.evaluateOnce();
            }
            return _super.getSliderValue();
        };

        obj.getTableInfo = function () {
            if (this._context.assignmentForbidden(this._tree.assigns.identifier)) {
                return {
                    independent_variable: this._analysis.graph_info.independent,
                    dependent_column: this._tree.expression.getInputString(),
                    by_reference: false
                };
            } else {
                return {
                    independent_variable: this._analysis.graph_info.independent,
                    dependent_column: this._analysis.graph_info.dependent,
                    by_reference: true
                };
            }
        };
    });

    AnalysisClass[IDENTIFIER] = P(StatementAnalysis, function (obj, _super) {
        obj.computeStatus = function (frame) {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length === 1 && free_variables[0] === 'x') return this.setGraphMode(GRAPHMODE_Y, 'x');
            if (free_variables.length > 0) return SILENT;
            return EVALUABLE;
        };
    });

    AnalysisClass[CONSTANT] = P(StatementAnalysis, function (obj, _super) {
        obj.computeStatus = function (frame) {
            return SILENT;
        };

        obj.getSliderValue = function () {
            return this._tree.evaluateOnce();
        };
    });

    AnalysisClass[ORDERED_PAIR_LIST] = P(StatementAnalysis, function (obj, _super) {
        obj.computeStatus = function (frame) {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length === 0) {
                return this.setGraphMode(GRAPHMODE_XYPOINT);
            }

            if (this._tree.elements.length > 1) {
                return this.markError("A list of points can't have free variables");
            }

            if (free_variables.length === 1) {
                if (free_variables[0] === 't') {
                    return this.setGraphMode(GRAPHMODE_PARAMETRIC, 't');
                }
                return this.markError("Define" + free_variables[0] + " to plot this point, or make each coordinate a function of t to plot it as a parametric function");
            }

            if (free_variables.length > 1) {
                return this.freeVariablesError(free_variables);
            }
        };

        obj.getSlidableVariables = function () {
            //Don't offer to create a slider for t
            var variables = _super.getSlidableVariables.call(this);
            var index = variables.indexOf('t');
            if (index > -1) {
                variables.splice(index, 1);
            }
            return variables;
        };

        obj.computeGraphData = function (viewState) {
            //Figure out graphMode
            var graph_info = this._analysis.graph_info;
            var graphData = {};

            //Test if we're points
            if (graph_info.graphMode === GRAPHMODE_XYPOINT) {
                var points = this._tree.evaluateOnce(this._context.getFrame());
                datum = {
                    segments: [points],
                    graphMode: GRAPHMODE_XYPOINT,
                    color: this._statement.color,
                    poi: []
                };
                graphData[this.id] = [datum];
                return graphData;
            }

            //Plot parametric

            //Compile
            var compiled = this.compile(this._context.getFrame());
            var fn = function (x) { return compiled.fn(x)[0] };  //TODO - fix this with compileAllBranches
            graphData[this.id] = Plotter.computeGraphData(viewState, graph_info, fn);

            return graphData;
            //Start intersections going (TODO - make sure starting / stopping these is still correct)
        };

        obj.getTableInfo = function () {
            var values = this._tree.evaluateOnce(this._context.getFrame());
            return {
                independent_variable: 'x',
                dependent_column: 'y',
                by_reference: false,
                values: values
            };
        };

    });

    AnalysisClass[DOUBLE_INEQUALITY] = P(StatementAnalysis, function (obj, _super) {
        obj.init = function (context, statement, tree) {
            _super.init.call(this, context, statement, tree);
            this._inequalities = [];
            for (var i = 0; i < 2; i++) {
                var subtree = tree.getInequality(i);
                this._inequalities.push(AnalysisClass[COMPARATOR](context, statement, subtree));
            }
        };

        obj.shade_between = true;

        obj.computeStatus = function (frame) {
            for (var i = 0; i < 2; i++) {
                this._inequalities[i].setAnalysis({ free_variables: this._analysis.free_variables });
            }
            var statuses = this._inequalities.map(function (x) { return x._analysis.status = x.computeStatus(frame) }); //Compute status for each sub-inequality

            if (statuses[0] === GRAPHABLE && statuses[1] === GRAPHABLE) {
                this._analysis.graph_info = this._inequalities[0]._analysis.graph_info;
                if (this._analysis.graph_info.graphMode === GRAPHMODE_POLAR)
                    return this.markError('Two-sided inequalities are only supported for x and y.  You can do one-sided polar inequalities.');
                return GRAPHABLE;
            }
            else {
                return this.markError('One or more sub-inequality had an error'); //TODO - good error messages and detection
            }
        };

        obj.computeGraphData = function (frame) {
            var id = this.id;
            var graphData = {};
            graphData[id] = [];

            var bottom_first;

            var updateOperator = function (s) {
                s.operator = Comparators.get(Comparators.table[s.operator].inclusive, 0);
            };

            for (var i = 0; i < 2; i++) {
                var subGraphData = this._inequalities[i].computeGraphData(frame)[id].slice(0, 4);
                subGraphData.forEach(updateOperator);
                graphData[id].push.apply(graphData[id], subGraphData);
            }

            var graphMode = graphData[id][0].graphMode;
            var polygons;

            polygons = Plotter.polygonsFromSegments(graphData[id][4].segments, graphData[id][0].segments, graphMode);

            graphData[id].push(
      {
          graphMode: GRAPHMODE_POLYGONFILL,
          segments: polygons,
          poi: {}
      }
    );

            polygons = Plotter.polygonsFromSegments(graphData[id][7].segments, graphData[id][3].segments, graphMode);

            graphData[id].push(
      {
          graphMode: GRAPHMODE_POLYGONFILL,
          segments: polygons,
          poi: {}
      }
    );

            return graphData;
        };

        obj.compileAllBranches = function (frame) {
            compiled = [];
            for (var i = 0; i < 2; i++) {
                compiled.push.apply(compiled, this._inequalities[i].compileAllBranches(frame));
            }
            return compiled;
        };

        obj.getOperators = function () {
            return [this._inequalities[0].getOperator(),
            this._inequalities[1].getOperator()];
        };

    });

    AnalysisClass[EQUATION] = P(StatementAnalysis, function (obj, _super) {
        obj.init = function (context, statement, tree) {
            _super.init.call(this, context, statement, tree);
            this.temp_tree = BinaryOperatorNode('-', this._tree.lhs, this._tree.rhs);
        };

        //Figure out which variables to solve for, save solution in analysis
        obj.computeStatus = function (frame) {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length > 2) return this.freeVariablesError(free_variables);

            if (free_variables.length === 2) {
                //Might be graphable, if variables are X and Y;
                if ((free_variables[0] === 'x' && free_variables[1] === 'y') ||
         (free_variables[0] === 'y' && free_variables[1] === 'x')) {
                    var x_order = this.temp_tree.polynomialOrder(frame, 'x');
                    var y_order = this.temp_tree.polynomialOrder(frame, 'y');
                    if (y_order <= 2) return this.setGraphMode(GRAPHMODE_Y, 'x', 'y');
                    if (x_order <= 2) return this.setGraphMode(GRAPHMODE_X, 'y', 'x');
                    return this.markError("Equation is too complicated.  One variable needs to be quadratic.");
                }
                return this.markError('You can only plot implicit equations of x and y');
            }

            if (free_variables.length === 1) {
                //Might be evaluable, let's try
                var solution = this.solveEvaluable(frame);
                if (solution) {
                    this._analysis.solution = solution;
                    return EVALUABLE;
                }
                else {
                    return this.markError('Sorry - unable to solve this equation.  Try something like a quadratic?');
                }
            }

            if (free_variables.length === 0) {
                return this.markError("This equation has no variables in it - there's nothing to solve");
                //TODO - support boolean true/false tests with equals sign
            }
        };

        obj.solveEvaluable = function (frame) {
            var coeffs, roots;

            if (this._analysis.free_variables.length != 1) return false;

            var variable = this._analysis.free_variables[0];
            var order = this.temp_tree.polynomialOrder(frame, variable);

            switch (order) {
                case 1:
                    coeffs = this.temp_tree.quadraticCoefficients(frame, variable);
                    roots = [-coeffs[2] / coeffs[1]];
                    break;
                case 2:
                    coeffs = this.temp_tree.quadraticCoefficients(frame, variable);
                    roots = Quadratic.formula(coeffs);
                    break;
                default:
                    return false;
            }

            return { roots: roots, variable: variable };
        };

        obj.getZeroValues = function () {
            var retval = [];
            var roots = this._analysis.solution.roots;
            for (var i = 0; i < roots.length; i++) {
                retval.push({ val: roots[i], operator: '=' });
            }
            return retval;
        };

        obj.getAssignedVariable = function () {
            switch (this._analysis.status) {
                case EVALUABLE:
                    return this._analysis.solution.variable;
                case GRAPHABLE:
                    return this._analysis.graph_info.dependent;
            }
        };

        obj.computeGraphData = function (viewState) {
            var graphData = {};
            var compiled = this.compileAllBranches(this._context.getFrame());
            var graph_info = this._analysis.graph_info;

            graphData[this.id] = [];
            for (var i = 0; i < compiled.length; i++) {
                var data = Plotter.computeGraphData(viewState, graph_info, compiled[i].fn)[0];
                data.compiled = compiled[i];
                graphData[this.id].push(data);
            }
            return graphData;
        };

        obj.compileAllBranches = function (frame) {
            var compiled = [];
            var independent = this._analysis.graph_info.independent;
            var dependent = this._analysis.graph_info.dependent;
            var coeffEvalStrings = this.temp_tree.polynomialEvalStrings(frame, dependent, independent);

            var evalStrings = Quadratic.formulaEvalStrings(coeffEvalStrings);

            var args = [independent];
            for (var i = 0; i < evalStrings.length; i++) {
                compiled.push({ fn: functions.compile(args, evalStrings[i]), args: args, function_string: evalStrings[i] });
            }
            return compiled;
        };
    });

    AnalysisClass[COMPARATOR] = P(StatementAnalysis, function (obj, _super) {
        obj.init = function (context, statement, tree) {
            _super.init.call(this, context, statement, tree);
            var operator = this._tree.operator;
            if (Comparators.table[operator].direction === 1) {
                this.temp_tree = BinaryOperatorNode(
        '-',
        this._tree.args[0],
        this._tree.args[1]
      );
            } else {
                this.temp_tree = BinaryOperatorNode(
        '-',
        this._tree.args[1],
        this._tree.args[0]
      );
            }
        };

        obj.computeStatus = function (frame) {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length === 0) return EVALUABLE;

            var singleVariables = { x: true, y: true, r: true };

            var fv0 = free_variables[0], fv1 = free_variables[1];
            var order0, x_order, y_order, r_order;

            if (free_variables.length === 1) {
                if (!singleVariables.hasOwnProperty(fv0)) {
                    return this.markError('We only plot inequalities of x and y, or r and theta');
                }

                order0 = this.temp_tree.polynomialOrder(frame, fv0);
                if (fv0 === 'r' && order0 > 1) {
                    return this.markError('We only plot polar inequalities that are first order in r.');
                }
                if (order0 > 2) {
                    return this.markError('Equation too complicated. One variable needs to be quadratic');
                }

                return this.setGraphMode(undefined, undefined, fv0);
            }

            var twoVariables = { x: 'y', y: 'x', r: 'theta', theta: 'r' };

            if (free_variables.length === 2) {
                if (twoVariables[fv0] !== fv1) {
                    return this.markError('We only plot inequalities of x and y, or r and theta');
                }

                if (fv0 === 'r' || fv1 === 'r') {
                    r_order = this.temp_tree.polynomialOrder(frame, 'r');
                    if (r_order > 1) {
                        return this.markError('We only plot polar inequalities that are first order in r.');
                    }
                    return this.setGraphMode(GRAPHMODE_POLAR, 'theta', 'r');
                }

                x_order = this.temp_tree.polynomialOrder(frame, 'x');
                y_order = this.temp_tree.polynomialOrder(frame, 'y');
                if (y_order <= 2) return this.setGraphMode(GRAPHMODE_Y, 'x', 'y');
                if (x_order <= 2) return this.setGraphMode(GRAPHMODE_X, 'y', 'x');
                return this.markError("Equation is too complicated.  One variable needs to be quadratic.");

            }

        };

        obj.computeGraphData = function (viewState) {
            var graphData = {};
            var compiled = this.compileAllBranches(this._context.getFrame());
            var graph_info = this._analysis.graph_info;
            var operator = this._tree.operator;
            var thisGraphData = graphData[this.id] = [];
            var data;

            //TODO this system doesn't work with polar inequalities yet.
            //Currently, this works for first-order polar inequalities by just pushing
            //the single open-ended inequality, and leaving the rest of the branches empty
            //
            //This would need to be fixed to support second-order polar inequalities

            var polarities = [-1, 0, 0, 1];

            for (var i = 0; i < 4; i++) {
                data = Plotter.computeGraphData(
        viewState,
        graph_info,
        compiled[i].fn
      )[0];
                data.compiled = compiled[i];
                data.operator = Comparators.get(
        Comparators.table[operator].inclusive,
        polarities[i]
      );
                thisGraphData.push(data);
            }

            var polygons;

            polygons = Plotter.polygonsFromSegments(
      thisGraphData[1].segments,
      thisGraphData[2].segments,
      thisGraphData[1].graphMode
    );

            thisGraphData.push({
                graphMode: GRAPHMODE_POLYGONFILL,
                segments: polygons,
                poi: {}
            });

            return graphData;
        };

        obj.compileAllBranches = function (frame) {
            var compiled = [];
            var independent = this._analysis.graph_info.independent;
            var dependent = this._analysis.graph_info.dependent;
            var coeffEvalStrings = this.temp_tree.polynomialEvalStrings(frame, dependent, independent);

            var evalStrings = Quadratic.inequalityRegionEvalStrings(coeffEvalStrings);

            var args = [independent];
            for (var i = 0; i < evalStrings.length; i++) {
                compiled.push({ fn: functions.compile(args, evalStrings[i]), args: args, function_string: evalStrings[i] });
            }
            return compiled;
        };

        obj.getOperator = function () {
            return this._tree.operator;
        };

        obj.getSlidableVariables = function () {
            //Don't offer a slider for r
            return _super.getSlidableVariables.call(this).filter(function (v) {
                return (v !== 'r');
            });
        };
    });

    AnalysisClass[CHAINED_COMPARATOR] = P(StatementAnalysis, function (obj, _super) {
        obj.computeStatus = function (frame) {
            var free_variables = this._analysis.free_variables;
            if (free_variables.length === 0) return EVALUABLE;

            return this.markError('We only graph solved double inequalities. Try sin(x) < y < cos(x).');
        };


    });

    var Table = P(AnalysisObject, function (obj, _super) {
        obj.init = function (context, table_description) {
            _super.init.call(this, context);
            this._description = table_description;
            this.id = table_description.id;
            this.ids_to_clean = [];
            this.columns = [];
            this.cell_tree = [];
            for (var i = 0; i < this._description.columns.length; i++) {
                //Not a great solution, but since we're using the same latex parser, this is what makes sense.
                //Might make sense to eventually create a different table-header latex parser which enforces that grammar, so that the parser errors come out properly, but for now I don't think the maintenance overhead is worth it
                if (this._description.columns[i].latex === '' && i > 0) {
                    this._description.columns[i].latex = '\\emptycolumn_' + i; //Make empty columns behave like scatterplot
                }
                var column_analysis = createAnalysisObject(this._context, this._description.columns[i]);
                this.columns.push(column_analysis);
                this.cell_tree[i] = [];
                var values = this._description.columns[i].values;
                for (var row = 0; row < values.length; row++) {
                    if (values[row].trim() === '') {
                        this.cell_tree[i][row] = ErrorNode('');  //Stay silent for empty cells
                        continue;
                    }
                    this.cell_tree[i][row] = Parser.tryParse(values[row]);
                }
            }
            if (this.columns[0]._tree && this.columns[0]._tree instanceof IdentifierNode) {
                this.shadowed_symbols = [this.columns[0]._tree.identifier];
                var symbol = this.shadowed_symbols[0];
                if (symbol === 'y') this.parse_error = "Sorry - can't make a table based on y yet.  Try x?";
                if (symbol === 'r') this.parse_error = "Sorry - can't make a table based on r yet.  Try x?";
            }
            else {
                this.parse_error = 'Tables need a single variable for their first independent column';
                this.shadowed_symbols = [];
            }
            //TODO - throw user-facing errors if any of the columns or rows try to export things
        };

        obj.cleanupId = function (id) {
            this.ids_to_clean.push(id);
        };

        obj.getAllIds = function () {
            var ids = [this.id];
            for (var i = 0; i < this.columns.length; i++) {
                ids.push(this.columns[i].id);
            }
            return ids;
        };

        obj.exportedSymbols = function () {
            //Tables never export anything
            return [];
        };

        obj.shadowedSymbols = function () {
            return this.shadowed_symbols;
        };

        obj.getDependencies = function () {
            //Record all dependencies of all headers as dependencies
            var dependencies = {};
            var dependency;
            for (var i = 0; i < this.columns.length; i++) {
                var column_dependencies = this.columns[i].getDependencies();
                for (dependency in column_dependencies) {
                    if (!column_dependencies.hasOwnProperty(dependency)) continue;
                    //TODO - verify that all dependencies are consistent arity
                    dependencies[dependency] = column_dependencies[dependency];
                }

                //Iterate over rows, for independent columns
                for (var row = 0; row < this.cell_tree[i].length; row++) {
                    var cell_tree = this.cell_tree[i][row];
                    var cell_dependencies = cell_tree.dependencies();
                    for (dependency in cell_dependencies) {
                        dependencies[dependency] = cell_dependencies[dependency];
                    }
                }
            }
            return dependencies;
        };

        obj.referencesSymbol = function (symbol) {
            //Iterate over all headers
            for (var i = 0; i < this.columns.length; i++) {
                //If header references symbol, return true
                if (this.columns[i].referencesSymbol(symbol)) return true;
                //If cell references symbol return true
                for (var row = 0; row < this.cell_tree[i].length; row++) {
                    if (this.cell_tree[i][row].references(symbol)) return true;
                }
            }
            return false;
        };

        obj.getParseError = function () {
            if (this.parse_error) return this.parse_error;
            return this.columns[0].getParseError(); //Only the first column is unrecoverable
        };

        obj.computeStatus = function (frame) {
            if (this.getParseError()) return ERROR;
            for (var i = 0; i < this.columns.length; i++) {
                //Check for un-defined, variable-like dependencies, and define them as free variables
                this.columns[i]._analysis.free_variables = []; //TODO - don't reach in to private members
                var dependencies = this.columns[i].getDependencies();
                for (var dependency in dependencies) {
                    if (!dependencies.hasOwnProperty(dependency)) continue;
                    var arity = dependencies[dependency];
                    if (arity <= 1 && !frame.defines(dependency)) {
                        this.columns[i].addFreeVariables([dependency]);
                    }
                    //TODO - if arity > 1, mark column as error.  We depend on an undefined function
                }
                this.columns[i]._analysis.status = this.columns[i].computeStatus(frame);
            }
            return GRAPHABLE;
        };

        obj.invalidate = function () {
            _super.invalidate.call(this);
            this.columns.forEach(function (column) {
                column.invalidate();
            });
        };

        obj.setAnalysis = function (analysis) {
            _super.setAnalysis.call(this, analysis);
            this.columns.forEach(function (column) {
                column.setAnalysis({});
            });
        };

        obj.getEvaluationState = function () {
            var result;
            var num_rows = this._description.columns[0].values.length;
            var columns_data = [];
            var symbols = [];
            var tmp_frame = EvalFrame(this._context.getFrame()); //Track what has been defined in previous columns
            var independent_frame = EvalFrame(this._context.getFrame());
            var frame = EvalFrame(this._context.getFrame());
            var error;
            for (var column = 0; column < this.columns.length; column++) {
                var is_independent = false;
                var is_continuous = false; //Can this be graphed at all values of the independent variable, or just graph values
                error = null;

                if (this.columns[column]._tree instanceof IdentifierNode) {
                    symbol = this.columns[column]._tree.identifier;
                    if (!tmp_frame.defines(symbol)) is_independent = true;
                    if (column === 0) {
                        if (!is_independent) {
                            error = "First column must be independent";
                        }
                        if (symbol === 'y' || symbol == 'theta' || symbol == 'r') {
                            error = "We don't do the right thing for tables with independent " + symbol + " yet";
                        }
                        if (!error) {
                            independent_frame.setVariable(symbol, ConstantNode(0));  //Should never be accessed, just used to say "this is defined" based on only the independent variable
                        }
                    }
                    if (!error) {
                        tmp_frame.setVariable(symbol, ConstantNode(0));  //Should never be accessed, just used to say "this is defined" based on all preceding variables
                    }
                    symbols[column] = symbol;
                }
                if (!is_independent) {
                    error = this.columns[column].getParseError();
                    if (!error) {
                        //Check if it's continuous
                        try {
                            result = this.columns[column].evaluateOnce(independent_frame);
                            is_continuous = true;
                        }
                        catch (e) {
                            //Unable to evaluate this at all values
                            is_continuous = false;
                        }
                        //Check if it's dependent
                        try {
                            result = this.columns[column].evaluateOnce(tmp_frame);
                            if (typeof result !== 'number') error = result;
                        }
                        catch (e) {
                            error = e; //Mark runtime errors that always occur at column-level
                        }
                    }
                }


                if (this.columns[column].getParseError()) {
                    this.error = this.columns[column].getParseError();
                }

                var values = [];
                if (!error) {
                    for (var row = 0; row < num_rows; row++) {
                        frame = EvalFrame(this._context.getFrame());
                        for (i = 0; i < column; i++) {
                            if (!columns_data[i].dependent && !columns_data[i].error) {
                                var independent_value = columns_data[i].values[row];
                                if (typeof (independent_value) === 'number')
                                    frame.setVariable(symbols[i], ConstantNode(independent_value));
                            }
                        }
                        if (is_independent) {
                            var tree = this.cell_tree[column][row];
                            if (tree.hasOwnProperty('error_msg')) value = tree.error_msg;
                            else {
                                try { value = tree.evaluateOnce(frame) }
                                catch (e) { value = e; }
                            }
                        }
                        else {
                            try { value = this.columns[column].evaluateOnce(frame); }
                            catch (e) { value = ''; }
                        }
                        values.push(value);
                    }
                }
                column_data = {
                    dependent: !is_independent,
                    discrete: !is_continuous,
                    error: error,
                    values: values
                };
                columns_data.push(column_data);
            }
            return columns_data;
        };

        obj.computeGraphData = function (viewState) {

            var id, x, y, row;
            var datum;
            var state = this.getEvaluationState(); //TODO - cache this so we don't double-compute
            var graphData = {};
            while (this.ids_to_clean.length) {
                graphData[this.ids_to_clean.pop()] = {};
            }
            //Compute points for all columns vs the first column
            for (var column = 1; column < state.length; column++) {
                var column_description = this._description.columns[column];
                id = this.columns[column].id;
                if (state[column].error) {
                    graphData[id] = {};
                }
                graphData[id] = [];
                if (column_description.showPoints) {
                    var segments = [];
                    for (row = 0; row < state[0].values.length; row++) {
                        //Push points into datum
                        //TODO - error checking
                        x = state[0].values[row];
                        y = state[column].values[row];
                        if (typeof (x) === 'number' && typeof (y) === 'number') {  //Don't make points for errors
                            segments.push([x, y]);
                        }
                    }
                    datum = {
                        segments: [segments],
                        graphMode: GRAPHMODE_XYPOINT,
                        poi: [],
                        color: column_description.color
                    };
                    graphData[id].push(datum);
                }

                //Connect points if discrete
                if (column_description.showLine && state[column].discrete) {
                    var accumulator = Plotter.Accumulator();
                    var segment = [];
                    for (row = 0; row < state[0].values.length; row++) {
                        //Push points into datum
                        //TODO - error checking
                        x = state[0].values[row];
                        y = state[column].values[row];
                        if (typeof (x) === 'number' && typeof (y) === 'number') {  //Don't make points for errors
                            accumulator.addPoint([x, y]);
                        }
                        else {
                            accumulator.breakSegment();
                        }
                    }
                    datum = {
                        segments: accumulator.getSegments(),
                        graphMode: GRAPHMODE_PARAMETRIC,
                        poi: [],
                        color: column_description.color
                    };
                    graphData[id].push(datum);
                }

                //Plot line for non-discrete headers
                if (column_description.showLine && !state[column].discrete) {
                    if (this.columns[column].getStatus() === GRAPHABLE) {
                        var columnGraphData = this.columns[column].computeGraphData(viewState);
                        if (columnGraphData[id].length !== 1) throw 'Programming error - graphData for table columns must be singleton';
                        graphData[id].push(columnGraphData[id][0]);
                    }
                    if (this.columns[column].getStatus() === EVALUABLE || this.columns[column].getStatus() === SILENT) {
                        try {
                            //Make and plot temporary constant function
                            var value = this.columns[column].evaluateOnce(this._context.getFrame());
                            var graph_info = {
                                graphMode: GRAPHMODE_Y,
                                independent: 'x',
                                dependent: 'y',
                                operator: '='
                            };
                            var compiled = this.compileConstantFunction(value);
                            constantGraphData = Plotter.computeGraphData(viewState, graph_info, compiled.fn);
                            constantGraphData[0].compiled = compiled;

                            if (constantGraphData.length !== 1) throw 'Programming error - graphData for table columns must be singleton';
                            graphData[id].push(constantGraphData[0]);
                        } catch (e) {
                            //I'm a bit worried that there may be a case I haven't thought of that will crash the above section.
                            //Protecting with a defensive try/catch to make sure it doesn't mess up the rest of the graph if someone manages to come up with it
                        }
                    }
                }
            }
            return graphData;
        };

        obj.compileConstantFunction = function (value) {
            /*jshint evil:true */
            var compiled = {
                args: [],
                function_string: 'return ' + String(value)
            };
            compiled.fn = new Function(compiled.args, compiled.function_string);
            return compiled;
        };

        // For now, tables can only have graphMode Y. Should probably enable
        // per-branch graphModes.
        obj.getGraphInfo = function () { return { graphMode: GRAPHMODE_Y }; };

        obj.shouldIntersect = function () { return true; };

        obj.compileAllBranches = function (frame) {
            return this.columns.slice(1).filter(function (column) {
                return column.getStatus() === GRAPHABLE;
            }).map(function (column) {
                return column.compile(frame);
            });
        };

    });

    var createAnalysisObject = function (context, statement) {
        switch (statement.type) {
            case 'table':
                return Table(context, statement);
            case 'statement':
            case undefined: //Not a good long-term solution
                var tree = Parser.tryParse(statement.latex);
                var analysisClass = AnalysisClass[tree.statementType];
                return analysisClass(context, statement, tree);
            default:
                throw ("Unrecognized statement type " + statement.type);
        }
    };

    return {
        createAnalysisObject: createAnalysisObject
    };

});

define('math/evaluatorcontext', ['require', 'pjs', './evalframe', './builtin', './evaluatorobject', './evaluationstate', './poi', './functions'], function (require) {
    var P = require('pjs');
    var EvalFrame = require('./evalframe');
    var BuiltIn = require('./builtin');
    var EvaluatorObject = require('./evaluatorobject');
    var EvaluationState = require('./evaluationstate');
    var POI = require('./poi');
    var functions = require('./functions');

    var EvaluatorContext = P(function (context) {

        // callback noop
        context.triggerGraphComputed = function () { };
        context.triggerChange = function () { };
        context.triggerRemoveGraph = function () { };
        context.triggerRender = function () { };
        context.triggerRenderSlowly = function () { };
        context.triggerDidAddStatement = function () { };
        context.triggerDidRemoveStatement = function () { };
        context.triggerDidSetCompleteState = function () { };
        context.triggerDidSetDegreeMode = function () { };
        context.triggerDidUpdateIntersections = function () { };
        context.triggerDidUpdateFunctionMap = function () { };

        context.init = function (frame) {
            this.parent_frame = frame;
            this.statements = {};    //Each statement should be immutable
            this.analysis = null;    //This can be cleaned out at re-derived each round
            this.current_state = {}; //Remember last sent message, so that we only update when necessary
            this.dirty = {}; //dirty[id] = True or undefined
            this.graph_changed = [];
        };

        context.eachStatement = function (fn) {
            for (var id in this.statements) {
                fn.apply(this, [this.statements[id]]); //Make sure this works from within context.eachStatement blocks
            }
        };

        context.setDegreeMode = function (use_degrees) {
            BuiltIn.setDegreeMode(use_degrees);
            this.invalidate();
            this.triggerDidSetDegreeMode(use_degrees);
            this.publishChanges();
        };

        context.setCompleteState = function (statements) {
            this.statements = {};
            this.invalidate();
            for (var i = 0; i < statements.length; i++) {
                this.addStatementSilent(statements[i]);
            }
            this.triggerDidSetCompleteState(statements);

            //Temporarily use slow rendering callback
            var triggerRender = this.triggerRender;
            this.triggerRender = this.triggerRenderSlowly;
            this.publishing_paused = false;
            this.publishChanges();
            this.triggerRender = triggerRender;
        };

        context.publishing_paused = false;
        context.changes_pending = false;

        context.pausePublishing = function () {
            //console.log("PAUSING");
            this.publishing_paused = true;
        };

        context.resumePublishing = function () {
            //console.log("RESUMING");
            this.publishing_paused = false;
            if (this.changes_pending) {
                this.publishChanges();
            }
        };

        context.publishChanges = function () {
            if (this.publishing_paused) {
                this.changes_pending = true;
                return;
            }
            this.pausePublishing();
            var self = this;
            //TODO - re-enable throttling
            setTimeout(function () { self.resumePublishing() }, 30); //Don't try to update faster than 30hz

            this.changes_pending = false;

            this.publishAllStatuses();
            if (!this.viewState) return;
            this.graphAllChanged();
        };

        context.publishAllStatuses = function () {
            //Compute new states, but only send them out if they're different from what we sent last time
            var changes = {};
            var last_state = this.current_state;
            this.current_state = {};

            this.eachStatement(function (statement) {
                var id = statement.id;
                var newState = this.getEvaluationState(id);
                if (JSON.stringify(newState) !== JSON.stringify(last_state[id])) {
                    changes[id] = this.getEvaluationState(id);
                }
                this.current_state[id] = newState;
            });

            this.triggerChange(changes);
        };

        context.graphAllChanged = function () {
            var viewState = this.viewState;
            var id;
            var i;
            for (i = 0; i < this.graph_changed.length; i++) {
                id = this.graph_changed[i];
                if (!this.statements.hasOwnProperty(id)) continue;
                if (
        this.getStatus(id) === GRAPHABLE &&
        this.statements[id].shouldGraph
      ) {
                    this.graph(id, viewState);
                } else if (this.statements[id].columns) {  //TODO - ugly hack
                    this.graph(id, viewState);
                } else {
                    this.triggerRemoveGraph(id);
                }
            }

            var graphChangedSet = {};
            for (i = 0; i < this.graph_changed.length; i++) {
                graphChangedSet[this.graph_changed[i]] = true;
            }

            // Recompute all visible intersections for curves that weren't regraphed.
            // Curves that were regraphed already had their intersections updated in
            // the graph routine. Need to do this because we're only keeping track of
            // one partner in an intersection, and the other partner might have
            // changed.
            for (id in this.intersectIds) {
                if (!this.intersectIds.hasOwnProperty(id)) continue;
                if (graphChangedSet.hasOwnProperty(id)) continue;
                this.updateIntersections(id);
            }

            this.triggerRender();
        };

        //TODO - delegate to statement objects
        context.graph = function (id, viewState) {
            if (!viewState) {
                //console.log("No view state.  Not graphing");
                return;
            }

            var statement = this.statements[id];
            var graphData = statement.computeGraphData(viewState);

            if (
      this.intersectIds.hasOwnProperty(id) &&
      statement.shouldIntersect() &&
      graphData.hasOwnProperty(id) // TODO bails on intersecting tables
    ) {
                someIntersections = this.findSomeIntersectionsWith(id);

                for (branch = 0; branch < someIntersections.intersections.length; branch++) {
                    graphData[id][branch].poi.intersections = someIntersections.intersections[branch];
                }
                // If we ran out of time to compute all the intersections, stream the
                // rest of them back to the grapher as we have time.
                someIntersections.streamRest();
            }

            for (var sketch_id in graphData) {
                this.triggerGraph(sketch_id, graphData[sketch_id]);
            }
        };

        // Find all intersections between a curve with the given id and other
        // curves.
        context.updateIntersections = function (id) {

            var statement = this.statements[id];

            if (!statement || !statement.shouldIntersect()) {
                this.triggerDidUpdateIntersections(id, []);
                return;
            }

            this.findSomeIntersectionsWith(id).streamRest();

        };


        // context.findSomeIntersectionsWith computes as many intersections with the
        // curve with given id as it can in 20 ms and then returns an object:
        // {
        //   intersections: // Intersections found so far
        //   streamRest: // Function that will stream the rest of the intersections
        //               // back to the grapher.
        // }
        //
        // We run a different timeout for every curve id that is having
        // having intersections computed on it so that we can start computing
        // intersections with a few curves at once without having them cancel
        // eachother. This will happen if you open intersections on a few different
        // curves and then change something that triggers a graphAll.
        //
        // Note that we typically only stick the intersection POI on one of the two
        // curves that is involved in an intersection (the one that was selected
        // when the intersection was computed).
        var streamIntersectionsTimeouts = {};
        context.findSomeIntersectionsWith = function (id1) {
            this.cancelIntersectionStreaming(id1);

            var runFor = 20; // ms
            var waitFor = 60; // ms
            var self = this;
            var push = Array.prototype.push;
            var statement1 = self.statements[id1];
            var graph_info = statement1.getGraphInfo();
            var graphMode = graph_info.graphMode;
            var compiled1 = self.statements[id1].compileAllBranches(self.getFrame());
            var domain = Plotter.computeDomain(self.viewState, graph_info, null);

            var otherStatements = [];
            for (var id2 in self.statements) {
                if (!self.statements.hasOwnProperty(id2)) continue;
                if (String(id2) === String(id1)) continue;
                otherStatements.push(self.statements[id2]);
            }

            // intersections accumulator and iterator i are modified during successive
            // calls to computeSome()
            var intersections = [];
            for (var branch = 0; branch < compiled1.length; branch++) {
                intersections[branch] = { x: [], y: [], intersects: [] };
            }
            var i = otherStatements.length - 1;
            var stream = false;
            var computeSome = function () {
                var now = new Date();
                var updated = false;
                var fn1;
                var fn2;
                var newIntersections;
                var statement2;
                var compiled2;
                var swap;
                for (i; i >= 0; i--) {
                    if (new Date() - now > runFor) {
                        if (!stream) return;
                        streamIntersectionsTimeouts[id1] = setTimeout(computeSome, waitFor);
                        if (!updated) return;
                        self.triggerDidUpdateIntersections(id1, intersections);
                        return;
                    }
                    statement2 = otherStatements[i];
                    if (!statement2.shouldIntersect()) continue;
                    if (statement2.getGraphInfo().graphMode !== graphMode) continue;

                    compiled2 = statement2.compileAllBranches(self.getFrame());

                    for (var branch1 = 0; branch1 < compiled1.length; branch1++) {
                        fn1 = compiled1[branch1].fn;
                        for (var branch2 = 0; branch2 < compiled2.length; branch2++) {
                            fn2 = compiled2[branch2].fn;
                            newIntersections = POI.findIntersections(domain, fn1, fn2);
                            if (newIntersections.x.length) updated = true;
                            newIntersections.intersects = Array(newIntersections.x.length);
                            for (var j = 0, jlen = newIntersections.x.length; j < jlen; j++) {
                                newIntersections.intersects[j] = statement2.id;
                            }
                            // Need to swap x and y if graphmode is GRAPHMODE_X
                            if (graphMode === 'GRAPHMODE_X') {
                                swap = newIntersections.y;
                                newIntersections.y = newIntersections.x;
                                newIntersections.x = swap;
                            }
                            push.apply(intersections[branch1].x, newIntersections.x);
                            push.apply(intersections[branch1].y, newIntersections.y);
                            push.apply(intersections[branch1].intersects, newIntersections.intersects);
                        }
                    }
                }

                if (!stream || !updated) return;
                self.triggerDidUpdateIntersections(id1, intersections);
                self.cancelIntersectionStreaming(id1);
            };

            computeSome();

            return {
                intersections: intersections,
                streamRest: function () {
                    // Slightly wasteful, but handy for clearing old intersections early.
                    self.triggerDidUpdateIntersections(id1, intersections);
                    stream = true;
                    computeSome();
                }
            };

        };

        context.cancelIntersectionStreaming = function (id) {
            clearTimeout(streamIntersectionsTimeouts[id]);
            delete streamIntersectionsTimeouts[id];
        };

        context.cancelAllIntersectionStreaming = function () {
            for (var id in streamIntersectionsTimeouts[id]) {
                if (!streamIntersectionsTimeouts.hasOwnProperty(id)) continue;
                this.cancelIntersectionStreaming(id);
            }
        };

        //Takes a object representing an "expression" (TODO - rename this concept)
        //Expects expr to have properties:
        // * id (integer)
        // * latex (string)
        // * shouldGraph (boolean)
        // * color (string)
        context.addStatement = function (statement) {
            this.addStatementSilent(statement);
            this.triggerDidAddStatement(statement);
            this.publishChanges();
        };

        context.addStatementSilent = function (statement) {
            if (!statement) return;
            var id = statement.id;
            this.markDirty(id); // Mark existing dependencies as dirty

            var previous_ids;  //Used to tell tables to ungraph old columns

            if (this.statements.hasOwnProperty(id)) {
                previous_ids = this.statements[id].getAllIds();
            }

            this.statements[id] = EvaluatorObject.createAnalysisObject(this, statement);

            if (previous_ids) {
                for (var i = 0; i < previous_ids.length; i++) {
                    var previous_id = previous_ids[i];
                    if (previous_id != id) {
                        this.statements[id].cleanupId(previous_id);
                    }
                }
            }
            // Need to mark clean before marking dirty again because otherwise we'll
            // hit an early return and fail to mark new dependencies dirty.
            this.markClean(statement.id);
            this.markDirty(statement.id); // Mark any new dependencies as dirty
        };

        context.removeStatement = function (id) {
            if (!this.statements.hasOwnProperty(id)) return; //Looks like it was already deleted.
            //This happens when a table is deleted, and then each column is deleted.

            this.markDirty(id); //Mark dirty before deletion
            var ids = this.statements[id].getAllIds();
            delete this.statements[id];
            //Remove all associated GraphSketch ids
            for (var i = 0; i < ids.length; i++) {
                this.triggerRemoveGraph(ids[i]);
            }
            this.triggerDidRemoveStatement(id);
            this.publishChanges();
        };

        context.recompute = function () {
            this.invalidate();
            this.publishChanges();
        };

        context.invalidate = function () {
            this.analysis = null;
            this.current_state = {};
            this.cancelAllIntersectionStreaming();
        };

        context.markDirty = function (id) {
            if (this.dirty[id]) return;
            this.dirty[id] = true;
            this.cancelIntersectionStreaming(id);
            //symbols which id exports
            if (!this.statements[id]) return;
            for (var symbol in this.statements[id].exportedSymbols()) {
                this.markSymbolDirty(symbol);
                if (this.assignmentForbidden(symbol)) continue;
            }
        };

        context.markSymbolDirty = function (symbol) {
            this.eachStatement(function (statement) {
                if (statement.referencesSymbol(symbol)) {
                    this.markDirty(statement.id);
                }
            });
        };

        context.markClean = function (id) {
            delete (this.dirty[id]);
        };

        context.isDirty = function (id) {
            return this.dirty.hasOwnProperty(id);
        };

        context.getFrame = function () {
            //Return frame, updating if necessary.
            return this.getAnalysis().frame;
        };

        context.getAnalysis = function () {
            this.updateAnalysis();
            return this.analysis;
        };

        context.getType = function (id) {
            return this.statements[id].getType();
        };

        context.updateAnalysis = function () {
            if (this.hasOwnProperty('partial_analysis')) throw "Programming error - two overlapping call to updateAnalysis";

            var dirty_statements = [];
            var id;
            if (this.analysis) {
                for (id in this.dirty) {
                    dirty_statements.push(id);
                }
                //If we already have analysis and nothing is dirty, return
                if (dirty_statements.length === 0) return;
            }
            else {
                for (id in this.statements) {
                    dirty_statements.push(id);
                }
            }

            //For a first pass, re-run the analysis for everything (since that's cheap), only graph dirty statements
            delete (this.analysis);
            this.partial_analysis = {};
            var a = this.partial_analysis;
            try {

                a.frame = EvalFrame(this.parent_frame);

                this.eachStatement(function (statement) {
                    var id = statement.id;
                    a[id] = {};
                    statement.setAnalysis(a[id]);
                    var error = statement.getParseError();
                    if (error) a[id].error = error;
                });

                a.assignments = this.analyzeAssignments();
                this.markVariableConflicts(a.assignments);

                this.analyzeDependencies(a);

                for (var i = 0; i < a.dependencyOrder.length; i++) {
                    id = a.dependencyOrder[i];
                    this.statements[id].exportDefinitionsTo(a.frame);
                }

                this.graph_changed = dirty_statements;
                this.dirty = {};

                var fm = a.frame.functionMap();
                for (var name in fm) {
                    functions.register(name, fm[name]);
                }
                //Used to send function definitions from worker to UI thread for tracing
                this.triggerDidUpdateFunctionMap(a.frame);

                this.analyzeStatus(a);

                //Mark analysis as done, and make it active
                this.analysis = this.partial_analysis;
            }
            catch (e) {
                //Error in analysis - invalidate everything so that we don't persist anything
                this.invalidate();
            }
            finally {
                //No matter what, partial_analysis should dissapear
                delete (this.partial_analysis);
            }
        };

        context.evaluateOnce = function (id) {
            if (!this.statements.hasOwnProperty(id)) { throw ('Statement ' + id + ' not defined'); }
            return this.statements[id].evaluateOnce(this.getFrame());
        };

        context.compile = function (id) {
            return this.statements[id].compile(this.getFrame());
        };

        context.evalStrings = function (id) {
            return this.statements[id].evalStrings(this.getFrame());
        };

        context.analyzeStatus = function (a) {
            this.eachStatement(function (statement) {
                var id = statement.id;
                var s = this.partial_analysis[id];
                if (s.error) s.status = ERROR;
                if (s.status) return;
                s.status = statement.computeStatus(a.frame);
            });
        };

        context.assignmentForbidden = function (identifier) {
            return (identifier === 'x' || identifier === 'y' || identifier === 'theta');
        };

        context.getStatus = function (id) {
            if (this.getAnalysis()[id] === undefined)
                return DOES_NOT_EXIST;
            return this.getAnalysis()[id].status;
        };

        //Returns an object that mirrors the API of Formula
        context.getEvaluationState = function (id) {
            this.getAnalysis(); // Used for side-effects
            return this.statements[id].getEvaluationState();
        };

        //Analyzing dependencies
        //Iterate over all definitions to identify multiple-definitions and mark defined identifiers with type
        //Multiple definitions are OK, as long as they are not referenced
        //Scan all statements, recording dependencies as free variables, or defined functions/variables
        //During this scan, drop out any equations which reference multiply-defined identifiers
        //During this scan, build data-structure for dependency DAG
        //Crawl data-structure, to create evaluation ordering with clean dependencies
        //Identify cycles in remaining statements, and mark those as errors
        //Return clean ordering, to be used in frame generation and compilation

        context.analyzeAssignments = function () {
            var assignments = {};
            this.eachStatement(function (statement) {
                var exports = statement.exportedSymbols();
                for (var symbol in exports) {
                    if (this.assignmentForbidden(symbol)) continue; //Nobody gets to assign x or y globally
                    if (this.parent_frame && this.parent_frame.defines(symbol)) {
                        statement.markError("Cannot redefine " + symbol);
                        continue;
                    }
                    if (!assignments.hasOwnProperty(symbol)) { assignments[symbol] = [] }
                    assignments[symbol].push({ id: statement.id, arity: exports[symbol] });
                }
            });
            return assignments;
        };

        context.markVariableConflicts = function (assignments) {
            this.eachStatement(function (statement) {
                var shadowed = statement.shadowedSymbols();
                for (i = 0; i < shadowed.length; i++) {
                    var symbol = shadowed[i];
                    if (assignments.hasOwnProperty(symbol)) {
                        statement.conflictError(symbol); //TODO - define this error message
                        //'"' + conflicts[0] + '" is already defined, so you can\'t use it as one of the parameters of this function. You could try a different letter, or using a subscript.';
                    }
                }
            });
        };

        //Returns dependency-ordered sequence of statement ids
        context.analyzeDependencies = function (a) {
            var order = [];       //The IDs of the sequence (built up incrementally)
            var ready = [];       //IDs of which statements are ready to add to the sequence
            var block_count = {}; //IDs of blocked statments are keys => number of blockers.
            var blocked_on = {};  //Term string are keys => IDs of blocked statements;

            //Note - for now, the same term can show up as a blocker multiple times for the same statement.
            //This is correct, but could become inefficient.  We might want to make the dependency lists unique.

            //Initialize data structure to be able to query DAG efficiently
            for (var id in this.statements) {
                var s = a[id];
                s.free_variables = [];
                if (!this.statements.hasOwnProperty(id)) continue;
                //Track dependencies
                var dependencies = this.statements[id].getDependencies();
                block_count[id] = 0;
                for (var dependency in dependencies) {
                    if (!dependencies.hasOwnProperty(dependency)) { continue; }
                    var dependency_arity = dependencies[dependency];

                    if (this.parent_frame) {
                        //If we're looking for a variable and the parent defines it, we're good (arity 1 could be either)
                        if ((dependency_arity <= 1) && this.parent_frame.hasVariable(dependency)) {
                            continue;
                        }

                        //If we're looking or a function with specific arity and the parent defines it, we're good
                        if ((dependency_arity >= 1) && this.parent_frame.hasFunctionWithArity(dependency, dependency_arity)) {
                            continue;
                        }
                    }

                    var assigners = a.assignments[dependency];  //List of IDs for statements which define dependency
                    //0 assigners => free variable or error, if it's a function
                    if (this.parent_frame && this.parent_frame.defines(dependency)) {
                        var real_arity = this.parent_frame.arity(dependency);
                        if (real_arity === 0) {
                            s.error = "Cannot call constant " + dependency + " as a function";
                        }
                        if (real_arity > 0) {
                            s.error = dependency + " is a function that requires " + real_arity + " arguments";
                        }
                        else {
                            s.error = "Something has gone wrong.  Please report this to desmos.com support";
                        }
                        continue;
                    }
                    if (!assigners || assigners.length === 0) {
                        if (dependency_arity <= 1) {
                            this.statements[id].addFreeVariables([dependency]);
                        }
                        else {
                            s.error = "Function '" + dependency + "' isn't defined. Try defining it in a new expression";
                        }
                    }

                    //1 => possibly healthy dependency
                    if (assigners && assigners.length === 1) {
                        var assignment_arity = assigners[0].arity;

                        if (assignment_arity === dependency_arity ||             //Check if assignment has the same arity as our dependency
             (assignment_arity === 0 && dependency_arity === 1)) {  //Ambiguous dependency can be resolved with arity 1 function or variable.

                            if (!blocked_on.hasOwnProperty(dependency)) { blocked_on[dependency] = []; } //create list if empty

                            blocked_on[dependency].push(id);
                            block_count[id]++;
                        }
                        else {
                            //construct an example of using the function
                            var args = [];
                            for (var i = 0; i < assignment_arity; i++) { args[i] = i + 1; }
                            var recommendation = dependency + "(" + args.join(",") + ")";
                            s.error = 'Function ' + dependency + ' requires ' + assignment_arity + ' argument' + (assignment_arity == 1 ? "" : "s") + ". For example, try typing: " + recommendation;
                        }
                    }
                    //>1 => dependency on an ambiguous term
                    if (assigners && assigners.length > 1) {
                        s.error = "'" + dependency + "' is defined more than once. Try deleting all but one definition of '" + dependency + "'";
                        //TODO - put errors or warning on all assigners as well
                    }
                }
                if (block_count[id] === 0) {
                    ready.push(id);
                }
            }

            //Keep pulling from ready list until it's empty (either we're done, or we can't finish)
            while (ready.length) {
                var next = ready.pop();
                if (a[next].error) {
                    //TODO Mark dependencies as errors for depending on it - currently just letting them fail the same as circular dependencies
                    continue;
                }
                order.push(next);
                var exported = this.statements[next].exportedSymbols();
                for (var symbol in exported) {
                    var unblocked_list = blocked_on[symbol];
                    if (!unblocked_list) continue;  //Doesn't unblock anything else

                    while (unblocked_list.length) {
                        var unblocked = unblocked_list.pop();
                        this.statements[unblocked].addFreeVariables(a[next].free_variables);
                        block_count[unblocked]--;      //Unblocks everything that depends on whatever next defines
                        if (block_count[unblocked] === 0) {
                            delete block_count[unblocked];
                            ready.push(unblocked);
                        }
                    }
                }
            }

            for (id in block_count) {
                if (block_count.hasOwnProperty(id) && block_count[id] !== 0) {
                    a[id].unresolved = true;
                    a[id].error = "Circular dependency";
                }
            }

            a.dependencyOrder = order;
        };

    });

    return EvaluatorContext;

});

define('math/workercore', ['require', 'math/evaluatorcontext', 'math/builtin', 'math/derivative'], function (require) {
    var EvaluatorContext = require('math/evaluatorcontext');
    var BuiltIn = require('math/builtin');
    require('math/derivative');

    return function (sendMessage) {
        //Set up listeners and communication
        var listeners = {};  //Array of listeners, indexed by event type

        //Initialize environment
        var context = EvaluatorContext(BuiltIn.getFrame());
        context.intersectIds = {};

        listeners.setViewState = function (viewState) {
            context.viewState = viewState;
            context.invalidate();
            context.publishChanges(); //TODO - fix the way viewState is passed around
        };

        listeners.setIntersectIds = function (intersectIds) {
            context.intersectIds = intersectIds;
        };

        listeners.addStatement = function (statement) {
            context.addStatement(statement);
        };

        listeners.removeStatement = function (id) {
            context.removeStatement(id);
        };

        listeners.updateIntersections = function (id) {
            context.updateIntersections(id);
        };

        listeners.setDegreeMode = function (use_degrees) {
            context.setDegreeMode(use_degrees);
        };

        listeners.setCompleteState = function (statements) {
            context.setCompleteState(statements);
        };

        listeners.invalidate = function () {
            context.invalidate();
        };

        listeners.sync = function (sync_id) { sendMessage('sync', sync_id) };

        //Functions to send data back to main thread
        context.triggerGraph = function (id, data) {
            //Can't pass function objects across worker boundary.  Will re-create on other side
            for (var i = 0; i < data.length; i++) {
                if (data[i].compiled) delete data[i].compiled.fn;
            }
            sendMessage('graphData', { id: id, graphData: data });
        };

        context.triggerDidUpdateIntersections = function (id, intersections) {
            sendMessage('updateIntersections', { id: id, intersections: intersections });
        };

        context.triggerDidUpdateFunctionMap = function (frame) {
            sendMessage('updateFunctionMap', frame.functionSourceMap());
        };

        context.triggerRender = function () {
            sendMessage('render');
        };

        context.triggerRenderSlowly = function () {
            sendMessage('renderSlowly');
        };

        context.triggerRemoveGraph = function (id) {
            sendMessage('removeGraph', id);
        };

        context.triggerDidSetDegreeMode = function (use_degrees) {
            sendMessage('setDegreeMode', use_degrees);
        };

        context.triggerChange = function (data) {
            sendMessage('change', data);
        };

        return listeners;
    };

});

define('fakeworker', ['require', 'math/workercore'], function (require) {
    var WorkerCore = require('math/workercore');

    return function (messageListener) {
        var fakeWorker = {};
        var workerCore;

        //Handle message from worker to UI thread
        var sendMessage = function (type, payload) {
            messageListener({ data: { type: type, payload: payload} });
        };

        var listeners = WorkerCore(sendMessage);

        //Handle messages from UI thread to worker
        fakeWorker.postMessage = function (e) {
            listeners[e.type](e.payload);
        };

        return fakeWorker;
    };
});

define('main/evaluator', ['require', 'pjs', 'math/builtin', 'math/functions', 'graphing/graphsketch', 'fakeworker'], function (require) {
    var P = require('pjs');
    var BuiltIn = require('math/builtin');
    var functions = require('math/functions');
    var GraphSketch = require('graphing/graphsketch');
    var FakeWorker = require('fakeworker');

    Evaluator = P(function (evaluator) {

        // Overwritten in calc.js
        evaluator.triggerChange = function () { };

        evaluator.init = function (workerPath) {
            //console.log("Initializing evaluator");
            this.statements = {};
            var self = this;
            if (window.Worker) {
                this.worker = new Worker(workerPath);
                this.worker.addEventListener('message', this.processMessage.bind(this));
                this.worker.onerror = function (evt) { console.log(evt) };
            } else {
                this.worker = FakeWorker(this.processMessage.bind(this));
            }
            this.sync_callbacks = {};

            this.listeners.setDegreeMode = function (use_degrees) {
                //TODO - set DegreeMode on builtIn
            };
        };

        evaluator.notifyWhenSynced = function (callback) {
            //Put the callback in a table
            var sync_id = Math.random();
            this.sync_callbacks[sync_id] = callback;
            //Send a sync command to the worker
            this.callWorker('sync', sync_id);
            //When the sync command comes back from the worker, we will call the callback
        };

        /* Set up event listeners */
        evaluator.listeners = {};

        evaluator.listeners.sync = function (sync_id, self) {
            var callback = self.sync_callbacks[sync_id];
            callback();
            delete (self.sync_callbacks[sync_id]);
        };

        evaluator.processMessage = function (e) {
            //console.log("Recieved " + e.data.type + " message of length " + JSON.stringify(e.data).length);
            this.listeners[e.data.type](e.data.payload, this);
        };

        evaluator.listeners.log = function (msg) {
            console.log("From worker: " + msg.msg);
            console.log(msg.data);
        };

        evaluator.listeners.removeGraph = function (id) {
            var sketch = grapher.getGraphSketch(id);
            if (sketch) sketch.visible = false;
        };

        evaluator.listeners.graphData = function (payload, self) {
            var id = payload.id;
            var graphData = payload.graphData;

            //Turn the function_string into an actual function, since we can't pass function objects across from the worker
            for (var i = 0; i < graphData.length; i++) {
                if (graphData[i].compiled) {
                    graphData[i].compiled.fn = functions.compile(graphData[i].compiled.args, graphData[i].compiled.function_string);
                }
            }

            //TODO - need to make sure color is part of the payload
            var color;
            if (graphData.length > 0) {
                color = graphData[0].color;
                var newSketch = new GraphSketch(graphData, color);  //TODO - handle differently-colored branches
                newSketch.updateFrom(grapher.getGraphSketch(id));
                grapher.setGraphSketch(id, newSketch);
                self.triggerGraphComputed(id);
            }
            else {
                self.listeners.removeGraph(id);
            }

        };

        evaluator.listeners.updateFunctionMap = function (sourceFunctionMap, self) {
            //TODO - don't repeat this for built-ins on every update.  This can run once at initialization
            var name;
            var fm = BuiltIn.getFrame().functionMap();
            for (name in fm) {
                if (fm.hasOwnProperty(name)) functions.register(name, fm[name]);
            }

            //Compile function definition strings, and bind them to functions object
            //Binding allows them to access other functions via "this.function_name()"
            for (name in sourceFunctionMap) {
                if (!sourceFunctionMap.hasOwnProperty(name)) continue;
                var source = sourceFunctionMap[name];
                functions.register(name, functions.compile(source.args, source.source));
            }
        };

        evaluator.listeners.updateIntersections = function (payload, self) {
            var intersections = payload.intersections;
            var id = payload.id;
            var graphSketch = grapher.getGraphSketch(id);
            if (graphSketch) graphSketch.updateIntersections(intersections);
            grapher.redrawPOILayer();
        };

        evaluator.listeners.change = function (changes, self) { //Updates to status of expression-list items
            self.triggerChange(changes);
        };

        evaluator.listeners.render = function () {
            //console.log("Render request in evaluator");
            grapher.redrawAllLayers();
        };

        evaluator.listeners.renderSlowly = function () {
            grapher.redrawSlowly();  //Used for initial slow draw after setCompleteState
        };

        //Set up outgoing communication to worker
        evaluator.callWorker = function (type, data) {
            this.worker.postMessage({ type: type, payload: data });
        };

        evaluator.setViewState = function (viewState) {
            this.callWorker('setViewState', viewState);
        };

        evaluator.setIntersectIds = function (intersectIds) {
            this.callWorker('setIntersectIds', intersectIds);
        };

        evaluator.setCompleteState = function (statements) {
            this.callWorker('setCompleteState', statements);
        };

        //Takes a object representing an "expression" (TODO - rename this concept)
        //Expects expr to have properties:
        // * id (integer)
        // * latex (string)
        // * shouldGraph (boolean)
        // * color (string)
        evaluator.addStatement = function (statement) {
            if (typeof (statement) === 'undefined') return;
            this.callWorker('addStatement', statement);
        };

        evaluator.removeStatement = function (id) {
            this.callWorker('removeStatement', id);
        };

        evaluator.updateIntersections = function (id) {
            this.callWorker('updateIntersections', id);
        };

        evaluator.setDegreeMode = function (use_degrees) {
            this.callWorker('setDegreeMode', use_degrees);
        };

    });

    return Evaluator;
});

define('lib/browser', [], function () {
    var Browser = {
        IS_IE8: navigator.userAgent.match(/MSIE 8.0/i) !== null,
        IS_IE9: navigator.userAgent.match(/MSIE 9.0/i) !== null,
        IS_IE: navigator.userAgent.match(/MSIE/i) !== null,
        IS_IPAD: navigator.userAgent.match(/iPad/i) !== null,
        IS_MOBILE: navigator.userAgent.match(/Mobile|Android/i) !== null,
        IS_ANDROID: navigator.userAgent.match(/Android/i) !== null,
        IS_KINDLE: navigator.userAgent.match(/Kindle/i) !== null || navigator.userAgent.match(/Silk/i) !== null
    };

    // Need to detet opera less than 12 because the implementation of webworkers
    // there breaks.
    Browser.IS_OPERA_LT_12 = (function () {
        if (!navigator.userAgent.match(/OPERA/i)) return false;

        var match = navigator.userAgent.match(/Version\/(\d+)/);
        if (!(match && match[1])) return false;

        var operaVersion = parseInt(match[1], 10);
        return operaVersion < 12;
    })();

    Browser.CAPABLE_BROWSER = (function () {
        var is_too_small = false;
        // Our interface doesn't work on phone-size devices.
        if (window.matchMedia) {
            mq = window.matchMedia("(max-device-width:480px)");
            if (mq.matches) is_too_small = true;
        } else if (Browser.IS_ANDROID) {
            // Assume Android devices without matchMedia are too small.
            is_too_small = true;
        }

        var elem = document.createElement('canvas');
        var supports_canvas = !!(elem.getContext && elem.getContext('2d'));

        return ((supports_canvas) && !(is_too_small || Browser.IS_KINDLE));
    })();

    return Browser;
});

window.ANIMATE_ZOOM_DURATION = 500;

window.DOUBLETAP_DELAY = 500;
window.DOUBLETAP_ZOOM = 2.0;

window.WHEELZOOM_TO_CURSOR = false;
window.ZOOM_FACTOR = 1.125;

window.MAX_DOTTED_SEGMENTS = 1000;

var STROKE_ALPHA = 0.7;
var HIGHLIGHTED_STROKE_ALPHA = 1;
var FILL_ALPHA = 0.4;
var POINT_ALPHA = 0.9;
var HIGHLIGHTED_POINT_ALPHA = 0.6;
var POLAR_ALPHA = 0.2;
var POI_ALPHA = 0.01;
define("graphing/constants", function () { });

define('lib/rounding', [], function () {
    var digitRound = function (x, places) {
        var pow10 = Math.pow(10, places);
        return (Math.round(x * pow10) / pow10);
    };

    Rounding = {
        bestRound: function (x, pixel_units, pixel_precision) {
            pixel_precision = pixel_precision || 1;

            //figure out how decimal places we can afford to round to
            var decimal_places = -Math.floor(Math.log(pixel_units) / Math.LN10);

            //round to that many decimal places
            var better_x = digitRound(x, decimal_places);

            //now we also want to check if we're within pixel_precision of one of
            //the *good* roundings
            var test_rounded_x = digitRound(x, decimal_places - 2);
            if (Math.abs(test_rounded_x - x) < pixel_precision * pixel_units) {
                better_x = test_rounded_x;
            }

            //good to go, return it
            return better_x;
        }
    };

    return Rounding;
});

define('graphing/viewport', ['./constants', 'lib/rounding'], function (Constants, Rounding) {

    function Viewport(xmin, xmax, ymin, ymax) {
        this.xmin = xmin !== undefined ? xmin : -10;
        this.xmax = xmax !== undefined ? xmax : 10;
        this.ymin = ymin !== undefined ? ymin : -10;
        this.ymax = ymax !== undefined ? ymax : 10;
    }

    Viewport.prototype.toObject = function () {
        return {
            xmin: this.xmin,
            ymin: this.ymin,
            xmax: this.xmax,
            ymax: this.ymax
        };
    };

    Viewport.fromObject = function (obj) {
        return new Viewport(obj.xmin, obj.xmax, obj.ymin, obj.ymax);
    };

    Viewport.prototype.equals = function (viewport) {
        if (this.xmin !== viewport.xmin) return false;
        if (this.ymin !== viewport.ymin) return false;
        if (this.xmax !== viewport.xmax) return false;
        if (this.ymax !== viewport.ymax) return false;

        return true;
    };

    Viewport.prototype.isXValid = function () {
        return (this.xmax - this.xmin > 0);
    };

    Viewport.prototype.isYValid = function () {
        return (this.ymax - this.ymin > 0);
    };

    Viewport.prototype.isValid = function () {
        return this.isXValid() && this.isYValid();
    };

    Viewport.prototype.isSquare = function (screen) {
        return Math.abs(screen.height - screen.width * this.aspectRatio()) < 1;
    };

    Viewport.prototype.aspectRatio = function (screen) {
        return (this.ymax - this.ymin) / (this.xmax - this.xmin);
    };

    Viewport.prototype.squareXAxis = function (screen) {
        var xrange = this.xmax - this.xmin;
        var yrange = this.ymax - this.ymin;
        var xcenter = this.xmin + xrange / 2;
        var new_xrange = yrange / screen.height * screen.width;

        this.xmin = xcenter - new_xrange / 2;
        this.xmax = xcenter + new_xrange / 2;
    };

    Viewport.prototype.squareYAxis = function (screen) {
        var xrange = this.xmax - this.xmin;
        var yrange = this.ymax - this.ymin;
        var ycenter = this.ymin + yrange / 2;
        var new_yrange = xrange / screen.width * screen.height;

        this.ymin = ycenter - new_yrange / 2;
        this.ymax = ycenter + new_yrange / 2;
    };

    Viewport.prototype.squareCrop = function (screen) {
        // Square axes in a way that is guaranteed to reduce the viewport
        if (this.aspectRatio() > screen.height / screen.width) {
            this.squareYAxis(screen);
        } else {
            this.squareXAxis(screen);
        }
    };

    // rounds the viewport so that it's not more precise than a pixel
    Viewport.prototype.round = function (screen) {
        var xrange = this.xmax - this.xmin;
        var yrange = this.ymax - this.ymin;

        var x_pixel_units = xrange / screen.width;
        var y_pixel_units = yrange / screen.height;

        // Do things this way to try to maintain xrange and yrange when panning.
        this.xmin = Rounding.bestRound(this.xmin, x_pixel_units / 10);
        this.xmax = Rounding.bestRound(this.xmin + xrange, x_pixel_units / 10);
        this.ymin = Rounding.bestRound(this.ymin, y_pixel_units / 10);
        this.ymax = Rounding.bestRound(this.ymin + yrange, y_pixel_units / 10);
    };

    Viewport.prototype.clone = function () {
        return new Viewport(this.xmin, this.xmax, this.ymin, this.ymax);
    };

    // calculates a distance from the origin that is guaranteed to reach out past
    // the edge of the viewport for all values of theta. The actual value doesn't
    // matter much. This is used for clipping and the value will get truncated
    // during the clipping routine. In theory could use a really big number but
    // it's possible that we won't pick a big enough number.
    Viewport.prototype.polarDiameter = function () {
        var d1 = Math.abs(this.xmax), d2 = Math.abs(this.xmin);
        var d3 = Math.abs(this.ymax), d4 = Math.abs(this.ymin);
        return d1 + d2 + d3 + d4;
    };

    return Viewport;
});

define('graphing/projection', [], function () {

    // A single object that contains all the information to map from
    // the theoretical space to the canvas space.
    var Projection = function (screen, viewport, settings) {
        this.screen = screen;
        this.viewport = viewport;
        this.settings = settings;
    };

    Projection.prototype.mapx = function (x) {
        return (x - this.viewport.xmin) * this.screen.width / (this.viewport.xmax - this.viewport.xmin);
    };

    Projection.prototype.mapy = function (y) {
        return this.screen.height - (y - this.viewport.ymin) * this.screen.height / (this.viewport.ymax - this.viewport.ymin);
    };

    Projection.prototype.map_pt = function (pt) {
        return { x: this.mapx(pt.x), y: this.mapy(pt.y) };
    };

    Projection.prototype.reverse_mapx = function (mapped_x) {
        return mapped_x * (this.viewport.xmax - this.viewport.xmin) / this.screen.width + this.viewport.xmin;
    };

    Projection.prototype.reverse_mapy = function (mapped_y) {
        return -(mapped_y - this.screen.height) * (this.viewport.ymax - this.viewport.ymin) / this.screen.height + this.viewport.ymin;
    };

    Projection.prototype.reverse_map_pt = function (mapped_pt) {
        return { x: this.reverse_mapx(mapped_pt.x), y: this.reverse_mapy(mapped_pt.y) };
    };

    return Projection;
});

define('graphing/viewporttransformation', ['require', './viewport', './projection', 'math/distance'], function (require) {
    var Viewport = require('./viewport');
    var Projection = require('./projection');
    var Distance = require('math/distance');

    function ViewportTransformation(xOffset, yOffset, scale) {
        this.xOffset = xOffset !== undefined ? xOffset : 0;
        this.yOffset = yOffset !== undefined ? yOffset : 0;
        this.scale = scale !== undefined ? scale : 1;
    }

    ViewportTransformation.prototype.clone = function () {
        return new ViewportTransformation(this.xOffset, this.yOffset, this.scale);
    };

    ViewportTransformation.prototype.equals = function (transformation) {
        return (
    this.xOffset === transformation.xOffset &&
    this.yOffset === transformation.yOffset &&
    this.scale === transformation.scale
  );
    };

    ViewportTransformation.prototype.compose = function (transformation) {
        return new ViewportTransformation(
    this.xOffset + transformation.xOffset,
    this.yOffset + transformation.yOffset,
    this.scale * transformation.scale
  );
    };

    ViewportTransformation.prototype.lerp = function (transformation, ratio) {
        return new ViewportTransformation(
    (1 - ratio) * this.xOffset + ratio * transformation.xOffset,
    (1 - ratio) * this.yOffset + ratio * transformation.yOffset,
    (1 - ratio) * this.scale + ratio * transformation.scale
  );
    };

    ViewportTransformation.prototype.applyPanTouchChanges = function (oldTouches, newTouches) {
        this.xOffset += newTouches[0].x - oldTouches[0].x;
        this.yOffset += newTouches[0].y - oldTouches[0].y;
    };

    ViewportTransformation.prototype.applyScaleTouchChanges = function (oldTouches, newTouches) {
        this.xOffset += 0.5 * (
    newTouches[0].x + newTouches[1].x -
    oldTouches[0].x - oldTouches[1].x
  );
        this.yOffset += 0.5 * (
    newTouches[0].y + newTouches[1].y -
    oldTouches[0].y - oldTouches[1].y
  );

        var dst1 = Distance.hypot(oldTouches[1].x - oldTouches[0].x, oldTouches[1].y - oldTouches[0].y);
        var dst2 = Distance.hypot(newTouches[1].x - newTouches[0].x, newTouches[1].y - newTouches[0].y);

        this.scale *= (dst2 / dst1);
    };

    ViewportTransformation.prototype.transformProjection = function (projection) {
        var viewport = projection.viewport;
        var screen = projection.screen;

        var vmidx = (viewport.xmin + viewport.xmax) / 2;
        var vmidy = (viewport.ymin + viewport.ymax) / 2;
        var vminx = vmidx + (viewport.xmin - vmidx) / this.scale;
        var vmaxx = vmidx + (viewport.xmax - vmidx) / this.scale;
        var vminy = vmidy + (viewport.ymin - vmidy) / this.scale;
        var vmaxy = vmidy + (viewport.ymax - vmidy) / this.scale;

        // Pixel coord vs cartesian coord flip means that voffset_y needs to be flipped.
        var vox = this.xOffset * (vmaxx - vminx) / screen.width;
        var voy = -this.yOffset * (vmaxy - vminy) / screen.height;

        return new Projection(
    projection.screen,
    new Viewport(vminx - vox, vmaxx - vox, vminy - voy, vmaxy - voy),
    projection.settings
  );
    };

    return ViewportTransformation;
});

define('graphing/screen', ['./viewport'], function (Viewport) {

    function Screen(width, height) {
        this.width = width;
        this.height = height;

        return this;
    }

    Screen.prototype.clone = function () {
        return new Screen(this.width, this.height);
    };

    Screen.prototype.toObject = function () {
        return { width: this.width, height: this.height };
    };

    Screen.prototype.toClippingViewport = function () {
        return new Viewport(-1, this.width + 2, -1, this.height + 2);
    };

    return Screen;
});

// Disable text selection
; (function ($) {

    $.fn.disableTextSelection = function (removeFocus) {

        if (removeFocus) {
            this.each(function () {
                $(this).bind("mousedown touchstart", function () {
                    $(document.activeElement).focusout();
                });
            });
        }

        return this.each(function () {
            $(this).attr('unselectable', 'on').css({
                '-moz-user-select': 'none',
                '-webkit-user-select': 'none',
                'user-select': 'none'
            })
               .each(function () {
                   this.onselectstart = function () { return false; };
               });
        });
    };

})(jQuery);

define("lib/jquery.disabletextselection", function () { });

define('graphing/canvaslayer', ['require', 'jquery', 'pjs', 'lib/browser', 'lib/jquery.disabletextselection'], function (require) {
    var $ = require('jquery');
    var P = require('pjs');
    var Browser = require('lib/browser');
    require('lib/jquery.disabletextselection');

    var CanvasLayer = P(function (layer) {

        layer.init = function (width, height) {
            this.$ = $("<div class='graph-outer'></div>")
           .css('position', 'absolute')
           .css('overflow', 'hidden')
           .disableTextSelection(Browser.IS_IE);

            this.canvas_node = $("<canvas class='graph-inner'></canvas>")
                     .css('position', 'relative')
                     .css('display', 'block')
                     .disableTextSelection(Browser.IS_IE);

            this.resize(width, height);

            this.$.append(this.canvas_node);
            this.ctx = this.canvas_node[0].getContext('2d');
        };

        layer.resize = function (width, height) {

            // early trap if not changing size
            if (width === this.width && height === this.height) return;

            this.width = width;
            this.height = height;

            this.$.css('width', width + "px")
          .css('height', height + "px");

            this.canvas_node.css('width', width + "px")
                    .css('height', height + "px")
                    .attr('width', width)
                    .attr('height', height);
        };

        // should get overridden by subclass
        layer.redraw = function () { };

        layer.saveUnscaledCanvas = function (projection) {

            // if we've already saved it, don't want to overwrite it. You must release
            // it if you want to resave it.
            if (this.unscaledCanvas) return;

            // create an offscreen canvas to store what the graphs looked like
            // unscaled. We can then apply a transformation to it and redraw
            // it on the visible canvas. This is way faster in safari.
            this.unscaledCanvas = document.createElement('canvas');
            this.unscaledCanvas.width = projection.screen.width;
            this.unscaledCanvas.height = projection.screen.height;

            var ctx = this.unscaledCanvas.getContext('2d');
            ctx.drawImage(this.canvas_node[0], 0, 0);
        };

        layer.releaseUnscaledCanvas = function () {
            // garbage collection should find remove the canvas node
            this.unscaledCanvas = null;
        };

        layer.paintScaledCanvas = function (transformation) {

            // can't do this if we don't have an unscaledCanvas to scale
            if (!this.unscaledCanvas) return;

            var t = transformation;

            var width = this.ctx.canvas.width;
            var height = this.ctx.canvas.height;

            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.clearRect(0, 0, width, height);
            this.ctx.setTransform(
        t.scale, 0,
        0, t.scale,
        t.xOffset - 0.5 * (t.scale - 1) * width,
        t.yOffset - 0.5 * (t.scale - 1) * height
      );
            this.ctx.drawImage(this.unscaledCanvas, 0, 0);
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        };
    });

    return CanvasLayer;
});

define('graphing/clipping', [], function () {

    var Clipping = {

        TOP: 1,
        BOTTOM: 2,
        LEFT: 4,
        RIGHT: 8,
        ALL: 15,
        X: 12,
        Y: 3,

        POLAR_RADIAN_EQUALITY: 1,
        POLAR_RADIAN_INEQUALITY: 2,
        POLAR_DEGREE_EQUALITY: 3,
        POLAR_DEGREE_INEQUALITY: 4,
        Y_EQUALS: 5,
        X_EQUALS: 6,

        mapSegmentToCanvas: function (segment, viewport, screen, graphType) {
            var output = [];
            var xmin = viewport.xmin;
            var ymin = viewport.ymin;
            var xrange = viewport.xmax - viewport.xmin;
            var yrange = viewport.ymax - viewport.ymin;
            var width = screen.width;
            var height = screen.height;
            var xscale = width / xrange;
            var yscale = -height / yrange;
            var len = segment.length;
            var i, x, y, theta, r;

            if (graphType === Clipping.Y_EQUALS) {

                for (i = 0; i < len; i += 2) {
                    x = (segment[i] - xmin) * xscale - 0.5;
                    y = (segment[i + 1] - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.X_EQUALS) {

                for (i = 0; i < len; i += 2) {
                    x = (segment[i + 1] - xmin) * xscale - 0.5;
                    y = (segment[i] - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_RADIAN_EQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i];
                    r = segment[i + 1];
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_RADIAN_INEQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i];
                    r = segment[i + 1];
                    if (r < 0) r = 0;
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_DEGREE_EQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i] * Math.PI / 180;
                    r = segment[i + 1];
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_DEGREE_INEQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i] * Math.PI / 180;
                    r = segment[i + 1];
                    if (r < 0) r = 0;
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            }

            return output;
        },

        clipStrokeEdges: function (segment, viewport) {
            return Clipping.clipFillEdges(segment, viewport, Clipping.ALL, true);
        },

        clipFillEdge: function (input, inside_test, exit_point, is_open) {
            var output = [];
            var push = [].push;
            var start_index;

            if (is_open) {  //stroke
                x = input[0];
                y = input[1];
                start_index = 2;
                inside = inside_test(x, y);
                if (inside) output.push(x, y);
            } else {      //fill
                x = input[input.length - 2];
                y = input[input.length - 1];
                start_index = 0;
                inside = inside_test(x, y);
            }

            for (var i = start_index; i < input.length; i += 2) {
                var x_prev = x;
                var y_prev = y;
                var inside_prev = inside;

                var x = input[i];
                var y = input[i + 1];
                var inside = inside_test(x, y);

                if (!inside && !inside_prev) {
                    continue;
                }
                if (inside && inside_prev) {
                    output.push(x, y);
                }
                if (inside && !inside_prev) {
                    push.apply(output, exit_point(x, y, x_prev, y_prev));
                    output.push(x, y);
                }
                if (!inside && inside_prev) {
                    push.apply(output, exit_point(x_prev, y_prev, x, y));
                }
            }
            return output;
        },

        clipFillEdges: function (input, viewport, edges, is_open) {
            var xmin = viewport.xmin;
            var xmax = viewport.xmax;
            var ymin = viewport.ymin;
            var ymax = viewport.ymax;

            var test_xmin = function (x, y) {
                return x >= xmin;
            };
            var test_xmax = function (x, y) {
                return x <= xmax;
            };
            var test_ymin = function (x, y) {
                return y >= ymin;
            };
            var test_ymax = function (x, y) {
                return y <= ymax;
            };

            var entry_xmin = function (x, y, x2, y2) {
                var dy = y2 - y;
                return [xmin, y + dy * (xmin - x) / (x2 - x)];
            };
            var entry_xmax = function (x, y, x2, y2) {
                var dy = y2 - y;
                return [xmax, y + dy * (xmax - x) / (x2 - x)];
            };
            var entry_ymin = function (x, y, x2, y2) {
                var dx = x2 - x;
                return [x + dx * (ymin - y) / (y2 - y), ymin];
            };
            var entry_ymax = function (x, y, x2, y2) {
                var dx = x2 - x;
                return [x + dx * (ymax - y) / (y2 - y), ymax];
            };

            var output = input;

            if (edges & Clipping.LEFT) {
                output = Clipping.clipFillEdge(input, test_xmin, entry_xmin, is_open);
            }

            if (edges & Clipping.BOTTOM) {
                output = Clipping.clipFillEdge(output, test_ymin, entry_ymin, is_open);
            }

            if (edges & Clipping.RIGHT) {
                output = Clipping.clipFillEdge(output, test_xmax, entry_xmax, is_open);
            }

            if (edges & Clipping.TOP) {
                output = Clipping.clipFillEdge(output, test_ymax, entry_ymax, is_open);
            }

            return output;
        },

        clipAllFillEdges: function (input, viewport) {
            return Clipping.clipFillEdges(input, viewport, Clipping.ALL, false);
        },

        computePolarFill: function (segment, fillTowards, polarInterval) {

            var push = [].push;
            var clipped_edges = null;
            var all_segments = [];

            var theta;
            var start_theta = segment[0];
            var end_theta = start_theta + polarInterval;
            var limited_segment = [];
            all_segments.push(limited_segment);

            // detect 2pi intervals and split into separate segments
            for (var i = 0; i < segment.length; i += 2) {
                theta = segment[i];
                var r = segment[i + 1];
                if (r < 0) r = 0;

                if (theta >= end_theta) {

                    limited_segment = [];
                    all_segments.push(limited_segment);
                    start_theta = segment[i - 2]; //previous theta
                    end_theta = start_theta;
                    // Make sure that end_theta always increases. Adding polarInterval
                    // only once isn't enough because theta might change by more than
                    // polarInterval between two samples.
                    while (theta >= end_theta) end_theta += polarInterval;
                    i -= 4; //go back 1 theta (for loop will +2)

                } else {
                    limited_segment.push(theta, r);
                }

            }

            if (fillTowards === 0) {
                // just fill towards the origin
                for (i = 0; i < all_segments.length; i++) {
                    all_segments[i].push(0, 0);
                }

            } else {

                // shade toward outside. trace around counter clockwise, jump to the
                // outside, and trace around clockwise again at pi/8 intervals. Then
                // go to the starting theta with very large radius.
                var clockwise_step = polarInterval / 16;
                var radius = fillTowards;
                for (i = 0; i < all_segments.length; i++) {
                    var seg = all_segments[i];
                    start_theta = seg[0];
                    end_theta = seg[seg.length - 2];
                    for (theta = end_theta; theta > start_theta; theta -= clockwise_step) {
                        seg.push(theta, radius);
                    }
                    seg.push(start_theta, radius);
                }

            }

            return all_segments;
        },

        computeCartesianFill: function (segment, fillTowards) {

            var push = [].push;
            var clipped_edges = null;
            var all_segments = [];

            // copy the incoming segment and push it to the list
            segment = segment.slice();

            // add a couple points that decide which direction we fill
            segment.push(segment[segment.length - 2], fillTowards);
            segment.push(segment[0], fillTowards);

            return [segment];
        }
    };

    return Clipping;
});

//TODO - something is slow about this when zoomed way out.
//       could be subpixel rendering.
define('graphing/dasheddrawer', ['require', './constants', 'math/distance'], function (require) {
    require('./constants');
    var Distance = require('math/distance');

    function DashedDrawer(ctx, seglen) {
        this.pattern = [11, 7];
        this.replen = this.pattern[0] + this.pattern[1];

        if (seglen !== null && seglen / this.replen > MAX_DOTTED_SEGMENTS) {
            this.pattern[0] = seglen * this.pattern[0] / this.replen / MAX_DOTTED_SEGMENTS;
            this.pattern[1] = seglen * this.pattern[1] / this.replen / MAX_DOTTED_SEGMENTS;
        }

        this.pstate = 0; // 0 being "draw a line"
        this.dstaccum = 0.0;
        this.px = null;
        this.py = null;
        this.ctx = ctx;

        return this;
    }

    DashedDrawer.getTotalSegmentLength = function (segment) {
        if (segment.length < 4) return 0;

        var len = 0;
        var x = segment[0];
        var y = segment[1];

        for (var i = 2; i < segment.length; i += 2) {
            var nx = segment[i];
            var ny = segment[i + 1];

            len += Distance.hypot(nx - x, ny - y);

            x = nx;
            y = ny;
        }

        return len;
    };

    DashedDrawer.prototype.start = function (x, y) {
        if (!this.ctx.desmos_batching) this.ctx.beginPath();
        this.px = x;
        this.py = y;
    };

    DashedDrawer.prototype.next = function (x, y) {
        var dstlimit = this.pattern[this.pstate];
        var dstincr = Math.sqrt(Math.pow(x - this.px, 2) + Math.pow(y - this.py, 2));

        if (dstincr > 0.00001) {
            while (dstincr + this.dstaccum >= dstlimit) {
                // Draw up to the phase change, change phase.
                // compute actual line-to point
                var incrx = x - this.px;
                var incry = y - this.py;

                // Scaling factor
                var linedst = dstlimit - this.dstaccum;
                incrx *= linedst / dstincr;
                incry *= linedst / dstincr;

                // Draw if in the draw state
                if (this.pstate === 0) {
                    this.ctx.moveTo(this.px, this.py);
                    this.ctx.lineTo(this.px + incrx, this.py + incry);
                }

                // Reset the accumulator
                this.dstaccum = 0.0;
                this.px += incrx;
                this.py += incry;
                // Flip the pattern state
                this.pstate = 1 - this.pstate;
                dstlimit = this.pattern[this.pstate];
                dstincr -= linedst;
            }

            // Draw up to the target point.
            if (this.pstate === 0) {
                this.ctx.moveTo(this.px, this.py);
                this.ctx.lineTo(x, y);
            }
        }
        this.px = x;
        this.py = y;
        this.dstaccum += dstincr;
    };

    DashedDrawer.prototype.skip = function (x, y) {
        this.px = x;
        this.py = y;
    };

    DashedDrawer.prototype.close = function () {
        if (!this.ctx.desmos_batching) this.ctx.stroke();

        this.pstate = 0; // 0 being "draw a line"
        this.dstaccum = 0.0;
        this.px = null;
        this.py = null;
    };

    return DashedDrawer;
});

define('graphing/graphslayer', ['require', 'pjs', './canvaslayer', './clipping', './dasheddrawer'], function (require) {
    var P = require('pjs');
    var CanvasLayer = require('./canvaslayer');
    var Clipping = require('./clipping');
    var DashedDrawer = require('./dasheddrawer');

    var GraphsLayer = P(CanvasLayer, function (layer) {

        layer.redraw = function (projection, graphSketches) {
            var screen = projection.screen;

            // make sure that this is the correct size
            this.resize(screen.width, screen.height);
            // Clear out the drawing area
            this.ctx.clearRect(0, 0, screen.width, screen.height);
            this.redrawToCtx(this.ctx, projection, graphSketches);

        };

        layer.redrawToCtx = function (ctx, projection, graphSketches) {
            // TODO - maybe should be more explict about order.
            // Do the drawing of the segments
            for (var id in graphSketches) {
                var sketch = graphSketches[id];

                if (sketch.visible) {
                    GraphsLayer.drawSketchToCtx(graphSketches[id], ctx, projection);
                }
            }
        };

    });

    GraphsLayer.eachSegment = function (sketch, fn) {
        for (var i = 0; i < sketch.branches.length; i++) {
            var branch = sketch.branches[i];
            for (var j = 0; j < branch.segments.length; j++) {
                var segment = branch.segments[j];
                fn(branch, segment);
            }
        }
    };

    GraphsLayer.drawSketchToCtx = function (sketch, ctx, projection) {

        if (!sketch.branches || !sketch.branches.length) return;

        ctx.lineWidth = projection.settings.graphLineWidth;
        ctx.strokeStyle = sketch.color;
        ctx.fillStyle = sketch.color;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        //If we're drawing points, draw points and return
        ctx.desmos_batching = true;
        ctx.beginPath();
        ctx.save();
        GraphsLayer.eachSegment(sketch, function (branch, segment) {
            if (branch.graphMode === GRAPHMODE_XYPOINT) {
                GraphsLayer.drawPointsToCtx(ctx, projection, segment);
            }
        });

        ctx.globalAlpha = POINT_ALPHA;
        ctx.stroke();
        ctx.restore();
        ctx.desmos_batching = false;

        //If we're filling, fill.  No batching, because we want polar to shade deeper in overlaps
        GraphsLayer.eachSegment(sketch, function (branch, segment) {
            if (branch.graphMode === GRAPHMODE_XYPOINT) return;
            graphMode = GRAPHMODE_Y;
            if (branch.flip) graphMode = GRAPHMODE_X;
            if (branch.graphMode) graphMode = branch.graphMode;

            if (graphMode === GRAPHMODE_POLYGONFILL) {
                GraphsLayer.fillPolygonToCtx(ctx, projection, segment);
            } else {
                var op = branch.operator;
                var fill = (op == "<" || op == ">" || op == "<=" || op == ">=" || op == "\\leq" || op == "\\le" || op == "\\geq" || op == "\\ge");
                var fill_d = (op == "<=" || op == "<" || op == "\\leq" || op == "\\le");

                if (fill) GraphsLayer.fillGraphStrokeToCtx(ctx, projection, segment, fill_d, graphMode);
            }
        });

        //If we're drawing segments, draw them
        ctx.desmos_batching = true;
        ctx.beginPath();
        GraphsLayer.eachSegment(sketch, function (branch, segment) {
            if (branch.graphMode === GRAPHMODE_XYPOINT) return;
            var graphMode = GRAPHMODE_Y;
            if (branch.flip) graphMode = GRAPHMODE_X;
            if (branch.graphMode) graphMode = branch.graphMode;

            var op = branch.operator;
            var dotted = (op == "<" || op == ">" || op == '!='); //!= is used for shade-between lines which should be dashed but not filled

            GraphsLayer.drawGraphStrokeToCtx(ctx, projection, segment, dotted, graphMode, op);
        });
        ctx.globalAlpha = STROKE_ALPHA;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        ctx.desmos_batching = false;
    };

    GraphsLayer.drawGraphStrokeToCtx = function (ctx, projection, segment, dotted, graphMode, op) {
        ctx.globalAlpha = projection.settings.highlight ? HIGHLIGHTED_STROKE_ALPHA : STROKE_ALPHA;

        // takes the raw array of numbers and maps it to the canvas. Then it clips.
        var graphType = GraphsLayer.getClippingGraphType(graphMode, op !== "=", projection.settings);
        var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, graphType);
        var clipped = Clipping.clipStrokeEdges(scaled, projection.screen.toClippingViewport());
        var i;

        // draws the clipped segment as a solid curve
        if (!dotted) {

            if (!ctx.desmos_batching) ctx.beginPath();
            ctx.moveTo(clipped[0], clipped[1]);
            for (i = 0; i < clipped.length; i += 2) {
                ctx.lineTo(clipped[i], clipped[i + 1]);
            }
            if (!ctx.desmos_batching) ctx.stroke();

            // draws the clipped segment as a dashed curve
        } else {

            var buf = new DashedDrawer(ctx, DashedDrawer.getTotalSegmentLength(clipped));
            buf.start(clipped[0], clipped[1]);
            for (i = 2; i < clipped.length; i += 2) {
                buf.next(clipped[i], clipped[i + 1]);
            }
            buf.close();

        }

        ctx.globalAlpha = 1.0;
    };

    GraphsLayer.drawPointToCtx = function (ctx, projection, x, y, alpha) {

        // if the point is more than 20px off the screen in any direction, we just
        // don't draw it.
        var padding = 20;
        var mx = projection.mapx(x) - 0.5;
        if (mx < -padding || mx > projection.screen.width + padding) return false;

        var my = projection.mapy(y) - 0.5;
        if (my < -padding || my > projection.screen.height + padding) return false;

        ctx.globalAlpha = projection.settings.highlight ? HIGHLIGHTED_POINT_ALPHA : POINT_ALPHA;
        if (alpha) ctx.globalAlpha = alpha;

        ctx.globalAlpha = POINT_ALPHA;
        if (!ctx.desmos_batching) ctx.beginPath();
        // For some reason we need a full polygon, but a small one.
        ctx.moveTo(mx - 0.1, my - 0.1);
        ctx.lineTo(mx - 0.1, my + 0.1);
        ctx.lineTo(mx + 0.1, my + 0.1);
        ctx.lineTo(mx + 0.1, my - 0.1);
        ctx.closePath();
        if (!ctx.desmos_batching) ctx.stroke();

        ctx.globalAlpha = 1.0;

        return true;
    };

    GraphsLayer.drawPointsToCtx = function (ctx, projection, segment) {
        ctx.lineWidth = projection.settings.pointLineWidth;

        for (var i = 0; i < segment.length; i++) {
            GraphsLayer.drawPointToCtx(ctx, projection, segment[i][0], segment[i][1]);
        }
    };

    GraphsLayer.fillGraphStrokeToCtx = function (ctx, projection, segment, fillDown, graphMode) {
        ctx.globalAlpha = (graphMode === GRAPHMODE_POLAR) ? POLAR_ALPHA : FILL_ALPHA;

        var push = [].push;
        var fill_paths = null;
        var clipped_edges = null;
        var fillTowards;

        if (graphMode === GRAPHMODE_POLAR) {

            clipped_edges = Clipping.ALL;
            var radius = fillDown ? 0 : projection.viewport.polarDiameter();
            var interval = projection.settings.degreeMode ? 180.0 : 2 * Math.PI;
            fill_paths = Clipping.computePolarFill(segment, radius, interval);

        } else if (graphMode === GRAPHMODE_Y) {

            clipped_edges = Clipping.Y;
            fillTowards = fillDown ? projection.viewport.ymin : projection.viewport.ymax;
            fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

        } else if (graphMode === GRAPHMODE_X) {

            clipped_edges = Clipping.X;
            fillTowards = fillDown ? projection.viewport.xmin : projection.viewport.xmax;
            fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

        }

        // scale, clip, and then draw each fill path
        var clipped_viewport = projection.screen.toClippingViewport();
        for (var i = 0; i < fill_paths.length; i++) {

            // scale the segment
            var map_graphType = GraphsLayer.getClippingGraphType(graphMode, true, projection.settings);
            var scaled = Clipping.mapSegmentToCanvas(fill_paths[i], projection.viewport, projection.screen, map_graphType);

            // clip the segment
            var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, clipped_edges);

            // draw the segment
            if (clipped.length >= 6) {
                ctx.beginPath();

                ctx.moveTo(clipped[0], clipped[1]);
                for (var j = 2; j < clipped.length; j += 2) {
                    ctx.lineTo(clipped[j], clipped[j + 1]);
                }

                ctx.closePath();
                ctx.fill();
            }
        }

        ctx.globalAlpha = 1.0;
    };

    GraphsLayer.fillPolygonToCtx = function (ctx, projection, segment) {
        ctx.globalAlpha = FILL_ALPHA;

        var clipped_viewport = projection.screen.toClippingViewport();

        // scale the segment
        var map_graphType = GraphsLayer.getClippingGraphType(graphMode, true, projection.settings);
        var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, Clipping.Y_EQUALS);

        // clip the segment
        var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, Clipping.ALL);

        // draw the segment
        if (clipped.length >= 6) {
            ctx.beginPath();

            ctx.moveTo(clipped[0], clipped[1]);
            for (var j = 2; j < clipped.length; j += 2) {
                ctx.lineTo(clipped[j], clipped[j + 1]);
            }

            ctx.closePath();
            ctx.fill();
        }

        ctx.globalAlpha = 1.0;
    };

    GraphsLayer.getClippingGraphType = function (graphMode, isInequality, settings) {
        switch (graphMode) {

            case GRAPHMODE_X:
                return Clipping.X_EQUALS;

            case GRAPHMODE_PARAMETRIC:
            case GRAPHMODE_Y:
                return Clipping.Y_EQUALS;

            case GRAPHMODE_POLAR:
                if (settings.degreeMode) {
                    return isInequality ? Clipping.POLAR_DEGREE_INEQUALITY : Clipping.POLAR_DEGREE_EQUALITY;
                } else {
                    return isInequality ? Clipping.POLAR_RADIAN_INEQUALITY : Clipping.POLAR_RADIAN_EQUALITY;
                }

        }
    };

    return GraphsLayer;
});

define('graphing/poidotslayer', ['pjs', './graphslayer', './canvaslayer'], function (P, GraphsLayer, CanvasLayer) {
    // TODO - rename from 'POIDotsLayer to something like SketchStyleLayer.
    var POIDotsLayer = P(CanvasLayer, function (layer) {

        layer.redraw = function (projection, graphSketches) {

            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // Clear out the drawing area
            this.ctx.clearRect(0, 0, projection.screen.width, projection.screen.height);

            // Iterate through each graphSketch, find the ones that should showPOI
            // and draw the poi dots. Also, we save the dots we drew.
            var savedPOI = [];
            for (var id in graphSketches) {
                var sketch = graphSketches[id];

                if (sketch.visible) {

                    if (sketch.showHighlight) {
                        POIDotsLayer.drawSketchHighlight(sketch, this.ctx, projection);
                    }

                    if (sketch.showPOI) {
                        savedPOI.push.apply(savedPOI, POIDotsLayer.drawSketchPOI(sketch, this.ctx, "#AAAAAA", projection));
                    }
                }
            }
            this.savedPOI = savedPOI;
        };

        layer.getDrawnPOI = function () {
            return this.savedPOI;
        };
    });

    POIDotsLayer.drawSketchHighlight = function (sketch, ctx, projection) {
        projection.settings.setProperty('highlight', true);
        GraphsLayer.drawSketchToCtx(sketch, ctx, projection);
        projection.settings.setProperty('highlight', false);
    };

    POIDotsLayer.drawSketchPOI = function (sketch, ctx, color, projection) {

        ctx.lineWidth = projection.settings.pointLineWidth;
        ctx.strokeStyle = color || "#AAAAAA";
        ctx.fillStyle = color || "#AAAAAA";
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        var oldGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = POI_ALPHA;

        var poiOnScreen = [];
        var pois = sketch.getPOI();
        var i, plen = pois.length;
        for (i = 0; i < plen; i++) {

            var poi = pois[i];
            if (GraphsLayer.drawPointToCtx(ctx, projection, poi.x, poi.y, POI_ALPHA)) {
                poiOnScreen.push(poi);
            }

        }

        ctx.globalAlpha = oldGlobalAlpha;
        return poiOnScreen;
    };

    return POIDotsLayer;
});

define('graphing/domlayer', ['require', 'pjs', 'jquery', 'lib/browser', 'lib/jquery.disabletextselection'], function (require) {
    var P = require('pjs');
    var $ = require('jquery');
    var Browser = require('lib/browser');
    require('lib/jquery.disabletextselection');

    var DOMLayer = P(function (layer) {

        layer.init = function (width, height) {
            this.$ = $("<div class='graph-outer'></div>")
           .css('position', 'absolute')
           .css('overflow', 'hidden')
           .disableTextSelection(Browser.IS_IE);

            this.dom_node = $("<div></div>")
                     .css('position', 'relative')
                     .css('display', 'block')
                     .disableTextSelection(Browser.IS_IE);

            this.resize(width, height);

            this.$.append(this.dom_node);
        };

        layer.resize = function (width, height) {

            // early trap if not changing size
            if (width === this.width && height === this.height) return;

            this.width = width;
            this.height = height;

            this.$.css('width', width + "px")
          .css('height', height + "px");

            this.dom_node.css('width', width + "px")
                 .css('height', height + "px");
        };

        // should get overridden by subclass
        layer.redraw = function () { };
    });

    return DOMLayer;
});

define('graphing/label', ['math/builtin'], function (BuiltIn) {
    // Returns a label for a point with an appropriate number of decimals for the
    // given scale. Scale is typically chosen to be the range of numbers displayed
    // in the current viewport. Rounds to pi fractions when the denominator is 24
    // or less, according to a tolerance that depends on x and scale.
    //
    // Label is returned as on object with the string representation given by
    // label.string, and represented value label.value, which is equal to x when
    // the string is a decimal representation, and equal to n*Math.PI/d for pi
    // fractions. This is used for checking if a labeled value is actually a hole
    // in the function.
    function value(x, scale) {

        if (isNaN(x)) return { string: 'undefined', value: x };

        if (x === 0) return { string: '0', value: x };

        if (!scale) scale = x;

        var piFraction = BuiltIn.toFraction(x / Math.PI, 24);
        var nString;
        var dString;

        if (
    x !== Math.floor(x) &&
    BuiltIn.approx(piFraction.n / piFraction.d * Math.PI, x, 3)
  ) {
            if (piFraction.n === 0) {
                nString = "0";
            } else if (piFraction.n === 1) {
                nString = "蟺";
            } else if (piFraction.n === -1) {
                nString = "-蟺";
            } else {
                nString = piFraction.n.toString() + "蟺";
            }

            if (piFraction.d === 1) {
                dString = "";
            } else {
                dString = "/" + piFraction.d.toString();
            }

            return {
                string: nString + dString,
                value: piFraction.n / piFraction.d * Math.PI
            };
        }

        var outputString = (fewDigits(scale)) ?
    stripZeros(x.toFixed(decimalsFromScale(scale))) :
    stripExponentialZeros(x.toExponential(decimalsFromScale(scale / x)))
  ;

        return { string: outputString, value: x };
    }

    // x and f(value(x).value), returning the results as two strings. Useful
    // because the function may have a hole at value(x).value.
    function point(x, xscale, yscale, fn) {
        var xlabel = value(x, xscale);
        var ylabel = value(fn(xlabel.value), yscale);
        return [xlabel, ylabel];
    }

    // Strip trailing zeros from a string representation of a decimal.
    var trailingZerosRegex = /\.?0+$/;
    function stripZeros(string) {
        if (string.indexOf('.') === -1) return string;
        return string.replace(trailingZerosRegex, '');
    }

    var exponentialTrailingZerosRegex = /\.?0+e/;
    function stripExponentialZeros(string) {
        return string.replace(exponentialTrailingZerosRegex, 'e');
    }

    function fewDigits(x) {
        x = Math.abs(x);
        return 1e-4 < x && x < 1e8;
    }

    // Returns integer number of decimals to show given scale of numbers to be
    // represented.
    function decimalsFromScale(scale) {
        scale = Math.abs(scale);
        scale = Math.max(scale, 1e-16);
        return Math.max(0, Math.floor(4.5 - Math.log(scale) / Math.LN10));
    }

    return {
        value: value,
        point: point
    };

});
define('graphing/poilabelslayer', ['pjs', 'jquery', './domlayer', './label'], function (P, $, DOMLayer, Label) {

    var POILabelsLayer = P(DOMLayer, function (layer, _super) {

        // can't use jquery addClass and removeClass because they are slow on ipad.
        // the problem appears to be that jquery implementation keeps setting the
        // className property of the element even if nothing has changed. In turn,
        // ios appears to rerender everything since .className was set. So we only
        // add/remove the class if it'll change the className of the body.
        var body = $('body');
        function addGlobalClass(className) {
            if (!body.hasClass(className)) {
                body.addClass(className);
            }
        }
        function removeGlobalClass(className) {
            if (body.hasClass(className)) {
                body.removeClass(className);
            }
        }

        layer.redraw = function (projection, graphSketches) {

            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // Clear out the drawing area
            this.dom_node.find('.poi').remove();

            // check if an old hoveredPOI was set and clear it out if so
            var hoveredPOI = this.hoveredPOI;
            var hoveredSketch = hoveredPOI ? hoveredPOI.sketch : null;
            var foundHoveredSketch = false;

            // Iterate through each graphSketch, find the opened poi and draw them
            // also saves which ones were drawn.
            var savedPOI = [];
            for (var id in graphSketches) {
                var sketch = graphSketches[id];
                if (sketch === hoveredSketch) foundHoveredSketch = true;
                if (!sketch.visible) continue;

                var pois = POILabelsLayer.drawOpenPOI(sketch, this.dom_node, projection);
                if (pois.length) {
                    savedPOI.push.apply(savedPOI, pois);
                }
            }

            // we had a hoveredPOI set but the sketch isn't there any more. clear out
            // the hoverdPOI property.
            if (!foundHoveredSketch) {
                hoveredPOI = this.hoveredPOI = null;
            }

            if (hoveredPOI && hoveredPOI.sketch.visible) {

                if (!hoveredPOI.isOpen()) {
                    POILabelsLayer.drawHoveredPOI(this.dom_node, hoveredPOI, projection);
                    addGlobalClass('mouse-over-closed-poi');
                } else {
                    addGlobalClass('mouse-over-opened-poi');
                }

            } else {

                removeGlobalClass('mouse-over-closed-poi');
                removeGlobalClass('mouse-over-opened-poi');

            }

            this.savedPOI = savedPOI;
        };

        layer.getDrawnPOI = function () {
            return this.savedPOI;
        };

    });

    POILabelsLayer.getPointLabel = function (poi_in, viewport, fn) {
        var xscale = viewport.xmax - viewport.xmin;
        var yscale = viewport.ymax - viewport.ymin;

        var flip = poi_in.getGraphMode() === GRAPHMODE_X;
        var x_i = flip ? 1 : 0;
        var y_i = flip ? 0 : 1;

        var independent = (flip) ? poi_in.y : poi_in.x;

        var labels = Label.point(independent, xscale, yscale, fn);
        return {
            x: labels[x_i].value,
            x_label: labels[x_i].string,
            y: labels[y_i].value,
            y_label: labels[y_i].string,
            is_hole: !isFinite(labels[1].value)
        };
    };

    // TODO - cleanup. Copied and modified from main/grapher.js
    POILabelsLayer.createSinglePOI = function (poi_in, viewport) {

        var fn = poi_in.getCompiledFunction();
        var pt = POILabelsLayer.getPointLabel(poi_in, viewport, fn);
        var hole = pt.is_hole ? 'hole' : '';

        var x_label = pt.x_label.replace("蟺", "<span class='pi'>蟺</span>");
        var y_label = pt.y_label.replace("蟺", "<span class='pi'>蟺</span>");

        return $("<div class='tracept poi " + hole + "'><div class='pt'></div><div class='label'>" + x_label + ", " + y_label + "</div><div class='arrow'></div></div>");
    };

    POILabelsLayer.drawHoveredPOI = function (dom, poi, projection) {
        var screen_x = projection.mapx(poi.x);
        var screen_y = projection.mapy(poi.y);

        // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
        if (screen_x > -20 && screen_y > -20 && screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20) {

            var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
            dom_poi.css({
                left: screen_x + "px",
                top: screen_y + "px"
            });
            dom_poi.addClass('mouseover');
            dom.append(dom_poi);

        }

    };

    POILabelsLayer.drawOpenPOI = function (sketch, dom, projection) {

        var pois = sketch.openPOI;
        if (!pois.length) return [];

        var poiOnScreen = [];
        for (var i = 0; i < pois.length; i++) {
            var poi = pois[i];
            var screen_x = projection.mapx(poi.x);
            var screen_y = projection.mapy(poi.y);

            // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
            if (screen_x > -20 && screen_y > -20 && screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20) {

                var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
                dom_poi.css({
                    left: screen_x + "px",
                    top: screen_y + "px"
                });
                dom_poi.addClass('opened');

                dom.append(dom_poi);
                poiOnScreen.push(poi);

            }
        }

        return poiOnScreen;
    };

    return POILabelsLayer;
});

define('graphing/gridlayer', ['jquery', 'pjs', './canvaslayer', './label'], function ($, P, CanvasLayer, Label) {

    var GridLayer = P(CanvasLayer, function (layer) {

        layer.redraw = function (projection) {
            var screen = projection.screen;
            // make sure that this is the correct size
            this.resize(screen.width, screen.height);
            // Clear out the drawing area
            this.ctx.clearRect(0, 0, screen.width, screen.height);
            this.redrawToCtx(this.ctx, projection);
        };

        layer.redrawToCtx = function (ctx, projection) {
            if (projection.settings.showGrid) {
                this.drawGridLines(ctx, projection);
            }

            if (projection.settings.showAxes) {
                this.drawAxes(ctx, projection);
            }

            if (projection.settings.showLabels) {
                this.drawLabels(ctx, projection);
            }
        };

        var eachStep = function (min, max, step, func) {
            var nmin = Math.ceil(min / step);
            var nmax = Math.floor(max / step);
            for (var n = nmin; n <= nmax; n++) func(n * step);
        };

        var clamp = function (value, min, max) {
            if (value < min) return min;
            if (value > max) return max;
            return value;
        };

        layer.drawGridLines = function (ctx, projection) {

            var xmin = projection.viewport.xmin, ymin = projection.viewport.ymin;
            var xmax = projection.viewport.xmax, ymax = projection.viewport.ymax;

            var info = bestStepSizes(projection);

            var width = projection.screen.width;
            var height = projection.screen.height;

            var minorOpacity = projection.settings.minorAxisOpacity;
            var majorOpacity = projection.settings.majorAxisOpacity;

            ctx.lineWidth = 1;

            // Minor gridlines

            ctx.beginPath();

            ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";

            eachStep(xmin, xmax, info.minorStepX, function (value) {
                var pixelValue = Math.round(projection.mapx(value)) - 0.5;
                ctx.moveTo(pixelValue, 0);
                ctx.lineTo(pixelValue, height);
            });

            eachStep(ymin, ymax, info.minorStepY, function (value) {
                var pixelValue = Math.round(projection.mapy(value)) - 0.5;
                ctx.moveTo(0, pixelValue);
                ctx.lineTo(width, pixelValue);
            });

            ctx.stroke();

            // Major gridlines

            ctx.beginPath();
            // Compensate for double stroking major gridlines. Strokes opacities
            // compose as o3 = 1 - (1 - o1)(1 - o2). We know what we've stroked so
            // far (o1), and what final stroke we'd like (o3), so solve for o2:
            // o2 = 1 - (1 - o3)/(1 - o1).
            var adjustedMajorOpacity = 1 - (1 - majorOpacity) / (1 - minorOpacity);
            ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";

            eachStep(xmin, xmax, info.majorStepX, function (value) {
                var pixelValue = Math.round(projection.mapx(value)) - 0.5;
                ctx.moveTo(pixelValue, 0);
                ctx.lineTo(pixelValue, height);
            });

            eachStep(ymin, ymax, info.majorStepY, function (value) {
                var pixelValue = Math.round(projection.mapy(value)) - 0.5;
                ctx.moveTo(0, pixelValue);
                ctx.lineTo(width, pixelValue);
            });

            ctx.stroke();

        };

        layer.drawAxes = function (ctx, projection) {
            var lineOffset = projection.settings.axisLineOffset;
            var axisOpacity = projection.settings.axisOpacity.toString();

            ctx.strokeStyle = "rgba(0,0,0," + axisOpacity + ")";
            ctx.lineWidth = projection.settings.axisLineWidth;
            ctx.beginPath();
            var pixelX = Math.round(projection.mapx(0)) - lineOffset;
            var pixelY = Math.round(projection.mapy(0)) - lineOffset;
            var height = projection.screen.height;
            var width = projection.screen.width;

            ctx.moveTo(pixelX, 0);
            ctx.lineTo(pixelX, height);
            ctx.moveTo(0, pixelY);
            ctx.lineTo(width, pixelY);
            ctx.stroke();
        };

        layer.drawLabels = function (ctx, projection) {

            var xmin = projection.viewport.xmin, xmax = projection.viewport.xmax;
            var ymin = projection.viewport.ymin, ymax = projection.viewport.ymax;
            var info = bestStepSizes(projection);
            var width = projection.screen.width;
            var height = projection.screen.height;

            var hangingColor = projection.settings.labelHangingColor;
            var normalColor = projection.settings.labelNormalColor;

            var xAxis = projection.mapx(0);
            var yAxis = projection.mapy(0);

            var fontSize = projection.settings.labelSize;
            var textHeight = fontSize;

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = fontSize.toString() + "px Arial";

            var minusWidth = (
      ctx.measureText("-1").width - ctx.measureText("1").width
    );

            eachStep(xmin, xmax, info.majorStepX, function (value) {
                var string = Label.value(value, xmax - xmin).string;
                var textWidth = ctx.measureText(string).width / 2;

                var pixelX = projection.mapx(value);
                var pixelY = yAxis + textHeight * 0.6 + 3;

                // Bump negative x values to the left so that the number without the
                // minus sign is centered on the grid line.
                if (value < 0) pixelX -= minusWidth / 2;

                var clampedPixelX = clamp(pixelX, 3 + textWidth, width - 3 - textWidth);
                var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);

                ctx.fillStyle = (pixelY === clampedPixelY) ? normalColor : hangingColor;

                if (string === "0") {
                    ctx.fillStyle = normalColor;
                    ctx.fillText("0", xAxis - 5 - textWidth, pixelY);
                    return;
                }

                ctx.fillText(string, clampedPixelX, clampedPixelY);
            });

            eachStep(ymin, ymax, info.majorStepY, function (value) {
                var string = Label.value(value, ymax - ymin).string;
                var textWidth = ctx.measureText(string).width / 2;

                var pixelY = projection.mapy(value);
                var pixelX = xAxis - textWidth - 5;

                var clampedPixelX = clamp(pixelX, 3 + textWidth, width - 3 - textWidth);
                var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);

                ctx.fillStyle = (pixelX === clampedPixelX) ? normalColor : hangingColor;

                if (string === "0") return;

                ctx.fillText(string, clampedPixelX, clampedPixelY);
            });
        };

        var RATIONAL_STEPS = {
            base: 10,
            major: [1, 2, 5],
            minor: [4, 4, 5]
        };

        var PI_STEPS = {
            base: 10,
            major: [Math.PI, 2 * Math.PI, 5 * Math.PI],
            minor: [4, 4, 5]
        };

        var PI_FRAC_STEPS = {
            base: 2,
            major: [Math.PI / 3],
            minor: [3]
        };

        // Helper for bestStepSizes
        var _bestStep = function (exact, steps) {

            // JM: What does this mean...

            /* 1 + xrange/bestMultiple <= expectedX
            * xrange/(expectedX-1) <= bestMultiple
            * xrange/(expectedX-1) <= mult*base^exp
            * (xrange/expectedX-1) / mult <= base^exp
            * ceil(log((range/expectedX-1)/mult)/log(base)) = exp
            */
            var major, bestMajor = Infinity, bestMinor, exp, num;
            for (var i = 0; i < steps.major.length; i++) {
                major = steps.major[i];
                exp = Math.ceil(Math.log(exact / major) / Math.log(steps.base));
                num = major * Math.pow(steps.base, exp);

                if (num < bestMajor) {
                    bestMajor = num;
                    bestMinor = bestMajor / steps.minor[i];
                }
            }

            return { major: bestMajor, minor: bestMinor };
        };

        var bestStepSizes = function (projection) {

            var width = projection.screen.width;
            var height = projection.screen.height;
            var expectedX = width / projection.settings.pixelsPerLabel + 1;
            var expectedY = height / projection.settings.pixelsPerLabel + 1;
            var xRange = projection.viewport.xmax - projection.viewport.xmin;
            var yRange = projection.viewport.ymax - projection.viewport.ymin;
            var exactX = xRange / (expectedX - 1);
            var exactY = yRange / (expectedY - 1);

            var stepModeX, stepModeY;

            if (!projection.settings.xAxisPiLabels) {
                stepModeX = RATIONAL_STEPS;
            } else if (exactX >= 1) {
                stepModeX = PI_STEPS;
            } else {
                stepModeX = PI_FRAC_STEPS;
            }

            bestX = _bestStep(exactX, stepModeX);

            if (!projection.settings.yAxisPiLabels) {
                stepModeY = RATIONAL_STEPS;
            } else if (exactY >= 1) {
                stepModeY = PI_STEPS;
            } else {
                stepModeY = PI_FRAC_STEPS;
            }

            bestY = _bestStep(exactY, stepModeY);

            // If the axes have similar extents, prefer to choose the same steps for
            // x and y.
            if (stepModeX === stepModeY) {
                var maxRatio = 2;
                var pixel_scale_ratio = (width / xRange) / (height / yRange);
                if (pixel_scale_ratio >= 1 && pixel_scale_ratio <= maxRatio) {
                    bestX = bestY;
                } else if (pixel_scale_ratio <= 1 && pixel_scale_ratio >= 1 / maxRatio) {
                    bestY = bestX;
                }
            }

            return {
                majorStepX: bestX.major,
                minorStepX: bestX.minor,
                majorStepY: bestY.major,
                minorStepY: bestY.minor
            };
        };

    });

    return GridLayer;
});

define('graphing/tracelayer', ['pjs', './domlayer', './poi', './poilabelslayer'], function (P, DOMLayer, POI, POILabelsLayer) {

    var TraceLayer = P(DOMLayer, function (layer) {

        layer.redraw = function (projection) {

            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // Clear out the drawing area
            this.dom_node.find('.tracept').remove();

            var poi = this.traceInfo ? this.traceInfo.pt : null;
            if (!poi) return;

            var screen_x = projection.mapx(poi.x);
            var screen_y = projection.mapy(poi.y);

            // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
            if (screen_x > -20 && screen_y > -20 && screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20) {

                // TODO - this is nasty. the createSinglePOI assumes that we pass in an
                //        instance of the POI class. traceInfo.pt is not a POI. Putting
                //        this here just to test tracing for now.
                var real_poi = new POI(poi.x,
                               poi.y,
                               POI_ZERO,
                               this.traceInfo.branchInfo.sketch,
                               this.traceInfo.branchInfo.branch);

                var dom_poi = POILabelsLayer.createSinglePOI(real_poi, projection.viewport);
                dom_poi.css({
                    left: screen_x + "px",
                    top: screen_y + "px"
                });
                dom_poi.addClass('temp');
                dom_poi.removeClass('poi');
                dom_poi.find('.pt').css('background-color', real_poi.sketch.color);
                dom_poi.find('.pt').css('border-color', real_poi.sketch.color);
                this.dom_node.append(dom_poi);

            }
        };

    });

    return TraceLayer;
});

define('graphing/grapher', ['require', 'lib/browser', './viewport', './viewporttransformation', './screen', './poidotslayer', './poilabelslayer', './gridlayer', './canvaslayer', './graphslayer', './projection', './tracelayer'], function (require) {
    var Browser = require('lib/browser');
    var Viewport = require('./viewport');
    var ViewportTransformation = require('./viewporttransformation');
    var Screen = require('./screen');
    var POIDotsLayer = require('./poidotslayer');
    var POILabelsLayer = require('./poilabelslayer');
    var GridLayer = require('./gridlayer');
    var CanvasLayer = require('./canvaslayer');
    var GraphsLayer = require('./graphslayer');
    var Projection = require('./projection');
    var TraceLayer = require('./tracelayer');


    // This is the guy you talk to in order to allocate/deallocate graph layers.
    // container is the <div> element that holds the graph area. Grapher handles resize automatically.
    // onRecompute is the handler that should be called when a recompute is requested.
    // onRecompute(viewport as Viewport, screen as Screen)
    function Grapher(container, settings) {
        var self = this;

        this.container = container;
        this.$ = $(container);

        this.viewport = new Viewport();
        this.screen = new Screen(this.$.width(), this.$.height());

        // a reference to an UnderscoreModel that we can ask for settings values
        this.settings = settings;

        // gridlines
        this.gridLayer = GridLayer(this.screen.width, this.screen.height);
        this.$.append(this.gridLayer.$);

        // poi dots
        this.poiDotsLayer = POIDotsLayer(this.screen.width, this.screen.height);
        this.$.append(this.poiDotsLayer.$);

        // graphs
        this.graphsLayer = GraphsLayer(this.screen.width, this.screen.height);
        this.$.append(this.graphsLayer.$);

        // screenshot layer
        this.$.append('<div class="screenshot"></div>');

        // poi labels (and opened dots)
        this.poiLabelsLayer = POILabelsLayer(this.screen.width, this.screen.height);
        // some weird interaction with overflow:hidden requires a z-index to be
        // set for openpoi to not flicker.
        this.poiLabelsLayer.$.css('z-index', '0');
        this.$.append(this.poiLabelsLayer.$);

        // trace layer
        this.traceLayer = TraceLayer(this.screen.width, this.screen.height);
        // some weird interaction with overflow:hidden requires a z-index to be
        // set for the tracing label to not flicker.
        this.traceLayer.$.css('z-index', '0');
        this.$.append(this.traceLayer.$);

        // needed to tell IE9 that the layer should steal mouse events.
        if (Browser.IS_IE9) {
            this.traceLayer.$.addClass('transparent-bg');
        }

        this.transformation = new ViewportTransformation();
        this.__transient = false;
        this.graphSketches = {};
        this.redrawAllLayers();
        return this;
    }

    Grapher.prototype.clear = function () {
        this.graphSketches = {};
    };

    Grapher.prototype.getGraphSketch = function (graphId) {
        if (graphId in this.graphSketches) {
            return this.graphSketches[graphId];
        } else {
            return null;
        }
    };

    Grapher.prototype.setGraphSketch = function (graphId, sketch) {
        this.graphSketches[graphId] = sketch;
    };

    Grapher.prototype.removeGraphSketch = function (graphId) {
        delete this.graphSketches[graphId];
    };

    Grapher.prototype.createProjection = function () {
        var projection = new Projection(this.screen, this.viewport, this.settings);

        if (this.isInTransientState()) {
            return this.transformation.transformProjection(projection);
        } else {
            return projection;
        }
    };

    // Updates the screen sizes of all of the layers and requests a redraw, viewport stays the same.
    Grapher.prototype.updateScreenSize = function () {
        var w = this.$.width();
        var h = this.$.height();
        if (w <= 0 || h <= 0) return;
        if (this.screen.width === w && this.screen.height === h) return false;

        this.screen.width = w;
        this.screen.height = h;
        return true;
    };

    Grapher.prototype.beginTransientState = function () {
        if (this.isInTransientState()) return;

        var projection = this.createProjection();
        this.graphsLayer.saveUnscaledCanvas(projection);

        this.__transient = true;
    };

    Grapher.prototype.endTransientState = function () {
        if (!this.isInTransientState()) return;
        var projection = this.createProjection();
        this.viewport = projection.viewport;
        this.transformation = new ViewportTransformation();
        this.viewport.round(projection.screen);
        this.graphsLayer.releaseUnscaledCanvas();
        this.__transient = false;
    };

    Grapher.prototype.isInTransientState = function () {
        return this.__transient;
    };

    Grapher.prototype.redrawAllLayers = function () {
        this.cancelRedrawSlowly();
        this.redrawGridLayer();
        this.redrawGraphsLayer();
        this.redrawPOILayer();
        this.redrawTraceLayer();
    };

    Grapher.prototype.cancelRedrawSlowly = function () {
        clearTimeout(this.redraw_slowly_timeout);
        this.redraw_slowly_timeout = null;
    };

    Grapher.prototype.redrawSlowly = function (delay, step, n) {
        //This is an intentional slow-down used on initial graph loads to give a line-by-line drawing effect.
        //It draws only the first n graphs, and calls itself repeatedly on a timeout until all layers are drawn
        //Every delay ms, it draws step more graphs
        if (typeof (delay) === 'undefined') {
            delay = 30;
        }
        if (typeof (step) === 'undefined') {
            step = 1;
        }
        if (typeof (n) === 'undefined') {
            this.cancelRedrawSlowly();
            n = 0;
        }

        this.redrawGridLayer(); //Always draw grid first
        var sketches_to_draw = {};
        var stopped_early = false;
        var i = 0;
        for (var id in this.graphSketches) {
            if (i++ > n) {
                stopped_early = true;
                break;
            }
            sketches_to_draw[id] = this.graphSketches[id];
        }
        this.graphsLayer.redraw(this.createProjection(), sketches_to_draw);
        if (stopped_early) {
            var self = this;
            //Store timeout so that this can be interrupted
            this.redraw_slowly_timeout = setTimeout(function () { self.redrawSlowly(delay, step, n + step) }, delay);
        }
        else {
            //Only draw trace and POI if this was our last iteration
            this.redrawPOILayer();
            this.redrawTraceLayer();

            this.redraw_slowly_timeout = null;
        }
    };

    Grapher.prototype.redrawGridLayer = function () {
        this.gridLayer.redraw(this.createProjection());
    };

    Grapher.prototype.redrawGraphsLayer = function () {
        if (!this.isInTransientState()) {
            this.graphsLayer.redraw(this.createProjection(), this.graphSketches);
        } else {
            this.graphsLayer.paintScaledCanvas(this.transformation);
        }
    };

    Grapher.prototype.redrawPOILayer = function () {
        this.poiDotsLayer.redraw(this.createProjection(), this.graphSketches);
        this.poiLabelsLayer.redraw(this.createProjection(), this.graphSketches);
    };

    Grapher.prototype.redrawTraceLayer = function () {
        this.traceLayer.redraw(this.createProjection());
    };

    Grapher.prototype.screenshot = function () {
        var screen = this.screen;

        var printLayer = CanvasLayer(screen.width, screen.height);
        var ctx = printLayer.ctx;

        // Make a white background, since transparent backgrounds are funny in some
        // environments.
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, screen.width, screen.height);

        ctx.drawImage(this.gridLayer.canvas_node.get(0), 0, 0);
        ctx.drawImage(this.graphsLayer.canvas_node.get(0), 0, 0);

        return printLayer.canvas_node.get(0).toDataURL("image/png");
    };

    Grapher.prototype.thumbnail = function (width, height) {
        var screen = new Screen(width, height);

        var printLayer = CanvasLayer(width, height);
        var ctx = printLayer.ctx;

        var settings = this.settings.clone();
        settings.setProperty('showLabels', false);
        var viewport = this.viewport.clone();

        if (viewport.isSquare(this.screen)) viewport.squareCrop(screen);

        var projection = new Projection(screen, viewport, settings);

        // Make a white background, since transparent backgrounds are funny in some
        // environments.
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, screen.width, screen.height);

        this.gridLayer.redrawToCtx(ctx, projection);
        this.graphsLayer.redrawToCtx(ctx, projection, this.graphSketches);

        return printLayer.canvas_node.get(0).toDataURL("image/png");
    };

    Grapher.prototype.getOpenIntersectionIds = function () {
        var openPOI;
        var hiddenOpenPOI;
        var i;

        var intersectIds = {};

        for (var id in this.graphSketches) {
            if (!this.graphSketches.hasOwnProperty(id)) continue;
            openPOI = this.graphSketches[id].openPOI;
            for (i = openPOI.length - 1; i >= 0; i--) {
                if (openPOI[i].type === POI_INTERSECTION) intersectIds[id] = true;
            }
            hiddenOpenPOI = this.graphSketches[id].hiddenOpenPOI;
            for (i = hiddenOpenPOI.length - 1; i >= 0; i--) {
                if (hiddenOpenPOI[i].type === POI_INTERSECTION) intersectIds[id] = true;
            }
        }

        return intersectIds;
    };

    return Grapher;
});

define('graphing/poicontroller', ['jquery', 'math/distance', 'lib/rounding'], function ($, Distance, Rounding) {

    function POIController(grapher) {
        this.manager = grapher;
        this.$ = this.manager.$;

        this.triggerTraceDown = function (id) { };
        this.triggerOpenPOIChanged = function () { };
        this.addTouchEventHandlers();
        this.addHoverEventHandler();
    }

    POIController.prototype.getToleranceByDevice = function (device) {
        return device === 'touch' ? 20 : 10;
    };

    POIController.prototype.addHoverEventHandler = function () {

        $(document).on('tapmove', function (evt) {

            // only want this handler to proceed on mouse-based interactions
            if (evt.device === 'touch') return;

            var screen_pt = this.getMouseRelativeToGrapher(evt);
            var tolerance = this.getToleranceByDevice(evt.device);
            var poi = this.getPOIUnderPoint(screen_pt, tolerance);
            if (poi != this.manager.poiLabelsLayer.hoveredPOI) {
                this.manager.poiLabelsLayer.hoveredPOI = poi;
                this.manager.redrawPOILayer();
            }

        } .bind(this));

    };

    POIController.prototype.addTouchEventHandlers = function () {

        // hack to prevent dblclick zoom from working when on poi. Ideally, this
        // would happen more naturally. Maybe we wouldn't listen for dblclick within
        // the graphcontroller. Only way that could happen is if we move these events
        // to click based instead of mousedown based.
        this.$.on('dblclick', function (evt) {
            var screen_pt = this.getMouseRelativeToGrapher(evt);
            var tolerance = this.getToleranceByDevice(evt.device);
            if (this.getPOIUnderPoint(screen_pt, tolerance) || this.getBranchInfoUnderPoint(screen_pt, tolerance)) {
                evt.preventDefault();
                evt.handle();
            }
        } .bind(this));

        this.$.on('tapstart', function (evt) {

            var screen_pt = this.getMouseRelativeToGrapher(evt);
            var tolerance = this.getToleranceByDevice(evt.device);
            var poiUnderMouse = this.getPOIUnderPoint(screen_pt, tolerance);
            var allPOIUnderMouse = this.getAllPOIAtSameLocation(poiUnderMouse);

            if (allPOIUnderMouse.length) {

                // want to set all poi under mouse to open or all to closed
                var isOpen = allPOIUnderMouse[0].isOpen();

                for (var i = 0; i < allPOIUnderMouse.length; i++) {
                    if (isOpen) {
                        allPOIUnderMouse[i].close();

                        // hide hovered poi
                        this.manager.poiLabelsLayer.hoveredPOI = null;
                    } else {
                        allPOIUnderMouse[i].open();
                    }
                }

                this.triggerOpenPOIChanged();
                this.manager.redrawPOILayer();

                evt.preventDefault(); //don't lose mathquill focus
                evt.handle(); //prevents panning/zooming
                return;
            }

            var branchInfoUnderMouse = this.getBranchInfoUnderPoint(screen_pt, tolerance);
            if (branchInfoUnderMouse) {
                this.startTracingBranch(screen_pt, branchInfoUnderMouse);

                evt.preventDefault(); //don't lose mathquill focus
                evt.handle(); //prevents panning/zooming
                return;
            }

            this.triggerTraceDown(null);
        } .bind(this));
    };

    POIController.prototype.getMouseRelativeToGrapher = function (evt) {
        var pageOffset = this.$.offset();
        var pt = evt.touches ? evt.touches[0] : evt;

        return { x: pt.pageX - pageOffset.left, y: pt.pageY - pageOffset.top };
    };

    POIController.prototype.getPOIUnderPoint = function (screen_pt, tolerance) {
        var projection = this.manager.createProjection();
        var poi = this.manager.poiLabelsLayer.getDrawnPOI();
        poi = poi.concat(this.manager.poiDotsLayer.getDrawnPOI());


        if (!poi.length) return null;

        var test_poi = poi[0];
        var mapped_poi = projection.map_pt(test_poi);
        var closest_distance = tolerance;
        var closest_poi = null;

        var test_distance = Distance.hypot(mapped_poi.x - screen_pt.x, mapped_poi.y - screen_pt.y);
        if (test_distance < closest_distance) {
            closest_poi = test_poi;
            closest_distance = test_distance;
        }

        for (var i = 1; i < poi.length; i++) {
            test_poi = poi[i];
            mapped_poi = projection.map_pt(test_poi);

            test_distance = Distance.hypot(mapped_poi.x - screen_pt.x, mapped_poi.y - screen_pt.y);
            if (test_distance < closest_distance) {
                closest_distance = test_distance;
                closest_poi = test_poi;
            }
        }

        return closest_poi;
    };

    // because a POI can be in both the poiLabelsLayer and in
    // the poiDotsLayer, it's possible that this function returns
    // an array with duplicate elements. But, opened points will
    // be returned at the start. Could possibly clean this up,
    // but not too important because this really has only 1 purpose.
    // That purpose is to allow us to open all POI a tthe exact same
    // location as another one. The functions that use this don't care
    // if a specific POI is contained within the returned array more
    // than once.
    POIController.prototype.getAllPOIAtSameLocation = function (pt) {
        if (!pt) return [];

        var same_poi = [];
        var openedPOI = this.manager.poiLabelsLayer.getDrawnPOI();
        var unopenedPOI = this.manager.poiDotsLayer.getDrawnPOI();
        var all_poi = openedPOI.concat(unopenedPOI);

        if (!all_poi.length) return [];

        for (var i = 0; i < all_poi.length; i++) {
            var poi = all_poi[i];

            // doesn't handle the case where x or y is NaN, but in that
            // case I don't think we'd be able to assume the POI are at
            // the same location. NaN means hole and there's no guarantee
            // that the hole is in the same spot. At this point, we don't
            // have information about if this is a discontinuity or not and
            // if it's a discontinuity, we definitely don't know where it is.
            if (poi.x === pt.x && poi.y === pt.y) {
                same_poi.push(poi);
            }
        }

        return same_poi;
    };

    // TODO - cleanup
    // returns an object containing the id, sketch, and the branch
    POIController.prototype.getBranchInfoUnderPoint = function (screen_pt, tolerance) {

        var graphInfo = null;
        var minDis = tolerance;
        var projection = this.manager.createProjection();
        var pt = projection.reverse_map_pt(screen_pt);

        for (var id in this.manager.graphSketches) {
            var sketch = this.manager.graphSketches[id];
            if (!sketch || !sketch.visible) continue;

            var branches = sketch.branches;
            if (!branches || !branches.length) continue;

            for (var i = 0; i < branches.length; i++) {
                var distance = POIController.calculateDistanceFromBranch(branches[i], pt, projection);

                if (distance < minDis) {
                    minDis = distance;
                    graphInfo = { id: id, branch: i, sketch: sketch };
                }
            }
        }

        return graphInfo;
    };

    POIController.calculateDistanceFromBranch = function (branch, pt, projection) {

        var tmp_pt = POIController.getBranchesClosestPoint(branch, pt, projection);
        if (!tmp_pt || isNaN(tmp_pt.x) || isNaN(tmp_pt.y)) return Infinity;

        var xscale = projection.screen.width / (projection.viewport.xmax - projection.viewport.xmin);
        var yscale = projection.screen.height / (projection.viewport.ymax - projection.viewport.ymin);
        return Distance.hypot((pt.x - tmp_pt.x) * xscale, (pt.y - tmp_pt.y) * yscale);
    };

    POIController.getBranchesClosestPoint = function (branch, pt, projection) {

        // tables lack this, so we shouldn't don't try to see how close we are
        if (!branch || !branch.compiled || !branch.compiled.fn) return;

        var xscale = projection.screen.width / (projection.viewport.xmax - projection.viewport.xmin);
        var yscale = projection.screen.height / (projection.viewport.ymax - projection.viewport.ymin);

        var x = pt.x;
        var y = pt.y;

        switch (branch.graphMode) {
            case GRAPHMODE_Y:
                break;

            case GRAPHMODE_X:
                var tmp_swap = x;
                x = y;
                y = tmp_swap;
                tmp_swap = xscale;
                xscale = yscale;
                yscale = tmp_swap;
                break;

            //TODO - maybe add back in 
            //case GRAPHMODE_XYPOINT: 
            //return { x: graph.segments[0][0], y: graph.segments[0][1] }; 

            default:
                return null;
        }

        var fn = branch.compiled.fn;
        var x0 = x;
        var x1 = x0 - 3 / xscale;
        var x2 = x0 + 3 / xscale;

        var y0 = y;

        var y1 = fn(x1);
        var y2 = fn(x2);
        var x_best;
        var p;

        if (isNaN(y1) || isNaN(y2)) {
            x_best = x0;
        } else {
            p = Distance.closestPointOnSegment(x, y, x1, y1, x2, y2);
            x_best = p[0];
        }

        var y_best = POIController.fillHole(fn, x_best, xscale, yscale, x0, y0);

        var smooth_start = 10;
        var smooth_end = 20;

        // this sequence of code creates a smooth transition between the guessed x and the mouse x
        var dis = Distance.hypot((x_best - x0) * xscale, (y_best - y0) * yscale);

        if (dis > smooth_start) {
            dis -= smooth_start;
            var perc = Math.min(1, dis / (smooth_end - smooth_start));
            x_best = Rounding.bestRound(x0 * perc + x_best * (1 - perc), 1 / xscale, 2);
        } else {
            x_best = Rounding.bestRound(x_best, 1 / xscale, 2);
        }

        y_best = POIController.fillHole(fn, x_best, xscale, yscale, x0, y0);

        switch (branch.graphMode) {
            case GRAPHMODE_Y:
                return { x: x_best, y: y_best };

            case GRAPHMODE_X:
                return { y: x_best, x: y_best };
        }
    };

    // TODO - duplicating some code here
    POIController.prototype.startTracingBranch = function (screen_pt, branchInfo) {

        var projection = this.manager.createProjection();
        var pt = projection.reverse_map_pt(screen_pt);

        var sketch = branchInfo.sketch;
        var branch = sketch.branches[branchInfo.branch];
        var tracePt = POIController.getBranchesClosestPoint(branch, pt, projection);

        this.manager.traceLayer.traceInfo = { pt: tracePt, branchInfo: branchInfo };
        this.manager.redrawTraceLayer();

        $(document).on('tapmove.tracing', this.handleTraceUpdate.bind(this));
        $(document).on('tapend.tracing tapcancel.tracing', this.stopTracingBranch.bind(this));

        this.triggerTraceDown(branchInfo.id);
    };

    POIController.prototype.stopTracingBranch = function (evt) {

        // if we're over an unopened hovered poi, open it
        var hoveredPOI = this.manager.poiLabelsLayer.hoveredPOI;
        if (hoveredPOI && !hoveredPOI.isOpen()) {
            hoveredPOI.open();
            this.triggerOpenPOIChanged();
            this.manager.redrawPOILayer();
        }

        this.manager.traceLayer.traceInfo = null;
        this.manager.redrawTraceLayer();

        $(document).off('.tracing');
    };

    POIController.prototype.handleTraceUpdate = function (evt) {
        // TODO - did we need this?
        //if (!this.tracing) return;

        var projection = this.manager.createProjection();
        var screen_pt = this.getMouseRelativeToGrapher(evt);
        var pt = projection.reverse_map_pt(screen_pt);
        var minDis = Infinity;
        var bestBranch = -1;

        var traceInfo = this.manager.traceLayer.traceInfo;
        var id = traceInfo.branchInfo.id;
        var branches = traceInfo.branchInfo.sketch.branches;

        // TODO - do we need this?
        //if (!(branches && evt)) {
        //  this.stopTracing();
        //  return;
        //}

        // Loop through branches to find which we're closest too
        for (var i = 0; i < branches.length; i++) {
            var branchDis = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
            if (branchDis < minDis) {
                bestBranch = i;
                minDis = branchDis;
            }
        }

        var branch = branches[bestBranch];
        var tracePt = branch ? POIController.getBranchesClosestPoint(branch, pt, projection) : null;

        this.manager.traceLayer.traceInfo.pt = tracePt;
        this.manager.redrawTraceLayer();
    };


    // TODO - might not belong here.. might be more appropriate in the math/poi.js
    // TODO - probably better to be smarter about 'tiny offset'. should use a
    //        dynmaic offset rather than always using 0.00000000001
    POIController.fillHole = function (fn, x_val, xscale, yscale, x, y) {
        var y_val = fn(x_val);
        if (isFinite(y_val)) return y_val;

        var x_left = x_val - 0.00000000001;
        var x_right = x_val + 0.00000000001;
        var y_left = fn(x_left);
        var y_right = fn(x_right);

        if (isNaN(y_left) && isNaN(y_right)) return NaN;
        if (isNaN(y_left)) return y_right;
        if (isNaN(y_right)) return y_left;

        var dx_left = (x - x_left) * xscale;
        var dx_right = (x - x_right) * xscale;
        var dy_left = (y - y_left) * yscale;
        var dy_right = (y - y_right) * yscale;

        if (Distance.hypot(dx_left, dy_left) < Distance.hypot(dx_right, dy_right)) {
            return y_left;
        } else {
            return y_right;
        }

    };

    return POIController;
});

/*! Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
* Licensed under the MIT License (LICENSE.txt).
*
* Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
* Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
* Thanks to: Seamus Leahy for adding deltaX and deltaY
*
* Version: 3.0.4
*
* Requires: 1.2.2+
*/


// need chrome visibility to fix scroll variances
(function ($) {
    var userAgent = navigator.userAgent.toLowerCase();
    $.browser.chrome = /chrome/.test(userAgent);
})(jQuery);


(function ($) {

    var types = ['DOMMouseScroll', 'mousewheel'];

    $.event.special.mousewheel = {
        setup: function () {
            if (this.addEventListener) {
                for (var i = types.length; i; ) {
                    this.addEventListener(types[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function () {
            if (this.removeEventListener) {
                for (var i = types.length; i; ) {
                    this.removeEventListener(types[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function (fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function (fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event, args = [].slice.call(arguments, 1), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";


        // Old school scrollwheel delta
        if (event.originalEvent) {
            if (event.originalEvent.wheelDelta) { delta = event.originalEvent.wheelDelta / 120; }
            else if (event.originalEvent.detail) { delta = -event.originalEvent.detail / 3; }
        }
        else {
            if (event.wheelDelta) { delta = event.wheelDelta / 120; }
            else if (event.detail) { delta = -event.detail / 3; }
        }
        // New school multidimensional scroll (touchpads) deltas
        deltaY = delta;

        // Gecko
        if (orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaY = 0;
            deltaX = -1 * delta;
        }

        // Webkit
        var wheelDeltaScaleFactor = 1;

        if (jQuery.browser.msie || (jQuery.browser.webkit && !jQuery.browser.chrome)) {
            wheelDeltaScaleFactor = 40;
        }

        if (orgEvent.wheelDeltaY !== undefined) { deltaY = orgEvent.wheelDeltaY / 120 / wheelDeltaScaleFactor; }
        if (orgEvent.wheelDeltaX !== undefined) { deltaX = -1 * orgEvent.wheelDeltaX / 120 / wheelDeltaScaleFactor; }

        if (delta > 0) delta = 1;
        else if (delta < 0) delta = -1;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return $.event.handle.apply(this, args);
    }

})(jQuery);

define("vendor/jquery.mousewheel", function () { });

/*
* Touch/Mouse event handling gets complicated when a user has both a touch
* device attached and a mouse attached. This tracking system helps deal with
* that situation. We listen for the touch and mouse events on the document
* and redispatch new, normalized events that work for many different devices
* It's important to note that evt.stopPropagation() cannot be called on any
* events that this is listening for.
*
* It normalizes 'touchStart' and 'mouseDown' to the 'tapstart' event.
* It normalizes 'touchMove' and 'mouseMove' to the 'tapmove' event.
* It normalizes 'touchEnd' and 'mouseUp' to the 'tapend' event.
* It sends out a 'tap' event after a single touchStart and touchEnd.

* TODO - dispatch 'doubletap' event after 'tap' and 'tap' near same location.
*
* One thing that it does is enforce that only one device, either touch or
* or mouse, be used at a time. TOUCH_MODE starts on 'touchStart' and ends when
* when all touches are lifted. MOUSE_MODE starts on 'mouseDown' and ends on
* 'mouseUp'. When in TOUCH_MODE, it ignores all MOUSE_MODE events. When in
* MOUSE_MODE, it ignores all TOUCH_MODE events.
*
* There is still one other slight complication. The ipad issues a 'mouseDown'
* event after the 'touchEnd' event. That means following the logic above, we'd
* leave TOUCH_MODE on touchEnd, and we'd get a mouseDown event. That'd put us
* in MOUSE_MODE. We'd process the 'mouseDown' as if it were from a mouse, and
* we'd happily process the 'mouseUp' event as well. In order to combat that,
* on each 'mouseDown' event we check if we've recently been in TOUCH_MODE. We
* enforce that half a second has passed since a person was in TOUCH_MODE
* before they can enter MOUSE_MODE. If we decide that that's not ideal, we
* can check if the mouseDown is near the 'touchStart' or 'touchEnd' events, but
* that sounds like an unnecessary complication.
*
* One other interesting thing is that 'mouseMove' can be dispatched even when
* the mouse button isn't pressed. For that reason, this doesn't require that
* you be in MOUSE_MODE to listen for 'mouseMove' events.
*/
define('lib/touchtracking', ['jquery'], function ($) {

    var NO_MODE = 0;    // nothing pressed
    var TOUCH_MODE = 1; // finger is on screen
    var MOUSE_MODE = 2; // mouse is held down

    var mode = NO_MODE;
    var modeEvents = {};
    var modeTargets = [];
    var endTouchModeTime = 0;
    var endTouchModeTimeout = null;

    // returns an array of node, parent, grandparent, etc
    var getAncestors = function (node) {
        var nodes = [];
        while (node) {
            nodes.push(node);
            node = $(node).parent()[0];
        }

        return nodes;
    };

    var beginMode = function (evnt) {
        if (evnt.type === 'mousedown') {
            mode = MOUSE_MODE;
            modeTargets = getAncestors(evnt.target);
        } else {
            mode = TOUCH_MODE;
            modeTargets = getAncestors(evnt.originalEvent.touches[0].target);
        }

        // make the elements under the mouse look pressed
        $(modeTargets).addClass('depressed');

        // save original scroll positions for elements we've moused on
        $(modeTargets).each(function () {
            var elm = $(this);

            elm.data({
                originalScrollTop: elm.scrollTop(),
                originalScrollLeft: elm.scrollLeft()
            });
        });

        modeEvents = { tapstart: 0, tapend: 0, tapcancel: 0, tapmove: 0 };
    };

    var endMode = function (evnt) {

        // nothing is pressed anymore
        $('.depressed').removeClass('depressed');

        // check if any of the elements we originally moused on have scrolled.
        $(modeTargets).each(function () {
            var elm = $(this);
            var verticalOffset = elm.data('originalScrollTop') - elm.scrollTop();
            var horizontalOffset = elm.data('originalScrollLeft') - elm.scrollLeft();
            // save original scroll positions
            if (verticalOffset || horizontalOffset) {
                modeEvents.scroll = true;
            }
        });

        if (modeEvents.tapstart === 1 && modeEvents.tapend === 1 && modeEvents.tapcancel === 0 && !modeEvents.scroll) {

            // get the x and y position of event.
            var x = evnt.device === 'mouse' ? evnt.pageX : evnt.originalEvent.changedTouches[0].pageX;
            var y = evnt.device === 'mouse' ? evnt.pageY : evnt.originalEvent.changedTouches[0].pageY;

            // run through the original modeTargets to see if the touchend is
            // with the bounds.
            for (var i = 0; i < modeTargets.length; i++) {
                var target = $(modeTargets[i]);
                var offset = target.offset();

                if (offset) {

                    // check if within top and left sides
                    if (x < offset.left || y < offset.top) continue;

                    // check if within right side
                    if (x > offset.left + target.outerWidth()) continue;

                    // check if within bottom side
                    if (y > offset.top + target.outerHeight()) continue;

                }

                dispatchEvent('tap', evnt, target[0]);
                break;
            }
        }

        // start the timer after we process the tap event.
        // this fires an event 1000ms in the future. If anything had caused the ipad
        // legacy events to get delayed, that'll also cause this function call to
        // get delayed. For us to switch back to MOUSE_MODE, this event must have
        // fired and it must not have been fired within 500ms of us trying to
        // switch to MOUSE_MODE
        if (mode === TOUCH_MODE) {
            endTouchModeTimeout = setTimeout(function () {
                clearTimeout(endTouchModeTimeout);
                endTouchModeTime = new Date().getTime();
            }, 1000);
        }

        modeTargets = [];
        mode = NO_MODE;
    };

    var hasRecentlyEndedTouchMode = function () {
        return endTouchModeTimeout || new Date().getTime() - endTouchModeTime < 500;
    };

    // it's important to clone touches because some devices keep updating the
    // same reference to a touch.
    var clone = function (touches) {
        var cloned = [];
        for (var i = 0; i < touches.length; i++) {

            var touch = touches[i];
            cloned.push({

                identifier: touch.identifier,
                x: touch.pageX,
                y: touch.pageY,

                screenX: touch.screenX,
                screenY: touch.screenY,
                pageX: touch.pageX,
                pageY: touch.pageY,
                clientX: touch.clientX,
                clientY: touch.clientY
            });
        }
        return cloned;
    };

    var dispatchEvent = function (type, evnt, differentTarget) {

        // count an event type. used to figure out if we should send out
        // a tap and doubletap event.
        modeEvents[type.toLowerCase()]++;

        var newEvnt = $.event.fix(evnt.originalEvent);
        newEvnt.type = type;
        newEvnt.device = mode === TOUCH_MODE ? 'touch' : 'mouse';
        newEvnt.touches = clone(evnt.originalEvent.touches);
        newEvnt.changedTouches = clone(evnt.originalEvent.changedTouches);
        newEvnt.target = differentTarget ? differentTarget : evnt.target;

        $(newEvnt.target).trigger(newEvnt);
    };

    // TODO - Remember nodes given .hovered last time instead of querying. Only
    //        problem I can see here is that it's possible for a person to
    //        clone an object that has the .hover and add it to
    //        the dom. Then it'll never lose the .hover class. If we find
    //        any more performance problems with this, then maybe we can worry
    //        about it, but I don't think we need that optimization.
    // Already optimized to leave .hover on elements that still are hovered. Saw
    // a preformance problem with sliders before optimization and problem went
    // away after optimization.
    var setHoveredNode = function (node) {

        var hoverableNodes = modeTargets; // gets a list of nodes that were under the mouse when it was pressed
        var checkIfNodeIsHoverable = !!modeTargets.length; // simple mouse move with no mouse down
        var hoveredBefore = $.makeArray($('.hovered'));
        var hoveredNow = [];
        var lostHover = [];
        var gainedHover = [];

        // loop through all that are currently hovered
        while (node && node !== document) {

            // only add to hovered list if it can be hovered.
            if (!checkIfNodeIsHoverable || hoverableNodes.indexOf(node) !== -1) {

                // hovered now, but wasn't before
                if (hoveredBefore.indexOf(node) === -1) {
                    gainedHover.push(node);
                }

                hoveredNow.push(node);
            }

            node = $(node).parent()[0];
        }

        // find the ones that used to be hovered but aren't any more
        for (var i = 0; i < hoveredBefore.length; i++) {
            node = hoveredBefore[i];
            if (hoveredNow.indexOf(node) === -1) {
                lostHover.push(node);
            }
        }

        $(lostHover).removeClass('hovered').trigger('tipsyhide');
        $(gainedHover).addClass('hovered').trigger('tipsyshow');
    };

    $(document).on('touchstart', function (evnt) {
        if (mode === MOUSE_MODE) return;

        // setup TOUCH_MODE
        if (mode === NO_MODE) {
            beginMode(evnt);
        }

        // nothing can be hovered now
        setHoveredNode(null);

        dispatchEvent('tapstart', evnt);
    });


    $(document).on('touchmove', function (evnt) {
        if (mode !== TOUCH_MODE) return;
        dispatchEvent('tapmove', evnt);
    });


    $(document).on('touchcancel', function (evnt) {
        if (mode !== TOUCH_MODE) return;

        dispatchEvent('tapcancel', evnt);

        // switch back to no mode if all touches are gone
        if (evnt.originalEvent.touches.length === 0) {
            endMode(evnt);
        }

    });


    $(document).on('touchend', function (evnt) {
        if (mode !== TOUCH_MODE) return;

        dispatchEvent('tapend', evnt);

        // switch back to no mode if all touches are gone
        if (evnt.originalEvent.touches.length === 0) {
            endMode(evnt);
        }
    });



    $(document).on('mousedown', function (evnt) {
        if (evnt.button === 1 || evnt.button === 2) return;

        // the following two commented lines were added in commit ca99f8c71724a68b7fab5a63c7bb2bd9db8567a8
        // as a fix for #1444. The problem there was that the on Android, the "mousedown" event would
        // be triggered late, and could have bad effects
        // (for example, clicking on the graph paper after the functions popup had been dismissed)
        //
        // unfortunately, this fix seems to break inputs on the iPad & Chrome on nexus.
        // reverting. Perfect support for the stock android browser seems comparatively unimportant,
        // as we're broken in other ways, and chrome is coming!
        //
        // hacky fix is to only do this preventDefault on android
        if (mode === TOUCH_MODE) {
            //evnt.preventDefault();
            return;
        }
        if (hasRecentlyEndedTouchMode()) {
            //evnt.preventDefault();
            return;
        }

        // setup MOUSE_MODE
        beginMode(evnt);

        // add in missing touch api information
        evnt.originalEvent.touches = [evnt];
        evnt.originalEvent.changedTouches = [evnt];

        dispatchEvent('tapstart', evnt);
    });

    // Stop mousedown event from propagating for any element with an ancestor with
    // class .do-not-blur (and no ancestor with .do-blur)
    $(document).ready(function () {
        $(document).on("mousedown", function (e) {
            var doNotBlur = !!$(e.target).closest('.do-not-blur').length,
        doBlur = !!$(e.target).closest('.do-blur').length;
            if (doNotBlur && !doBlur) {
                e.preventDefault();
            }

            // we use preventDefault() in places and that will cause text selection
            // to be preserved when it shouldn't be. On mouse down, if the only
            // thing with selection is something that has the .text-selectable class
            // then we can safely remove selection.
            var selection = window.getSelection();
            if (selection.rangeCount === 1) {
                var range = selection.getRangeAt(0);
                if (range.startContainer === range.endContainer && $(range.startContainer).closest('.text-selectable').length) {
                    selection.removeAllRanges();
                }
            }

        });
    });

    // If the mouse isn't pressed, then the mousemove that moves us off the
    // the screen isn't reported. That'll leave the last hovered element hoverd.
    // this checks if we are in NO_MODE and have a mouseleave event.
    $(document).on('mouseleave', function (evnt) {
        // we can move the mouse while not being in mouseMode
        if (mode !== NO_MODE) return;

        // check if a significant amount of time has passed since
        // switching from TOUCH_MODE to NO_MODE
        if (hasRecentlyEndedTouchMode()) return;

        // nothing is hovered
        setHoveredNode(null);
    });

    $(document).on('mousemove', function (evnt) {
        if (evnt.button === 1 || evnt.button === 2) return;


        // we can move the mouse while not being in mouseMode
        if (mode === TOUCH_MODE) return;

        // check if a significant amount of time has passed since
        // switching from TOUCH_MODE to MOUSE_MODE
        if (hasRecentlyEndedTouchMode()) return;

        setHoveredNode(evnt.target);

        // add in missing touch api information
        evnt.originalEvent.touches = [evnt]; // TODO - not perfect because it could be a non-touch
        evnt.originalEvent.changedTouches = [evnt];

        dispatchEvent('tapmove', evnt);
    });


    $(document).on('mouseup', function (evnt) {
        if (evnt.button === 1 || evnt.button === 2) return;

        if (mode !== MOUSE_MODE) return;

        // add in missing touch api information
        evnt.originalEvent.touches = [];
        evnt.originalEvent.changedTouches = [evnt];

        dispatchEvent('tapend', evnt);

        endMode(evnt);
    });

    /*For debugging
   
    $(document).on('tapstart tapend tapmove tap tapcancel', function (evt){
    console.log(evt.type, evt.originalEvent.changedTouches);
    });*/

});

/*
* A handled event is one that should act like propagation was
*  stopped, yet it's allowed to still bubble because other
*  code might expect to see an event higher up on the dom.
*
* So the solution is to call 'handle()' when you don't
*  want the event to be handled by any other other listeners.
*  The listeners will still get called, but they can check
*  that evt.wasHandled() == false to make sure that it
*  should handle the event.
*
* You can namespace your event handlings so that two
*  completely different parts of code can both use this
*  utility. When you call 'wasHandled()', just pass in a
*  string, and it will check that namespace. And when you
*  call 'handle()', pass in a namespace string.
*
* For convienience, you can set the handleEvent attribute
*  for any dom element and the 'wasHandled()' method will
*  check if the event has passed through any dom element
*  that should have handled the event.
*/
; (function ($) {

    $.Event.prototype.wasHandled = function (namespace) {
        namespace = namespace ? namespace : "_*_";
        var oe = this.originalEvent;
        var hb = oe && oe.handledBy;

        //check if it was explicitly handled in code
        if (hb && hb[namespace]) return true;

        //Now, check if it was implicitly handled through
        //the dom attribute 'handleEvent'
        var dom = $(this.target).closest('[handleEvent]');
        while (dom.length && dom[0] !== this.currentTarget) {

            //TEMPORARY: just return true instead of deeply parsing
            var handle = dom.attr('handleEvent');
            if (handle === "false") return false;
            else return true;

            //parse the handleEvent attribute to figure out
            //things like namespace and event types
            var handles = handle.split(" ");
            for (var i = 0; i < handles.length; i++) {
                var full = handles[i];
            }

            dom = dom.parent().closest('[handleEvent]');
        }

        //must not have been handled
        return false;
    };

    $.Event.prototype.handle = function (namespace) {
        namespace = namespace ? namespace : "_*_";
        var oe = this.originalEvent;
        if (!oe) return; //can't handle this properly

        var hb = oe.handledBy;
        if (!hb) hb = oe.handledBy = {};

        hb[namespace] = true;
    };

})(jQuery);

define("lib/jquery.handleevent", function () { });

// TODO - rename this.manager to something better. But that'll probably be
//        around the time we rename the Grapher class to something else.
//
// TODO - rename this class to something else. This class is really only
//        supposed to be for the animation / panning / zooming of the
//        grapher. It's not for any and all controlling. There are some
//        methods (such as grapher.addGraphSketch) that should be called
//        directly on the grapher and shouldn't go through this 'controller.'
define('graphing/graphcontroller', ['require', './viewport', './viewporttransformation', 'vendor/jquery.mousewheel', 'lib/touchtracking', 'lib/jquery.handleevent'], function (require) {
    var Viewport = require('./viewport');
    var ViewportTransformation = require('./viewporttransformation');

    require('vendor/jquery.mousewheel');
    require('lib/touchtracking');
    require('lib/jquery.handleevent');

    function GraphController(grapher) {

        this.manager = grapher;
        this.$ = this.manager.$;

        // callback
        this.triggerViewportStable = function () { };
        // using for jquery's animate feature. Would be nice to use something
        // more suited to only animation, but probably not worth the overhead.
        this.$animation = $('<div></div>');

        this.addMouseWheelEventHandler();
        this.addTouchEventHandler();
    }

    GraphController.prototype.getScreen = function () {
        return this.manager.screen.clone();
    };

    GraphController.prototype.getViewport = function () {
        return this.manager.viewport.clone();
    };

    GraphController.prototype.setViewport = function (viewport) {
        if (!viewport.isValid()) return;
        if (!this.manager.isInTransientState() && viewport.equals(this.manager.viewport)) {
            this.triggerViewportStable();
            return;
        }

        this.manager.viewport = viewport.clone();
        this.endTransientState();
    };

    GraphController.prototype.setTransformation = function (transformation) {

        this.manager.beginTransientState();
        this.manager.transformation = transformation;
        this.manager.redrawAllLayers();

        clearTimeout(this.endTransientTimeout);
        this.endTransientTimeout = setTimeout(this.endTransientState.bind(this), 250);
    };

    GraphController.prototype.endTransientState = function () {
        clearTimeout(this.endTransientTimeout);

        this.manager.endTransientState();
        this.manager.redrawAllLayers();

        this.triggerViewportStable();
    };

    GraphController.prototype.animateTransformation = function (transformation) {
        var self = this;
        var currentTransformation = this.manager.transformation.clone();
        var targetTransformation = currentTransformation.compose(transformation);
        this.cancelAnimation();
        this.$animation.css('percent', 0);
        this.$animation.animate({ 'percent': 100 }, {

            duration: ANIMATE_ZOOM_DURATION,

            step: function (percent) {
                self.setTransformation(
        currentTransformation.lerp(targetTransformation, percent / 100.0)
      );
            }
        });
    };

    GraphController.prototype.cancelAnimation = function () {
        this.$animation.stop();
    };

    GraphController.prototype.resetTransform = function () {
        this.transform = new ViewportTransformation(this.getViewport());
    };

    // this is simple enough to encapsulate everything in a single closure.
    GraphController.prototype.addMouseWheelEventHandler = function () {

        var mousewheel_counter = 0;

        var self = this;

        var onMouseWheel = function (evt, delta) {
            evt.preventDefault();

            if (mousewheel_counter > 0) return;

            mousewheel_counter += 1;
            setTimeout(function () { mousewheel_counter-- }, 50);
            delta = (delta > 0 ? 1 : -1);

            var t = this.manager.transformation;

            this.setTransformation(
      this.manager.transformation.compose(new ViewportTransformation(
        0,
        0,
        (delta > 0) ? ZOOM_FACTOR : 1 / ZOOM_FACTOR
      ))
    );
        };

        this.$.mousewheel(onMouseWheel.bind(this));
    };

    // a complete closure to all touch event related code
    GraphController.prototype.addTouchEventHandler = function () {

        var touches = [];
        var isDragging = false;

        var handleDoubleClick = function (evt) {
            if (evt.wasHandled()) return;
            evt.preventDefault();

            var pageOffset = this.$.offset();
            var x = evt.pageX - pageOffset.left;
            var y = evt.pageY - pageOffset.top;

            var screen = this.getScreen();

            var scale = DOUBLETAP_ZOOM;
            var xOffset = (x - 0.5 * (screen.width)) * (1 - scale);
            var yOffset = (y - 0.5 * (screen.height)) * (1 - scale);

            this.animateTransformation(new ViewportTransformation(
      xOffset,
      yOffset,
      scale
    ));
        };


        var beginDrag = function (evnt) {

            // must not have been handled already. The POI controller may handle
            // this tapStart for POI purposes and we may want to ignore it.
            if (evnt.wasHandled()) return;

            // must not already be dragging
            if (isDragging) return;

            // must not have a touch down anywhere else. Only want to start dragging
            // if this is the first touch and it's on the grapher
            if (evnt.touches.length !== evnt.changedTouches.length) return;

            // setup drag
            isDragging = true;
            $(document).on('tapmove.graphdrag', updateDrag.bind(this));
            $(document).on('tapstart.graphdrag tapend.graphdrag tapcancel.graphdrag', updateTouches.bind(this));
        };

        var updateDrag = function (evnt) {
            // must be dragging
            if (!isDragging) return;

            var screen = this.getScreen();
            var newTouches = evnt.touches;

            var transformation = this.manager.transformation.clone();

            if (touches.length === 1) {
                // only option is to pan...
                transformation.applyPanTouchChanges(touches, newTouches);
            } else {
                // zoom and pan
                transformation.applyScaleTouchChanges(touches, newTouches);
            }

            this.setTransformation(transformation);
            touches = newTouches;
        };

        var updateTouches = function (evnt) {

            // must be dragging
            if (!isDragging) return;

            this.cancelAnimation();

            // save our touches so that when we move one we can
            // figure out how the touches have moved.
            touches = evnt.touches;

            // check if drag is over
            if (evnt.touches.length === 0) {
                isDragging = false;
                $(document).off('.graphdrag');
            }

        };

        this.$.on('tapstart', beginDrag.bind(this));
        this.$.on('dblclick', handleDoubleClick.bind(this));
    };

    GraphController.prototype.getSetting = function (setting, _default) {
        var value = this.manager.settings.getProperty(setting);
        return value !== undefined ? value : _default;
    };

    GraphController.prototype.setSetting = function (setting, value, _default) {
        this.manager.settings.setProperty(setting, value !== undefined ? value : _default);
    };

    GraphController.prototype.getState = function () {
        return {
            viewport: this.getViewport().toObject(),
            showLabels: this.getSetting('showLabels'),
            degreeMode: this.getSetting('degreeMode'),
            showGrid: this.getSetting('showGrid'),
            showAxes: this.getSetting('showAxes'),
            squareAxes: this.getSetting('squareAxes'),
            labelXMode: this.getSetting('xAxisPiLabels') ? 'pi' : '',
            labelYMode: this.getSetting('yAxisPiLabels') ? 'pi' : ''
        };
    };

    // TODO - Each one of these setSetting commands will update the grids layer.
    //        That's not terrible, but it might be nice to have control over that.
    //
    //        Might be worth adding the observer in here rather than in
    //        graph_settings.js so that we can turn the observer off/on cleanly
    //        any time we do a batch update like this.
    GraphController.prototype.setState = function (state) {
        this.setSetting('showLabels', state.showLabels, true);
        this.setSetting('showGrid', state.showGrid, true);
        this.setSetting('showAxes', state.showAxes, true);
        this.setSetting('squareAxes', state.squareAxes, true);
        this.setSetting('xAxisPiLabels', state.labelXMode === 'pi');
        this.setSetting('yAxisPiLabels', state.labelYMode === 'pi');
        this.setSetting('degreeMode', state.degreeMode, false);

        if ("viewport" in state) {
            var viewport = Viewport.fromObject(state.viewport);
            if (this.getSetting('squareAxes') && !viewport.isSquare(this.manager.screen)) {
                viewport.squareYAxis(this.manager.screen);
                viewport.round(this.manager.screen);
            }

            this.setViewport(viewport);
        }

    };

    GraphController.prototype.zoom = function (action) {
        var viewport;

        if (action === 'in') {
            this.animateTransformation(
      new ViewportTransformation(0, 0, 2)
    );
        } else if (action === 'out') {
            this.animateTransformation(
      new ViewportTransformation(0, 0, 0.5)
    );
        } else if (action === 'default') {
            //TO DO: clean this up using one of the methods below?
            viewport = new Viewport(-10, 10, -10, 10);
            grapher.settings.setProperty('squareAxes', true);
            viewport.squareYAxis(grapher.screen);
            viewport.round(grapher.screen);
            this.setViewport(viewport);
        }
    };

    return GraphController;
});

// Ember.js config
window.ENV = {
    CP_DEFAULT_CACHEABLE: true,
    VIEW_PRESERVES_CONTEXT: true
};
define("configure-ember", function () { });

; (function () {
    /*global __fail__*/

    if ('undefined' === typeof Ember) {
        Ember = {};

        if ('undefined' !== typeof window) {
            window.Em = window.Ember = Em = Ember;
        }
    }

    /**
    Define an assertion that will throw an exception if the condition is not
    met.  Ember build tools will remove any calls to Ember.assert() when
    doing a production build.

    ## Examples

    #js:

    // pass a simple Boolean value
    Ember.assert('must pass a valid object', !!obj);

    // pass a function.  If the function returns false the assertion fails
    // any other return value (including void) will pass.
    Ember.assert('a passed record must have a firstName', function() {
    if (obj instanceof Ember.Record) {
    return !Ember.empty(obj.firstName);
    }
    });

    @static
    @function
    @param {String} desc
    A description of the assertion.  This will become the text of the Error
    thrown if the assertion fails.

    @param {Boolean} test
    Must return true for the assertion to pass.  If you pass a function it
    will be executed.  If the function returns false an exception will be
    thrown.
    */
    Ember.assert = function (desc, test) {
        if ('function' === typeof test) test = test() !== false;
        if (!test) throw new Error("assertion failed: " + desc);
    };


    /**
    Display a warning with the provided message. Ember build tools will
    remove any calls to Ember.warn() when doing a production build.

    @static
    @function
    @param {String} message
    A warning to display.

    @param {Boolean} test
    An optional boolean or function. If the test returns false, the warning
    will be displayed.
    */
    Ember.warn = function (message, test) {
        if (arguments.length === 1) { test = false; }
        if ('function' === typeof test) test = test() !== false;
        if (!test) Ember.Logger.warn("WARNING: " + message);
    };

    /**
    Display a deprecation warning with the provided message and a stack trace
    (Chrome and Firefox only). Ember build tools will remove any calls to
    Ember.deprecate() when doing a production build.

    @static
    @function
    @param {String} message
    A description of the deprecation.

    @param {Boolean} test
    An optional boolean or function. If the test returns false, the deprecation
    will be displayed.
    */
    Ember.deprecate = function (message, test) {
        if (Ember && Ember.TESTING_DEPRECATION) { return; }

        if (arguments.length === 1) { test = false; }
        if ('function' === typeof test) { test = test() !== false; }
        if (test) { return; }

        if (Ember && Ember.ENV.RAISE_ON_DEPRECATION) { throw new Error(message); }

        var error, stackStr = '';

        // When using new Error, we can't do the arguments check for Chrome. Alternatives are welcome
        try { __fail__.fail(); } catch (e) { error = e; }

        if (error.stack) {
            var stack;

            if (error['arguments']) {
                // Chrome
                stack = error.stack.replace(/^\s+at\s+/gm, '').
                          replace(/^([^\(]+?)([\n$])/gm, '{anonymous}($1)$2').
                          replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}($1)').split('\n');
                stack.shift();
            } else {
                // Firefox
                stack = error.stack.replace(/(?:\n@:0)?\s+$/m, '').
                          replace(/^\(/gm, '{anonymous}(').split('\n');
            }

            stackStr = "\n    " + stack.slice(2).join("\n    ");
        }

        Ember.Logger.warn("DEPRECATION: " + message + stackStr);
    };



    /**
    Display a deprecation warning with the provided message and a stack trace
    (Chrome and Firefox only) when the wrapped method is called.

    Ember build tools will not remove calls to Ember.deprecateFunc(), though
    no warnings will be shown in production.

    @static
    @function
    @param {String} message
    A description of the deprecation.

    @param {Function} func
    The function to be deprecated.
    */
    Ember.deprecateFunc = function (message, func) {
        return function () {
            Ember.deprecate(message);
            return func.apply(this, arguments);
        };
    };


    window.ember_assert = Ember.deprecateFunc("ember_assert is deprecated. Please use Ember.assert instead.", Ember.assert);
    window.ember_warn = Ember.deprecateFunc("ember_warn is deprecated. Please use Ember.warn instead.", Ember.warn);
    window.ember_deprecate = Ember.deprecateFunc("ember_deprecate is deprecated. Please use Ember.deprecate instead.", Ember.deprecate);
    window.ember_deprecateFunc = Ember.deprecateFunc("ember_deprecateFunc is deprecated. Please use Ember.deprecateFunc instead.", Ember.deprecateFunc);

})();

(function () {
    // lib/handlebars/base.js
    var Handlebars = {};

    window.Handlebars = Handlebars;

    Handlebars.VERSION = "1.0.beta.6";

    Handlebars.helpers = {};
    Handlebars.partials = {};

    Handlebars.registerHelper = function (name, fn, inverse) {
        if (inverse) { fn.not = inverse; }
        this.helpers[name] = fn;
    };

    Handlebars.registerPartial = function (name, str) {
        this.partials[name] = str;
    };

    Handlebars.registerHelper('helperMissing', function (arg) {
        if (arguments.length === 2) {
            return undefined;
        } else {
            throw new Error("Could not find property '" + arg + "'");
        }
    });

    var toString = Object.prototype.toString, functionType = "[object Function]";

    Handlebars.registerHelper('blockHelperMissing', function (context, options) {
        var inverse = options.inverse || function () { }, fn = options.fn;


        var ret = "";
        var type = toString.call(context);

        if (type === functionType) { context = context.call(this); }

        if (context === true) {
            return fn(this);
        } else if (context === false || context == null) {
            return inverse(this);
        } else if (type === "[object Array]") {
            if (context.length > 0) {
                for (var i = 0, j = context.length; i < j; i++) {
                    ret = ret + fn(context[i]);
                }
            } else {
                ret = inverse(this);
            }
            return ret;
        } else {
            return fn(context);
        }
    });

    Handlebars.registerHelper('each', function (context, options) {
        var fn = options.fn, inverse = options.inverse;
        var ret = "";

        if (context && context.length > 0) {
            for (var i = 0, j = context.length; i < j; i++) {
                ret = ret + fn(context[i]);
            }
        } else {
            ret = inverse(this);
        }
        return ret;
    });

    Handlebars.registerHelper('if', function (context, options) {
        var type = toString.call(context);
        if (type === functionType) { context = context.call(this); }

        if (!context || Handlebars.Utils.isEmpty(context)) {
            return options.inverse(this);
        } else {
            return options.fn(this);
        }
    });

    Handlebars.registerHelper('unless', function (context, options) {
        var fn = options.fn, inverse = options.inverse;
        options.fn = inverse;
        options.inverse = fn;

        return Handlebars.helpers['if'].call(this, context, options);
    });

    Handlebars.registerHelper('with', function (context, options) {
        return options.fn(context);
    });

    Handlebars.registerHelper('log', function (context) {
        Handlebars.log(context);
    });
    ;
    // lib/handlebars/compiler/parser.js
    /* Jison generated parser */
    var handlebars = (function () {

        var parser = { trace: function trace() { },
            yy: {},
            symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "statements": 6, "simpleInverse": 7, "statement": 8, "openInverse": 9, "closeBlock": 10, "openBlock": 11, "mustache": 12, "partial": 13, "CONTENT": 14, "COMMENT": 15, "OPEN_BLOCK": 16, "inMustache": 17, "CLOSE": 18, "OPEN_INVERSE": 19, "OPEN_ENDBLOCK": 20, "path": 21, "OPEN": 22, "OPEN_UNESCAPED": 23, "OPEN_PARTIAL": 24, "params": 25, "hash": 26, "param": 27, "STRING": 28, "INTEGER": 29, "BOOLEAN": 30, "hashSegments": 31, "hashSegment": 32, "ID": 33, "EQUALS": 34, "pathSegments": 35, "SEP": 36, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 5: "EOF", 14: "CONTENT", 15: "COMMENT", 16: "OPEN_BLOCK", 18: "CLOSE", 19: "OPEN_INVERSE", 20: "OPEN_ENDBLOCK", 22: "OPEN", 23: "OPEN_UNESCAPED", 24: "OPEN_PARTIAL", 28: "STRING", 29: "INTEGER", 30: "BOOLEAN", 33: "ID", 34: "EQUALS", 36: "SEP" },
            productions_: [0, [3, 2], [4, 3], [4, 1], [4, 0], [6, 1], [6, 2], [8, 3], [8, 3], [8, 1], [8, 1], [8, 1], [8, 1], [11, 3], [9, 3], [10, 3], [12, 3], [12, 3], [13, 3], [13, 4], [7, 2], [17, 3], [17, 2], [17, 2], [17, 1], [25, 2], [25, 1], [27, 1], [27, 1], [27, 1], [27, 1], [26, 1], [31, 2], [31, 1], [32, 3], [32, 3], [32, 3], [32, 3], [21, 1], [35, 3], [35, 1]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1: return $$[$0 - 1]
                        break;
                    case 2: this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0])
                        break;
                    case 3: this.$ = new yy.ProgramNode($$[$0])
                        break;
                    case 4: this.$ = new yy.ProgramNode([])
                        break;
                    case 5: this.$ = [$$[$0]]
                        break;
                    case 6: $$[$0 - 1].push($$[$0]); this.$ = $$[$0 - 1]
                        break;
                    case 7: this.$ = new yy.InverseNode($$[$0 - 2], $$[$0 - 1], $$[$0])
                        break;
                    case 8: this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0])
                        break;
                    case 9: this.$ = $$[$0]
                        break;
                    case 10: this.$ = $$[$0]
                        break;
                    case 11: this.$ = new yy.ContentNode($$[$0])
                        break;
                    case 12: this.$ = new yy.CommentNode($$[$0])
                        break;
                    case 13: this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1])
                        break;
                    case 14: this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1])
                        break;
                    case 15: this.$ = $$[$0 - 1]
                        break;
                    case 16: this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1])
                        break;
                    case 17: this.$ = new yy.MustacheNode($$[$0 - 1][0], $$[$0 - 1][1], true)
                        break;
                    case 18: this.$ = new yy.PartialNode($$[$0 - 1])
                        break;
                    case 19: this.$ = new yy.PartialNode($$[$0 - 2], $$[$0 - 1])
                        break;
                    case 20:
                        break;
                    case 21: this.$ = [[$$[$0 - 2]].concat($$[$0 - 1]), $$[$0]]
                        break;
                    case 22: this.$ = [[$$[$0 - 1]].concat($$[$0]), null]
                        break;
                    case 23: this.$ = [[$$[$0 - 1]], $$[$0]]
                        break;
                    case 24: this.$ = [[$$[$0]], null]
                        break;
                    case 25: $$[$0 - 1].push($$[$0]); this.$ = $$[$0 - 1];
                        break;
                    case 26: this.$ = [$$[$0]]
                        break;
                    case 27: this.$ = $$[$0]
                        break;
                    case 28: this.$ = new yy.StringNode($$[$0])
                        break;
                    case 29: this.$ = new yy.IntegerNode($$[$0])
                        break;
                    case 30: this.$ = new yy.BooleanNode($$[$0])
                        break;
                    case 31: this.$ = new yy.HashNode($$[$0])
                        break;
                    case 32: $$[$0 - 1].push($$[$0]); this.$ = $$[$0 - 1]
                        break;
                    case 33: this.$ = [$$[$0]]
                        break;
                    case 34: this.$ = [$$[$0 - 2], $$[$0]]
                        break;
                    case 35: this.$ = [$$[$0 - 2], new yy.StringNode($$[$0])]
                        break;
                    case 36: this.$ = [$$[$0 - 2], new yy.IntegerNode($$[$0])]
                        break;
                    case 37: this.$ = [$$[$0 - 2], new yy.BooleanNode($$[$0])]
                        break;
                    case 38: this.$ = new yy.IdNode($$[$0])
                        break;
                    case 39: $$[$0 - 2].push($$[$0]); this.$ = $$[$0 - 2];
                        break;
                    case 40: this.$ = [$$[$0]]
                        break;
                }
            },
            table: [{ 3: 1, 4: 2, 5: [2, 4], 6: 3, 8: 4, 9: 5, 11: 6, 12: 7, 13: 8, 14: [1, 9], 15: [1, 10], 16: [1, 12], 19: [1, 11], 22: [1, 13], 23: [1, 14], 24: [1, 15] }, { 1: [3] }, { 5: [1, 16] }, { 5: [2, 3], 7: 17, 8: 18, 9: 5, 11: 6, 12: 7, 13: 8, 14: [1, 9], 15: [1, 10], 16: [1, 12], 19: [1, 19], 20: [2, 3], 22: [1, 13], 23: [1, 14], 24: [1, 15] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 16: [2, 5], 19: [2, 5], 20: [2, 5], 22: [2, 5], 23: [2, 5], 24: [2, 5] }, { 4: 20, 6: 3, 8: 4, 9: 5, 11: 6, 12: 7, 13: 8, 14: [1, 9], 15: [1, 10], 16: [1, 12], 19: [1, 11], 20: [2, 4], 22: [1, 13], 23: [1, 14], 24: [1, 15] }, { 4: 21, 6: 3, 8: 4, 9: 5, 11: 6, 12: 7, 13: 8, 14: [1, 9], 15: [1, 10], 16: [1, 12], 19: [1, 11], 20: [2, 4], 22: [1, 13], 23: [1, 14], 24: [1, 15] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 16: [2, 9], 19: [2, 9], 20: [2, 9], 22: [2, 9], 23: [2, 9], 24: [2, 9] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 16: [2, 10], 19: [2, 10], 20: [2, 10], 22: [2, 10], 23: [2, 10], 24: [2, 10] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 16: [2, 11], 19: [2, 11], 20: [2, 11], 22: [2, 11], 23: [2, 11], 24: [2, 11] }, { 5: [2, 12], 14: [2, 12], 15: [2, 12], 16: [2, 12], 19: [2, 12], 20: [2, 12], 22: [2, 12], 23: [2, 12], 24: [2, 12] }, { 17: 22, 21: 23, 33: [1, 25], 35: 24 }, { 17: 26, 21: 23, 33: [1, 25], 35: 24 }, { 17: 27, 21: 23, 33: [1, 25], 35: 24 }, { 17: 28, 21: 23, 33: [1, 25], 35: 24 }, { 21: 29, 33: [1, 25], 35: 24 }, { 1: [2, 1] }, { 6: 30, 8: 4, 9: 5, 11: 6, 12: 7, 13: 8, 14: [1, 9], 15: [1, 10], 16: [1, 12], 19: [1, 11], 22: [1, 13], 23: [1, 14], 24: [1, 15] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 16: [2, 6], 19: [2, 6], 20: [2, 6], 22: [2, 6], 23: [2, 6], 24: [2, 6] }, { 17: 22, 18: [1, 31], 21: 23, 33: [1, 25], 35: 24 }, { 10: 32, 20: [1, 33] }, { 10: 34, 20: [1, 33] }, { 18: [1, 35] }, { 18: [2, 24], 21: 40, 25: 36, 26: 37, 27: 38, 28: [1, 41], 29: [1, 42], 30: [1, 43], 31: 39, 32: 44, 33: [1, 45], 35: 24 }, { 18: [2, 38], 28: [2, 38], 29: [2, 38], 30: [2, 38], 33: [2, 38], 36: [1, 46] }, { 18: [2, 40], 28: [2, 40], 29: [2, 40], 30: [2, 40], 33: [2, 40], 36: [2, 40] }, { 18: [1, 47] }, { 18: [1, 48] }, { 18: [1, 49] }, { 18: [1, 50], 21: 51, 33: [1, 25], 35: 24 }, { 5: [2, 2], 8: 18, 9: 5, 11: 6, 12: 7, 13: 8, 14: [1, 9], 15: [1, 10], 16: [1, 12], 19: [1, 11], 20: [2, 2], 22: [1, 13], 23: [1, 14], 24: [1, 15] }, { 14: [2, 20], 15: [2, 20], 16: [2, 20], 19: [2, 20], 22: [2, 20], 23: [2, 20], 24: [2, 20] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 16: [2, 7], 19: [2, 7], 20: [2, 7], 22: [2, 7], 23: [2, 7], 24: [2, 7] }, { 21: 52, 33: [1, 25], 35: 24 }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 16: [2, 8], 19: [2, 8], 20: [2, 8], 22: [2, 8], 23: [2, 8], 24: [2, 8] }, { 14: [2, 14], 15: [2, 14], 16: [2, 14], 19: [2, 14], 20: [2, 14], 22: [2, 14], 23: [2, 14], 24: [2, 14] }, { 18: [2, 22], 21: 40, 26: 53, 27: 54, 28: [1, 41], 29: [1, 42], 30: [1, 43], 31: 39, 32: 44, 33: [1, 45], 35: 24 }, { 18: [2, 23] }, { 18: [2, 26], 28: [2, 26], 29: [2, 26], 30: [2, 26], 33: [2, 26] }, { 18: [2, 31], 32: 55, 33: [1, 56] }, { 18: [2, 27], 28: [2, 27], 29: [2, 27], 30: [2, 27], 33: [2, 27] }, { 18: [2, 28], 28: [2, 28], 29: [2, 28], 30: [2, 28], 33: [2, 28] }, { 18: [2, 29], 28: [2, 29], 29: [2, 29], 30: [2, 29], 33: [2, 29] }, { 18: [2, 30], 28: [2, 30], 29: [2, 30], 30: [2, 30], 33: [2, 30] }, { 18: [2, 33], 33: [2, 33] }, { 18: [2, 40], 28: [2, 40], 29: [2, 40], 30: [2, 40], 33: [2, 40], 34: [1, 57], 36: [2, 40] }, { 33: [1, 58] }, { 14: [2, 13], 15: [2, 13], 16: [2, 13], 19: [2, 13], 20: [2, 13], 22: [2, 13], 23: [2, 13], 24: [2, 13] }, { 5: [2, 16], 14: [2, 16], 15: [2, 16], 16: [2, 16], 19: [2, 16], 20: [2, 16], 22: [2, 16], 23: [2, 16], 24: [2, 16] }, { 5: [2, 17], 14: [2, 17], 15: [2, 17], 16: [2, 17], 19: [2, 17], 20: [2, 17], 22: [2, 17], 23: [2, 17], 24: [2, 17] }, { 5: [2, 18], 14: [2, 18], 15: [2, 18], 16: [2, 18], 19: [2, 18], 20: [2, 18], 22: [2, 18], 23: [2, 18], 24: [2, 18] }, { 18: [1, 59] }, { 18: [1, 60] }, { 18: [2, 21] }, { 18: [2, 25], 28: [2, 25], 29: [2, 25], 30: [2, 25], 33: [2, 25] }, { 18: [2, 32], 33: [2, 32] }, { 34: [1, 57] }, { 21: 61, 28: [1, 62], 29: [1, 63], 30: [1, 64], 33: [1, 25], 35: 24 }, { 18: [2, 39], 28: [2, 39], 29: [2, 39], 30: [2, 39], 33: [2, 39], 36: [2, 39] }, { 5: [2, 19], 14: [2, 19], 15: [2, 19], 16: [2, 19], 19: [2, 19], 20: [2, 19], 22: [2, 19], 23: [2, 19], 24: [2, 19] }, { 5: [2, 15], 14: [2, 15], 15: [2, 15], 16: [2, 15], 19: [2, 15], 20: [2, 15], 22: [2, 15], 23: [2, 15], 24: [2, 15] }, { 18: [2, 34], 33: [2, 34] }, { 18: [2, 35], 33: [2, 35] }, { 18: [2, 36], 33: [2, 36] }, { 18: [2, 37], 33: [2, 37]}],
            defaultActions: { 16: [2, 1], 37: [2, 23], 53: [2, 21] },
            parseError: function parseError(str, hash) {
                throw new Error(str);
            },
            parse: function parse(input) {
                var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                if (typeof this.lexer.yylloc == "undefined")
                    this.lexer.yylloc = {};
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                if (typeof this.yy.parseError === "function")
                    this.parseError = this.yy.parseError;
                function popStack(n) {
                    stack.length = stack.length - 2 * n;
                    vstack.length = vstack.length - n;
                    lstack.length = lstack.length - n;
                }
                function lex() {
                    var token;
                    token = self.lexer.lex() || 1;
                    if (typeof token !== "number") {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol == null)
                            symbol = lex();
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === "undefined" || !action.length || !action[0]) {
                        if (!recovering) {
                            expected = [];
                            for (p in table[state])
                                if (this.terminals_[p] && p > 2) {
                                    expected.push("'" + this.terminals_[p] + "'");
                                }
                            var errStr = "";
                            if (this.lexer.showPosition) {
                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + this.terminals_[symbol] + "'";
                            } else {
                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                            }
                            this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                        }
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0)
                                    recovering--;
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            }
        }; /* Jison generated lexer */
        var lexer = (function () {

            var lexer = ({ EOF: 1,
                parseError: function parseError(str, hash) {
                    if (this.yy.parseError) {
                        this.yy.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },
                setInput: function (input) {
                    this._input = input;
                    this._more = this._less = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                    return this;
                },
                input: function () {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/\n/);
                    if (lines) this.yylineno++;
                    this._input = this._input.slice(1);
                    return ch;
                },
                unput: function (ch) {
                    this._input = ch + this._input;
                    return this;
                },
                more: function () {
                    this._more = true;
                    return this;
                },
                pastInput: function () {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function () {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },
                showPosition: function () {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },
                next: function () {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) this.done = true;

                    var token,
            match,
            col,
            lines;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        match = this._input.match(this.rules[rules[i]]);
                        if (match) {
                            lines = match[0].match(/\n.*/g);
                            if (lines) this.yylineno += lines.length;
                            this.yylloc = { first_line: this.yylloc.last_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.last_column,
                                last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                            }
                            this.yytext += match[0];
                            this.match += match[0];
                            this.matches = match;
                            this.yyleng = this.yytext.length;
                            this._more = false;
                            this._input = this._input.slice(match[0].length);
                            this.matched += match[0];
                            token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                            if (token) return token;
                            else return;
                        }
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(),
                    { text: "", token: null, line: this.yylineno });
                    }
                },
                lex: function lex() {
                    var r = this.next();
                    if (typeof r !== 'undefined') {
                        return r;
                    } else {
                        return this.lex();
                    }
                },
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },
                popState: function popState() {
                    return this.conditionStack.pop();
                },
                _currentRules: function _currentRules() {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                },
                topState: function () {
                    return this.conditionStack[this.conditionStack.length - 2];
                },
                pushState: function begin(condition) {
                    this.begin(condition);
                } 
            });
            lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

                var YYSTATE = YY_START
                switch ($avoiding_name_collisions) {
                    case 0:
                        if (yy_.yytext.slice(-1) !== "\\") this.begin("mu");
                        if (yy_.yytext.slice(-1) === "\\") yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1), this.begin("emu");
                        if (yy_.yytext) return 14;

                        break;
                    case 1: return 14;
                        break;
                    case 2: this.popState(); return 14;
                        break;
                    case 3: return 24;
                        break;
                    case 4: return 16;
                        break;
                    case 5: return 20;
                        break;
                    case 6: return 19;
                        break;
                    case 7: return 19;
                        break;
                    case 8: return 23;
                        break;
                    case 9: return 23;
                        break;
                    case 10: yy_.yytext = yy_.yytext.substr(3, yy_.yyleng - 5); this.popState(); return 15;
                        break;
                    case 11: return 22;
                        break;
                    case 12: return 34;
                        break;
                    case 13: return 33;
                        break;
                    case 14: return 33;
                        break;
                    case 15: return 36;
                        break;
                    case 16: /*ignore whitespace*/
                        break;
                    case 17: this.popState(); return 18;
                        break;
                    case 18: this.popState(); return 18;
                        break;
                    case 19: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2).replace(/\\"/g, '"'); return 28;
                        break;
                    case 20: return 30;
                        break;
                    case 21: return 30;
                        break;
                    case 22: return 29;
                        break;
                    case 23: return 33;
                        break;
                    case 24: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2); return 33;
                        break;
                    case 25: return 'INVALID';
                        break;
                    case 26: return 5;
                        break;
                }
            };
            lexer.rules = [/^[^\x00]*?(?=(\{\{))/, /^[^\x00]+/, /^[^\x00]{2,}?(?=(\{\{))/, /^\{\{>/, /^\{\{#/, /^\{\{\//, /^\{\{\^/, /^\{\{\s*else\b/, /^\{\{\{/, /^\{\{&/, /^\{\{![\s\S]*?\}\}/, /^\{\{/, /^=/, /^\.(?=[} ])/, /^\.\./, /^[\/.]/, /^\s+/, /^\}\}\}/, /^\}\}/, /^"(\\["]|[^"])*"/, /^true(?=[}\s])/, /^false(?=[}\s])/, /^[0-9]+(?=[}\s])/, /^[a-zA-Z0-9_$-]+(?=[=}\s\/.])/, /^\[[^\]]*\]/, /^./, /^$/];
            lexer.conditions = { "mu": { "rules": [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "INITIAL": { "rules": [0, 1, 26], "inclusive": true} }; return lexer;
        })()
        parser.lexer = lexer;
        return parser;
    })();
    if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
        exports.parser = handlebars;
        exports.parse = function () { return handlebars.parse.apply(handlebars, arguments); }
        exports.main = function commonjsMain(args) {
            if (!args[1])
                throw new Error('Usage: ' + args[0] + ' FILE');
            if (typeof process !== 'undefined') {
                var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), "utf8");
            } else {
                var cwd = require("file").path(require("file").cwd());
                var source = cwd.join(args[1]).read({ charset: "utf-8" });
            }
            return exports.parser.parse(source);
        }
        if (typeof module !== 'undefined' && require.main === module) {
            exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require("system").args);
        }
    };
    ;
    // lib/handlebars/compiler/base.js
    Handlebars.Parser = handlebars;

    Handlebars.parse = function (string) {
        Handlebars.Parser.yy = Handlebars.AST;
        return Handlebars.Parser.parse(string);
    };

    Handlebars.print = function (ast) {
        return new Handlebars.PrintVisitor().accept(ast);
    };

    Handlebars.logger = {
        DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3,

        // override in the host environment
        log: function (level, str) { }
    };

    Handlebars.log = function (level, str) { Handlebars.logger.log(level, str); };
    ;
    // lib/handlebars/compiler/ast.js
    (function () {

        Handlebars.AST = {};

        Handlebars.AST.ProgramNode = function (statements, inverse) {
            this.type = "program";
            this.statements = statements;
            if (inverse) { this.inverse = new Handlebars.AST.ProgramNode(inverse); }
        };

        Handlebars.AST.MustacheNode = function (params, hash, unescaped) {
            this.type = "mustache";
            this.id = params[0];
            this.params = params.slice(1);
            this.hash = hash;
            this.escaped = !unescaped;
        };

        Handlebars.AST.PartialNode = function (id, context) {
            this.type = "partial";

            // TODO: disallow complex IDs

            this.id = id;
            this.context = context;
        };

        var verifyMatch = function (open, close) {
            if (open.original !== close.original) {
                throw new Handlebars.Exception(open.original + " doesn't match " + close.original);
            }
        };

        Handlebars.AST.BlockNode = function (mustache, program, close) {
            verifyMatch(mustache.id, close);
            this.type = "block";
            this.mustache = mustache;
            this.program = program;
        };

        Handlebars.AST.InverseNode = function (mustache, program, close) {
            verifyMatch(mustache.id, close);
            this.type = "inverse";
            this.mustache = mustache;
            this.program = program;
        };

        Handlebars.AST.ContentNode = function (string) {
            this.type = "content";
            this.string = string;
        };

        Handlebars.AST.HashNode = function (pairs) {
            this.type = "hash";
            this.pairs = pairs;
        };

        Handlebars.AST.IdNode = function (parts) {
            this.type = "ID";
            this.original = parts.join(".");

            var dig = [], depth = 0;

            for (var i = 0, l = parts.length; i < l; i++) {
                var part = parts[i];

                if (part === "..") { depth++; }
                else if (part === "." || part === "this") { this.isScoped = true; }
                else { dig.push(part); }
            }

            this.parts = dig;
            this.string = dig.join('.');
            this.depth = depth;
            this.isSimple = (dig.length === 1) && (depth === 0);
        };

        Handlebars.AST.StringNode = function (string) {
            this.type = "STRING";
            this.string = string;
        };

        Handlebars.AST.IntegerNode = function (integer) {
            this.type = "INTEGER";
            this.integer = integer;
        };

        Handlebars.AST.BooleanNode = function (bool) {
            this.type = "BOOLEAN";
            this.bool = bool;
        };

        Handlebars.AST.CommentNode = function (comment) {
            this.type = "comment";
            this.comment = comment;
        };

    })(); ;
    // lib/handlebars/utils.js
    Handlebars.Exception = function (message) {
        var tmp = Error.prototype.constructor.apply(this, arguments);

        for (var p in tmp) {
            if (tmp.hasOwnProperty(p)) { this[p] = tmp[p]; }
        }

        this.message = tmp.message;
    };
    Handlebars.Exception.prototype = new Error;

    // Build out our basic SafeString type
    Handlebars.SafeString = function (string) {
        this.string = string;
    };
    Handlebars.SafeString.prototype.toString = function () {
        return this.string.toString();
    };

    (function () {
        var escape = {
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        };

        var badChars = /&(?!\w+;)|[<>"'`]/g;
        var possible = /[&<>"'`]/;

        var escapeChar = function (chr) {
            return escape[chr] || "&amp;";
        };

        Handlebars.Utils = {
            escapeExpression: function (string) {
                // don't escape SafeStrings, since they're already safe
                if (string instanceof Handlebars.SafeString) {
                    return string.toString();
                } else if (string == null || string === false) {
                    return "";
                }

                if (!possible.test(string)) { return string; }
                return string.replace(badChars, escapeChar);
            },

            isEmpty: function (value) {
                if (typeof value === "undefined") {
                    return true;
                } else if (value === null) {
                    return true;
                } else if (value === false) {
                    return true;
                } else if (Object.prototype.toString.call(value) === "[object Array]" && value.length === 0) {
                    return true;
                } else {
                    return false;
                }
            }
        };
    })(); ;
    // lib/handlebars/compiler/compiler.js
    Handlebars.Compiler = function () { };
    Handlebars.JavaScriptCompiler = function () { };

    (function (Compiler, JavaScriptCompiler) {
        Compiler.OPCODE_MAP = {
            appendContent: 1,
            getContext: 2,
            lookupWithHelpers: 3,
            lookup: 4,
            append: 5,
            invokeMustache: 6,
            appendEscaped: 7,
            pushString: 8,
            truthyOrFallback: 9,
            functionOrFallback: 10,
            invokeProgram: 11,
            invokePartial: 12,
            push: 13,
            assignToHash: 15,
            pushStringParam: 16
        };

        Compiler.MULTI_PARAM_OPCODES = {
            appendContent: 1,
            getContext: 1,
            lookupWithHelpers: 2,
            lookup: 1,
            invokeMustache: 3,
            pushString: 1,
            truthyOrFallback: 1,
            functionOrFallback: 1,
            invokeProgram: 3,
            invokePartial: 1,
            push: 1,
            assignToHash: 1,
            pushStringParam: 1
        };

        Compiler.DISASSEMBLE_MAP = {};

        for (var prop in Compiler.OPCODE_MAP) {
            var value = Compiler.OPCODE_MAP[prop];
            Compiler.DISASSEMBLE_MAP[value] = prop;
        }

        Compiler.multiParamSize = function (code) {
            return Compiler.MULTI_PARAM_OPCODES[Compiler.DISASSEMBLE_MAP[code]];
        };

        Compiler.prototype = {
            compiler: Compiler,

            disassemble: function () {
                var opcodes = this.opcodes, opcode, nextCode;
                var out = [], str, name, value;

                for (var i = 0, l = opcodes.length; i < l; i++) {
                    opcode = opcodes[i];

                    if (opcode === 'DECLARE') {
                        name = opcodes[++i];
                        value = opcodes[++i];
                        out.push("DECLARE " + name + " = " + value);
                    } else {
                        str = Compiler.DISASSEMBLE_MAP[opcode];

                        var extraParams = Compiler.multiParamSize(opcode);
                        var codes = [];

                        for (var j = 0; j < extraParams; j++) {
                            nextCode = opcodes[++i];

                            if (typeof nextCode === "string") {
                                nextCode = "\"" + nextCode.replace("\n", "\\n") + "\"";
                            }

                            codes.push(nextCode);
                        }

                        str = str + " " + codes.join(" ");

                        out.push(str);
                    }
                }

                return out.join("\n");
            },

            guid: 0,

            compile: function (program, options) {
                this.children = [];
                this.depths = { list: [] };
                this.options = options;

                // These changes will propagate to the other compiler components
                var knownHelpers = this.options.knownHelpers;
                this.options.knownHelpers = {
                    'helperMissing': true,
                    'blockHelperMissing': true,
                    'each': true,
                    'if': true,
                    'unless': true,
                    'with': true,
                    'log': true
                };
                if (knownHelpers) {
                    for (var name in knownHelpers) {
                        this.options.knownHelpers[name] = knownHelpers[name];
                    }
                }

                return this.program(program);
            },

            accept: function (node) {
                return this[node.type](node);
            },

            program: function (program) {
                var statements = program.statements, statement;
                this.opcodes = [];

                for (var i = 0, l = statements.length; i < l; i++) {
                    statement = statements[i];
                    this[statement.type](statement);
                }
                this.isSimple = l === 1;

                this.depths.list = this.depths.list.sort(function (a, b) {
                    return a - b;
                });

                return this;
            },

            compileProgram: function (program) {
                var result = new this.compiler().compile(program, this.options);
                var guid = this.guid++;

                this.usePartial = this.usePartial || result.usePartial;

                this.children[guid] = result;

                for (var i = 0, l = result.depths.list.length; i < l; i++) {
                    depth = result.depths.list[i];

                    if (depth < 2) { continue; }
                    else { this.addDepth(depth - 1); }
                }

                return guid;
            },

            block: function (block) {
                var mustache = block.mustache;
                var depth, child, inverse, inverseGuid;

                var params = this.setupStackForMustache(mustache);

                var programGuid = this.compileProgram(block.program);

                if (block.program.inverse) {
                    inverseGuid = this.compileProgram(block.program.inverse);
                    this.declare('inverse', inverseGuid);
                }

                this.opcode('invokeProgram', programGuid, params.length, !!mustache.hash);
                this.declare('inverse', null);
                this.opcode('append');
            },

            inverse: function (block) {
                var params = this.setupStackForMustache(block.mustache);

                var programGuid = this.compileProgram(block.program);

                this.declare('inverse', programGuid);

                this.opcode('invokeProgram', null, params.length, !!block.mustache.hash);
                this.declare('inverse', null);
                this.opcode('append');
            },

            hash: function (hash) {
                var pairs = hash.pairs, pair, val;

                this.opcode('push', '{}');

                for (var i = 0, l = pairs.length; i < l; i++) {
                    pair = pairs[i];
                    val = pair[1];

                    this.accept(val);
                    this.opcode('assignToHash', pair[0]);
                }
            },

            partial: function (partial) {
                var id = partial.id;
                this.usePartial = true;

                if (partial.context) {
                    this.ID(partial.context);
                } else {
                    this.opcode('push', 'depth0');
                }

                this.opcode('invokePartial', id.original);
                this.opcode('append');
            },

            content: function (content) {
                this.opcode('appendContent', content.string);
            },

            mustache: function (mustache) {
                var params = this.setupStackForMustache(mustache);

                this.opcode('invokeMustache', params.length, mustache.id.original, !!mustache.hash);

                if (mustache.escaped && !this.options.noEscape) {
                    this.opcode('appendEscaped');
                } else {
                    this.opcode('append');
                }
            },

            ID: function (id) {
                this.addDepth(id.depth);

                this.opcode('getContext', id.depth);

                this.opcode('lookupWithHelpers', id.parts[0] || null, id.isScoped || false);

                for (var i = 1, l = id.parts.length; i < l; i++) {
                    this.opcode('lookup', id.parts[i]);
                }
            },

            STRING: function (string) {
                this.opcode('pushString', string.string);
            },

            INTEGER: function (integer) {
                this.opcode('push', integer.integer);
            },

            BOOLEAN: function (bool) {
                this.opcode('push', bool.bool);
            },

            comment: function () { },

            // HELPERS
            pushParams: function (params) {
                var i = params.length, param;

                while (i--) {
                    param = params[i];

                    if (this.options.stringParams) {
                        if (param.depth) {
                            this.addDepth(param.depth);
                        }

                        this.opcode('getContext', param.depth || 0);
                        this.opcode('pushStringParam', param.string);
                    } else {
                        this[param.type](param);
                    }
                }
            },

            opcode: function (name, val1, val2, val3) {
                this.opcodes.push(Compiler.OPCODE_MAP[name]);
                if (val1 !== undefined) { this.opcodes.push(val1); }
                if (val2 !== undefined) { this.opcodes.push(val2); }
                if (val3 !== undefined) { this.opcodes.push(val3); }
            },

            declare: function (name, value) {
                this.opcodes.push('DECLARE');
                this.opcodes.push(name);
                this.opcodes.push(value);
            },

            addDepth: function (depth) {
                if (depth === 0) { return; }

                if (!this.depths[depth]) {
                    this.depths[depth] = true;
                    this.depths.list.push(depth);
                }
            },

            setupStackForMustache: function (mustache) {
                var params = mustache.params;

                this.pushParams(params);

                if (mustache.hash) {
                    this.hash(mustache.hash);
                }

                this.ID(mustache.id);

                return params;
            }
        };

        JavaScriptCompiler.prototype = {
            // PUBLIC API: You can override these methods in a subclass to provide
            // alternative compiled forms for name lookup and buffering semantics
            nameLookup: function (parent, name, type) {
                if (/^[0-9]+$/.test(name)) {
                    return parent + "[" + name + "]";
                } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                    return parent + "." + name;
                }
                else {
                    return parent + "['" + name + "']";
                }
            },

            appendToBuffer: function (string) {
                if (this.environment.isSimple) {
                    return "return " + string + ";";
                } else {
                    return "buffer += " + string + ";";
                }
            },

            initializeBuffer: function () {
                return this.quotedString("");
            },

            namespace: "Handlebars",
            // END PUBLIC API

            compile: function (environment, options, context, asObject) {
                this.environment = environment;
                this.options = options || {};

                this.name = this.environment.name;
                this.isChild = !!context;
                this.context = context || {
                    programs: [],
                    aliases: { self: 'this' },
                    registers: { list: [] }
                };

                this.preamble();

                this.stackSlot = 0;
                this.stackVars = [];

                this.compileChildren(environment, options);

                var opcodes = environment.opcodes, opcode;

                this.i = 0;

                for (l = opcodes.length; this.i < l; this.i++) {
                    opcode = this.nextOpcode(0);

                    if (opcode[0] === 'DECLARE') {
                        this.i = this.i + 2;
                        this[opcode[1]] = opcode[2];
                    } else {
                        this.i = this.i + opcode[1].length;
                        this[opcode[0]].apply(this, opcode[1]);
                    }
                }

                return this.createFunctionContext(asObject);
            },

            nextOpcode: function (n) {
                var opcodes = this.environment.opcodes, opcode = opcodes[this.i + n], name, val;
                var extraParams, codes;

                if (opcode === 'DECLARE') {
                    name = opcodes[this.i + 1];
                    val = opcodes[this.i + 2];
                    return ['DECLARE', name, val];
                } else {
                    name = Compiler.DISASSEMBLE_MAP[opcode];

                    extraParams = Compiler.multiParamSize(opcode);
                    codes = [];

                    for (var j = 0; j < extraParams; j++) {
                        codes.push(opcodes[this.i + j + 1 + n]);
                    }

                    return [name, codes];
                }
            },

            eat: function (opcode) {
                this.i = this.i + opcode.length;
            },

            preamble: function () {
                var out = [];

                // this register will disambiguate helper lookup from finding a function in
                // a context. This is necessary for mustache compatibility, which requires
                // that context functions in blocks are evaluated by blockHelperMissing, and
                // then proceed as if the resulting value was provided to blockHelperMissing.
                this.useRegister('foundHelper');

                if (!this.isChild) {
                    var namespace = this.namespace;
                    var copies = "helpers = helpers || " + namespace + ".helpers;";
                    if (this.environment.usePartial) { copies = copies + " partials = partials || " + namespace + ".partials;"; }
                    out.push(copies);
                } else {
                    out.push('');
                }

                if (!this.environment.isSimple) {
                    out.push(", buffer = " + this.initializeBuffer());
                } else {
                    out.push("");
                }

                // track the last context pushed into place to allow skipping the
                // getContext opcode when it would be a noop
                this.lastContext = 0;
                this.source = out;
            },

            createFunctionContext: function (asObject) {
                var locals = this.stackVars;
                if (!this.isChild) {
                    locals = locals.concat(this.context.registers.list);
                }

                if (locals.length > 0) {
                    this.source[1] = this.source[1] + ", " + locals.join(", ");
                }

                // Generate minimizer alias mappings
                if (!this.isChild) {
                    var aliases = []
                    for (var alias in this.context.aliases) {
                        this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];
                    }
                }

                if (this.source[1]) {
                    this.source[1] = "var " + this.source[1].substring(2) + ";";
                }

                // Merge children
                if (!this.isChild) {
                    this.source[1] += '\n' + this.context.programs.join('\n') + '\n';
                }

                if (!this.environment.isSimple) {
                    this.source.push("return buffer;");
                }

                var params = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"];

                for (var i = 0, l = this.environment.depths.list.length; i < l; i++) {
                    params.push("depth" + this.environment.depths.list[i]);
                }

                if (asObject) {
                    params.push(this.source.join("\n  "));

                    return Function.apply(this, params);
                } else {
                    var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\n  ' + this.source.join("\n  ") + '}';
                    Handlebars.log(Handlebars.logger.DEBUG, functionSource + "\n\n");
                    return functionSource;
                }
            },

            appendContent: function (content) {
                this.source.push(this.appendToBuffer(this.quotedString(content)));
            },

            append: function () {
                var local = this.popStack();
                this.source.push("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
                if (this.environment.isSimple) {
                    this.source.push("else { " + this.appendToBuffer("''") + " }");
                }
            },

            appendEscaped: function () {
                var opcode = this.nextOpcode(1), extra = "";
                this.context.aliases.escapeExpression = 'this.escapeExpression';

                if (opcode[0] === 'appendContent') {
                    extra = " + " + this.quotedString(opcode[1][0]);
                    this.eat(opcode);
                }

                this.source.push(this.appendToBuffer("escapeExpression(" + this.popStack() + ")" + extra));
            },

            getContext: function (depth) {
                if (this.lastContext !== depth) {
                    this.lastContext = depth;
                }
            },

            lookupWithHelpers: function (name, isScoped) {
                if (name) {
                    var topStack = this.nextStack();

                    this.usingKnownHelper = false;

                    var toPush;
                    if (!isScoped && this.options.knownHelpers[name]) {
                        toPush = topStack + " = " + this.nameLookup('helpers', name, 'helper');
                        this.usingKnownHelper = true;
                    } else if (isScoped || this.options.knownHelpersOnly) {
                        toPush = topStack + " = " + this.nameLookup('depth' + this.lastContext, name, 'context');
                    } else {
                        this.register('foundHelper', this.nameLookup('helpers', name, 'helper'));
                        toPush = topStack + " = foundHelper || " + this.nameLookup('depth' + this.lastContext, name, 'context');
                    }

                    toPush += ';';
                    this.source.push(toPush);
                } else {
                    this.pushStack('depth' + this.lastContext);
                }
            },

            lookup: function (name) {
                var topStack = this.topStack();
                this.source.push(topStack + " = (" + topStack + " === null || " + topStack + " === undefined || " + topStack + " === false ? " +
 				topStack + " : " + this.nameLookup(topStack, name, 'context') + ");");
            },

            pushStringParam: function (string) {
                this.pushStack('depth' + this.lastContext);
                this.pushString(string);
            },

            pushString: function (string) {
                this.pushStack(this.quotedString(string));
            },

            push: function (name) {
                this.pushStack(name);
            },

            invokeMustache: function (paramSize, original, hasHash) {
                this.populateParams(paramSize, this.quotedString(original), "{}", null, hasHash, function (nextStack, helperMissingString, id) {
                    if (!this.usingKnownHelper) {
                        this.context.aliases.helperMissing = 'helpers.helperMissing';
                        this.context.aliases.undef = 'void 0';
                        this.source.push("else if(" + id + "=== undef) { " + nextStack + " = helperMissing.call(" + helperMissingString + "); }");
                        if (nextStack !== id) {
                            this.source.push("else { " + nextStack + " = " + id + "; }");
                        }
                    }
                });
            },

            invokeProgram: function (guid, paramSize, hasHash) {
                var inverse = this.programExpression(this.inverse);
                var mainProgram = this.programExpression(guid);

                this.populateParams(paramSize, null, mainProgram, inverse, hasHash, function (nextStack, helperMissingString, id) {
                    if (!this.usingKnownHelper) {
                        this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';
                        this.source.push("else { " + nextStack + " = blockHelperMissing.call(" + helperMissingString + "); }");
                    }
                });
            },

            populateParams: function (paramSize, helperId, program, inverse, hasHash, fn) {
                var needsRegister = hasHash || this.options.stringParams || inverse || this.options.data;
                var id = this.popStack(), nextStack;
                var params = [], param, stringParam, stringOptions;

                if (needsRegister) {
                    this.register('tmp1', program);
                    stringOptions = 'tmp1';
                } else {
                    stringOptions = '{ hash: {} }';
                }

                if (needsRegister) {
                    var hash = (hasHash ? this.popStack() : '{}');
                    this.source.push('tmp1.hash = ' + hash + ';');
                }

                if (this.options.stringParams) {
                    this.source.push('tmp1.contexts = [];');
                }

                for (var i = 0; i < paramSize; i++) {
                    param = this.popStack();
                    params.push(param);

                    if (this.options.stringParams) {
                        this.source.push('tmp1.contexts.push(' + this.popStack() + ');');
                    }
                }

                if (inverse) {
                    this.source.push('tmp1.fn = tmp1;');
                    this.source.push('tmp1.inverse = ' + inverse + ';');
                }

                if (this.options.data) {
                    this.source.push('tmp1.data = data;');
                }

                params.push(stringOptions);

                this.populateCall(params, id, helperId || id, fn, program !== '{}');
            },

            populateCall: function (params, id, helperId, fn, program) {
                var paramString = ["depth0"].concat(params).join(", ");
                var helperMissingString = ["depth0"].concat(helperId).concat(params).join(", ");

                var nextStack = this.nextStack();

                if (this.usingKnownHelper) {
                    this.source.push(nextStack + " = " + id + ".call(" + paramString + ");");
                } else {
                    this.context.aliases.functionType = '"function"';
                    var condition = program ? "foundHelper && " : ""
                    this.source.push("if(" + condition + "typeof " + id + " === functionType) { " + nextStack + " = " + id + ".call(" + paramString + "); }");
                }
                fn.call(this, nextStack, helperMissingString, id);
                this.usingKnownHelper = false;
            },

            invokePartial: function (context) {
                params = [this.nameLookup('partials', context, 'partial'), "'" + context + "'", this.popStack(), "helpers", "partials"];

                if (this.options.data) {
                    params.push("data");
                }

                this.pushStack("self.invokePartial(" + params.join(", ") + ");");
            },

            assignToHash: function (key) {
                var value = this.popStack();
                var hash = this.topStack();

                this.source.push(hash + "['" + key + "'] = " + value + ";");
            },

            // HELPERS

            compiler: JavaScriptCompiler,

            compileChildren: function (environment, options) {
                var children = environment.children, child, compiler;

                for (var i = 0, l = children.length; i < l; i++) {
                    child = children[i];
                    compiler = new this.compiler();

                    this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
                    var index = this.context.programs.length;
                    child.index = index;
                    child.name = 'program' + index;
                    this.context.programs[index] = compiler.compile(child, options, this.context);
                }
            },

            programExpression: function (guid) {
                if (guid == null) { return "self.noop"; }

                var child = this.environment.children[guid],
          depths = child.depths.list;
                var programParams = [child.index, child.name, "data"];

                for (var i = 0, l = depths.length; i < l; i++) {
                    depth = depths[i];

                    if (depth === 1) { programParams.push("depth0"); }
                    else { programParams.push("depth" + (depth - 1)); }
                }

                if (depths.length === 0) {
                    return "self.program(" + programParams.join(", ") + ")";
                } else {
                    programParams.shift();
                    return "self.programWithDepth(" + programParams.join(", ") + ")";
                }
            },

            register: function (name, val) {
                this.useRegister(name);
                this.source.push(name + " = " + val + ";");
            },

            useRegister: function (name) {
                if (!this.context.registers[name]) {
                    this.context.registers[name] = true;
                    this.context.registers.list.push(name);
                }
            },

            pushStack: function (item) {
                this.source.push(this.nextStack() + " = " + item + ";");
                return "stack" + this.stackSlot;
            },

            nextStack: function () {
                this.stackSlot++;
                if (this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
                return "stack" + this.stackSlot;
            },

            popStack: function () {
                return "stack" + this.stackSlot--;
            },

            topStack: function () {
                return "stack" + this.stackSlot;
            },

            quotedString: function (str) {
                return '"' + str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r') + '"';
            }
        };

        var reservedWords = (
    "break else new var" +
    " case finally return void" +
    " catch for switch while" +
    " continue function this with" +
    " default if throw" +
    " delete in try" +
    " do instanceof typeof" +
    " abstract enum int short" +
    " boolean export interface static" +
    " byte extends long super" +
    " char final native synchronized" +
    " class float package throws" +
    " const goto private transient" +
    " debugger implements protected volatile" +
    " double import public let yield"
  ).split(" ");

        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

        for (var i = 0, l = reservedWords.length; i < l; i++) {
            compilerWords[reservedWords[i]] = true;
        }

        JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
            if (!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name)) {
                return true;
            }
            return false;
        }

    })(Handlebars.Compiler, Handlebars.JavaScriptCompiler);

    Handlebars.precompile = function (string, options) {
        options = options || {};

        var ast = Handlebars.parse(string);
        var environment = new Handlebars.Compiler().compile(ast, options);
        return new Handlebars.JavaScriptCompiler().compile(environment, options);
    };

    Handlebars.compile = function (string, options) {
        options = options || {};

        var compiled;
        function compile() {
            var ast = Handlebars.parse(string);
            var environment = new Handlebars.Compiler().compile(ast, options);
            var templateSpec = new Handlebars.JavaScriptCompiler().compile(environment, options, undefined, true);
            return Handlebars.template(templateSpec);
        }

        // Template is only compiled on first use and cached after that point.
        return function (context, options) {
            if (!compiled) {
                compiled = compile();
            }
            return compiled.call(this, context, options);
        };
    };
    ;
    // lib/handlebars/runtime.js
    Handlebars.VM = {
        template: function (templateSpec) {
            // Just add water
            var container = {
                escapeExpression: Handlebars.Utils.escapeExpression,
                invokePartial: Handlebars.VM.invokePartial,
                programs: [],
                program: function (i, fn, data) {
                    var programWrapper = this.programs[i];
                    if (data) {
                        return Handlebars.VM.program(fn, data);
                    } else if (programWrapper) {
                        return programWrapper;
                    } else {
                        programWrapper = this.programs[i] = Handlebars.VM.program(fn);
                        return programWrapper;
                    }
                },
                programWithDepth: Handlebars.VM.programWithDepth,
                noop: Handlebars.VM.noop
            };

            return function (context, options) {
                options = options || {};
                return templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);
            };
        },

        programWithDepth: function (fn, data, $depth) {
            var args = Array.prototype.slice.call(arguments, 2);

            return function (context, options) {
                options = options || {};

                return fn.apply(this, [context, options.data || data].concat(args));
            };
        },
        program: function (fn, data) {
            return function (context, options) {
                options = options || {};

                return fn(context, options.data || data);
            };
        },
        noop: function () { return ""; },
        invokePartial: function (partial, name, context, helpers, partials, data) {
            options = { helpers: helpers, partials: partials, data: data };

            if (partial === undefined) {
                throw new Handlebars.Exception("The partial " + name + " could not be found");
            } else if (partial instanceof Function) {
                return partial(context, options);
            } else if (!Handlebars.compile) {
                throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
            } else {
                partials[name] = Handlebars.compile(partial);
                return partials[name](context, options);
            }
        }
    };

    Handlebars.template = Handlebars.VM.template;
    ;

})();

(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Em:true ENV */

    if ('undefined' === typeof Ember) {
        /**
        @namespace
        @name Ember
        @version 0.9.8.1

        All Ember methods and functions are defined inside of this namespace.
        You generally should not add new properties to this namespace as it may be
        overwritten by future versions of Ember.

        You can also use the shorthand "Em" instead of "Ember".

        Ember-Runtime is a framework that provides core functions for
        Ember including cross-platform functions, support for property
        observing and objects. Its focus is on small size and performance. You can
        use this in place of or along-side other cross-platform libraries such as
        jQuery.

        The core Runtime framework is based on the jQuery API with a number of
        performance optimizations.
        */

        // Create core object. Make it act like an instance of Ember.Namespace so that
        // objects assigned to it are given a sane string representation.
        Ember = {};

        // aliases needed to keep minifiers from removing the global context
        if ('undefined' !== typeof window) {
            window.Em = window.Ember = Em = Ember;
        }

    }

    // Make sure these are set whether Ember was already defined or not

    Ember.isNamespace = true;

    Ember.toString = function () { return "Ember"; };


    /**
    @static
    @type String
    @default '0.9.8.1'
    @constant
    */
    Ember.VERSION = '0.9.8.1';

    /**
    @static
    @type Hash
    @constant

    Standard environmental variables.  You can define these in a global `ENV`
    variable before loading Ember to control various configuration
    settings.
    */
    Ember.ENV = 'undefined' === typeof ENV ? {} : ENV;


    // ..........................................................
    // BOOTSTRAP
    //

    /**
    @static
    @type Boolean
    @default true
    @constant

    Determines whether Ember should enhances some built-in object
    prototypes to provide a more friendly API.  If enabled, a few methods
    will be added to Function, String, and Array.  Object.prototype will not be
    enhanced, which is the one that causes most troubles for people.

    In general we recommend leaving this option set to true since it rarely
    conflicts with other code.  If you need to turn it off however, you can
    define an ENV.EXTEND_PROTOTYPES config to disable it.
    */
    Ember.EXTEND_PROTOTYPES = (Ember.ENV.EXTEND_PROTOTYPES !== false);


    /**
    @static
    @type Boolean
    @default Ember.EXTEND_PROTOTYPES
    @constant

    Determines whether Ember should add ECMAScript 5 shims to older browsers.
    */
    Ember.SHIM_ES5 = (Ember.ENV.SHIM_ES5 === false) ? false : Ember.EXTEND_PROTOTYPES;


    /**
    @static
    @type Boolean
    @default false
    @constant

    Determines whether computed properties are cacheable by default.
    In future releases this will default to `true`. For the 1.0 release,
    the option to turn off caching by default will be removed entirely.

    When caching is enabled by default, you can use `volatile()` to disable
    caching on individual computed properties.
    */
    Ember.CP_DEFAULT_CACHEABLE = !!Ember.ENV.CP_DEFAULT_CACHEABLE;

    /**
    @static
    @type Boolean
    @default false
    @constant

    Determines whether views render their templates using themselves
    as the context, or whether it is inherited from the parent. In
    future releases, this will default to `true`. For the 1.0 release,
    the option to have views change context by default will be removed entirely.

    If you need to update your application to use the new context rules, simply
    prefix property access with `view.`:

    // Before:
    {{#each App.photosController}}
    Photo Title: {{title}}
    {{#view App.InfoView contentBinding="this"}}
    {{content.date}}
    {{content.cameraType}}
    {{otherViewProperty}}
    {{/view}}
    {{/each}}

    // After:
    {{#each App.photosController}}
    Photo Title: {{title}}
    {{#view App.InfoView}}
    {{date}}
    {{cameraType}}
    {{view.otherViewProperty}}
    {{/view}}
    {{/each}}
    */
    Ember.VIEW_PRESERVES_CONTEXT = !!Ember.ENV.VIEW_PRESERVES_CONTEXT;

    /**
    Empty function.  Useful for some operations.

    @returns {Object}
    @private
    */
    Ember.K = function () { return this; };

    /**
    @namespace
    @name window
    @description The global window object
    */


    // Stub out the methods defined by the ember-debug package in case it's not loaded

    if ('undefined' === typeof Ember.assert) { Ember.assert = Ember.K; }
    if ('undefined' === typeof Ember.warn) { Ember.warn = Ember.K; }
    if ('undefined' === typeof Ember.deprecate) { Ember.deprecate = Ember.K; }
    if ('undefined' === typeof Ember.deprecateFunc) {
        Ember.deprecateFunc = function (_, func) { return func; };
    }

    // These are deprecated but still supported

    if ('undefined' === typeof ember_assert) { window.ember_assert = Ember.K; }
    if ('undefined' === typeof ember_warn) { window.ember_warn = Ember.K; }
    if ('undefined' === typeof ember_deprecate) { window.ember_deprecate = Ember.K; }
    if ('undefined' === typeof ember_deprecateFunc) {
        /** @private */
        window.ember_deprecateFunc = function (_, func) { return func; };
    }


    // ..........................................................
    // LOGGER
    //

    /**
    @class

    Inside Ember-Metal, simply uses the window.console object.
    Override this to provide more robust logging functionality.
    */
    Ember.Logger = window.console || { log: Ember.K, warn: Ember.K, error: Ember.K };

})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Node */
    /**
    @class

    Platform specific methods and feature detectors needed by the framework.

    @name Ember.platform
    */
    var platform = Ember.platform = {};

    /**
    Identical to Object.create().  Implements if not available natively.
    @memberOf Ember.platform
    @name create
    */
    platform.create = Object.create;

    if (!platform.create) {
        /** @private */
        var O_ctor = function () { },
      O_proto = O_ctor.prototype;

        platform.create = function (obj, descs) {
            O_ctor.prototype = obj;
            obj = new O_ctor();
            O_ctor.prototype = O_proto;

            if (descs !== undefined) {
                for (var key in descs) {
                    if (!descs.hasOwnProperty(key)) continue;
                    platform.defineProperty(obj, key, descs[key]);
                }
            }

            return obj;
        };

        platform.create.isSimulated = true;
    }

    /** @private */
    var defineProperty = Object.defineProperty;
    var canRedefineProperties, canDefinePropertyOnDOM;

    // Catch IE8 where Object.defineProperty exists but only works on DOM elements
    if (defineProperty) {
        try {
            defineProperty({}, 'a', { get: function () { } });
        } catch (e) {
            /** @private */
            defineProperty = null;
        }
    }

    if (defineProperty) {
        // Detects a bug in Android <3.2 where you cannot redefine a property using
        // Object.defineProperty once accessors have already been set.
        /** @private */
        canRedefineProperties = (function () {
            var obj = {};

            defineProperty(obj, 'a', {
                configurable: true,
                enumerable: true,
                get: function () { },
                set: function () { }
            });

            defineProperty(obj, 'a', {
                configurable: true,
                enumerable: true,
                writable: true,
                value: true
            });

            return obj.a === true;
        })();

        // This is for Safari 5.0, which supports Object.defineProperty, but not
        // on DOM nodes.
        /** @private */
        canDefinePropertyOnDOM = (function () {
            try {
                defineProperty(document.createElement('div'), 'definePropertyOnDOM', {});
                return true;
            } catch (e) { }

            return false;
        })();

        if (!canRedefineProperties) {
            /** @private */
            defineProperty = null;
        } else if (!canDefinePropertyOnDOM) {
            /** @private */
            defineProperty = function (obj, keyName, desc) {
                var isNode;

                if (typeof Node === "object") {
                    isNode = obj instanceof Node;
                } else {
                    isNode = typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string";
                }

                if (isNode) {
                    // TODO: Should we have a warning here?
                    return (obj[keyName] = desc.value);
                } else {
                    return Object.defineProperty(obj, keyName, desc);
                }
            };
        }
    }

    /**
    Identical to Object.defineProperty().  Implements as much functionality
    as possible if not available natively.

    @memberOf Ember.platform
    @name defineProperty
    @param {Object} obj The object to modify
    @param {String} keyName property name to modify
    @param {Object} desc descriptor hash
    @returns {void}
    */
    platform.defineProperty = defineProperty;

    /**
    Set to true if the platform supports native getters and setters.

    @memberOf Ember.platform
    @name hasPropertyAccessors
    */
    platform.hasPropertyAccessors = true;

    if (!platform.defineProperty) {
        platform.hasPropertyAccessors = false;

        platform.defineProperty = function (obj, keyName, desc) {
            Ember.assert("property descriptor cannot have `get` or `set` on this platform", !desc.get && !desc.set);
            obj[keyName] = desc.value;
        };

        platform.defineProperty.isSimulated = true;
    }

})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    // ..........................................................
    // GUIDS
    //

    // Used for guid generation...
    var GUID_KEY = '__ember' + (+new Date());
    var uuid, numberCache, stringCache;

    uuid = 0;
    numberCache = [];
    stringCache = {};

    var GUID_DESC = Ember.GUID_DESC = {
        configurable: true,
        writable: true,
        enumerable: false
    };

    var o_defineProperty = Ember.platform.defineProperty;
    var o_create = Ember.platform.create;

    /**
    @private
    @static
    @type String
    @constant

    A unique key used to assign guids and other private metadata to objects.
    If you inspect an object in your browser debugger you will often see these.
    They can be safely ignored.

    On browsers that support it, these properties are added with enumeration
    disabled so they won't show up when you iterate over your properties.
    */
    Ember.GUID_KEY = GUID_KEY;

    /**
    @private

    Generates a new guid, optionally saving the guid to the object that you
    pass in.  You will rarely need to use this method.  Instead you should
    call Ember.guidFor(obj), which return an existing guid if available.

    @param {Object} obj
    Optional object the guid will be used for.  If passed in, the guid will
    be saved on the object and reused whenever you pass the same object
    again.

    If no object is passed, just generate a new guid.

    @param {String} prefix
    Optional prefix to place in front of the guid.  Useful when you want to
    separate the guid into separate namespaces.

    @returns {String} the guid
    */
    Ember.generateGuid = function (obj, prefix) {
        if (!prefix) prefix = 'ember';
        var ret = (prefix + (uuid++));
        if (obj) {
            GUID_DESC.value = ret;
            o_defineProperty(obj, GUID_KEY, GUID_DESC);
            GUID_DESC.value = null;
        }

        return ret;
    };

    /**
    @private

    Returns a unique id for the object.  If the object does not yet have
    a guid, one will be assigned to it.  You can call this on any object,
    Ember.Object-based or not, but be aware that it will add a _guid property.

    You can also use this method on DOM Element objects.

    @method
    @param obj {Object} any object, string, number, Element, or primitive
    @returns {String} the unique guid for this instance.
    */
    Ember.guidFor = function (obj) {

        // special cases where we don't want to add a key to object
        if (obj === undefined) return "(undefined)";
        if (obj === null) return "(null)";

        var cache, ret;
        var type = typeof obj;

        // Don't allow prototype changes to String etc. to change the guidFor
        switch (type) {
            case 'number':
                ret = numberCache[obj];
                if (!ret) ret = numberCache[obj] = 'nu' + obj;
                return ret;

            case 'string':
                ret = stringCache[obj];
                if (!ret) ret = stringCache[obj] = 'st' + (uuid++);
                return ret;

            case 'boolean':
                return obj ? '(true)' : '(false)';

            default:
                if (obj[GUID_KEY]) return obj[GUID_KEY];
                if (obj === Object) return '(Object)';
                if (obj === Array) return '(Array)';
                return Ember.generateGuid(obj, 'ember');
        }
    };


    // ..........................................................
    // META
    //

    var META_DESC = {
        writable: true,
        configurable: false,
        enumerable: false,
        value: null
    };

    var META_KEY = Ember.GUID_KEY + '_meta';

    /**
    The key used to store meta information on object for property observing.

    @static
    @property
    */
    Ember.META_KEY = META_KEY;

    // Placeholder for non-writable metas.
    var EMPTY_META = {
        descs: {},
        watching: {}
    };

    if (Object.freeze) Object.freeze(EMPTY_META);

    var createMeta = Ember.platform.defineProperty.isSimulated ? o_create : (function (meta) { return meta; });

    /**
    @private
    @function

    Retrieves the meta hash for an object.  If 'writable' is true ensures the
    hash is writable for this object as well.

    The meta object contains information about computed property descriptors as
    well as any watched properties and other information.  You generally will
    not access this information directly but instead work with higher level
    methods that manipulate this hash indirectly.

    @param {Object} obj
    The object to retrieve meta for

    @param {Boolean} writable
    Pass false if you do not intend to modify the meta hash, allowing the
    method to avoid making an unnecessary copy.

    @returns {Hash}
    */
    Ember.meta = function meta(obj, writable) {

        var ret = obj[META_KEY];
        if (writable === false) return ret || EMPTY_META;

        if (!ret) {
            o_defineProperty(obj, META_KEY, META_DESC);
            ret = obj[META_KEY] = createMeta({
                descs: {},
                watching: {},
                values: {},
                lastSetValues: {},
                cache: {},
                source: obj
            });

            // make sure we don't accidentally try to create constructor like desc
            ret.descs.constructor = null;

        } else if (ret.source !== obj) {
            ret = o_create(ret);
            ret.descs = o_create(ret.descs);
            ret.values = o_create(ret.values);
            ret.watching = o_create(ret.watching);
            ret.lastSetValues = {};
            ret.cache = {};
            ret.source = obj;

            o_defineProperty(obj, META_KEY, META_DESC);
            ret = obj[META_KEY] = createMeta(ret);
        }
        return ret;
    };

    Ember.getMeta = function getMeta(obj, property) {
        var meta = Ember.meta(obj, false);
        return meta[property];
    };

    Ember.setMeta = function setMeta(obj, property, value) {
        var meta = Ember.meta(obj, true);
        meta[property] = value;
        return value;
    };

    /**
    @private

    In order to store defaults for a class, a prototype may need to create
    a default meta object, which will be inherited by any objects instantiated
    from the class's constructor.

    However, the properties of that meta object are only shallow-cloned,
    so if a property is a hash (like the event system's `listeners` hash),
    it will by default be shared across all instances of that class.

    This method allows extensions to deeply clone a series of nested hashes or
    other complex objects. For instance, the event system might pass
    ['listeners', 'foo:change', 'ember157'] to `prepareMetaPath`, which will
    walk down the keys provided.

    For each key, if the key does not exist, it is created. If it already
    exists and it was inherited from its constructor, the constructor's
    key is cloned.

    You can also pass false for `writable`, which will simply return
    undefined if `prepareMetaPath` discovers any part of the path that
    shared or undefined.

    @param {Object} obj The object whose meta we are examining
    @param {Array} path An array of keys to walk down
    @param {Boolean} writable whether or not to create a new meta
    (or meta property) if one does not already exist or if it's
    shared with its constructor
    */
    Ember.metaPath = function (obj, path, writable) {
        var meta = Ember.meta(obj, writable), keyName, value;

        for (var i = 0, l = path.length; i < l; i++) {
            keyName = path[i];
            value = meta[keyName];

            if (!value) {
                if (!writable) { return undefined; }
                value = meta[keyName] = { __ember_source__: obj };
            } else if (value.__ember_source__ !== obj) {
                if (!writable) { return undefined; }
                value = meta[keyName] = o_create(value);
                value.__ember_source__ = obj;
            }

            meta = value;
        }

        return value;
    };

    /**
    @private

    Wraps the passed function so that `this._super` will point to the superFunc
    when the function is invoked.  This is the primitive we use to implement
    calls to super.

    @param {Function} func
    The function to call

    @param {Function} superFunc
    The super function.

    @returns {Function} wrapped function.
    */
    Ember.wrap = function (func, superFunc) {

        function K() { }

        var newFunc = function () {
            var ret, sup = this._super;
            this._super = superFunc || K;
            ret = func.apply(this, arguments);
            this._super = sup;
            return ret;
        };

        newFunc.base = func;
        return newFunc;
    };

    /**
    Returns true if the passed object is an array or Array-like.

    Ember Array Protocol:

    - the object has an objectAt property
    - the object is a native Array
    - the object is an Object, and has a length property

    Unlike Ember.typeOf this method returns true even if the passed object is
    not formally array but appears to be array-like (i.e. implements Ember.Array)

    Ember.isArray(); // false
    Ember.isArray([]); // true
    Ember.isArray( Ember.ArrayProxy.create({ content: [] }) ); // true

    @param {Object} obj The object to test
    @returns {Boolean}
    */
    Ember.isArray = function (obj) {
        if (!obj || obj.setInterval) { return false; }
        if (Array.isArray && Array.isArray(obj)) { return true; }
        if (Ember.Array && Ember.Array.detect(obj)) { return true; }
        if ((obj.length !== undefined) && 'object' === typeof obj) { return true; }
        return false;
    };

    /**
    Forces the passed object to be part of an array.  If the object is already
    an array or array-like, returns the object.  Otherwise adds the object to
    an array.  If obj is null or undefined, returns an empty array.

    Ember.makeArray();          => []
    Ember.makeArray(null);      => []
    Ember.makeArray(undefined); => []
    Ember.makeArray('lindsay'); => ['lindsay'] 
    Ember.makeArray([1,2,42]);  => [1,2,42]

    var controller = Ember.ArrayProxy.create({ content: [] });
    Ember.makeArray(controller) === controller;   => true

    @param {Object} obj the object
    @returns {Array}
    */
    Ember.makeArray = function (obj) {
        if (obj === null || obj === undefined) return [];
        return Ember.isArray(obj) ? obj : [obj];
    };



})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var USE_ACCESSORS = Ember.platform.hasPropertyAccessors && Ember.ENV.USE_ACCESSORS;
    Ember.USE_ACCESSORS = !!USE_ACCESSORS;

    var meta = Ember.meta;

    // ..........................................................
    // GET AND SET
    //
    // If we are on a platform that supports accessors we can get use those.
    // Otherwise simulate accessors by looking up the property directly on the
    // object.

    var get, set;

    /** @private */
    get = function get(obj, keyName) {
        if (keyName === undefined && 'string' === typeof obj) {
            keyName = obj;
            obj = Ember;
        }

        if (!obj) return undefined;
        var ret = obj[keyName];
        if (ret === undefined && 'function' === typeof obj.unknownProperty) {
            ret = obj.unknownProperty(keyName);
        }
        return ret;
    };

    /** @private */
    set = function set(obj, keyName, value) {
        if (('object' === typeof obj) && !(keyName in obj)) {
            if ('function' === typeof obj.setUnknownProperty) {
                obj.setUnknownProperty(keyName, value);
            } else if ('function' === typeof obj.unknownProperty) {
                obj.unknownProperty(keyName, value);
            } else obj[keyName] = value;
        } else {
            obj[keyName] = value;
        }
        return value;
    };

    if (!USE_ACCESSORS) {

        var o_get = get, o_set = set;

        /** @private */
        get = function (obj, keyName) {
            if (keyName === undefined && 'string' === typeof obj) {
                keyName = obj;
                obj = Ember;
            }

            Ember.assert("You need to provide an object and key to `get`.", !!obj && keyName);

            if (!obj) return undefined;
            var desc = meta(obj, false).descs[keyName];
            if (desc) return desc.get(obj, keyName);
            else return o_get(obj, keyName);
        };

        /** @private */
        set = function (obj, keyName, value) {
            Ember.assert("You need to provide an object and key to `set`.", !!obj && keyName !== undefined);
            var desc = meta(obj, false).descs[keyName];
            if (desc) desc.set(obj, keyName, value);
            else o_set(obj, keyName, value);
            return value;
        };

    }

    /**
    @function

    Gets the value of a property on an object.  If the property is computed,
    the function will be invoked.  If the property is not defined but the
    object implements the unknownProperty() method then that will be invoked.

    If you plan to run on IE8 and older browsers then you should use this
    method anytime you want to retrieve a property on an object that you don't
    know for sure is private.  (My convention only properties beginning with
    an underscore '_' are considered private.)

    On all newer browsers, you only need to use this method to retrieve
    properties if the property might not be defined on the object and you want
    to respect the unknownProperty() handler.  Otherwise you can ignore this
    method.

    Note that if the obj itself is null, this method will simply return
    undefined.

    @param {Object} obj
    The object to retrieve from.

    @param {String} keyName
    The property key to retrieve

    @returns {Object} the property value or null.
    */
    Ember.get = get;

    /**
    @function

    Sets the value of a property on an object, respecting computed properties
    and notifying observers and other listeners of the change.  If the
    property is not defined but the object implements the unknownProperty()
    method then that will be invoked as well.

    If you plan to run on IE8 and older browsers then you should use this
    method anytime you want to set a property on an object that you don't
    know for sure is private.  (My convention only properties beginning with
    an underscore '_' are considered private.)

    On all newer browsers, you only need to use this method to set
    properties if the property might not be defined on the object and you want
    to respect the unknownProperty() handler.  Otherwise you can ignore this
    method.

    @param {Object} obj
    The object to modify.

    @param {String} keyName
    The property key to set

    @param {Object} value
    The value to set

    @returns {Object} the passed value.
    */
    Ember.set = set;

    // ..........................................................
    // PATHS
    //

    /** @private */
    function cleanupStars(path) {
        if (path.indexOf('*') === -1 || path === '*') return path;

        Ember.deprecate('Star paths are now treated the same as normal paths', !/(^|[^\.])\*/.test(path));

        return path.replace(/(^|.)\*/, function (match, char) {
            return (char === '.') ? match : (char + '.');
        });
    }

    /** @private */
    function normalizePath(path) {
        Ember.assert('must pass non-empty string to normalizePath()', path && path !== '');
        path = cleanupStars(path);

        if (path === '*') return path; //special case...
        var first = path.charAt(0);
        if (first === '.') return 'this' + path;
        return path;
    }

    // assumes normalized input; no *, normalized path, always a target...
    /** @private */
    function getPath(target, path) {
        var len = path.length, idx, next, key;

        path = cleanupStars(path);

        idx = 0;
        while (target && idx < len) {
            next = path.indexOf('.', idx);
            if (next < 0) next = len;
            key = path.slice(idx, next);
            target = key === '*' ? target : get(target, key);

            if (target && target.isDestroyed) { return undefined; }

            idx = next + 1;
        }
        return target;
    }

    var TUPLE_RET = [];
    var IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/;
    var IS_GLOBAL_PATH = /^([A-Z$]|([0-9][A-Z$])).*[\.\*]/;
    var HAS_THIS = /^this[\.\*]/;
    var FIRST_KEY = /^([^\.\*]+)/;

    /** @private */
    function firstKey(path) {
        return path.match(FIRST_KEY)[0];
    }

    // assumes path is already normalized
    /** @private */
    function normalizeTuple(target, path) {
        var hasThis = HAS_THIS.test(path),
      isGlobal = !hasThis && IS_GLOBAL_PATH.test(path),
      key;

        if (!target || isGlobal) target = window;
        if (hasThis) path = path.slice(5);

        path = cleanupStars(path);

        if (target === window) {
            key = firstKey(path);
            target = get(target, key);
            path = path.slice(key.length + 1);
        }

        // must return some kind of path to be valid else other things will break.
        if (!path || path.length === 0) throw new Error('Invalid Path');

        TUPLE_RET[0] = target;
        TUPLE_RET[1] = path;
        return TUPLE_RET;
    }

    /**
    @private

    Normalizes a path to support older-style property paths beginning with . or

    @function
    @param {String} path path to normalize
    @returns {String} normalized path
    */
    Ember.normalizePath = normalizePath;

    /**
    @private

    Normalizes a target/path pair to reflect that actual target/path that should
    be observed, etc.  This takes into account passing in global property
    paths (i.e. a path beginning with a captial letter not defined on the
    target) and * separators.

    @param {Object} target
    The current target.  May be null.

    @param {String} path
    A path on the target or a global property path.

    @returns {Array} a temporary array with the normalized target/path pair.
    */
    Ember.normalizeTuple = function (target, path) {
        return normalizeTuple(target, normalizePath(path));
    };

    Ember.normalizeTuple.primitive = normalizeTuple;

    Ember.getWithDefault = function (root, key, defaultValue) {
        var value = Ember.get(root, key);

        if (value === undefined) { return defaultValue; }
        return value;
    };

    Ember.getPath = function (root, path) {
        var hasThis, isGlobal, ret;

        // Helpers that operate with 'this' within an #each
        if (path === '') {
            return root;
        }

        if (!path && 'string' === typeof root) {
            path = root;
            root = null;
        }

        path = cleanupStars(path);

        // If there is no root and path is a key name, return that
        // property from the global object.
        // E.g. getPath('Ember') -> Ember
        if (root === null && path.indexOf('.') < 0) { return get(window, path); }

        // detect complicated paths and normalize them
        path = normalizePath(path);
        hasThis = HAS_THIS.test(path);

        if (!root || hasThis) {
            var tuple = normalizeTuple(root, path);
            root = tuple[0];
            path = tuple[1];
            tuple.length = 0;
        }

        return getPath(root, path);
    };

    Ember.setPath = function (root, path, value, tolerant) {
        var keyName;

        if (arguments.length === 2 && 'string' === typeof root) {
            value = path;
            path = root;
            root = null;
        }

        path = normalizePath(path);

        if (path.indexOf('.') > 0) {
            keyName = path.slice(path.lastIndexOf('.') + 1);
            path = path.slice(0, path.length - (keyName.length + 1));
            if (path !== 'this') {
                root = Ember.getPath(root, path);
            }

        } else {
            if (IS_GLOBAL.test(path)) throw new Error('Invalid Path');
            keyName = path;
        }

        if (!keyName || keyName.length === 0 || keyName === '*') {
            throw new Error('Invalid Path');
        }

        if (!root) {
            if (tolerant) { return; }
            else { throw new Error('Object in path ' + path + ' could not be found or was destroyed.'); }
        }

        return Ember.set(root, keyName, value);
    };

    /**
    Error-tolerant form of Ember.setPath. Will not blow up if any part of the
    chain is undefined, null, or destroyed.

    This is primarily used when syncing bindings, which may try to update after
    an object has been destroyed.
    */
    Ember.trySetPath = function (root, path, value) {
        if (arguments.length === 2 && 'string' === typeof root) {
            value = path;
            path = root;
            root = null;
        }

        return Ember.setPath(root, path, value, true);
    };

    /**
    Returns true if the provided path is global (e.g., "MyApp.fooController.bar")
    instead of local ("foo.bar.baz").

    @param {String} path
    @returns Boolean
    */
    Ember.isGlobalPath = function (path) {
        return !HAS_THIS.test(path) && IS_GLOBAL.test(path);
    };

})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var USE_ACCESSORS = Ember.USE_ACCESSORS;
    var GUID_KEY = Ember.GUID_KEY;
    var META_KEY = Ember.META_KEY;
    var meta = Ember.meta;
    var o_create = Ember.platform.create;
    var o_defineProperty = Ember.platform.defineProperty;
    var SIMPLE_PROPERTY, WATCHED_PROPERTY;

    // ..........................................................
    // DESCRIPTOR
    //

    var SIMPLE_DESC = {
        writable: true,
        configurable: true,
        enumerable: true,
        value: null
    };

    /**
    @private
    @constructor

    Objects of this type can implement an interface to responds requests to
    get and set.  The default implementation handles simple properties.

    You generally won't need to create or subclass this directly.
    */
    var Dc = Ember.Descriptor = function () { };

    var setup = Dc.setup = function (obj, keyName, value) {
        SIMPLE_DESC.value = value;
        o_defineProperty(obj, keyName, SIMPLE_DESC);
        SIMPLE_DESC.value = null;
    };

    var Dp = Ember.Descriptor.prototype;

    /**
    Called whenever we want to set the property value.  Should set the value
    and return the actual set value (which is usually the same but may be
    different in the case of computed properties.)

    @param {Object} obj
    The object to set the value on.

    @param {String} keyName
    The key to set.

    @param {Object} value
    The new value

    @returns {Object} value actual set value
    */
    Dp.set = function (obj, keyName, value) {
        obj[keyName] = value;
        return value;
    };

    /**
    Called whenever we want to get the property value.  Should retrieve the
    current value.

    @param {Object} obj
    The object to get the value on.

    @param {String} keyName
    The key to retrieve

    @returns {Object} the current value
    */
    Dp.get = function (obj, keyName) {
        return w_get(obj, keyName, obj);
    };

    /**
    This is called on the descriptor to set it up on the object.  The
    descriptor is responsible for actually defining the property on the object
    here.

    The passed `value` is the transferValue returned from any previous
    descriptor.

    @param {Object} obj
    The object to set the value on.

    @param {String} keyName
    The key to set.

    @param {Object} value
    The transfer value from any previous descriptor.

    @returns {void}
    */
    Dp.setup = setup;

    /**
    This is called on the descriptor just before another descriptor takes its
    place.  This method should at least return the 'transfer value' of the
    property - which is the value you want to passed as the input to the new
    descriptor's setup() method.

    It is not generally necessary to actually 'undefine' the property as a new
    property descriptor will redefine it immediately after this method returns.

    @param {Object} obj
    The object to set the value on.

    @param {String} keyName
    The key to set.

    @returns {Object} transfer value
    */
    Dp.teardown = function (obj, keyName) {
        return obj[keyName];
    };

    Dp.val = function (obj, keyName) {
        return obj[keyName];
    };

    // ..........................................................
    // SIMPLE AND WATCHED PROPERTIES
    //

    // if accessors are disabled for the app then this will act as a guard when
    // testing on browsers that do support accessors.  It will throw an exception
    // if you do foo.bar instead of Ember.get(foo, 'bar')

    // The exception to this is that any objects managed by Ember but not a descendant
    // of Ember.Object will not throw an exception, instead failing silently. This
    // prevent errors with other libraries that may attempt to access special
    // properties on standard objects like Array. Usually this happens when copying
    // an object by looping over all properties.

    if (!USE_ACCESSORS) {
        Ember.Descriptor.MUST_USE_GETTER = function () {
            if (this instanceof Ember.Object) {
                Ember.assert('Must use Ember.get() to access this property', false);
            }
        };

        Ember.Descriptor.MUST_USE_SETTER = function () {
            if (this instanceof Ember.Object) {
                if (this.isDestroyed) {
                    Ember.assert('You cannot set observed properties on destroyed objects', false);
                } else {
                    Ember.assert('Must use Ember.set() to access this property', false);
                }
            }
        };
    }

    var WATCHED_DESC = {
        configurable: true,
        enumerable: true,
        set: Ember.Descriptor.MUST_USE_SETTER
    };

    /** @private */
    function w_get(obj, keyName, values) {
        values = values || meta(obj, false).values;

        if (values) {
            var ret = values[keyName];
            if (ret !== undefined) { return ret; }
            if (obj.unknownProperty) { return obj.unknownProperty(keyName); }
        }

    }

    /** @private */
    function w_set(obj, keyName, value) {
        var m = meta(obj), watching;

        watching = m.watching[keyName] > 0 && value !== m.values[keyName];
        if (watching) Ember.propertyWillChange(obj, keyName);
        m.values[keyName] = value;
        if (watching) Ember.propertyDidChange(obj, keyName);
        return value;
    }

    var WATCHED_GETTERS = {};
    /** @private */
    function mkWatchedGetter(keyName) {
        var ret = WATCHED_GETTERS[keyName];
        if (!ret) {
            ret = WATCHED_GETTERS[keyName] = function () {
                return w_get(this, keyName);
            };
        }
        return ret;
    }

    var WATCHED_SETTERS = {};
    /** @private */
    function mkWatchedSetter(keyName) {
        var ret = WATCHED_SETTERS[keyName];
        if (!ret) {
            ret = WATCHED_SETTERS[keyName] = function (value) {
                return w_set(this, keyName, value);
            };
        }
        return ret;
    }

    /**
    @private

    Private version of simple property that invokes property change callbacks.
    */
    WATCHED_PROPERTY = new Ember.Descriptor();

    if (Ember.platform.hasPropertyAccessors) {
        WATCHED_PROPERTY.get = w_get;
        WATCHED_PROPERTY.set = w_set;

        if (USE_ACCESSORS) {
            WATCHED_PROPERTY.setup = function (obj, keyName, value) {
                WATCHED_DESC.get = mkWatchedGetter(keyName);
                WATCHED_DESC.set = mkWatchedSetter(keyName);
                o_defineProperty(obj, keyName, WATCHED_DESC);
                WATCHED_DESC.get = WATCHED_DESC.set = null;
                if (value !== undefined) meta(obj).values[keyName] = value;
            };

        } else {
            WATCHED_PROPERTY.setup = function (obj, keyName, value) {
                WATCHED_DESC.get = mkWatchedGetter(keyName);
                o_defineProperty(obj, keyName, WATCHED_DESC);
                WATCHED_DESC.get = null;
                if (value !== undefined) meta(obj).values[keyName] = value;
            };
        }

        WATCHED_PROPERTY.teardown = function (obj, keyName) {
            var ret = meta(obj).values[keyName];
            delete meta(obj).values[keyName];
            return ret;
        };

        // NOTE: if platform does not have property accessors then we just have to
        // set values and hope for the best.  You just won't get any warnings...
    } else {

        WATCHED_PROPERTY.set = function (obj, keyName, value) {
            var m = meta(obj), watching;

            watching = m.watching[keyName] > 0 && value !== obj[keyName];
            if (watching) Ember.propertyWillChange(obj, keyName);
            obj[keyName] = value;
            if (watching) Ember.propertyDidChange(obj, keyName);
            return value;
        };

    }

    /**
    The default descriptor for simple properties.  Pass as the third argument
    to Ember.defineProperty() along with a value to set a simple value.

    @static
    @default Ember.Descriptor
    */
    Ember.SIMPLE_PROPERTY = new Ember.Descriptor();
    SIMPLE_PROPERTY = Ember.SIMPLE_PROPERTY;

    SIMPLE_PROPERTY.unwatched = WATCHED_PROPERTY.unwatched = SIMPLE_PROPERTY;
    SIMPLE_PROPERTY.watched = WATCHED_PROPERTY.watched = WATCHED_PROPERTY;


    // ..........................................................
    // DEFINING PROPERTIES API
    //

    /** @private */
    function hasDesc(descs, keyName) {
        if (keyName === 'toString') return 'function' !== typeof descs.toString;
        else return !!descs[keyName];
    }

    /**
    @private

    NOTE: This is a low-level method used by other parts of the API.  You almost
    never want to call this method directly.  Instead you should use Ember.mixin()
    to define new properties.

    Defines a property on an object.  This method works much like the ES5
    Object.defineProperty() method except that it can also accept computed
    properties and other special descriptors.

    Normally this method takes only three parameters.  However if you pass an
    instance of Ember.Descriptor as the third param then you can pass an optional
    value as the fourth parameter.  This is often more efficient than creating
    new descriptor hashes for each property.

    ## Examples

    // ES5 compatible mode
    Ember.defineProperty(contact, 'firstName', {
    writable: true,
    configurable: false,
    enumerable: true,
    value: 'Charles'
    });

    // define a simple property
    Ember.defineProperty(contact, 'lastName', Ember.SIMPLE_PROPERTY, 'Jolley');

    // define a computed property
    Ember.defineProperty(contact, 'fullName', Ember.computed(function() {
    return this.firstName+' '+this.lastName;
    }).property('firstName', 'lastName').cacheable());
    */
    Ember.defineProperty = function (obj, keyName, desc, val) {
        var m = meta(obj, false), descs = m.descs, watching = m.watching[keyName] > 0, override = true;

        if (val === undefined) {
            override = false;
            val = hasDesc(descs, keyName) ? descs[keyName].teardown(obj, keyName) : obj[keyName];
        } else if (hasDesc(descs, keyName)) {
            descs[keyName].teardown(obj, keyName);
        }

        if (!desc) desc = SIMPLE_PROPERTY;

        if (desc instanceof Ember.Descriptor) {
            m = meta(obj, true);
            descs = m.descs;

            desc = (watching ? desc.watched : desc.unwatched) || desc;
            descs[keyName] = desc;
            desc.setup(obj, keyName, val, watching);

            // compatibility with ES5
        } else {
            if (descs[keyName]) meta(obj).descs[keyName] = null;
            o_defineProperty(obj, keyName, desc);
        }

        // if key is being watched, override chains that
        // were initialized with the prototype
        if (override && watching) Ember.overrideChains(obj, keyName, m);

        return this;
    };

    /**
    Creates a new object using the passed object as its prototype.  On browsers
    that support it, this uses the built in Object.create method.  Else one is
    simulated for you.

    This method is a better choice than Object.create() because it will make
    sure that any observers, event listeners, and computed properties are
    inherited from the parent as well.

    @param {Object} obj
    The object you want to have as the prototype.

    @returns {Object} the newly created object
    */
    Ember.create = function (obj, props) {
        var ret = o_create(obj, props);
        if (GUID_KEY in ret) Ember.generateGuid(ret, 'ember');
        if (META_KEY in ret) Ember.rewatch(ret); // setup watch chains if needed.
        return ret;
    };

    /**
    @private

    Creates a new object using the passed object as its prototype.  This method
    acts like `Ember.create()` in every way except that bindings, observers, and
    computed properties will be activated on the object.

    The purpose of this method is to build an object for use in a prototype
    chain. (i.e. to be set as the `prototype` property on a constructor
    function).  Prototype objects need to inherit bindings, observers and
    other configuration so they pass it on to their children.  However since
    they are never 'live' objects themselves, they should not fire or make
    other changes when various properties around them change.

    You should use this method anytime you want to create a new object for use
    in a prototype chain.

    @param {Object} obj
    The base object.

    @param {Object} hash
    Optional hash of properties to define on the object.

    @returns {Object} new object
    */
    Ember.createPrototype = function (obj, props) {
        var ret = o_create(obj, props);
        meta(ret, true).proto = ret;
        if (GUID_KEY in ret) Ember.generateGuid(ret, 'ember');
        if (META_KEY in ret) Ember.rewatch(ret); // setup watch chains if needed.
        return ret;
    };

})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    Ember.warn("Computed properties will soon be cacheable by default. To enable this in your app, set `ENV.CP_DEFAULT_CACHEABLE = true`.", Ember.CP_DEFAULT_CACHEABLE);


    var meta = Ember.meta;
    var guidFor = Ember.guidFor;
    var USE_ACCESSORS = Ember.USE_ACCESSORS;
    var a_slice = Array.prototype.slice;
    var o_create = Ember.platform.create;
    var o_defineProperty = Ember.platform.defineProperty;

    // ..........................................................
    // DEPENDENT KEYS
    //

    // data structure:
    //  meta.deps = {
    //   'depKey': {
    //     'keyName': count,
    //     __emberproto__: SRC_OBJ [to detect clones]
    //     },
    //   __emberproto__: SRC_OBJ
    //  }

    /** @private */
    function uniqDeps(obj, depKey) {
        var m = meta(obj), deps, ret;
        deps = m.deps;
        if (!deps) {
            deps = m.deps = { __emberproto__: obj };
        } else if (deps.__emberproto__ !== obj) {
            deps = m.deps = o_create(deps);
            deps.__emberproto__ = obj;
        }

        ret = deps[depKey];
        if (!ret) {
            ret = deps[depKey] = { __emberproto__: obj };
        } else if (ret.__emberproto__ !== obj) {
            ret = deps[depKey] = o_create(ret);
            ret.__emberproto__ = obj;
        }

        return ret;
    }

    /** @private */
    function addDependentKey(obj, keyName, depKey) {
        var deps = uniqDeps(obj, depKey);
        deps[keyName] = (deps[keyName] || 0) + 1;
        Ember.watch(obj, depKey);
    }

    /** @private */
    function removeDependentKey(obj, keyName, depKey) {
        var deps = uniqDeps(obj, depKey);
        deps[keyName] = (deps[keyName] || 0) - 1;
        Ember.unwatch(obj, depKey);
    }

    /** @private */
    function addDependentKeys(desc, obj, keyName) {
        var keys = desc._dependentKeys,
      len = keys ? keys.length : 0;
        for (var idx = 0; idx < len; idx++) addDependentKey(obj, keyName, keys[idx]);
    }

    // ..........................................................
    // COMPUTED PROPERTY
    //

    /** @private */
    function ComputedProperty(func, opts) {
        this.func = func;
        this._cacheable = (opts && opts.cacheable !== undefined) ? opts.cacheable : Ember.CP_DEFAULT_CACHEABLE;
        this._dependentKeys = opts && opts.dependentKeys;
    }

    /**
    @constructor
    */
    Ember.ComputedProperty = ComputedProperty;
    ComputedProperty.prototype = new Ember.Descriptor();

    var CP_DESC = {
        configurable: true,
        enumerable: true,
        get: function () { return undefined; }, // for when use_accessors is false.
        set: Ember.Descriptor.MUST_USE_SETTER  // for when use_accessors is false
    };

    /** @private */
    function mkCpGetter(keyName, desc) {
        var cacheable = desc._cacheable,
      func = desc.func;

        if (cacheable) {
            return function () {
                var ret, cache = meta(this).cache;
                if (keyName in cache) return cache[keyName];
                ret = cache[keyName] = func.call(this, keyName);
                return ret;
            };
        } else {
            return function () {
                return func.call(this, keyName);
            };
        }
    }

    /** @private */
    function mkCpSetter(keyName, desc) {
        var cacheable = desc._cacheable,
      func = desc.func;

        return function (value) {
            var m = meta(this, cacheable),
        watched = (m.source === this) && m.watching[keyName] > 0,
        ret, oldSuspended, lastSetValues;

            oldSuspended = desc._suspended;
            desc._suspended = this;

            watched = watched && m.lastSetValues[keyName] !== guidFor(value);
            if (watched) {
                m.lastSetValues[keyName] = guidFor(value);
                Ember.propertyWillChange(this, keyName);
            }

            if (cacheable) delete m.cache[keyName];
            ret = func.call(this, keyName, value);
            if (cacheable) m.cache[keyName] = ret;
            if (watched) Ember.propertyDidChange(this, keyName);
            desc._suspended = oldSuspended;
            return ret;
        };
    }

    /**
    @extends Ember.ComputedProperty
    @private
    */
    var Cp = ComputedProperty.prototype;

    /**
    Call on a computed property to set it into cacheable mode.  When in this
    mode the computed property will automatically cache the return value of
    your function until one of the dependent keys changes.

    MyApp.president = Ember.Object.create({
    fullName: function() {
    return this.get('firstName') + ' ' + this.get('lastName');

    // After calculating the value of this function, Ember.js will
    // return that value without re-executing this function until
    // one of the dependent properties change.
    }.property('firstName', 'lastName').cacheable()
    });

    Properties are cacheable by default.

    @name Ember.ComputedProperty.cacheable
    @param {Boolean} aFlag optional set to false to disable caching
    @returns {Ember.ComputedProperty} receiver
    */
    Cp.cacheable = function (aFlag) {
        this._cacheable = aFlag !== false;
        return this;
    };

    /**
    Call on a computed property to set it into non-cached mode.  When in this
    mode the computed property will not automatically cache the return value.

    MyApp.outsideService = Ember.Object.create({
    value: function() {
    return OutsideService.getValue();
    }.property().volatile()
    });

    @name Ember.ComputedProperty.volatile
    @returns {Ember.ComputedProperty} receiver
    */
    Cp.volatile = function () {
        return this.cacheable(false);
    };

    /**
    Sets the dependent keys on this computed property.  Pass any number of
    arguments containing key paths that this computed property depends on.

    MyApp.president = Ember.Object.create({
    fullName: Ember.computed(function() {
    return this.get('firstName') + ' ' + this.get('lastName');

    // Tell Ember.js that this computed property depends on firstName
    // and lastName
    }).property('firstName', 'lastName')
    });

    @name Ember.ComputedProperty.property
    @param {String} path... zero or more property paths
    @returns {Ember.ComputedProperty} receiver
    */
    Cp.property = function () {
        this._dependentKeys = a_slice.call(arguments);
        return this;
    };

    /**
    In some cases, you may want to annotate computed properties with additional
    metadata about how they function or what values they operate on. For example,
    computed property functions may close over variables that are then no longer
    available for introspection.

    You can pass a hash of these values to a computed property like this:

    person: function() {
    var personId = this.get('personId');
    return App.Person.create({ id: personId });
    }.property().meta({ type: App.Person })

    The hash that you pass to the `meta()` function will be saved on the
    computed property descriptor under the `_meta` key. Ember runtime
    exposes a public API for retrieving these values from classes,
    via the `metaForProperty()` function.

    @name Ember.ComputedProperty.meta
    @param {Hash} metadata
    @returns {Ember.ComputedProperty} property descriptor instance
    */

    Cp.meta = function (meta) {
        this._meta = meta;
        return this;
    };

    /** @private - impl descriptor API */
    Cp.setup = function (obj, keyName, value) {
        CP_DESC.get = mkCpGetter(keyName, this);
        CP_DESC.set = mkCpSetter(keyName, this);
        o_defineProperty(obj, keyName, CP_DESC);
        CP_DESC.get = CP_DESC.set = null;
        addDependentKeys(this, obj, keyName);
    };

    /** @private - impl descriptor API */
    Cp.teardown = function (obj, keyName) {
        var keys = this._dependentKeys,
      len = keys ? keys.length : 0;
        for (var idx = 0; idx < len; idx++) removeDependentKey(obj, keyName, keys[idx]);

        if (this._cacheable) delete meta(obj).cache[keyName];

        return null; // no value to restore
    };

    /** @private - impl descriptor API */
    Cp.didChange = function (obj, keyName) {
        if (this._cacheable && (this._suspended !== obj)) {
            delete meta(obj).cache[keyName];
        }
    };

    /** @private - impl descriptor API */
    Cp.get = function (obj, keyName) {
        var ret, cache;

        if (this._cacheable) {
            cache = meta(obj).cache;
            if (keyName in cache) return cache[keyName];
            ret = cache[keyName] = this.func.call(obj, keyName);
        } else {
            ret = this.func.call(obj, keyName);
        }
        return ret;
    };

    /** @private - impl descriptor API */
    Cp.set = function (obj, keyName, value) {
        var cacheable = this._cacheable;

        var m = meta(obj, cacheable),
      watched = (m.source === obj) && m.watching[keyName] > 0,
      ret, oldSuspended, lastSetValues;

        oldSuspended = this._suspended;
        this._suspended = obj;

        watched = watched && m.lastSetValues[keyName] !== guidFor(value);
        if (watched) {
            m.lastSetValues[keyName] = guidFor(value);
            Ember.propertyWillChange(obj, keyName);
        }

        if (cacheable) delete m.cache[keyName];
        ret = this.func.call(obj, keyName, value);
        if (cacheable) m.cache[keyName] = ret;
        if (watched) Ember.propertyDidChange(obj, keyName);
        this._suspended = oldSuspended;
        return ret;
    };

    Cp.val = function (obj, keyName) {
        return meta(obj, false).values[keyName];
    };

    if (!Ember.platform.hasPropertyAccessors) {
        Cp.setup = function (obj, keyName, value) {
            obj[keyName] = undefined; // so it shows up in key iteration
            addDependentKeys(this, obj, keyName);
        };

    } else if (!USE_ACCESSORS) {
        Cp.setup = function (obj, keyName) {
            // throw exception if not using Ember.get() and Ember.set() when supported
            o_defineProperty(obj, keyName, CP_DESC);
            addDependentKeys(this, obj, keyName);
        };
    }

    /**
    This helper returns a new property descriptor that wraps the passed
    computed property function.  You can use this helper to define properties
    with mixins or via Ember.defineProperty().

    The function you pass will be used to both get and set property values.
    The function should accept two parameters, key and value.  If value is not
    undefined you should set the value first.  In either case return the
    current value of the property.

    @param {Function} func
    The computed property function.

    @returns {Ember.ComputedProperty} property descriptor instance
    */
    Ember.computed = function (func) {
        var args;

        if (arguments.length > 1) {
            args = a_slice.call(arguments, 0, -1);
            func = a_slice.call(arguments, -1)[0];
        }

        var cp = new ComputedProperty(func);

        if (args) {
            cp.property.apply(cp, args);
        }

        return cp;
    };

    /**
    Returns the cached value for a property, if one exists.
    This can be useful for peeking at the value of a computed
    property that is generated lazily, without accidentally causing
    it to be created.

    @param {Object} obj the object whose property you want to check
    @param {String} key the name of the property whose cached value you want
    to return

    */
    Ember.cacheFor = function (obj, key) {
        var cache = meta(obj, false).cache;

        if (cache && key in cache) {
            return cache[key];
        }
    };

})();



(function () {
    /*jshint newcap:false*/

    // NOTE: There is a bug in jshint that doesn't recognize `Object()` without `new`
    // as being ok unless both `newcap:false` and not `use strict`.
    // https://github.com/jshint/jshint/issues/392

    // Testing this is not ideal, but we want ArrayUtils to use native functions
    // if available, but not to use versions created by libraries like Prototype
    /** @private */
    var isNativeFunc = function (func) {
        // This should probably work in all browsers likely to have ES5 array methods
        return func && Function.prototype.toString.call(func).indexOf('[native code]') > -1;
    };

    // From: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/map
    /** @private */
    var arrayMap = isNativeFunc(Array.prototype.map) ? Array.prototype.map : function (fun /*, thisp */) {
        //

        if (this === void 0 || this === null) {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== "function") {
            throw new TypeError();
        }

        var res = new Array(len);
        var thisp = arguments[1];
        for (var i = 0; i < len; i++) {
            if (i in t) {
                res[i] = fun.call(thisp, t[i], i, t);
            }
        }

        return res;
    };

    // From: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach
    /** @private */
    var arrayForEach = isNativeFunc(Array.prototype.forEach) ? Array.prototype.forEach : function (fun /*, thisp */) {
        //

        if (this === void 0 || this === null) {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== "function") {
            throw new TypeError();
        }

        var thisp = arguments[1];
        for (var i = 0; i < len; i++) {
            if (i in t) {
                fun.call(thisp, t[i], i, t);
            }
        }
    };

    /** @private */
    var arrayIndexOf = isNativeFunc(Array.prototype.indexOf) ? Array.prototype.indexOf : function (obj, fromIndex) {
        if (fromIndex === null || fromIndex === undefined) { fromIndex = 0; }
        else if (fromIndex < 0) { fromIndex = Math.max(0, this.length + fromIndex); }
        for (var i = fromIndex, j = this.length; i < j; i++) {
            if (this[i] === obj) { return i; }
        }
        return -1;
    };


    Ember.ArrayUtils = {
        map: function (obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            return obj.map ? obj.map.apply(obj, args) : arrayMap.apply(obj, args);
        },

        forEach: function (obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            return obj.forEach ? obj.forEach.apply(obj, args) : arrayForEach.apply(obj, args);
        },

        indexOf: function (obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            return obj.indexOf ? obj.indexOf.apply(obj, args) : arrayIndexOf.apply(obj, args);
        },

        indexesOf: function (obj) {
            var args = Array.prototype.slice.call(arguments, 1);
            return args[0] === undefined ? [] : Ember.ArrayUtils.map(args[0], function (item) {
                return Ember.ArrayUtils.indexOf(obj, item);
            });
        },

        removeObject: function (array, item) {
            var index = this.indexOf(array, item);
            if (index !== -1) { array.splice(index, 1); }
        }
    };


    if (Ember.SHIM_ES5) {
        if (!Array.prototype.map) {
            /** @private */
            Array.prototype.map = arrayMap;
        }

        if (!Array.prototype.forEach) {
            /** @private */
            Array.prototype.forEach = arrayForEach;
        }

        if (!Array.prototype.indexOf) {
            /** @private */
            Array.prototype.indexOf = arrayIndexOf;
        }
    }

})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var AFTER_OBSERVERS = ':change';
    var BEFORE_OBSERVERS = ':before';
    var guidFor = Ember.guidFor;
    var normalizePath = Ember.normalizePath;

    var deferred = 0;
    var array_Slice = Array.prototype.slice;
    var array_ForEach = Ember.ArrayUtils.forEach;

    /** @private */
    var ObserverSet = function () {
        this.targetSet = {};
    };
    ObserverSet.prototype.add = function (target, path) {
        var targetSet = this.targetSet,
    targetGuid = Ember.guidFor(target),
    pathSet = targetSet[targetGuid];
        if (!pathSet) {
            targetSet[targetGuid] = pathSet = {};
        }
        if (pathSet[path]) {
            return false;
        } else {
            return pathSet[path] = true;
        }
    };
    ObserverSet.prototype.clear = function () {
        this.targetSet = {};
    };

    /** @private */
    var DeferredEventQueue = function () {
        this.targetSet = {};
        this.queue = [];
    };

    DeferredEventQueue.prototype.push = function (target, eventName) {
        var targetSet = this.targetSet,
    queue = this.queue,
    targetGuid = Ember.guidFor(target),
    eventNameSet = targetSet[targetGuid],
    index;

        if (!eventNameSet) {
            targetSet[targetGuid] = eventNameSet = {};
        }
        index = eventNameSet[eventName];
        if (index === undefined) {
            eventNameSet[eventName] = queue.push(Ember.deferEvent(target, eventName)) - 1;
        } else {
            queue[index] = Ember.deferEvent(target, eventName);
        }
    };

    DeferredEventQueue.prototype.flush = function () {
        var queue = this.queue;
        this.queue = [];
        this.targetSet = {};
        for (var i = 0, len = queue.length; i < len; ++i) {
            queue[i]();
        }
    };

    var queue = new DeferredEventQueue(), beforeObserverSet = new ObserverSet();

    /** @private */
    function notifyObservers(obj, eventName, forceNotification) {
        if (deferred && !forceNotification) {
            queue.push(obj, eventName);
        } else {
            Ember.sendEvent(obj, eventName);
        }
    }

    /** @private */
    function flushObserverQueue() {
        beforeObserverSet.clear();

        queue.flush();
    }

    Ember.beginPropertyChanges = function () {
        deferred++;
        return this;
    };

    Ember.endPropertyChanges = function () {
        deferred--;
        if (deferred <= 0) flushObserverQueue();
    };

    /**
    Make a series of property changes together in an
    exception-safe way.

    Ember.changeProperties(function() {
    obj1.set('foo', mayBlowUpWhenSet);
    obj2.set('bar', baz);
    });
    */
    Ember.changeProperties = function (cb, binding) {
        Ember.beginPropertyChanges();
        try {
            cb.call(binding);
        } finally {
            Ember.endPropertyChanges();
        }
    };

    /**
    Set a list of properties on an object. These properties are set inside
    a single `beginPropertyChanges` and `endPropertyChanges` batch, so
    observers will be buffered.
    */
    Ember.setProperties = function (self, hash) {
        Ember.changeProperties(function () {
            for (var prop in hash) {
                if (hash.hasOwnProperty(prop)) Ember.set(self, prop, hash[prop]);
            }
        });
        return self;
    };


    /** @private */
    function changeEvent(keyName) {
        return keyName + AFTER_OBSERVERS;
    }

    /** @private */
    function beforeEvent(keyName) {
        return keyName + BEFORE_OBSERVERS;
    }

    /** @private */
    function changeKey(eventName) {
        return eventName.slice(0, -7);
    }

    /** @private */
    function beforeKey(eventName) {
        return eventName.slice(0, -7);
    }

    /** @private */
    function xformForArgs(args) {
        return function (target, method, params) {
            var obj = params[0], keyName = changeKey(params[1]), val;
            var copy_args = args.slice();
            if (method.length > 2) {
                val = Ember.getPath(Ember.isGlobalPath(keyName) ? window : obj, keyName);
            }
            copy_args.unshift(obj, keyName, val);
            method.apply(target, copy_args);
        };
    }

    var xformChange = xformForArgs([]);

    /** @private */
    function xformBefore(target, method, params) {
        var obj = params[0], keyName = beforeKey(params[1]), val;
        if (method.length > 2) val = Ember.getPath(obj, keyName);
        method.call(target, obj, keyName, val);
    }

    Ember.addObserver = function (obj, path, target, method) {
        path = normalizePath(path);

        var xform;
        if (arguments.length > 4) {
            var args = array_Slice.call(arguments, 4);
            xform = xformForArgs(args);
        } else {
            xform = xformChange;
        }
        Ember.addListener(obj, changeEvent(path), target, method, xform);
        Ember.watch(obj, path);
        return this;
    };

    /** @private */
    Ember.observersFor = function (obj, path) {
        return Ember.listenersFor(obj, changeEvent(path));
    };

    Ember.removeObserver = function (obj, path, target, method) {
        path = normalizePath(path);
        Ember.unwatch(obj, path);
        Ember.removeListener(obj, changeEvent(path), target, method);
        return this;
    };

    Ember.addBeforeObserver = function (obj, path, target, method) {
        path = normalizePath(path);
        Ember.addListener(obj, beforeEvent(path), target, method, xformBefore);
        Ember.watch(obj, path);
        return this;
    };

    // Suspend observer during callback.
    //
    // This should only be used by the target of the observer
    // while it is setting the observed path.
    /** @private */
    Ember._suspendObserver = function (obj, path, target, method, callback) {
        return Ember._suspendListener(obj, changeEvent(path), target, method, callback);
    };

    /** @private */
    Ember.beforeObserversFor = function (obj, path) {
        return Ember.listenersFor(obj, beforeEvent(path));
    };

    Ember.removeBeforeObserver = function (obj, path, target, method) {
        path = normalizePath(path);
        Ember.unwatch(obj, path);
        Ember.removeListener(obj, beforeEvent(path), target, method);
        return this;
    };

    /** @private */
    Ember.notifyObservers = function (obj, keyName) {
        if (obj.isDestroying) { return; }

        notifyObservers(obj, changeEvent(keyName));
    };

    /** @private */
    Ember.notifyBeforeObservers = function (obj, keyName) {
        if (obj.isDestroying) { return; }

        var guid, set, forceNotification = false;

        if (deferred) {
            if (beforeObserverSet.add(obj, keyName)) {
                forceNotification = true;
            } else {
                return;
            }
        }

        notifyObservers(obj, beforeEvent(keyName), forceNotification);
    };


})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var guidFor = Ember.guidFor;
    var meta = Ember.meta;
    var get = Ember.get, set = Ember.set;
    var normalizeTuple = Ember.normalizeTuple.primitive;
    var normalizePath = Ember.normalizePath;
    var SIMPLE_PROPERTY = Ember.SIMPLE_PROPERTY;
    var GUID_KEY = Ember.GUID_KEY;
    var META_KEY = Ember.META_KEY;
    var notifyObservers = Ember.notifyObservers;
    var forEach = Ember.ArrayUtils.forEach;

    var FIRST_KEY = /^([^\.\*]+)/;
    var IS_PATH = /[\.\*]/;

    /** @private */
    function firstKey(path) {
        return path.match(FIRST_KEY)[0];
    }

    // returns true if the passed path is just a keyName
    /** @private */
    function isKeyName(path) {
        return path === '*' || !IS_PATH.test(path);
    }

    // ..........................................................
    // DEPENDENT KEYS
    //

    var DEP_SKIP = { __emberproto__: true }; // skip some keys and toString

    /** @private */
    function iterDeps(method, obj, depKey, seen, meta) {

        var guid = guidFor(obj);
        if (!seen[guid]) seen[guid] = {};
        if (seen[guid][depKey]) return;
        seen[guid][depKey] = true;

        var deps = meta.deps;
        deps = deps && deps[depKey];
        if (deps) {
            for (var key in deps) {
                if (DEP_SKIP[key]) continue;
                method(obj, key);
            }
        }
    }


    var WILL_SEEN, DID_SEEN;

    // called whenever a property is about to change to clear the cache of any dependent keys (and notify those properties of changes, etc...)
    /** @private */
    function dependentKeysWillChange(obj, depKey, meta) {
        if (obj.isDestroying) { return; }

        var seen = WILL_SEEN, top = !seen;
        if (top) seen = WILL_SEEN = {};
        iterDeps(propertyWillChange, obj, depKey, seen, meta);
        if (top) WILL_SEEN = null;
    }

    // called whenever a property has just changed to update dependent keys
    /** @private */
    function dependentKeysDidChange(obj, depKey, meta) {
        if (obj.isDestroying) { return; }

        var seen = DID_SEEN, top = !seen;
        if (top) seen = DID_SEEN = {};
        iterDeps(propertyDidChange, obj, depKey, seen, meta);
        if (top) DID_SEEN = null;
    }

    // ..........................................................
    // CHAIN
    //

    /** @private */
    function addChainWatcher(obj, keyName, node) {
        if (!obj || ('object' !== typeof obj)) return; // nothing to do
        var m = meta(obj);
        var nodes = m.chainWatchers;
        if (!nodes || nodes.__emberproto__ !== obj) {
            nodes = m.chainWatchers = { __emberproto__: obj };
        }

        if (!nodes[keyName]) nodes[keyName] = {};
        nodes[keyName][guidFor(node)] = node;
        Ember.watch(obj, keyName);
    }

    /** @private */
    function removeChainWatcher(obj, keyName, node) {
        if (!obj || ('object' !== typeof obj)) return; // nothing to do
        var m = meta(obj, false);
        var nodes = m.chainWatchers;
        if (!nodes || nodes.__emberproto__ !== obj) return; //nothing to do
        if (nodes[keyName]) delete nodes[keyName][guidFor(node)];
        Ember.unwatch(obj, keyName);
    }

    var pendingQueue = [];

    // attempts to add the pendingQueue chains again.  If some of them end up
    // back in the queue and reschedule is true, schedules a timeout to try
    // again.
    /** @private */
    function flushPendingChains() {
        if (pendingQueue.length === 0) return; // nothing to do

        var queue = pendingQueue;
        pendingQueue = [];

        forEach(queue, function (q) { q[0].add(q[1]); });

        Ember.warn('Watching an undefined global, Ember expects watched globals to be setup by the time the run loop is flushed, check for typos', pendingQueue.length > 0);
    }

    /** @private */
    function isProto(pvalue) {
        return meta(pvalue, false).proto === pvalue;
    }

    // A ChainNode watches a single key on an object.  If you provide a starting
    // value for the key then the node won't actually watch it.  For a root node
    // pass null for parent and key and object for value.
    /** @private */
    var ChainNode = function (parent, key, value, separator) {
        var obj;
        this._parent = parent;
        this._key = key;

        // _watching is true when calling get(this._parent, this._key) will
        // return the value of this node.
        //
        // It is false for the root of a chain (because we have no parent)
        // and for global paths (because the parent node is the object with
        // the observer on it)
        this._watching = value === undefined;

        this._value = value;
        this._separator = separator || '.';
        this._paths = {};
        if (this._watching) {
            this._object = parent.value();
            if (this._object) addChainWatcher(this._object, this._key, this);
        }

        // Special-case: the EachProxy relies on immediate evaluation to
        // establish its observers.
        //
        // TODO: Replace this with an efficient callback that the EachProxy
        // can implement.
        if (this._parent && this._parent._key === '@each') {
            this.value();
        }
    };


    var Wp = ChainNode.prototype;

    Wp.value = function () {
        if (this._value === undefined && this._watching) {
            var obj = this._parent.value();
            this._value = (obj && !isProto(obj)) ? get(obj, this._key) : undefined;
        }
        return this._value;
    };

    Wp.destroy = function () {
        if (this._watching) {
            var obj = this._object;
            if (obj) removeChainWatcher(obj, this._key, this);
            this._watching = false; // so future calls do nothing
        }
    };

    // copies a top level object only
    Wp.copy = function (obj) {
        var ret = new ChainNode(null, null, obj, this._separator);
        var paths = this._paths, path;
        for (path in paths) {
            if (paths[path] <= 0) continue; // this check will also catch non-number vals.
            ret.add(path);
        }
        return ret;
    };

    // called on the root node of a chain to setup watchers on the specified
    // path.
    Wp.add = function (path) {
        var obj, tuple, key, src, separator, paths;

        paths = this._paths;
        paths[path] = (paths[path] || 0) + 1;

        obj = this.value();
        tuple = normalizeTuple(obj, path);

        // the path was a local path
        if (tuple[0] && (tuple[0] === obj)) {
            path = tuple[1];
            key = firstKey(path);
            path = path.slice(key.length + 1);

            // global path, but object does not exist yet.
            // put into a queue and try to connect later.
        } else if (!tuple[0]) {
            pendingQueue.push([this, path]);
            tuple.length = 0;
            return;

            // global path, and object already exists
        } else {
            src = tuple[0];
            key = path.slice(0, 0 - (tuple[1].length + 1));
            separator = path.slice(key.length, key.length + 1);
            path = tuple[1];
        }

        tuple.length = 0;
        this.chain(key, path, src, separator);
    };

    // called on the root node of a chain to teardown watcher on the specified
    // path
    Wp.remove = function (path) {
        var obj, tuple, key, src, paths;

        paths = this._paths;
        if (paths[path] > 0) paths[path]--;

        obj = this.value();
        tuple = normalizeTuple(obj, path);
        if (tuple[0] === obj) {
            path = tuple[1];
            key = firstKey(path);
            path = path.slice(key.length + 1);

        } else {
            src = tuple[0];
            key = path.slice(0, 0 - (tuple[1].length + 1));
            path = tuple[1];
        }

        tuple.length = 0;
        this.unchain(key, path);
    };

    Wp.count = 0;

    Wp.chain = function (key, path, src, separator) {
        var chains = this._chains, node;
        if (!chains) chains = this._chains = {};

        node = chains[key];
        if (!node) node = chains[key] = new ChainNode(this, key, src, separator);
        node.count++; // count chains...

        // chain rest of path if there is one
        if (path && path.length > 0) {
            key = firstKey(path);
            path = path.slice(key.length + 1);
            node.chain(key, path); // NOTE: no src means it will observe changes...
        }
    };

    Wp.unchain = function (key, path) {
        var chains = this._chains, node = chains[key];

        // unchain rest of path first...
        if (path && path.length > 1) {
            key = firstKey(path);
            path = path.slice(key.length + 1);
            node.unchain(key, path);
        }

        // delete node if needed.
        node.count--;
        if (node.count <= 0) {
            delete chains[node._key];
            node.destroy();
        }

    };

    Wp.willChange = function () {
        var chains = this._chains;
        if (chains) {
            for (var key in chains) {
                if (!chains.hasOwnProperty(key)) continue;
                chains[key].willChange();
            }
        }

        if (this._parent) this._parent.chainWillChange(this, this._key, 1);
    };

    Wp.chainWillChange = function (chain, path, depth) {
        if (this._key) path = this._key + this._separator + path;

        if (this._parent) {
            this._parent.chainWillChange(this, path, depth + 1);
        } else {
            if (depth > 1) Ember.propertyWillChange(this.value(), path);
            path = 'this.' + path;
            if (this._paths[path] > 0) Ember.propertyWillChange(this.value(), path);
        }
    };

    Wp.chainDidChange = function (chain, path, depth) {
        if (this._key) path = this._key + this._separator + path;
        if (this._parent) {
            this._parent.chainDidChange(this, path, depth + 1);
        } else {
            if (depth > 1) Ember.propertyDidChange(this.value(), path);
            path = 'this.' + path;
            if (this._paths[path] > 0) Ember.propertyDidChange(this.value(), path);
        }
    };

    Wp.didChange = function (suppressEvent) {
        // invalidate my own value first.
        if (this._watching) {
            var obj = this._parent.value();
            if (obj !== this._object) {
                removeChainWatcher(this._object, this._key, this);
                this._object = obj;
                addChainWatcher(obj, this._key, this);
            }
            this._value = undefined;

            // Special-case: the EachProxy relies on immediate evaluation to
            // establish its observers.
            if (this._parent && this._parent._key === '@each')
                this.value();
        }

        // then notify chains...
        var chains = this._chains;
        if (chains) {
            for (var key in chains) {
                if (!chains.hasOwnProperty(key)) continue;
                chains[key].didChange(suppressEvent);
            }
        }

        if (suppressEvent) return;

        // and finally tell parent about my path changing...
        if (this._parent) this._parent.chainDidChange(this, this._key, 1);
    };

    // get the chains for the current object.  If the current object has
    // chains inherited from the proto they will be cloned and reconfigured for
    // the current object.
    /** @private */
    function chainsFor(obj) {
        var m = meta(obj), ret = m.chains;
        if (!ret) {
            ret = m.chains = new ChainNode(null, null, obj);
        } else if (ret.value() !== obj) {
            ret = m.chains = ret.copy(obj);
        }
        return ret;
    }


    /** @private */
    function notifyChains(obj, m, keyName, methodName, arg) {
        var nodes = m.chainWatchers;

        if (!nodes || nodes.__emberproto__ !== obj) return; // nothing to do

        nodes = nodes[keyName];
        if (!nodes) return;

        for (var key in nodes) {
            if (!nodes.hasOwnProperty(key)) continue;
            nodes[key][methodName](arg);
        }
    }

    Ember.overrideChains = function (obj, keyName, m) {
        notifyChains(obj, m, keyName, 'didChange', true);
    };

    /** @private */
    function chainsWillChange(obj, keyName, m) {
        notifyChains(obj, m, keyName, 'willChange');
    }

    /** @private */
    function chainsDidChange(obj, keyName, m) {
        notifyChains(obj, m, keyName, 'didChange');
    }

    // ..........................................................
    // WATCH
    //

    var WATCHED_PROPERTY = Ember.SIMPLE_PROPERTY.watched;

    /**
    @private

    Starts watching a property on an object.  Whenever the property changes,
    invokes Ember.propertyWillChange and Ember.propertyDidChange.  This is the
    primitive used by observers and dependent keys; usually you will never call
    this method directly but instead use higher level methods like
    Ember.addObserver().
    */
    Ember.watch = function (obj, keyName) {

        // can't watch length on Array - it is special...
        if (keyName === 'length' && Ember.typeOf(obj) === 'array') return this;

        var m = meta(obj), watching = m.watching, desc;
        keyName = normalizePath(keyName);

        // activate watching first time
        if (!watching[keyName]) {
            watching[keyName] = 1;
            if (isKeyName(keyName)) {
                desc = m.descs[keyName];
                desc = desc ? desc.watched : WATCHED_PROPERTY;
                if (desc) Ember.defineProperty(obj, keyName, desc);
            } else {
                chainsFor(obj).add(keyName);
            }

        } else {
            watching[keyName] = (watching[keyName] || 0) + 1;
        }
        return this;
    };

    Ember.isWatching = function (obj, keyName) {
        return !!meta(obj).watching[keyName];
    };

    Ember.watch.flushPending = flushPendingChains;

    /** @private */
    Ember.unwatch = function (obj, keyName) {
        // can't watch length on Array - it is special...
        if (keyName === 'length' && Ember.typeOf(obj) === 'array') return this;

        var watching = meta(obj).watching, desc, descs;
        keyName = normalizePath(keyName);
        if (watching[keyName] === 1) {
            watching[keyName] = 0;
            if (isKeyName(keyName)) {
                desc = meta(obj).descs[keyName];
                desc = desc ? desc.unwatched : SIMPLE_PROPERTY;
                if (desc) Ember.defineProperty(obj, keyName, desc);
            } else {
                chainsFor(obj).remove(keyName);
            }

        } else if (watching[keyName] > 1) {
            watching[keyName]--;
        }

        return this;
    };

    /**
    @private

    Call on an object when you first beget it from another object.  This will
    setup any chained watchers on the object instance as needed.  This method is
    safe to call multiple times.
    */
    Ember.rewatch = function (obj) {
        var m = meta(obj, false), chains = m.chains, bindings = m.bindings, key, b;

        // make sure the object has its own guid.
        if (GUID_KEY in obj && !obj.hasOwnProperty(GUID_KEY)) {
            Ember.generateGuid(obj, 'ember');
        }

        // make sure any chained watchers update.
        if (chains && chains.value() !== obj) chainsFor(obj);

        return this;
    };

    // ..........................................................
    // PROPERTY CHANGES
    //

    /**
    This function is called just before an object property is about to change.
    It will notify any before observers and prepare caches among other things.

    Normally you will not need to call this method directly but if for some
    reason you can't directly watch a property you can invoke this method
    manually along with `Ember.propertyDidChange()` which you should call just
    after the property value changes.

    @memberOf Ember

    @param {Object} obj
    The object with the property that will change

    @param {String} keyName
    The property key (or path) that will change.

    @returns {void}
    */
    function propertyWillChange(obj, keyName) {
        var m = meta(obj, false), proto = m.proto, desc = m.descs[keyName];
        if (proto === obj) return;
        if (desc && desc.willChange) desc.willChange(obj, keyName);
        dependentKeysWillChange(obj, keyName, m);
        chainsWillChange(obj, keyName, m);
        Ember.notifyBeforeObservers(obj, keyName);
    }

    Ember.propertyWillChange = propertyWillChange;

    /**
    This function is called just after an object property has changed.
    It will notify any observers and clear caches among other things.

    Normally you will not need to call this method directly but if for some
    reason you can't directly watch a property you can invoke this method
    manually along with `Ember.propertyWilLChange()` which you should call just
    before the property value changes.

    @memberOf Ember

    @param {Object} obj
    The object with the property that will change

    @param {String} keyName
    The property key (or path) that will change.

    @returns {void}
    */
    function propertyDidChange(obj, keyName) {
        var m = meta(obj, false), proto = m.proto, desc = m.descs[keyName];
        if (proto === obj) return;
        if (desc && desc.didChange) desc.didChange(obj, keyName);
        dependentKeysDidChange(obj, keyName, m);
        chainsDidChange(obj, keyName, m);
        Ember.notifyObservers(obj, keyName);
    }

    Ember.propertyDidChange = propertyDidChange;

    var NODE_STACK = [];

    /**
    Tears down the meta on an object so that it can be garbage collected.
    Multiple calls will have no effect.

    @param {Object} obj  the object to destroy
    @returns {void}
    */
    Ember.destroy = function (obj) {
        var meta = obj[META_KEY], node, nodes, key, nodeObject;
        if (meta) {
            obj[META_KEY] = null;
            // remove chainWatchers to remove circular references that would prevent GC
            node = meta.chains;
            if (node) {
                NODE_STACK.push(node);
                // process tree
                while (NODE_STACK.length > 0) {
                    node = NODE_STACK.pop();
                    // push children
                    nodes = node._chains;
                    if (nodes) {
                        for (key in nodes) {
                            if (nodes.hasOwnProperty(key)) {
                                NODE_STACK.push(nodes[key]);
                            }
                        }
                    }
                    // remove chainWatcher in node object
                    if (node._watching) {
                        nodeObject = node._object;
                        if (nodeObject) {
                            removeChainWatcher(nodeObject, node._key, node);
                        }
                    }
                }
            }
        }
    };

})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var o_create = Ember.platform.create;
    var meta = Ember.meta;
    var guidFor = Ember.guidFor;
    var a_slice = Array.prototype.slice;

    /**
    The event system uses a series of nested hashes to store listeners on an
    object. When a listener is registered, or when an event arrives, these
    hashes are consulted to determine which target and action pair to invoke.

    The hashes are stored in the object's meta hash, and look like this:

    // Object's meta hash
    {
    listeners: {               // variable name: `listenerSet`
    "foo:changed": {         // variable name: `targetSet`
    [targetGuid]: {        // variable name: `actionSet`
    [methodGuid]: {      // variable name: `action`
    target: [Object object],
    method: [Function function],
    xform: [Function function]
    }
    }
    }
    }
    }

    */

    /** @private */
    var metaPath = Ember.metaPath;

    // Gets the set of all actions, keyed on the guid of each action's
    // method property.
    /** @private */
    function actionSetFor(obj, eventName, target, writable) {
        var targetGuid = guidFor(target);
        return metaPath(obj, ['listeners', eventName, targetGuid], writable);
    }

    // Gets the set of all targets, keyed on the guid of each action's
    // target property.
    /** @private */
    function targetSetFor(obj, eventName) {
        var listenerSet = meta(obj, false).listeners;
        if (!listenerSet) { return false; }

        return listenerSet[eventName] || false;
    }

    // TODO: This knowledge should really be a part of the
    // meta system.
    var SKIP_PROPERTIES = { __ember_source__: true };

    /** @private */
    function iterateSet(targetSet, callback, params) {
        if (!targetSet) { return false; }
        // Iterate through all elements of the target set
        for (var targetGuid in targetSet) {
            if (SKIP_PROPERTIES[targetGuid]) { continue; }

            var actionSet = targetSet[targetGuid];
            if (actionSet) {
                // Iterate through the elements of the action set
                for (var methodGuid in actionSet) {
                    if (SKIP_PROPERTIES[methodGuid]) { continue; }

                    var action = actionSet[methodGuid];
                    if (action) {
                        if (callback(action, params) === true) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    /** @private */
    function invokeAction(action, params) {
        var method = action.method, target = action.target, xform = action.xform;
        // If there is no target, the target is the object
        // on which the event was fired.
        if (!target) { target = params[0]; }
        if ('string' === typeof method) { method = target[method]; }

        // Listeners can provide an `xform` function, which can perform
        // arbitrary transformations, such as changing the order of
        // parameters.
        //
        // This is primarily used by ember-runtime's observer system, which
        // provides a higher level abstraction on top of events, including
        // dynamically looking up current values and passing them into the
        // registered listener.
        if (xform) {
            xform(target, method, params);
        } else {
            method.apply(target, params);
        }
    }

    /**
    The parameters passed to an event listener are not exactly the
    parameters passed to an observer. if you pass an xform function, it will
    be invoked and is able to translate event listener parameters into the form
    that observers are expecting.

    @memberOf Ember
    */
    function addListener(obj, eventName, target, method, xform) {
        Ember.assert("You must pass at least an object and event name to Ember.addListener", !!obj && !!eventName);

        if (!method && 'function' === typeof target) {
            method = target;
            target = null;
        }

        var actionSet = actionSetFor(obj, eventName, target, true),
      methodGuid = guidFor(method);

        if (!actionSet[methodGuid]) {
            actionSet[methodGuid] = { target: target, method: method, xform: xform };
        } else {
            actionSet[methodGuid].xform = xform; // used by observers etc to map params
        }

        if ('function' === typeof obj.didAddListener) {
            obj.didAddListener(eventName, target, method);
        }
    }

    /** @memberOf Ember */
    function removeListener(obj, eventName, target, method) {
        if (!method && 'function' === typeof target) {
            method = target;
            target = null;
        }

        var actionSet = actionSetFor(obj, eventName, target, true),
      methodGuid = guidFor(method);

        // we can't simply delete this parameter, because if we do, we might
        // re-expose the property from the prototype chain.
        if (actionSet && actionSet[methodGuid]) { actionSet[methodGuid] = null; }

        if (obj && 'function' === typeof obj.didRemoveListener) {
            obj.didRemoveListener(eventName, target, method);
        }
    }

    // Suspend listener during callback.
    //
    // This should only be used by the target of the event listener
    // when it is taking an action that would cause the event, e.g.
    // an object might suspend its property change listener while it is
    // setting that property.
    /** @private */
    function suspendListener(obj, eventName, target, method, callback) {
        if (!method && 'function' === typeof target) {
            method = target;
            target = null;
        }

        var actionSet = actionSetFor(obj, eventName, target, true),
      methodGuid = guidFor(method),
      action = actionSet && actionSet[methodGuid];

        actionSet[methodGuid] = null;
        try {
            return callback.call(target);
        } finally {
            actionSet[methodGuid] = action;
        }
    }

    // returns a list of currently watched events
    /** @memberOf Ember */
    function watchedEvents(obj) {
        var listeners = meta(obj, false).listeners, ret = [];

        if (listeners) {
            for (var eventName in listeners) {
                if (!SKIP_PROPERTIES[eventName] && listeners[eventName]) {
                    ret.push(eventName);
                }
            }
        }
        return ret;
    }

    /** @memberOf Ember */
    function sendEvent(obj, eventName) {

        // first give object a chance to handle it
        if (obj !== Ember && 'function' === typeof obj.sendEvent) {
            obj.sendEvent.apply(obj, a_slice.call(arguments, 1));
        }

        var targetSet = targetSetFor(obj, eventName);
        iterateSet(targetSet, invokeAction, arguments);

        return true;
    }

    /** @memberOf Ember */
    function deferEvent(obj, eventName) {
        var targetSet = targetSetFor(obj, eventName), actions = [], params = arguments;
        iterateSet(targetSet, function (action) {
            actions.push(action);
        });

        return function () {
            if (obj !== Ember && 'function' === typeof obj.sendEvent) {
                obj.sendEvent.apply(obj, a_slice.call(params, 1));
            }

            for (var i = 0, len = actions.length; i < len; ++i) {
                invokeAction(actions[i], params);
            }
        };
    }

    /** @memberOf Ember */
    function hasListeners(obj, eventName) {
        var targetSet = targetSetFor(obj, eventName);
        if (iterateSet(targetSet, function () { return true; })) {
            return true;
        }

        // no listeners!  might as well clean this up so it is faster later.
        var set = metaPath(obj, ['listeners'], true);
        set[eventName] = null;

        return false;
    }

    /** @memberOf Ember */
    function listenersFor(obj, eventName) {
        var targetSet = targetSetFor(obj, eventName), ret = [];
        iterateSet(targetSet, function (action) {
            ret.push([action.target, action.method]);
        });
        return ret;
    }

    Ember.addListener = addListener;
    Ember.removeListener = removeListener;
    Ember._suspendListener = suspendListener;
    Ember.sendEvent = sendEvent;
    Ember.hasListeners = hasListeners;
    Ember.watchedEvents = watchedEvents;
    Ember.listenersFor = listenersFor;
    Ember.deferEvent = deferEvent;
})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2010 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    // Ember.Logger
    // Ember.watch.flushPending
    // Ember.beginPropertyChanges, Ember.endPropertyChanges
    // Ember.guidFor
    // Ember.ArrayUtils

    // ..........................................................
    // HELPERS
    //

    var slice = Array.prototype.slice;
    var forEach = Ember.ArrayUtils.forEach;

    // invokes passed params - normalizing so you can pass target/func,
    // target/string or just func
    /** @private */
    function invoke(target, method, args, ignore) {

        if (method === undefined) {
            method = target;
            target = undefined;
        }

        if ('string' === typeof method) method = target[method];
        if (args && ignore > 0) {
            args = args.length > ignore ? slice.call(args, ignore) : null;
        }

        // Unfortunately in some browsers we lose the backtrace if we rethrow the existing error,
        // so in the event that we don't have an `onerror` handler we don't wrap in a try/catch
        if ('function' === typeof Ember.onerror) {
            try {
                // IE8's Function.prototype.apply doesn't accept undefined/null arguments.
                return method.apply(target || this, args || []);
            } catch (error) {
                Ember.onerror(error);
            }
        } else {
            // IE8's Function.prototype.apply doesn't accept undefined/null arguments.
            return method.apply(target || this, args || []);
        }
    }


    // ..........................................................
    // RUNLOOP
    //

    var timerMark; // used by timers...

    /** @private */
    var K = function () { };

    /** @private */
    var RunLoop = function (prev) {
        var self;

        if (this instanceof RunLoop) {
            self = this;
        } else {
            self = new K();
        }

        self._prev = prev || null;
        self.onceTimers = {};

        return self;
    };

    K.prototype = RunLoop.prototype;

    RunLoop.prototype = {
        end: function () {
            this.flush();
        },

        prev: function () {
            return this._prev;
        },

        // ..........................................................
        // Delayed Actions
        //

        schedule: function (queueName, target, method) {
            var queues = this._queues, queue;
            if (!queues) queues = this._queues = {};
            queue = queues[queueName];
            if (!queue) queue = queues[queueName] = [];

            var args = arguments.length > 3 ? slice.call(arguments, 3) : null;
            queue.push({ target: target, method: method, args: args });
            return this;
        },

        flush: function (queueName) {
            var queues = this._queues, queueNames, idx, len, queue, log;

            if (!queues) return this; // nothing to do

            function iter(item) {
                invoke(item.target, item.method, item.args);
            }

            Ember.watch.flushPending(); // make sure all chained watchers are setup

            if (queueName) {
                while (this._queues && (queue = this._queues[queueName])) {
                    this._queues[queueName] = null;

                    // the sync phase is to allow property changes to propagate.  don't
                    // invoke observers until that is finished.
                    if (queueName === 'sync') {
                        log = Ember.LOG_BINDINGS;
                        if (log) Ember.Logger.log('Begin: Flush Sync Queue');

                        Ember.beginPropertyChanges();
                        try {
                            forEach(queue, iter);
                        } finally {
                            Ember.endPropertyChanges();
                        }

                        if (log) Ember.Logger.log('End: Flush Sync Queue');

                    } else {
                        forEach(queue, iter);
                    }
                }

            } else {
                queueNames = Ember.run.queues;
                len = queueNames.length;
                do {
                    this._queues = null;
                    for (idx = 0; idx < len; idx++) {
                        queueName = queueNames[idx];
                        queue = queues[queueName];

                        if (queue) {
                            // the sync phase is to allow property changes to propagate.  don't
                            // invoke observers until that is finished.
                            if (queueName === 'sync') {
                                log = Ember.LOG_BINDINGS;
                                if (log) Ember.Logger.log('Begin: Flush Sync Queue');

                                Ember.beginPropertyChanges();
                                try {
                                    forEach(queue, iter);
                                } finally {
                                    Ember.endPropertyChanges();
                                }

                                if (log) Ember.Logger.log('End: Flush Sync Queue');
                            } else {
                                forEach(queue, iter);
                            }
                        }
                    }
                } while (queues = this._queues); // go until queues stay clean
            }

            timerMark = null;

            return this;
        }

    };

    Ember.RunLoop = RunLoop;

    // ..........................................................
    // Ember.run - this is ideally the only public API the dev sees
    //
    /** 
    * @namespace Ember.run is both a function and a namespace for
    * RunLoop-related functions.
    * @name Ember.run
    */

    /**
    Runs the passed target and method inside of a RunLoop, ensuring any
    deferred actions including bindings and views updates are flushed at the
    end.

    Normally you should not need to invoke this method yourself.  However if
    you are implementing raw event handlers when interfacing with other
    libraries or plugins, you should probably wrap all of your code inside this
    call.

    Ember.run(function(){
    // code to be execute within a RunLoop 
    });

    @name run^2
    @methodOf Ember.run
    @param {Object} target
    (Optional) target of method to call

    @param {Function|String} method
    Method to invoke.  May be a function or a string.  If you pass a string
    then it will be looked up on the passed target.

    @param {Object...} args
    Any additional arguments you wish to pass to the method.

    @returns {Object} return value from invoking the passed function.
    */
    Ember.run = function (target, method) {

        var ret, loop;
        run.begin();
        try {
            if (target || method) ret = invoke(target, method, arguments, 2);
        } finally {
            run.end();
        }
        return ret;
    };

    /** @private */
    var run = Ember.run;


    /**
    Begins a new RunLoop.  Any deferred actions invoked after the begin will
    be buffered until you invoke a matching call to Ember.run.end().  This is
    an lower-level way to use a RunLoop instead of using Ember.run().

    Ember.run.begin();
    // code to be execute within a RunLoop 
    Ember.run.end();


    @returns {void}
    */
    Ember.run.begin = function () {
        run.currentRunLoop = new RunLoop(run.currentRunLoop);
    };

    /**
    Ends a RunLoop.  This must be called sometime after you call Ember.run.begin()
    to flush any deferred actions.  This is a lower-level way to use a RunLoop
    instead of using Ember.run().

    Ember.run.begin();
    // code to be execute within a RunLoop 
    Ember.run.end();

    @returns {void}
    */
    Ember.run.end = function () {
        Ember.assert('must have a current run loop', run.currentRunLoop);
        try {
            run.currentRunLoop.end();
        }
        finally {
            run.currentRunLoop = run.currentRunLoop.prev();
        }
    };

    /**
    Array of named queues.  This array determines the order in which queues
    are flushed at the end of the RunLoop.  You can define your own queues by
    simply adding the queue name to this array.  Normally you should not need
    to inspect or modify this property.

    @property {String}
    @default ['sync', 'actions', 'destroy', 'timers']
    */
    Ember.run.queues = ['sync', 'actions', 'destroy', 'timers'];

    /**
    Adds the passed target/method and any optional arguments to the named
    queue to be executed at the end of the RunLoop.  If you have not already
    started a RunLoop when calling this method one will be started for you
    automatically.

    At the end of a RunLoop, any methods scheduled in this way will be invoked.
    Methods will be invoked in an order matching the named queues defined in
    the run.queues property.

    Ember.run.schedule('timers', this, function(){
    // this will be executed at the end of the RunLoop, when timers are run
    console.log("scheduled on timers queue");
    });
    Ember.run.schedule('sync', this, function(){
    // this will be executed at the end of the RunLoop, when bindings are synced
    console.log("scheduled on sync queue");
    });
    // Note the functions will be run in order based on the run queues order. Output would be:
    //   scheduled on sync queue
    //   scheduled on timers queue

    @param {String} queue
    The name of the queue to schedule against.  Default queues are 'sync' and
    'actions'

    @param {Object} target
    (Optional) target object to use as the context when invoking a method.

    @param {String|Function} method
    The method to invoke.  If you pass a string it will be resolved on the
    target object at the time the scheduled item is invoked allowing you to
    change the target function.

    @param {Object} arguments...
    Optional arguments to be passed to the queued method.

    @returns {void}
    */
    Ember.run.schedule = function (queue, target, method) {
        var loop = run.autorun();
        loop.schedule.apply(loop, arguments);
    };

    var autorunTimer;

    /** @private */
    function autorun() {
        autorunTimer = null;
        if (run.currentRunLoop) run.end();
    }

    /**
    Begins a new RunLoop if necessary and schedules a timer to flush the
    RunLoop at a later time.  This method is used by parts of Ember to
    ensure the RunLoop always finishes.  You normally do not need to call this
    method directly.  Instead use Ember.run().

    Ember.run.autorun();

    @returns {Ember.RunLoop} the new current RunLoop
    */
    Ember.run.autorun = function () {

        if (!run.currentRunLoop) {
            run.begin();

            // TODO: throw during tests
            if (Ember.testing) {
                run.end();
            } else if (!autorunTimer) {
                autorunTimer = setTimeout(autorun, 1);
            }
        }

        return run.currentRunLoop;
    };

    /**
    Immediately flushes any events scheduled in the 'sync' queue.  Bindings
    use this queue so this method is a useful way to immediately force all
    bindings in the application to sync.

    You should call this method anytime you need any changed state to propagate
    throughout the app immediately without repainting the UI.

    Ember.run.sync();

    @returns {void}
    */
    Ember.run.sync = function () {
        run.autorun();
        run.currentRunLoop.flush('sync');
    };

    // ..........................................................
    // TIMERS
    //

    var timers = {}; // active timers...

    var laterScheduled = false;
    /** @private */
    function invokeLaterTimers() {
        var now = (+new Date()), earliest = -1;
        for (var key in timers) {
            if (!timers.hasOwnProperty(key)) continue;
            var timer = timers[key];
            if (timer && timer.expires) {
                if (now >= timer.expires) {
                    delete timers[key];
                    invoke(timer.target, timer.method, timer.args, 2);
                } else {
                    if (earliest < 0 || (timer.expires < earliest)) earliest = timer.expires;
                }
            }
        }

        // schedule next timeout to fire...
        if (earliest > 0) setTimeout(invokeLaterTimers, earliest - (+new Date()));
    }

    /**
    Invokes the passed target/method and optional arguments after a specified
    period if time.  The last parameter of this method must always be a number
    of milliseconds.

    You should use this method whenever you need to run some action after a
    period of time instead of using setTimeout().  This method will ensure that
    items that expire during the same script execution cycle all execute
    together, which is often more efficient than using a real setTimeout.

    Ember.run.later(myContext, function(){
    // code here will execute within a RunLoop in about 500ms with this == myContext
    }, 500);

    @param {Object} target
    (optional) target of method to invoke

    @param {Function|String} method
    The method to invoke.  If you pass a string it will be resolved on the
    target at the time the method is invoked.

    @param {Object...} args
    Optional arguments to pass to the timeout.

    @param {Number} wait
    Number of milliseconds to wait.

    @returns {Timer} an object you can use to cancel a timer at a later time.
    */
    Ember.run.later = function (target, method) {
        var args, expires, timer, guid, wait;

        // setTimeout compatibility...
        if (arguments.length === 2 && 'function' === typeof target) {
            wait = method;
            method = target;
            target = undefined;
            args = [target, method];

        } else {
            args = slice.call(arguments);
            wait = args.pop();
        }

        expires = (+new Date()) + wait;
        timer = { target: target, method: method, expires: expires, args: args };
        guid = Ember.guidFor(timer);
        timers[guid] = timer;
        run.once(timers, invokeLaterTimers);
        return guid;
    };

    /** @private */
    function invokeOnceTimer(guid, onceTimers) {
        if (onceTimers[this.tguid]) delete onceTimers[this.tguid][this.mguid];
        if (timers[guid]) invoke(this.target, this.method, this.args, 2);
        delete timers[guid];
    }

    /**
    Schedules an item to run one time during the current RunLoop.  Calling
    this method with the same target/method combination will have no effect.

    Note that although you can pass optional arguments these will not be
    considered when looking for duplicates.  New arguments will replace previous
    calls.

    Ember.run(function(){
    var doFoo = function() { foo(); }
    Ember.run.once(myContext, doFoo);
    Ember.run.once(myContext, doFoo);
    // doFoo will only be executed once at the end of the RunLoop
    });

    @param {Object} target
    (optional) target of method to invoke

    @param {Function|String} method
    The method to invoke.  If you pass a string it will be resolved on the
    target at the time the method is invoked.

    @param {Object...} args
    Optional arguments to pass to the timeout.


    @returns {Object} timer
    */
    Ember.run.once = function (target, method) {
        var tguid = Ember.guidFor(target), mguid = Ember.guidFor(method), guid, timer;

        var onceTimers = run.autorun().onceTimers;
        guid = onceTimers[tguid] && onceTimers[tguid][mguid];
        if (guid && timers[guid]) {
            timers[guid].args = slice.call(arguments); // replace args

        } else {
            timer = {
                target: target,
                method: method,
                args: slice.call(arguments),
                tguid: tguid,
                mguid: mguid
            };

            guid = Ember.guidFor(timer);
            timers[guid] = timer;
            if (!onceTimers[tguid]) onceTimers[tguid] = {};
            onceTimers[tguid][mguid] = guid; // so it isn't scheduled more than once

            run.schedule('actions', timer, invokeOnceTimer, guid, onceTimers);
        }

        return guid;
    };

    var scheduledNext = false;
    /** @private */
    function invokeNextTimers() {
        scheduledNext = null;
        for (var key in timers) {
            if (!timers.hasOwnProperty(key)) continue;
            var timer = timers[key];
            if (timer.next) {
                delete timers[key];
                invoke(timer.target, timer.method, timer.args, 2);
            }
        }
    }

    /**
    Schedules an item to run after control has been returned to the system.
    This is often equivalent to calling setTimeout(function...,1).

    Ember.run.next(myContext, function(){
    // code to be executed in the next RunLoop, which will be scheduled after the current one
    });

    @param {Object} target
    (optional) target of method to invoke

    @param {Function|String} method
    The method to invoke.  If you pass a string it will be resolved on the
    target at the time the method is invoked.

    @param {Object...} args
    Optional arguments to pass to the timeout.

    @returns {Object} timer
    */
    Ember.run.next = function (target, method) {
        var timer, guid;

        timer = {
            target: target,
            method: method,
            args: slice.call(arguments),
            next: true
        };

        guid = Ember.guidFor(timer);
        timers[guid] = timer;

        if (!scheduledNext) scheduledNext = setTimeout(invokeNextTimers, 1);
        return guid;
    };

    /**
    Cancels a scheduled item.  Must be a value returned by `Ember.run.later()`,
    `Ember.run.once()`, or `Ember.run.next()`.

    var runNext = Ember.run.next(myContext, function(){
    // will not be executed
    });
    Ember.run.cancel(runNext);

    var runLater = Ember.run.next(myContext, function(){
    // will not be executed
    }, 500);
    Ember.run.cancel(runLater);

    var runOnce = Ember.run.once(myContext, function(){
    // will not be executed
    });
    Ember.run.cancel(runOnce);

    @param {Object} timer
    Timer object to cancel

    @returns {void}
    */
    Ember.run.cancel = function (timer) {
        delete timers[timer];
    };

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    // Ember.Logger
    // get, getPath, setPath, trySetPath
    // guidFor, isArray, meta
    // addObserver, removeObserver
    // Ember.run.schedule

    // ..........................................................
    // CONSTANTS
    //


    /**
    @static

    Debug parameter you can turn on. This will log all bindings that fire to
    the console. This should be disabled in production code. Note that you
    can also enable this from the console or temporarily.

    @type Boolean
    @default false
    */
    Ember.LOG_BINDINGS = false || !!Ember.ENV.LOG_BINDINGS;

    /**
    @static

    Performance paramter. This will benchmark the time spent firing each
    binding.

    @type Boolean
    */
    Ember.BENCHMARK_BINDING_NOTIFICATIONS = !!Ember.ENV.BENCHMARK_BINDING_NOTIFICATIONS;

    /**
    @static

    Performance parameter. This will benchmark the time spend configuring each
    binding.

    @type Boolean
    */
    Ember.BENCHMARK_BINDING_SETUP = !!Ember.ENV.BENCHMARK_BINDING_SETUP;


    /**
    @static

    Default placeholder for multiple values in bindings.

    @type String
    @default '@@MULT@@'
    */
    Ember.MULTIPLE_PLACEHOLDER = '@@MULT@@';

    /**
    @static

    Default placeholder for empty values in bindings.  Used by notEmpty()
    helper unless you specify an alternative.

    @type String
    @default '@@EMPTY@@'
    */
    Ember.EMPTY_PLACEHOLDER = '@@EMPTY@@';

    // ..........................................................
    // TYPE COERCION HELPERS
    //

    // Coerces a non-array value into an array.
    /** @private */
    function MULTIPLE(val) {
        if (val instanceof Array) return val;
        if (val === undefined || val === null) return [];
        return [val];
    }

    // Treats a single-element array as the element. Otherwise
    // returns a placeholder.
    /** @private */
    function SINGLE(val, placeholder) {
        if (val instanceof Array) {
            if (val.length > 1) return placeholder;
            else return val[0];
        }
        return val;
    }

    // Coerces the binding value into a Boolean.

    var BOOL = {
        to: function (val) {
            return !!val;
        }
    };

    // Returns the Boolean inverse of the value.
    var NOT = {
        to: function NOT(val) {
            return !val;
        }
    };

    var get = Ember.get,
    getPath = Ember.getPath,
    setPath = Ember.setPath,
    guidFor = Ember.guidFor,
    isGlobalPath = Ember.isGlobalPath;

    // Applies a binding's transformations against a value.
    /** @private */
    function getTransformedValue(binding, val, obj, dir) {

        // First run a type transform, if it exists, that changes the fundamental
        // type of the value. For example, some transforms convert an array to a
        // single object.

        var typeTransform = binding._typeTransform;
        if (typeTransform) { val = typeTransform(val, binding._placeholder); }

        // handle transforms
        var transforms = binding._transforms,
      len = transforms ? transforms.length : 0,
      idx;

        for (idx = 0; idx < len; idx++) {
            var transform = transforms[idx][dir];
            if (transform) { val = transform.call(this, val, obj); }
        }
        return val;
    }

    /** @private */
    function empty(val) {
        return val === undefined || val === null || val === '' || (Ember.isArray(val) && get(val, 'length') === 0);
    }

    /** @private */
    function getPathWithGlobals(obj, path) {
        return getPath(isGlobalPath(path) ? window : obj, path);
    }

    /** @private */
    function getTransformedFromValue(obj, binding) {
        var operation = binding._operation,
      fromValue;
        if (operation) {
            fromValue = operation(obj, binding._from, binding._operand);
        } else {
            fromValue = getPathWithGlobals(obj, binding._from);
        }
        return getTransformedValue(binding, fromValue, obj, 'to');
    }

    /** @private */
    function getTransformedToValue(obj, binding) {
        var toValue = getPath(obj, binding._to);
        return getTransformedValue(binding, toValue, obj, 'from');
    }

    /** @private */
    var AND_OPERATION = function (obj, left, right) {
        return getPathWithGlobals(obj, left) && getPathWithGlobals(obj, right);
    };

    /** @private */
    var OR_OPERATION = function (obj, left, right) {
        return getPathWithGlobals(obj, left) || getPathWithGlobals(obj, right);
    };

    // ..........................................................
    // BINDING
    //
    /** @private */
    var K = function () { };

    /** @private */
    var Binding = function (toPath, fromPath) {
        var self;

        if (this instanceof Binding) {
            self = this;
        } else {
            self = new K();
        }

        /** @private */
        self._direction = 'fwd';

        /** @private */
        self._from = fromPath;
        self._to = toPath;

        return self;
    };

    K.prototype = Binding.prototype;

    Binding.prototype = /** @scope Ember.Binding.prototype */{
    /**
    This copies the Binding so it can be connected to another object.
    @returns {Ember.Binding}
    */
    copy: function () {
        var copy = new Binding(this._to, this._from);
        if (this._oneWay) {
            copy._oneWay = true;
        }
        if (this._transforms) {
            copy._transforms = this._transforms.slice(0);
        }
        if (this._typeTransform) {
            copy._typeTransform = this._typeTransform;
            copy._placeholder = this._placeholder;
        }
        if (this._operand) {
            copy._operand = this._operand;
            copy._operation = this._operation;
        }
        return copy;
    },

    // ..........................................................
    // CONFIG
    //

    /**
    This will set "from" property path to the specified value. It will not
    attempt to resolve this property path to an actual object until you
    connect the binding.

    The binding will search for the property path starting at the root object
    you pass when you connect() the binding.  It follows the same rules as
    `getPath()` - see that method for more information.

    @param {String} propertyPath the property path to connect to
    @returns {Ember.Binding} receiver
    */
    from: function (path) {
        this._from = path;
        return this;
    },

    /**
    This will set the "to" property path to the specified value. It will not
    attempt to resolve this property path to an actual object until you
    connect the binding.

    The binding will search for the property path starting at the root object
    you pass when you connect() the binding.  It follows the same rules as
    `getPath()` - see that method for more information.

    @param {String|Tuple} propertyPath A property path or tuple
    @param {Object} [root] Root object to use when resolving the path.
    @returns {Ember.Binding} this
    */
    to: function (path) {
        this._to = path;
        return this;
    },

    /**
    Configures the binding as one way. A one-way binding will relay changes
    on the "from" side to the "to" side, but not the other way around. This
    means that if you change the "to" side directly, the "from" side may have
    a different value.

    @param {Boolean} flag
    (Optional) passing nothing here will make the binding oneWay.  You can
    instead pass false to disable oneWay, making the binding two way again.

    @returns {Ember.Binding} receiver
    */
    oneWay: function (flag) {
        this._oneWay = flag === undefined ? true : !!flag;
        return this;
    },

    /**
    Adds the specified transform to the array of transform functions.

    A transform is a hash with `to` and `from` properties. Each property
    should be a function that performs a transformation in either the
    forward or back direction.

    The functions you pass must have the following signature:

    function(value) {};

    They must also return the transformed value.

    Transforms are invoked in the order they were added. If you are
    extending a binding and want to reset the transforms, you can call
    `resetTransform()` first.

    @param {Function} transformFunc the transform function.
    @returns {Ember.Binding} this
    */
    transform: function (transform) {
        if ('function' === typeof transform) {
            transform = { to: transform };
        }

        if (!this._transforms) this._transforms = [];
        this._transforms.push(transform);
        return this;
    },

    /**
    Resets the transforms for the binding. After calling this method the
    binding will no longer transform values. You can then add new transforms
    as needed.

    @returns {Ember.Binding} this
    */
    resetTransforms: function () {
        this._transforms = null;
        return this;
    },

    /**
    Adds a transform to the chain that will allow only single values to pass.
    This will allow single values and nulls to pass through. If you pass an
    array, it will be mapped as so:

    - [] => null
    - [a] => a
    - [a,b,c] => Multiple Placeholder

    You can pass in an optional multiple placeholder or it will use the
    default.

    Note that this transform will only happen on forwarded valued. Reverse
    values are send unchanged.

    @param {String} fromPath from path or null
    @param {Object} [placeholder] Placeholder value.
    @returns {Ember.Binding} this
    */
    single: function (placeholder) {
        if (placeholder === undefined) placeholder = Ember.MULTIPLE_PLACEHOLDER;
        this._typeTransform = SINGLE;
        this._placeholder = placeholder;
        return this;
    },

    /**
    Adds a transform that will convert the passed value to an array. If
    the value is null or undefined, it will be converted to an empty array.

    @param {String} [fromPath]
    @returns {Ember.Binding} this
    */
    multiple: function () {
        this._typeTransform = MULTIPLE;
        this._placeholder = null;
        return this;
    },

    /**
    Adds a transform to convert the value to a bool value. If the value is
    an array it will return true if array is not empty. If the value is a
    string it will return true if the string is not empty.

    @returns {Ember.Binding} this
    */
    bool: function () {
        this.transform(BOOL);
        return this;
    },

    /**
    Adds a transform that will return the placeholder value if the value is
    null, undefined, an empty array or an empty string. See also notNull().

    @param {Object} [placeholder] Placeholder value.
    @returns {Ember.Binding} this
    */
    notEmpty: function (placeholder) {
        if (placeholder === null || placeholder === undefined) {
            placeholder = Ember.EMPTY_PLACEHOLDER;
        }

        this.transform({
            to: function (val) { return empty(val) ? placeholder : val; }
        });

        return this;
    },

    /**
    Adds a transform that will return the placeholder value if the value is
    null or undefined. Otherwise it will passthrough untouched. See also notEmpty().

    @param {String} fromPath from path or null
    @param {Object} [placeholder] Placeholder value.
    @returns {Ember.Binding} this
    */
    notNull: function (placeholder) {
        if (placeholder === null || placeholder === undefined) {
            placeholder = Ember.EMPTY_PLACEHOLDER;
        }

        this.transform({
            to: function (val) { return (val === null || val === undefined) ? placeholder : val; }
        });

        return this;
    },

    /**
    Adds a transform to convert the value to the inverse of a bool value. This
    uses the same transform as bool() but inverts it.

    @returns {Ember.Binding} this
    */
    not: function () {
        this.transform(NOT);
        return this;
    },

    /**
    Adds a transform that will return true if the value is null or undefined, false otherwise.

    @returns {Ember.Binding} this
    */
    isNull: function () {
        this.transform(function (val) { return val === null || val === undefined; });
        return this;
    },

    /** @private */
    toString: function () {
        var oneWay = this._oneWay ? '[oneWay]' : '';
        return "Ember.Binding<" + guidFor(this) + ">(" + this._from + " -> " + this._to + ")" + oneWay;
    },

    // ..........................................................
    // CONNECT AND SYNC
    //

    /**
    Attempts to connect this binding instance so that it can receive and relay
    changes. This method will raise an exception if you have not set the
    from/to properties yet.

    @param {Object} obj
    The root object for this binding.

    @param {Boolean} preferFromParam
    private: Normally, `connect` cannot take an object if `from` already set
    an object. Internally, we would like to be able to provide a default object
    to be used if no object was provided via `from`, so this parameter turns
    off the assertion.

    @returns {Ember.Binding} this
    */
    connect: function (obj) {
        Ember.assert('Must pass a valid object to Ember.Binding.connect()', !!obj);

        var oneWay = this._oneWay, operand = this._operand;

        // add an observer on the object to be notified when the binding should be updated
        Ember.addObserver(obj, this._from, this, this.fromDidChange);

        // if there is an operand, add an observer onto it as well
        if (operand) { Ember.addObserver(obj, operand, this, this.fromDidChange); }

        // if the binding is a two-way binding, also set up an observer on the target
        // object.
        if (!oneWay) { Ember.addObserver(obj, this._to, this, this.toDidChange); }

        if (Ember.meta(obj, false).proto !== obj) { this._scheduleSync(obj, 'fwd'); }

        this._readyToSync = true;
        return this;
    },

    /**
    Disconnects the binding instance. Changes will no longer be relayed. You
    will not usually need to call this method.

    @param {Object} obj
    The root object you passed when connecting the binding.

    @returns {Ember.Binding} this
    */
    disconnect: function (obj) {
        Ember.assert('Must pass a valid object to Ember.Binding.disconnect()', !!obj);

        var oneWay = this._oneWay, operand = this._operand;

        // remove an observer on the object so we're no longer notified of
        // changes that should update bindings.
        Ember.removeObserver(obj, this._from, this, this.fromDidChange);

        // if there is an operand, remove the observer from it as well
        if (operand) Ember.removeObserver(obj, operand, this, this.fromDidChange);

        // if the binding is two-way, remove the observer from the target as well
        if (!oneWay) Ember.removeObserver(obj, this._to, this, this.toDidChange);

        this._readyToSync = false; // disable scheduled syncs...
        return this;
    },

    // ..........................................................
    // PRIVATE
    //

    /** @private - called when the from side changes */
    fromDidChange: function (target) {
        this._scheduleSync(target, 'fwd');
    },

    /** @private - called when the to side changes */
    toDidChange: function (target) {
        this._scheduleSync(target, 'back');
    },

    /** @private */
    _scheduleSync: function (obj, dir) {
        var guid = guidFor(obj), existingDir = this[guid];

        // if we haven't scheduled the binding yet, schedule it
        if (!existingDir) {
            Ember.run.schedule('sync', this, this._sync, obj);
            this[guid] = dir;
        }

        // If both a 'back' and 'fwd' sync have been scheduled on the same object,
        // default to a 'fwd' sync so that it remains deterministic.
        if (existingDir === 'back' && dir === 'fwd') {
            this[guid] = 'fwd';
        }
    },

    /** @private */
    _sync: function (obj) {
        var log = Ember.LOG_BINDINGS;

        // don't synchronize destroyed objects or disconnected bindings
        if (obj.isDestroyed || !this._readyToSync) { return; }

        // get the direction of the binding for the object we are
        // synchronizing from
        var guid = guidFor(obj), direction = this[guid];

        var fromPath = this._from, toPath = this._to;

        delete this[guid];

        // if we're synchronizing from the remote object...
        if (direction === 'fwd') {
            var fromValue = getTransformedFromValue(obj, this);
            if (log) {
                Ember.Logger.log(' ', this.toString(), '->', fromValue, obj);
            }
            if (this._oneWay) {
                Ember.trySetPath(Ember.isGlobalPath(toPath) ? window : obj, toPath, fromValue);
            } else {
                Ember._suspendObserver(obj, toPath, this, this.toDidChange, function () {
                    Ember.trySetPath(Ember.isGlobalPath(toPath) ? window : obj, toPath, fromValue);
                });
            }
            // if we're synchronizing *to* the remote object
        } else if (direction === 'back') {// && !this._oneWay) {
            var toValue = getTransformedToValue(obj, this);
            if (log) {
                Ember.Logger.log(' ', this.toString(), '<-', toValue, obj);
            }
            Ember._suspendObserver(obj, fromPath, this, this.fromDidChange, function () {
                Ember.trySetPath(Ember.isGlobalPath(fromPath) ? window : obj, fromPath, toValue);
            });
        }
    }

};

/** @private */
function mixinProperties(to, from) {
    for (var key in from) {
        if (from.hasOwnProperty(key)) {
            to[key] = from[key];
        }
    }
}

mixinProperties(Binding,
/** @scope Ember.Binding */{

/**
@see Ember.Binding.prototype.from
*/
from: function () {
    var C = this, binding = new C();
    return binding.from.apply(binding, arguments);
},

/**
@see Ember.Binding.prototype.to
*/
to: function () {
    var C = this, binding = new C();
    return binding.to.apply(binding, arguments);
},

/**
@see Ember.Binding.prototype.oneWay
*/
oneWay: function (from, flag) {
    var C = this, binding = new C(null, from);
    return binding.oneWay(flag);
},

/**
@see Ember.Binding.prototype.single
*/
single: function (from, placeholder) {
    var C = this, binding = new C(null, from);
    return binding.single(placeholder);
},

/**
@see Ember.Binding.prototype.multiple
*/
multiple: function (from) {
    var C = this, binding = new C(null, from);
    return binding.multiple();
},

/**
@see Ember.Binding.prototype.transform
*/
transform: function (from, func) {
    if (!func) {
        func = from;
        from = null;
    }
    var C = this, binding = new C(null, from);
    return binding.transform(func);
},

/**
@see Ember.Binding.prototype.notEmpty
*/
notEmpty: function (from, placeholder) {
    var C = this, binding = new C(null, from);
    return binding.notEmpty(placeholder);
},

/**
@see Ember.Binding.prototype.notNull
*/
notNull: function (from, placeholder) {
    var C = this, binding = new C(null, from);
    return binding.notNull(placeholder);
},


/**
@see Ember.Binding.prototype.bool
*/
bool: function (from) {
    var C = this, binding = new C(null, from);
    return binding.bool();
},

/**
@see Ember.Binding.prototype.not
*/
not: function (from) {
    var C = this, binding = new C(null, from);
    return binding.not();
},

/**
@see Ember.Binding.prototype.isNull
*/
isNull: function (from) {
    var C = this, binding = new C(null, from);
    return binding.isNull();
},

/**
Adds a transform that forwards the logical 'AND' of values at 'pathA' and
'pathB' whenever either source changes. Note that the transform acts
strictly as a one-way binding, working only in the direction

'pathA' AND 'pathB' --> value  (value returned is the result of ('pathA' && 'pathB'))

Usage example where a delete button's `isEnabled` value is determined by
whether something is selected in a list and whether the current user is
allowed to delete:

deleteButton: Ember.ButtonView.design({
isEnabledBinding: Ember.Binding.and('MyApp.itemsController.hasSelection', 'MyApp.userController.canDelete')
})

@param {String} pathA The first part of the conditional
@param {String} pathB The second part of the conditional
*/
and: function (pathA, pathB) {
    var C = this, binding = new C(null, pathA).oneWay();
    binding._operand = pathB;
    binding._operation = AND_OPERATION;
    return binding;
},

/**
Adds a transform that forwards the 'OR' of values at 'pathA' and
'pathB' whenever either source changes. Note that the transform acts
strictly as a one-way binding, working only in the direction

'pathA' AND 'pathB' --> value  (value returned is the result of ('pathA' || 'pathB'))

@param {String} pathA The first part of the conditional
@param {String} pathB The second part of the conditional
*/
or: function (pathA, pathB) {
    var C = this, binding = new C(null, pathA).oneWay();
    binding._operand = pathB;
    binding._operation = OR_OPERATION;
    return binding;
},

/**
Registers a custom transform for use in bindings.

@param {String} name The name of the transform
@param {Function} transform The transformation function
*/
registerTransform: function (name, transform) {
    this.prototype[name] = transform;
    this[name] = function (from) {
        var C = this, binding = new C(null, from), args;
        args = Array.prototype.slice.call(arguments, 1);
        return binding[name].apply(binding, args);
    };
}

});

/**
@class

A binding simply connects the properties of two objects so that whenever the
value of one property changes, the other property will be changed also. You
do not usually work with Binding objects directly but instead describe
bindings in your class definition using something like:

valueBinding: "MyApp.someController.title"

This will create a binding from `MyApp.someController.title` to the `value`
property of your object instance automatically. Now the two values will be
kept in sync.

## Customizing Your Bindings

In addition to synchronizing values, bindings can also perform some basic
transforms on values. These transforms can help to make sure the data fed
into one object always meets the expectations of that object regardless of
what the other object outputs.

To customize a binding, you can use one of the many helper methods defined
on Ember.Binding like so:

valueBinding: Ember.Binding.single("MyApp.someController.title")

This will create a binding just like the example above, except that now the
binding will convert the value of `MyApp.someController.title` to a single
object (removing any arrays) before applying it to the `value` property of
your object.

You can also chain helper methods to build custom bindings like so:

valueBinding: Ember.Binding.single("MyApp.someController.title").notEmpty("(EMPTY)")

This will force the value of MyApp.someController.title to be a single value
and then check to see if the value is "empty" (null, undefined, empty array,
or an empty string). If it is empty, the value will be set to the string
"(EMPTY)".

## One Way Bindings

One especially useful binding customization you can use is the `oneWay()`
helper. This helper tells Ember that you are only interested in
receiving changes on the object you are binding from. For example, if you
are binding to a preference and you want to be notified if the preference
has changed, but your object will not be changing the preference itself, you
could do:

bigTitlesBinding: Ember.Binding.oneWay("MyApp.preferencesController.bigTitles")

This way if the value of MyApp.preferencesController.bigTitles changes the
"bigTitles" property of your object will change also. However, if you
change the value of your "bigTitles" property, it will not update the
preferencesController.

One way bindings are almost twice as fast to setup and twice as fast to
execute because the binding only has to worry about changes to one side.

You should consider using one way bindings anytime you have an object that
may be created frequently and you do not intend to change a property; only
to monitor it for changes. (such as in the example above).

## Adding Custom Transforms

In addition to using the standard helpers provided by Ember, you can
also defined your own custom transform functions which will be used to
convert the value. To do this, just define your transform function and add
it to the binding with the transform() helper. The following example will
not allow Integers less than ten. Note that it checks the value of the
bindings and allows all other values to pass:

valueBinding: Ember.Binding.transform(function(value, binding) {
return ((Ember.typeOf(value) === 'number') && (value < 10)) ? 10 : value;
}).from("MyApp.someController.value")

If you would like to instead use this transform on a number of bindings,
you can also optionally add your own helper method to Ember.Binding. This
method should simply return the value of `this.transform()`. The example
below adds a new helper called `notLessThan()` which will limit the value to
be not less than the passed minimum:

Ember.Binding.registerTransform('notLessThan', function(minValue) {
return this.transform(function(value, binding) {
return ((Ember.typeOf(value) === 'number') && (value < minValue)) ? minValue : value;
});
});

You could specify this in your core.js file, for example. Then anywhere in
your application you can use it to define bindings like so:

valueBinding: Ember.Binding.from("MyApp.someController.value").notLessThan(10)

Also, remember that helpers are chained so you can use your helper along
with any other helpers. The example below will create a one way binding that
does not allow empty values or values less than 10:

valueBinding: Ember.Binding.oneWay("MyApp.someController.value").notEmpty().notLessThan(10)

Finally, it's also possible to specify bi-directional transforms. To do this,
you can pass a hash to `transform` with `to` and `from`. In the following
example, we are expecting a lowercase string that we want to transform to
uppercase.

valueBinding: Ember.Binding.transform({
to:   function(value, binding) { return value.toUpperCase(); },
from: function(value, binding) { return value.toLowerCase(); }

## How to Manually Adding Binding

All of the examples above show you how to configure a custom binding, but
the result of these customizations will be a binding template, not a fully
active binding. The binding will actually become active only when you
instantiate the object the binding belongs to. It is useful however, to
understand what actually happens when the binding is activated.

For a binding to function it must have at least a "from" property and a "to"
property. The from property path points to the object/key that you want to
bind from while the to path points to the object/key you want to bind to.

When you define a custom binding, you are usually describing the property
you want to bind from (such as "MyApp.someController.value" in the examples
above). When your object is created, it will automatically assign the value
you want to bind "to" based on the name of your binding key. In the
examples above, during init, Ember objects will effectively call
something like this on your binding:

binding = Ember.Binding.from(this.valueBinding).to("value");

This creates a new binding instance based on the template you provide, and
sets the to path to the "value" property of the new object. Now that the
binding is fully configured with a "from" and a "to", it simply needs to be
connected to become active. This is done through the connect() method:

binding.connect(this);

Note that when you connect a binding you pass the object you want it to be
connected to.  This object will be used as the root for both the from and
to side of the binding when inspecting relative paths.  This allows the
binding to be automatically inherited by subclassed objects as well.

Now that the binding is connected, it will observe both the from and to side
and relay changes.

If you ever needed to do so (you almost never will, but it is useful to
understand this anyway), you could manually create an active binding by
using the Ember.bind() helper method. (This is the same method used by
to setup your bindings on objects):

Ember.bind(MyApp.anotherObject, "value", "MyApp.someController.value");

Both of these code fragments have the same effect as doing the most friendly
form of binding creation like so:

MyApp.anotherObject = Ember.Object.create({
valueBinding: "MyApp.someController.value",

// OTHER CODE FOR THIS OBJECT...

});

Ember's built in binding creation method makes it easy to automatically
create bindings for you. You should always use the highest-level APIs
available, even if you understand how it works underneath.

@since Ember 0.9
*/
Ember.Binding = Binding;

/**
Global helper method to create a new binding.  Just pass the root object
along with a to and from path to create and connect the binding.  The new
binding object will be returned which you can further configure with
transforms and other conditions.

@param {Object} obj
The root object of the transform.

@param {String} to
The path to the 'to' side of the binding.  Must be relative to obj.

@param {String} from
The path to the 'from' side of the binding.  Must be relative to obj or
a global path.

@returns {Ember.Binding} binding instance
*/
Ember.bind = function (obj, to, from) {
    return new Ember.Binding(to, from).connect(obj);
};

Ember.oneWay = function (obj, to, from) {
    return new Ember.Binding(to, from).oneWay().connect(obj);
};

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var Mixin, MixinDelegate, REQUIRED, Alias;
    var classToString, superClassString;

    var a_map = Ember.ArrayUtils.map;
    var a_indexOf = Ember.ArrayUtils.indexOf;
    var a_forEach = Ember.ArrayUtils.forEach;
    var a_slice = Array.prototype.slice;
    var EMPTY_META = {}; // dummy for non-writable meta
    var META_SKIP = { __emberproto__: true, __ember_count__: true };

    var o_create = Ember.platform.create;

    /** @private */
    function meta(obj, writable) {
        var m = Ember.meta(obj, writable !== false), ret = m.mixins;
        if (writable === false) return ret || EMPTY_META;

        if (!ret) {
            ret = m.mixins = { __emberproto__: obj };
        } else if (ret.__emberproto__ !== obj) {
            ret = m.mixins = o_create(ret);
            ret.__emberproto__ = obj;
        }
        return ret;
    }

    /** @private */
    function initMixin(mixin, args) {
        if (args && args.length > 0) {
            mixin.mixins = a_map(args, function (x) {
                if (x instanceof Mixin) return x;

                // Note: Manually setup a primitive mixin here.  This is the only
                // way to actually get a primitive mixin.  This way normal creation
                // of mixins will give you combined mixins...
                var mixin = new Mixin();
                mixin.properties = x;
                return mixin;
            });
        }
        return mixin;
    }

    var NATIVES = [Boolean, Object, Number, Array, Date, String];
    /** @private */
    function isMethod(obj) {
        if ('function' !== typeof obj || obj.isMethod === false) return false;
        return a_indexOf(NATIVES, obj) < 0;
    }

    /** @private */
    function mergeMixins(mixins, m, descs, values, base) {
        var len = mixins.length, idx, mixin, guid, props, value, key, ovalue, concats;

        /** @private */
        function removeKeys(keyName) {
            delete descs[keyName];
            delete values[keyName];
        }

        for (idx = 0; idx < len; idx++) {

            mixin = mixins[idx];
            if (!mixin) throw new Error('Null value found in Ember.mixin()');

            if (mixin instanceof Mixin) {
                guid = Ember.guidFor(mixin);
                if (m[guid]) continue;
                m[guid] = mixin;
                props = mixin.properties;
            } else {
                props = mixin; // apply anonymous mixin properties
            }

            if (props) {

                // reset before adding each new mixin to pickup concats from previous
                concats = values.concatenatedProperties || base.concatenatedProperties;
                if (props.concatenatedProperties) {
                    concats = concats ? concats.concat(props.concatenatedProperties) : props.concatenatedProperties;
                }

                for (key in props) {
                    if (!props.hasOwnProperty(key)) continue;
                    value = props[key];
                    if (value instanceof Ember.Descriptor) {
                        if (value === REQUIRED && descs[key]) { continue; }

                        descs[key] = value;
                        values[key] = undefined;
                    } else {

                        // impl super if needed...
                        if (isMethod(value)) {
                            ovalue = (descs[key] === Ember.SIMPLE_PROPERTY) && values[key];
                            if (!ovalue) ovalue = base[key];
                            if ('function' !== typeof ovalue) ovalue = null;
                            if (ovalue) {
                                var o = value.__ember_observes__, ob = value.__ember_observesBefore__;
                                value = Ember.wrap(value, ovalue);
                                value.__ember_observes__ = o;
                                value.__ember_observesBefore__ = ob;
                            }
                        } else if ((concats && a_indexOf(concats, key) >= 0) || key === 'concatenatedProperties') {
                            var baseValue = values[key] || base[key];
                            value = baseValue ? baseValue.concat(value) : Ember.makeArray(value);
                        }

                        descs[key] = Ember.SIMPLE_PROPERTY;
                        values[key] = value;
                    }
                }

                // manually copy toString() because some JS engines do not enumerate it
                if (props.hasOwnProperty('toString')) {
                    base.toString = props.toString;
                }

            } else if (mixin.mixins) {
                mergeMixins(mixin.mixins, m, descs, values, base);
                if (mixin._without) a_forEach(mixin._without, removeKeys);
            }
        }
    }

    /** @private */
    var defineProperty = Ember.defineProperty;

    /** @private */
    function writableReq(obj) {
        var m = Ember.meta(obj), req = m.required;
        if (!req || (req.__emberproto__ !== obj)) {
            req = m.required = req ? o_create(req) : { __ember_count__: 0 };
            req.__emberproto__ = obj;
        }
        return req;
    }

    /** @private */
    function getObserverPaths(value) {
        return ('function' === typeof value) && value.__ember_observes__;
    }

    /** @private */
    function getBeforeObserverPaths(value) {
        return ('function' === typeof value) && value.__ember_observesBefore__;
    }

    var IS_BINDING = Ember.IS_BINDING = /^.+Binding$/;

    function detectBinding(obj, key, m) {
        if (IS_BINDING.test(key)) {
            var bindings = m.bindings;
            if (!bindings) {
                bindings = m.bindings = { __emberproto__: obj };
            } else if (bindings.__emberproto__ !== obj) {
                bindings = m.bindings = o_create(m.bindings);
                bindings.__emberproto__ = obj;
            }
            bindings[key] = true;
        }
    }

    function connectBindings(obj, m) {
        if (m === undefined) {
            m = Ember.meta(obj);
        }
        var bindings = m.bindings, key, binding;
        if (bindings) {
            for (key in bindings) {
                binding = key !== '__emberproto__' && obj[key];
                if (binding) {
                    if (binding instanceof Ember.Binding) {
                        binding = binding.copy(); // copy prototypes' instance
                        binding.to(key.slice(0, -7));
                    } else {
                        binding = new Ember.Binding(key.slice(0, -7), binding);
                    }
                    binding.connect(obj);
                    obj[key] = binding;
                }
            }
        }
    }

    /** @private */
    function applyMixin(obj, mixins, partial) {
        var descs = {}, values = {}, m = Ember.meta(obj), req = m.required;
        var key, willApply, didApply, value, desc;

        // Go through all mixins and hashes passed in, and:
        //
        // * Handle concatenated properties
        // * Set up _super wrapping if necessary
        // * Set up descriptors (simple, watched or computed properties)
        // * Copying `toString` in broken browsers
        mergeMixins(mixins, meta(obj), descs, values, obj);

        if (MixinDelegate.detect(obj)) {
            willApply = values.willApplyProperty || obj.willApplyProperty;
            didApply = values.didApplyProperty || obj.didApplyProperty;
        }

        for (key in descs) {
            if (!descs.hasOwnProperty(key)) continue;

            desc = descs[key];
            value = values[key];

            if (desc === REQUIRED) {
                if (!(key in obj)) {
                    if (!partial) throw new Error('Required property not defined: ' + key);

                    // for partial applies add to hash of required keys
                    req = writableReq(obj);
                    req.__ember_count__++;
                    req[key] = true;
                }

            } else {

                while (desc instanceof Alias) {

                    var altKey = desc.methodName;
                    if (descs[altKey]) {
                        value = values[altKey];
                        desc = descs[altKey];
                    } else if (m.descs[altKey]) {
                        desc = m.descs[altKey];
                        value = desc.val(obj, altKey);
                    } else {
                        value = obj[altKey];
                        desc = Ember.SIMPLE_PROPERTY;
                    }
                }

                if (willApply) willApply.call(obj, key);

                var observerPaths = getObserverPaths(value),
          curObserverPaths = observerPaths && getObserverPaths(obj[key]),
          beforeObserverPaths = getBeforeObserverPaths(value),
          curBeforeObserverPaths = beforeObserverPaths && getBeforeObserverPaths(obj[key]),
          len, idx;

                if (curObserverPaths) {
                    len = curObserverPaths.length;
                    for (idx = 0; idx < len; idx++) {
                        Ember.removeObserver(obj, curObserverPaths[idx], null, key);
                    }
                }

                if (curBeforeObserverPaths) {
                    len = curBeforeObserverPaths.length;
                    for (idx = 0; idx < len; idx++) {
                        Ember.removeBeforeObserver(obj, curBeforeObserverPaths[idx], null, key);
                    }
                }

                detectBinding(obj, key, m);

                defineProperty(obj, key, desc, value);

                if (observerPaths) {
                    len = observerPaths.length;
                    for (idx = 0; idx < len; idx++) {
                        Ember.addObserver(obj, observerPaths[idx], null, key);
                    }
                }

                if (beforeObserverPaths) {
                    len = beforeObserverPaths.length;
                    for (idx = 0; idx < len; idx++) {
                        Ember.addBeforeObserver(obj, beforeObserverPaths[idx], null, key);
                    }
                }

                if (req && req[key]) {
                    req = writableReq(obj);
                    req.__ember_count__--;
                    req[key] = false;
                }

                if (didApply) didApply.call(obj, key);

            }
        }

        if (!partial) { // don't apply to prototype
            value = connectBindings(obj, m);
        }

        // Make sure no required attrs remain
        if (!partial && req && req.__ember_count__ > 0) {
            var keys = [];
            for (key in req) {
                if (META_SKIP[key]) continue;
                keys.push(key);
            }
            throw new Error('Required properties not defined: ' + keys.join(','));
        }
        return obj;
    }

    Ember.mixin = function (obj) {
        var args = a_slice.call(arguments, 1);
        return applyMixin(obj, args, false);
    };


    /**
    @constructor
    */
    Ember.Mixin = function () { return initMixin(this, arguments); };

    /** @private */
    Mixin = Ember.Mixin;

    /** @private */
    Mixin._apply = applyMixin;

    Mixin.applyPartial = function (obj) {
        var args = a_slice.call(arguments, 1);
        return applyMixin(obj, args, true);
    };

    Mixin.finishPartial = function (obj) {
        connectBindings(obj);
        return obj;
    };

    Mixin.create = function () {
        classToString.processed = false;
        var M = this;
        return initMixin(new M(), arguments);
    };

    Mixin.prototype.reopen = function () {

        var mixin, tmp;

        if (this.properties) {
            mixin = Mixin.create();
            mixin.properties = this.properties;
            delete this.properties;
            this.mixins = [mixin];
        }

        var len = arguments.length, mixins = this.mixins, idx;

        for (idx = 0; idx < len; idx++) {
            mixin = arguments[idx];
            if (mixin instanceof Mixin) {
                mixins.push(mixin);
            } else {
                tmp = Mixin.create();
                tmp.properties = mixin;
                mixins.push(tmp);
            }
        }

        return this;
    };

    var TMP_ARRAY = [];
    Mixin.prototype.apply = function (obj) {
        TMP_ARRAY[0] = this;
        var ret = applyMixin(obj, TMP_ARRAY, false);
        TMP_ARRAY.length = 0;
        return ret;
    };

    Mixin.prototype.applyPartial = function (obj) {
        TMP_ARRAY[0] = this;
        var ret = applyMixin(obj, TMP_ARRAY, true);
        TMP_ARRAY.length = 0;
        return ret;
    };

    /** @private */
    function _detect(curMixin, targetMixin, seen) {
        var guid = Ember.guidFor(curMixin);

        if (seen[guid]) return false;
        seen[guid] = true;

        if (curMixin === targetMixin) return true;
        var mixins = curMixin.mixins, loc = mixins ? mixins.length : 0;
        while (--loc >= 0) {
            if (_detect(mixins[loc], targetMixin, seen)) return true;
        }
        return false;
    }

    Mixin.prototype.detect = function (obj) {
        if (!obj) return false;
        if (obj instanceof Mixin) return _detect(obj, this, {});
        return !!meta(obj, false)[Ember.guidFor(this)];
    };

    Mixin.prototype.without = function () {
        var ret = new Mixin(this);
        ret._without = a_slice.call(arguments);
        return ret;
    };

    /** @private */
    function _keys(ret, mixin, seen) {
        if (seen[Ember.guidFor(mixin)]) return;
        seen[Ember.guidFor(mixin)] = true;

        if (mixin.properties) {
            var props = mixin.properties;
            for (var key in props) {
                if (props.hasOwnProperty(key)) ret[key] = true;
            }
        } else if (mixin.mixins) {
            a_forEach(mixin.mixins, function (x) { _keys(ret, x, seen); });
        }
    }

    Mixin.prototype.keys = function () {
        var keys = {}, seen = {}, ret = [];
        _keys(keys, this, seen);
        for (var key in keys) {
            if (keys.hasOwnProperty(key)) ret.push(key);
        }
        return ret;
    };

    /** @private - make Mixin's have nice displayNames */

    var NAME_KEY = Ember.GUID_KEY + '_name';
    var get = Ember.get;

    /** @private */
    function processNames(paths, root, seen) {
        var idx = paths.length;
        for (var key in root) {
            if (!root.hasOwnProperty || !root.hasOwnProperty(key)) continue;
            var obj = root[key];
            paths[idx] = key;

            if (obj && obj.toString === classToString) {
                obj[NAME_KEY] = paths.join('.');
            } else if (obj && get(obj, 'isNamespace')) {
                if (seen[Ember.guidFor(obj)]) continue;
                seen[Ember.guidFor(obj)] = true;
                processNames(paths, obj, seen);
            }

        }
        paths.length = idx; // cut out last item
    }

    /** @private */
    function findNamespaces() {
        var Namespace = Ember.Namespace, obj, isNamespace;

        if (Namespace.PROCESSED) { return; }

        for (var prop in window) {
            //  get(window.globalStorage, 'isNamespace') would try to read the storage for domain isNamespace and cause exception in Firefox.
            // globalStorage is a storage obsoleted by the WhatWG storage specification. See https://developer.mozilla.org/en/DOM/Storage#globalStorage
            if (prop === "globalStorage" && window.StorageList && window.globalStorage instanceof window.StorageList) { continue; }
            // Unfortunately, some versions of IE don't support window.hasOwnProperty
            if (window.hasOwnProperty && !window.hasOwnProperty(prop)) { continue; }

            // At times we are not allowed to access certain properties for security reasons.
            // There are also times where even if we can access them, we are not allowed to access their properties.
            try {
                obj = window[prop];
                isNamespace = obj && get(obj, 'isNamespace');
            } catch (e) {
                continue;
            }

            if (isNamespace) {
                Ember.deprecate("Namespaces should not begin with lowercase.", /^[A-Z]/.test(prop));
                obj[NAME_KEY] = prop;
            }
        }
    }

    Ember.identifyNamespaces = findNamespaces;

    /** @private */
    superClassString = function (mixin) {
        var superclass = mixin.superclass;
        if (superclass) {
            if (superclass[NAME_KEY]) { return superclass[NAME_KEY]; }
            else { return superClassString(superclass); }
        } else {
            return;
        }
    };

    /** @private */
    classToString = function () {
        var Namespace = Ember.Namespace, namespace;

        // TODO: Namespace should really be in Metal
        if (Namespace) {
            if (!this[NAME_KEY] && !classToString.processed) {
                if (!Namespace.PROCESSED) {
                    findNamespaces();
                    Namespace.PROCESSED = true;
                }

                classToString.processed = true;

                var namespaces = Namespace.NAMESPACES;
                for (var i = 0, l = namespaces.length; i < l; i++) {
                    namespace = namespaces[i];
                    processNames([namespace.toString()], namespace, {});
                }
            }
        }

        if (this[NAME_KEY]) {
            return this[NAME_KEY];
        } else {
            var str = superClassString(this);
            if (str) {
                return "(subclass of " + str + ")";
            } else {
                return "(unknown mixin)";
            }
        }
    };

    Mixin.prototype.toString = classToString;

    // returns the mixins currently applied to the specified object
    // TODO: Make Ember.mixin
    Mixin.mixins = function (obj) {
        var ret = [], mixins = meta(obj, false), key, mixin;
        for (key in mixins) {
            if (META_SKIP[key]) continue;
            mixin = mixins[key];

            // skip primitive mixins since these are always anonymous
            if (!mixin.properties) ret.push(mixins[key]);
        }
        return ret;
    };

    REQUIRED = new Ember.Descriptor();
    REQUIRED.toString = function () { return '(Required Property)'; };

    Ember.required = function () {
        return REQUIRED;
    };

    /** @private */
    Alias = function (methodName) {
        this.methodName = methodName;
    };
    Alias.prototype = new Ember.Descriptor();

    Ember.alias = function (methodName) {
        return new Alias(methodName);
    };

    Ember.MixinDelegate = Mixin.create({

        willApplyProperty: Ember.required(),
        didApplyProperty: Ember.required()

    });

    /** @private */
    MixinDelegate = Ember.MixinDelegate;


    // ..........................................................
    // OBSERVER HELPER
    //

    Ember.observer = function (func) {
        var paths = a_slice.call(arguments, 1);
        func.__ember_observes__ = paths;
        return func;
    };

    Ember.beforeObserver = function (func) {
        var paths = a_slice.call(arguments, 1);
        func.__ember_observesBefore__ = paths;
        return func;
    };







})();



(function () {
    // ==========================================================================
    // Project:  Ember Metal
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();

(function () {
    /**
    * @license
    * ==========================================================================
    * Ember
    * Copyright 漏2006-2011, Strobe Inc. and contributors.
    * Portions copyright 漏2008-2011 Apple Inc. All rights reserved.
    *
    * Permission is hereby granted, free of charge, to any person obtaining a
    * copy of this software and associated documentation files (the "Software"),
    * to deal in the Software without restriction, including without limitation
    * the rights to use, copy, modify, merge, publish, distribute, sublicense,
    * and/or sell copies of the Software, and to permit persons to whom the
    * Software is furnished to do so, subject to the following conditions:
    *
    * The above copyright notice and this permission notice shall be included in
    * all copies or substantial portions of the Software.
    *
    * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    * DEALINGS IN THE SOFTWARE.
    *
    * For more information about Ember, visit http://www.emberjs.com
    *
    * ==========================================================================
    */

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals ENV */
    var indexOf = Ember.ArrayUtils.indexOf;

    // ........................................
    // TYPING & ARRAY MESSAGING
    //

    var TYPE_MAP = {};
    var t = "Boolean Number String Function Array Date RegExp Object".split(" ");
    Ember.ArrayUtils.forEach(t, function (name) {
        TYPE_MAP["[object " + name + "]"] = name.toLowerCase();
    });

    var toString = Object.prototype.toString;

    /**
    Returns a consistent type for the passed item.

    Use this instead of the built-in Ember.typeOf() to get the type of an item.
    It will return the same result across all browsers and includes a bit
    more detail.  Here is what will be returned:

    | Return Value  | Meaning                                              |
    |---------------|------------------------------------------------------|
    | 'string'      | String primitive                                     |
    | 'number'      | Number primitive                                     |
    | 'boolean'     | Boolean primitive                                    |
    | 'null'        | Null value                                           |
    | 'undefined'   | Undefined value                                      |
    | 'function'    | A function                                           |
    | 'array'       | An instance of Array                                 |
    | 'class'       | A Ember class (created using Ember.Object.extend())  |
    | 'instance'    | A Ember object instance                              |
    | 'error'       | An instance of the Error object                      |
    | 'object'      | A JavaScript object not inheriting from Ember.Object |

    Examples:

    Ember.typeOf();                      => 'undefined'
    Ember.typeOf(null);                  => 'null'
    Ember.typeOf(undefined);             => 'undefined'
    Ember.typeOf('michael');             => 'string'
    Ember.typeOf(101);                   => 'number'
    Ember.typeOf(true);                  => 'boolean'
    Ember.typeOf(Ember.makeArray);       => 'function'
    Ember.typeOf([1,2,90]);              => 'array'
    Ember.typeOf(Ember.Object.extend()); => 'class'
    Ember.typeOf(Ember.Object.create()); => 'instance'
    Ember.typeOf(new Error('teamocil')); => 'error'

    // "normal" JavaScript object
    Ember.typeOf({a: 'b'});              => 'object'

    @param item {Object} the item to check
    @returns {String} the type
    */
    Ember.typeOf = function (item) {
        var ret;

        ret = (item === null || item === undefined) ? String(item) : TYPE_MAP[toString.call(item)] || 'object';

        if (ret === 'function') {
            if (Ember.Object && Ember.Object.detect(item)) ret = 'class';
        } else if (ret === 'object') {
            if (item instanceof Error) ret = 'error';
            else if (Ember.Object && item instanceof Ember.Object) ret = 'instance';
            else ret = 'object';
        }

        return ret;
    };

    /**
    Returns true if the passed value is null or undefined.  This avoids errors
    from JSLint complaining about use of ==, which can be technically
    confusing.

    Ember.none();             => true
    Ember.none(null);         => true
    Ember.none(undefined);    => true
    Ember.none('');           => false
    Ember.none([]);           => false
    Ember.none(function(){}); => false

    @param {Object} obj Value to test
    @returns {Boolean}
    */
    Ember.none = function (obj) {
        return obj === null || obj === undefined;
    };

    /**
    Verifies that a value is null or an empty string | array | function.

    Constrains the rules on `Ember.none` by returning false for empty
    string and empty arrays.

    Ember.empty();               => true
    Ember.empty(null);           => true
    Ember.empty(undefined);      => true
    Ember.empty('');             => true
    Ember.empty([]);             => true
    Ember.empty('tobias f眉nke'); => false
    Ember.empty([0,1,2]);        => false

    @param {Object} obj Value to test
    @returns {Boolean}
    */
    Ember.empty = function (obj) {
        return obj === null || obj === undefined || (obj.length === 0 && typeof obj !== 'function');
    };

    /**
    This will compare two javascript values of possibly different types.
    It will tell you which one is greater than the other by returning:

    - -1 if the first is smaller than the second,
    - 0 if both are equal,
    - 1 if the first is greater than the second.

    The order is calculated based on Ember.ORDER_DEFINITION, if types are different.
    In case they have the same type an appropriate comparison for this type is made.

    Ember.compare('hello', 'hello');  => 0
    Ember.compare('abc', 'dfg');      => -1
    Ember.compare(2, 1);              => 1

    @param {Object} v First value to compare
    @param {Object} w Second value to compare
    @returns {Number} -1 if v < w, 0 if v = w and 1 if v > w.
    */
    Ember.compare = function compare(v, w) {
        if (v === w) { return 0; }

        var type1 = Ember.typeOf(v);
        var type2 = Ember.typeOf(w);

        var Comparable = Ember.Comparable;
        if (Comparable) {
            if (type1 === 'instance' && Comparable.detect(v.constructor)) {
                return v.constructor.compare(v, w);
            }

            if (type2 === 'instance' && Comparable.detect(w.constructor)) {
                return 1 - w.constructor.compare(w, v);
            }
        }

        // If we haven't yet generated a reverse-mapping of Ember.ORDER_DEFINITION,
        // do so now.
        var mapping = Ember.ORDER_DEFINITION_MAPPING;
        if (!mapping) {
            var order = Ember.ORDER_DEFINITION;
            mapping = Ember.ORDER_DEFINITION_MAPPING = {};
            var idx, len;
            for (idx = 0, len = order.length; idx < len; ++idx) {
                mapping[order[idx]] = idx;
            }

            // We no longer need Ember.ORDER_DEFINITION.
            delete Ember.ORDER_DEFINITION;
        }

        var type1Index = mapping[type1];
        var type2Index = mapping[type2];

        if (type1Index < type2Index) { return -1; }
        if (type1Index > type2Index) { return 1; }

        // types are equal - so we have to check values now
        switch (type1) {
            case 'boolean':
            case 'number':
                if (v < w) { return -1; }
                if (v > w) { return 1; }
                return 0;

            case 'string':
                var comp = v.localeCompare(w);
                if (comp < 0) { return -1; }
                if (comp > 0) { return 1; }
                return 0;

            case 'array':
                var vLen = v.length;
                var wLen = w.length;
                var l = Math.min(vLen, wLen);
                var r = 0;
                var i = 0;
                while (r === 0 && i < l) {
                    r = compare(v[i], w[i]);
                    i++;
                }
                if (r !== 0) { return r; }

                // all elements are equal now
                // shorter array should be ordered first
                if (vLen < wLen) { return -1; }
                if (vLen > wLen) { return 1; }
                // arrays are equal now
                return 0;

            case 'instance':
                if (Ember.Comparable && Ember.Comparable.detect(v)) {
                    return v.compare(v, w);
                }
                return 0;

            default:
                return 0;
        }
    };

    /** @private */
    function _copy(obj, deep, seen, copies) {
        var ret, loc, key;

        // primitive data types are immutable, just return them.
        if ('object' !== typeof obj || obj === null) return obj;

        // avoid cyclical loops
        if (deep && (loc = indexOf(seen, obj)) >= 0) return copies[loc];

        Ember.assert('Cannot clone an Ember.Object that does not implement Ember.Copyable', !(obj instanceof Ember.Object) || (Ember.Copyable && Ember.Copyable.detect(obj)));

        // IMPORTANT: this specific test will detect a native array only.  Any other
        // object will need to implement Copyable.
        if (Ember.typeOf(obj) === 'array') {
            ret = obj.slice();
            if (deep) {
                loc = ret.length;
                while (--loc >= 0) ret[loc] = _copy(ret[loc], deep, seen, copies);
            }
        } else if (Ember.Copyable && Ember.Copyable.detect(obj)) {
            ret = obj.copy(deep, seen, copies);
        } else {
            ret = {};
            for (key in obj) {
                if (!obj.hasOwnProperty(key)) continue;
                ret[key] = deep ? _copy(obj[key], deep, seen, copies) : obj[key];
            }
        }

        if (deep) {
            seen.push(obj);
            copies.push(ret);
        }

        return ret;
    }

    /**
    Creates a clone of the passed object. This function can take just about
    any type of object and create a clone of it, including primitive values
    (which are not actually cloned because they are immutable).

    If the passed object implements the clone() method, then this function
    will simply call that method and return the result.

    @param {Object} object The object to clone
    @param {Boolean} deep If true, a deep copy of the object is made
    @returns {Object} The cloned object
    */
    Ember.copy = function (obj, deep) {
        // fast paths
        if ('object' !== typeof obj || obj === null) return obj; // can't copy primitives
        if (Ember.Copyable && Ember.Copyable.detect(obj)) return obj.copy(deep);
        return _copy(obj, deep, deep ? [] : null, deep ? [] : null);
    };

    /**
    Convenience method to inspect an object. This method will attempt to
    convert the object into a useful string description.

    @param {Object} obj The object you want to inspect.
    @returns {String} A description of the object
    */
    Ember.inspect = function (obj) {
        var v, ret = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                v = obj[key];
                if (v === 'toString') { continue; } // ignore useless items
                if (Ember.typeOf(v) === 'function') { v = "function() { ... }"; }
                ret.push(key + ": " + v);
            }
        }
        return "{" + ret.join(" , ") + "}";
    };

    /**
    Compares two objects, returning true if they are logically equal.  This is
    a deeper comparison than a simple triple equal. For sets it will compare the
    internal objects.  For any other object that implements `isEqual()` it will 
    respect that method.

    Ember.isEqual('hello', 'hello');  => true
    Ember.isEqual(1, 2);              => false
    Ember.isEqual([4,2], [4,2]);      => false

    @param {Object} a first object to compare
    @param {Object} b second object to compare
    @returns {Boolean}
    */
    Ember.isEqual = function (a, b) {
        if (a && 'function' === typeof a.isEqual) return a.isEqual(b);
        return a === b;
    };

    /**
    @private
    Used by Ember.compare
    */
    Ember.ORDER_DEFINITION = Ember.ENV.ORDER_DEFINITION || [
  'undefined',
  'null',
  'boolean',
  'number',
  'string',
  'array',
  'object',
  'instance',
  'function',
  'class'
];

    /**
    Returns all of the keys defined on an object or hash. This is useful
    when inspecting objects for debugging.  On browsers that support it, this
    uses the native Object.keys implementation.

    @function
    @param {Object} obj
    @returns {Array} Array containing keys of obj
    */
    Ember.keys = Object.keys;

    if (!Ember.keys) {
        Ember.keys = function (obj) {
            var ret = [];
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) { ret.push(key); }
            }
            return ret;
        };
    }

    // ..........................................................
    // ERROR
    //

    /**
    @class

    A subclass of the JavaScript Error object for use in Ember.
    */
    Ember.Error = function () {
        var tmp = Error.prototype.constructor.apply(this, arguments);

        for (var p in tmp) {
            if (tmp.hasOwnProperty(p)) { this[p] = tmp[p]; }
        }
        this.message = tmp.message;
    };

    Ember.Error.prototype = Ember.create(Error.prototype);

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    /** @private **/
    var STRING_DASHERIZE_REGEXP = (/[ _]/g);
    var STRING_DASHERIZE_CACHE = {};
    var STRING_DECAMELIZE_REGEXP = (/([a-z])([A-Z])/g);
    var STRING_CAMELIZE_REGEXP = (/(\-|_|\s)+(.)?/g);
    var STRING_UNDERSCORE_REGEXP_1 = (/([a-z\d])([A-Z]+)/g);
    var STRING_UNDERSCORE_REGEXP_2 = (/\-|\s+/g);

    /**
    Defines the hash of localized strings for the current language.  Used by
    the `Ember.String.loc()` helper.  To localize, add string values to this
    hash.

    @property {String}
    */
    Ember.STRINGS = {};

    /**
    Defines string helper methods including string formatting and localization.
    Unless Ember.EXTEND_PROTOTYPES = false these methods will also be added to the
    String.prototype as well.

    @namespace
    */
    Ember.String = {

        /**
        Apply formatting options to the string.  This will look for occurrences
        of %@ in your string and substitute them with the arguments you pass into
        this method.  If you want to control the specific order of replacement,
        you can add a number after the key as well to indicate which argument
        you want to insert.

        Ordered insertions are most useful when building loc strings where values
        you need to insert may appear in different orders.

        "Hello %@ %@".fmt('John', 'Doe') => "Hello John Doe"
        "Hello %@2, %@1".fmt('John', 'Doe') => "Hello Doe, John"

        @param {Object...} [args]
        @returns {String} formatted string
        */
        fmt: function (str, formats) {
            // first, replace any ORDERED replacements.
            var idx = 0; // the current index for non-numerical replacements
            return str.replace(/%@([0-9]+)?/g, function (s, argIndex) {
                argIndex = (argIndex) ? parseInt(argIndex, 0) - 1 : idx++;
                s = formats[argIndex];
                return ((s === null) ? '(null)' : (s === undefined) ? '' : s).toString();
            });
        },

        /**
        Formats the passed string, but first looks up the string in the localized
        strings hash.  This is a convenient way to localize text.  See
        `Ember.String.fmt()` for more information on formatting.

        Note that it is traditional but not required to prefix localized string
        keys with an underscore or other character so you can easily identify
        localized strings.

        Ember.STRINGS = {
        '_Hello World': 'Bonjour le monde',
        '_Hello %@ %@': 'Bonjour %@ %@'
        };

        Ember.String.loc("_Hello World");
        => 'Bonjour le monde';

        Ember.String.loc("_Hello %@ %@", ["John", "Smith"]);
        => "Bonjour John Smith";

        @param {String} str
        The string to format

        @param {Array} formats
        Optional array of parameters to interpolate into string.

        @returns {String} formatted string
        */
        loc: function (str, formats) {
            str = Ember.STRINGS[str] || str;
            return Ember.String.fmt(str, formats);
        },

        /**
        Splits a string into separate units separated by spaces, eliminating any
        empty strings in the process.  This is a convenience method for split that
        is mostly useful when applied to the String.prototype.

        Ember.String.w("alpha beta gamma").forEach(function(key) {
        console.log(key);
        });
        > alpha
        > beta
        > gamma

        @param {String} str 
        The string to split

        @returns {String} split string
        */
        w: function (str) { return str.split(/\s+/); },

        /**
        Converts a camelized string into all lower case separated by underscores.
    
        'innerHTML'.decamelize()         => 'inner_html'
        'action_name'.decamelize()       => 'action_name'
        'css-class-name'.decamelize()    => 'css-class-name'
        'my favorite items'.decamelize() => 'my favorite items'

        @param {String} str
        The string to decamelize.

        @returns {String} the decamelized string.
        */
        decamelize: function (str) {
            return str.replace(STRING_DECAMELIZE_REGEXP, '$1_$2').toLowerCase();
        },

        /**
        Replaces underscores or spaces with dashes.
    
        'innerHTML'.dasherize()         => 'inner-html'
        'action_name'.dasherize()       => 'action-name'
        'css-class-name'.dasherize()    => 'css-class-name'
        'my favorite items'.dasherize() => 'my-favorite-items'

        @param {String} str
        The string to dasherize.

        @returns {String} the dasherized string.
        */
        dasherize: function (str) {
            var cache = STRING_DASHERIZE_CACHE,
        ret = cache[str];

            if (ret) {
                return ret;
            } else {
                ret = Ember.String.decamelize(str).replace(STRING_DASHERIZE_REGEXP, '-');
                cache[str] = ret;
            }

            return ret;
        },

        /**
        Returns the lowerCaseCamel form of a string.
    
        'innerHTML'.camelize()         => 'innerHTML'
        'action_name'.camelize()       => 'actionName'
        'css-class-name'.camelize()    => 'cssClassName'
        'my favorite items'.camelize() => 'myFavoriteItems'

        @param {String} str
        The string to camelize.

        @returns {String} the camelized string.
        */
        camelize: function (str) {
            return str.replace(STRING_CAMELIZE_REGEXP, function (match, separator, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },

        /**
        More general than decamelize. Returns the lower_case_and_underscored
        form of a string.

        'innerHTML'.underscore()         => 'inner_html'
        'action_name'.underscore()       => 'action_name'
        'css-class-name'.underscore()    => 'css_class_name'
        'my favorite items'.underscore() => 'my_favorite_items'

        @param {String} str
        The string to underscore.

        @returns {String} the underscored string.
        */
        underscore: function (str) {
            return str.replace(STRING_UNDERSCORE_REGEXP_1, '$1_$2').
      replace(STRING_UNDERSCORE_REGEXP_2, '_').toLowerCase();
        }
    };
})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var fmt = Ember.String.fmt,
    w = Ember.String.w,
    loc = Ember.String.loc,
    camelize = Ember.String.camelize,
    decamelize = Ember.String.decamelize,
    dasherize = Ember.String.dasherize,
    underscore = Ember.String.underscore;

    if (Ember.EXTEND_PROTOTYPES) {

        /**
        @see Ember.String.fmt
        */
        String.prototype.fmt = function () {
            return fmt(this, arguments);
        };

        /**
        @see Ember.String.w
        */
        String.prototype.w = function () {
            return w(this);
        };

        /**
        @see Ember.String.loc
        */
        String.prototype.loc = function () {
            return loc(this, arguments);
        };

        /**
        @see Ember.String.camelize
        */
        String.prototype.camelize = function () {
            return camelize(this);
        };

        /**
        @see Ember.String.decamelize
        */
        String.prototype.decamelize = function () {
            return decamelize(this);
        };

        /**
        @see Ember.String.dasherize
        */
        String.prototype.dasherize = function () {
            return dasherize(this);
        };

        /**
        @see Ember.String.underscore
        */
        String.prototype.underscore = function () {
            return underscore(this);
        };

    }


})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var a_slice = Array.prototype.slice;

    if (Ember.EXTEND_PROTOTYPES) {

        /**
        The `property` extension of Javascript's Function prototype is available
        when Ember.EXTEND_PROTOTYPES is true, which is the default. 

        Computed properties allow you to treat a function like a property:

        MyApp.president = Ember.Object.create({
        firstName: "Barack",
        lastName: "Obama",

        fullName: function() {
        return this.get('firstName') + ' ' + this.get('lastName');

        // Call this flag to mark the function as a property
        }.property()
        });

        MyApp.president.get('fullName');    => "Barack Obama"

        Treating a function like a property is useful because they can work with
        bindings, just like any other property.

        Many computed properties have dependencies on other properties. For
        example, in the above example, the `fullName` property depends on
        `firstName` and `lastName` to determine its value. You can tell Ember.js
        about these dependencies like this:

        MyApp.president = Ember.Object.create({
        firstName: "Barack",
        lastName: "Obama",

        fullName: function() {
        return this.get('firstName') + ' ' + this.get('lastName');

        // Tell Ember.js that this computed property depends on firstName
        // and lastName
        }.property('firstName', 'lastName')
        });

        Make sure you list these dependencies so Ember.js knows when to update
        bindings that connect to a computed property. Changing a dependency
        will not immediately trigger an update of the computed property, but
        will instead clear the cache so that it is updated when the next `get`
        is called on the property.

        Note: you will usually want to use `property(...)` with `cacheable()`.

        @see Ember.ComputedProperty
        @see Ember.computed
        */
        Function.prototype.property = function () {
            var ret = Ember.computed(this);
            return ret.property.apply(ret, arguments);
        };

        /**
        The `observes` extension of Javascript's Function prototype is available
        when Ember.EXTEND_PROTOTYPES is true, which is the default. 

        You can observe property changes simply by adding the `observes`
        call to the end of your method declarations in classes that you write.
        For example:

        Ember.Object.create({
        valueObserver: function() {
        // Executes whenever the "value" property changes
        }.observes('value')
        });
    
        @see Ember.Observable
        */
        Function.prototype.observes = function () {
            this.__ember_observes__ = a_slice.call(arguments);
            return this;
        };

        /**
        The `observesBefore` extension of Javascript's Function prototype is
        available when Ember.EXTEND_PROTOTYPES is true, which is the default. 

        You can get notified when a property changes is about to happen by
        by adding the `observesBefore` call to the end of your method
        declarations in classes that you write. For example:

        Ember.Object.create({
        valueObserver: function() {
        // Executes whenever the "value" property is about to change
        }.observesBefore('value')
        });
    
        @see Ember.Observable
        */
        Function.prototype.observesBefore = function () {
            this.__ember_observesBefore__ = a_slice.call(arguments);
            return this;
        };

    }


})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================





    // ..........................................................
    // HELPERS
    //

    var get = Ember.get, set = Ember.set;
    var a_slice = Array.prototype.slice;
    var a_indexOf = Ember.ArrayUtils.indexOf;

    var contexts = [];
    /** @private */
    function popCtx() {
        return contexts.length === 0 ? {} : contexts.pop();
    }

    /** @private */
    function pushCtx(ctx) {
        contexts.push(ctx);
        return null;
    }

    /** @private */
    function iter(key, value) {
        var valueProvided = arguments.length === 2;

        function i(item) {
            var cur = get(item, key);
            return valueProvided ? value === cur : !!cur;
        }
        return i;
    }

    /** @private */
    function xform(target, method, params) {
        method.call(target, params[0], params[2], params[3]);
    }

    /**
    @class

    This mixin defines the common interface implemented by enumerable objects
    in Ember.  Most of these methods follow the standard Array iteration
    API defined up to JavaScript 1.8 (excluding language-specific features that
    cannot be emulated in older versions of JavaScript).

    This mixin is applied automatically to the Array class on page load, so you
    can use any of these methods on simple arrays.  If Array already implements
    one of these methods, the mixin will not override them.

    h3. Writing Your Own Enumerable

    To make your own custom class enumerable, you need two items:

    1. You must have a length property.  This property should change whenever
    the number of items in your enumerable object changes.  If you using this
    with an Ember.Object subclass, you should be sure to change the length
    property using set().

    2. If you must implement nextObject().  See documentation.

    Once you have these two methods implement, apply the Ember.Enumerable mixin
    to your class and you will be able to enumerate the contents of your object
    like any other collection.

    h3. Using Ember Enumeration with Other Libraries

    Many other libraries provide some kind of iterator or enumeration like
    facility.  This is often where the most common API conflicts occur.
    Ember's API is designed to be as friendly as possible with other
    libraries by implementing only methods that mostly correspond to the
    JavaScript 1.8 API.

    @since Ember 0.9
    */
    Ember.Enumerable = Ember.Mixin.create( /** @lends Ember.Enumerable */{

    /** @private - compatibility */
    isEnumerable: true,

    /**
    Implement this method to make your class enumerable.

    This method will be call repeatedly during enumeration.  The index value
    will always begin with 0 and increment monotonically.  You don't have to
    rely on the index value to determine what object to return, but you should
    always check the value and start from the beginning when you see the
    requested index is 0.

    The previousObject is the object that was returned from the last call
    to nextObject for the current iteration.  This is a useful way to
    manage iteration if you are tracing a linked list, for example.

    Finally the context parameter will always contain a hash you can use as
    a "scratchpad" to maintain any other state you need in order to iterate
    properly.  The context object is reused and is not reset between
    iterations so make sure you setup the context with a fresh state whenever
    the index parameter is 0.

    Generally iterators will continue to call nextObject until the index
    reaches the your current length-1.  If you run out of data before this
    time for some reason, you should simply return undefined.

    The default implementation of this method simply looks up the index.
    This works great on any Array-like objects.

    @param index {Number} the current index of the iteration
    @param previousObject {Object} the value returned by the last call to nextObject.
    @param context {Object} a context object you can use to maintain state.
    @returns {Object} the next object in the iteration or undefined
    */
    nextObject: Ember.required(Function),

    /**
    Helper method returns the first object from a collection.  This is usually
    used by bindings and other parts of the framework to extract a single
    object if the enumerable contains only one item.

    If you override this method, you should implement it so that it will
    always return the same value each time it is called.  If your enumerable
    contains only one object, this method should always return that object.
    If your enumerable is empty, this method should return undefined.

    var arr = ["a", "b", "c"];
    arr.firstObject(); => "a"

    var arr = [];
    arr.firstObject(); => undefined

    @returns {Object} the object or undefined
    */
    firstObject: Ember.computed(function () {
        if (get(this, 'length') === 0) return undefined;

        // handle generic enumerables
        var context = popCtx(), ret;
        ret = this.nextObject(0, null, context);
        pushCtx(context);
        return ret;
    }).property('[]').cacheable(),

    /**
    Helper method returns the last object from a collection. If your enumerable
    contains only one object, this method should always return that object.
    If your enumerable is empty, this method should return undefined.

    var arr = ["a", "b", "c"];
    arr.lastObject(); => "c"

    var arr = [];
    arr.lastObject(); => undefined

    @returns {Object} the last object or undefined
    */
    lastObject: Ember.computed(function () {
        var len = get(this, 'length');
        if (len === 0) return undefined;
        var context = popCtx(), idx = 0, cur, last = null;
        do {
            last = cur;
            cur = this.nextObject(idx++, last, context);
        } while (cur !== undefined);
        pushCtx(context);
        return last;
    }).property('[]').cacheable(),

    /**
    Returns true if the passed object can be found in the receiver.  The
    default version will iterate through the enumerable until the object
    is found.  You may want to override this with a more efficient version.

    var arr = ["a", "b", "c"];
    arr.contains("a"); => true
    arr.contains("z"); => false

    @param {Object} obj
    The object to search for.

    @returns {Boolean} true if object is found in enumerable.
    */
    contains: function (obj) {
        return this.find(function (item) { return item === obj; }) !== undefined;
    },

    /**
    Iterates through the enumerable, calling the passed function on each
    item. This method corresponds to the forEach() method defined in
    JavaScript 1.6.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(item, index, enumerable);

    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as "this" on the context. This is a good way
    to give your iterator function access to the current object.

    @param {Function} callback The callback to execute
    @param {Object} target The target object to use
    @returns {Object} receiver
    */
    forEach: function (callback, target) {
        if (typeof callback !== "function") throw new TypeError();
        var len = get(this, 'length'), last = null, context = popCtx();

        if (target === undefined) target = null;

        for (var idx = 0; idx < len; idx++) {
            var next = this.nextObject(idx, last, context);
            callback.call(target, next, idx, this);
            last = next;
        }
        last = null;
        context = pushCtx(context);
        return this;
    },

    /**
    Alias for mapProperty

    @params key {String} name of the property
    @returns {Array} The mapped array.
    */
    getEach: function (key) {
        return this.mapProperty(key);
    },

    /**
    Sets the value on the named property for each member. This is more
    efficient than using other methods defined on this helper. If the object
    implements Ember.Observable, the value will be changed to set(), otherwise
    it will be set directly. null objects are skipped.

    @param {String} key The key to set
    @param {Object} value The object to set
    @returns {Object} receiver
    */
    setEach: function (key, value) {
        return this.forEach(function (item) {
            set(item, key, value);
        });
    },

    /**
    Maps all of the items in the enumeration to another value, returning
    a new array. This method corresponds to map() defined in JavaScript 1.6.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(item, index, enumerable);

    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    It should return the mapped value.

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as "this" on the context. This is a good way
    to give your iterator function access to the current object.

    @param {Function} callback The callback to execute
    @param {Object} target The target object to use
    @returns {Array} The mapped array.
    */
    map: function (callback, target) {
        var ret = [];
        this.forEach(function (x, idx, i) {
            ret[idx] = callback.call(target, x, idx, i);
        });
        return ret;
    },

    /**
    Similar to map, this specialized function returns the value of the named
    property on all items in the enumeration.

    @params key {String} name of the property
    @returns {Array} The mapped array.
    */
    mapProperty: function (key) {
        return this.map(function (next) {
            return get(next, key);
        });
    },

    /**
    Returns an array with all of the items in the enumeration that the passed
    function returns true for. This method corresponds to filter() defined in
    JavaScript 1.6.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(item, index, enumerable);

    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    It should return the true to include the item in the results, false otherwise.

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as "this" on the context. This is a good way
    to give your iterator function access to the current object.

    @param {Function} callback The callback to execute
    @param {Object} target The target object to use
    @returns {Array} A filtered array.
    */
    filter: function (callback, target) {
        var ret = [];
        this.forEach(function (x, idx, i) {
            if (callback.call(target, x, idx, i)) ret.push(x);
        });
        return ret;
    },

    /**
    Returns an array with just the items with the matched property.  You
    can pass an optional second argument with the target value.  Otherwise
    this will match any property that evaluates to true.

    @params key {String} the property to test
    @param value {String} optional value to test against.
    @returns {Array} filtered array
    */
    filterProperty: function (key, value) {
        return this.filter(iter.apply(this, arguments));
    },

    /**
    Returns the first item in the array for which the callback returns true.
    This method works similar to the filter() method defined in JavaScript 1.6
    except that it will stop working on the array once a match is found.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(item, index, enumerable);

    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    It should return the true to include the item in the results, false otherwise.

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as "this" on the context. This is a good way
    to give your iterator function access to the current object.

    @param {Function} callback The callback to execute
    @param {Object} target The target object to use
    @returns {Object} Found item or null.
    */
    find: function (callback, target) {
        var len = get(this, 'length');
        if (target === undefined) target = null;

        var last = null, next, found = false, ret;
        var context = popCtx();
        for (var idx = 0; idx < len && !found; idx++) {
            next = this.nextObject(idx, last, context);
            if (found = callback.call(target, next, idx, this)) ret = next;
            last = next;
        }
        next = last = null;
        context = pushCtx(context);
        return ret;
    },

    /**
    Returns an the first item with a property matching the passed value.  You
    can pass an optional second argument with the target value.  Otherwise
    this will match any property that evaluates to true.

    This method works much like the more generic find() method.

    @params key {String} the property to test
    @param value {String} optional value to test against.
    @returns {Object} found item or null
    */
    findProperty: function (key, value) {
        return this.find(iter.apply(this, arguments));
    },

    /**
    Returns true if the passed function returns true for every item in the
    enumeration. This corresponds with the every() method in JavaScript 1.6.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(item, index, enumerable);

    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    It should return the true or false.

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as "this" on the context. This is a good way
    to give your iterator function access to the current object.

    Example Usage:

    if (people.every(isEngineer)) { Paychecks.addBigBonus(); }

    @param {Function} callback The callback to execute
    @param {Object} target The target object to use
    @returns {Boolean}
    */
    every: function (callback, target) {
        return !this.find(function (x, idx, i) {
            return !callback.call(target, x, idx, i);
        });
    },

    /**
    Returns true if the passed property resolves to true for all items in the
    enumerable.  This method is often simpler/faster than using a callback.

    @params key {String} the property to test
    @param value {String} optional value to test against.
    @returns {Array} filtered array
    */
    everyProperty: function (key, value) {
        return this.every(iter.apply(this, arguments));
    },


    /**
    Returns true if the passed function returns true for any item in the
    enumeration. This corresponds with the every() method in JavaScript 1.6.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(item, index, enumerable);

    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    It should return the true to include the item in the results, false otherwise.

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as "this" on the context. This is a good way
    to give your iterator function access to the current object.

    Usage Example:

    if (people.some(isManager)) { Paychecks.addBiggerBonus(); }

    @param {Function} callback The callback to execute
    @param {Object} target The target object to use
    @returns {Array} A filtered array.
    */
    some: function (callback, target) {
        return !!this.find(function (x, idx, i) {
            return !!callback.call(target, x, idx, i);
        });
    },

    /**
    Returns true if the passed property resolves to true for any item in the
    enumerable.  This method is often simpler/faster than using a callback.

    @params key {String} the property to test
    @param value {String} optional value to test against.
    @returns {Boolean} true
    */
    someProperty: function (key, value) {
        return this.some(iter.apply(this, arguments));
    },

    /**
    This will combine the values of the enumerator into a single value. It
    is a useful way to collect a summary value from an enumeration. This
    corresponds to the reduce() method defined in JavaScript 1.8.

    The callback method you provide should have the following signature (all
    parameters are optional):

    function(previousValue, item, index, enumerable);

    - *previousValue* is the value returned by the last call to the iterator.
    - *item* is the current item in the iteration.
    - *index* is the current index in the iteration
    - *enumerable* is the enumerable object itself.

    Return the new cumulative value.

    In addition to the callback you can also pass an initialValue. An error
    will be raised if you do not pass an initial value and the enumerator is
    empty.

    Note that unlike the other methods, this method does not allow you to
    pass a target object to set as this for the callback. It's part of the
    spec. Sorry.

    @param {Function} callback The callback to execute
    @param {Object} initialValue Initial value for the reduce
    @param {String} reducerProperty internal use only.
    @returns {Object} The reduced value.
    */
    reduce: function (callback, initialValue, reducerProperty) {
        if (typeof callback !== "function") { throw new TypeError(); }

        var ret = initialValue;

        this.forEach(function (item, i) {
            ret = callback.call(null, ret, item, i, this, reducerProperty);
        }, this);

        return ret;
    },

    /**
    Invokes the named method on every object in the receiver that
    implements it.  This method corresponds to the implementation in
    Prototype 1.6.

    @param methodName {String} the name of the method
    @param args {Object...} optional arguments to pass as well.
    @returns {Array} return values from calling invoke.
    */
    invoke: function (methodName) {
        var args, ret = [];
        if (arguments.length > 1) args = a_slice.call(arguments, 1);

        this.forEach(function (x, idx) {
            var method = x && x[methodName];
            if ('function' === typeof method) {
                ret[idx] = args ? method.apply(x, args) : method.call(x);
            }
        }, this);

        return ret;
    },

    /**
    Simply converts the enumerable into a genuine array.  The order is not
    guaranteed.  Corresponds to the method implemented by Prototype.

    @returns {Array} the enumerable as an array.
    */
    toArray: function () {
        var ret = [];
        this.forEach(function (o, idx) { ret[idx] = o; });
        return ret;
    },

    /**
    Returns a copy of the array with all null elements removed.
    
    var arr = ["a", null, "c", null];
    arr.compact(); => ["a", "c"] 

    @returns {Array} the array without null elements.
    */
    compact: function () { return this.without(null); },

    /**
    Returns a new enumerable that excludes the passed value.  The default
    implementation returns an array regardless of the receiver type unless
    the receiver does not contain the value.

    var arr = ["a", "b", "a", "c"];
    arr.without("a"); => ["b", "c"]

    @param {Object} value
    @returns {Ember.Enumerable}
    */
    without: function (value) {
        if (!this.contains(value)) return this; // nothing to do
        var ret = [];
        this.forEach(function (k) {
            if (k !== value) ret[ret.length] = k;
        });
        return ret;
    },

    /**
    Returns a new enumerable that contains only unique values.  The default
    implementation returns an array regardless of the receiver type.

    var arr = ["a", "a", "b", "b"];
    arr.uniq(); => ["a", "b"]

    @returns {Ember.Enumerable}
    */
    uniq: function () {
        var ret = [];
        this.forEach(function (k) {
            if (a_indexOf(ret, k) < 0) ret.push(k);
        });
        return ret;
    },

    /**
    This property will trigger anytime the enumerable's content changes.
    You can observe this property to be notified of changes to the enumerables
    content.

    For plain enumerables, this property is read only.  Ember.Array overrides
    this method.

    @property {Ember.Array}
    */
    '[]': Ember.computed(function (key, value) {
        return this;
    }).property().cacheable(),

    // ..........................................................
    // ENUMERABLE OBSERVERS
    //

    /**
    Registers an enumerable observer.   Must implement Ember.EnumerableObserver
    mixin.
    */
    addEnumerableObserver: function (target, opts) {
        var willChange = (opts && opts.willChange) || 'enumerableWillChange',
        didChange = (opts && opts.didChange) || 'enumerableDidChange';

        var hasObservers = get(this, 'hasEnumerableObservers');
        if (!hasObservers) Ember.propertyWillChange(this, 'hasEnumerableObservers');
        Ember.addListener(this, '@enumerable:before', target, willChange, xform);
        Ember.addListener(this, '@enumerable:change', target, didChange, xform);
        if (!hasObservers) Ember.propertyDidChange(this, 'hasEnumerableObservers');
        return this;
    },

    /**
    Removes a registered enumerable observer.
    */
    removeEnumerableObserver: function (target, opts) {
        var willChange = (opts && opts.willChange) || 'enumerableWillChange',
        didChange = (opts && opts.didChange) || 'enumerableDidChange';

        var hasObservers = get(this, 'hasEnumerableObservers');
        if (hasObservers) Ember.propertyWillChange(this, 'hasEnumerableObservers');
        Ember.removeListener(this, '@enumerable:before', target, willChange);
        Ember.removeListener(this, '@enumerable:change', target, didChange);
        if (hasObservers) Ember.propertyDidChange(this, 'hasEnumerableObservers');
        return this;
    },

    /**
    Becomes true whenever the array currently has observers watching changes
    on the array.

    @property {Boolean}
    */
    hasEnumerableObservers: Ember.computed(function () {
        return Ember.hasListeners(this, '@enumerable:change') || Ember.hasListeners(this, '@enumerable:before');
    }).property().cacheable(),


    /**
    Invoke this method just before the contents of your enumerable will
    change.  You can either omit the parameters completely or pass the objects
    to be removed or added if available or just a count.

    @param {Ember.Enumerable|Number} removing
    An enumerable of the objects to be removed or the number of items to
    be removed.

    @param {Ember.Enumerable|Number} adding
    An enumerable of the objects to be added or the number of items to be
    added.

    @returns {Ember.Enumerable} receiver
    */
    enumerableContentWillChange: function (removing, adding) {

        var removeCnt, addCnt, hasDelta;

        if ('number' === typeof removing) removeCnt = removing;
        else if (removing) removeCnt = get(removing, 'length');
        else removeCnt = removing = -1;

        if ('number' === typeof adding) addCnt = adding;
        else if (adding) addCnt = get(adding, 'length');
        else addCnt = adding = -1;

        hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;

        if (removing === -1) removing = null;
        if (adding === -1) adding = null;

        Ember.propertyWillChange(this, '[]');
        if (hasDelta) Ember.propertyWillChange(this, 'length');
        Ember.sendEvent(this, '@enumerable:before', removing, adding);

        return this;
    },

    /**
    Invoke this method when the contents of your enumerable has changed.
    This will notify any observers watching for content changes.  If your are
    implementing an ordered enumerable (such as an array), also pass the
    start and end values where the content changed so that it can be used to
    notify range observers.

    @param {Number} start
    optional start offset for the content change.  For unordered
    enumerables, you should always pass -1.

    @param {Ember.Enumerable|Number} removing
    An enumerable of the objects to be removed or the number of items to
    be removed.

    @param {Ember.Enumerable|Numbe} adding
    An enumerable of the objects to be added or the number of items to be
    added.

    @returns {Object} receiver
    */
    enumerableContentDidChange: function (removing, adding) {
        var notify = this.propertyDidChange, removeCnt, addCnt, hasDelta;

        if ('number' === typeof removing) removeCnt = removing;
        else if (removing) removeCnt = get(removing, 'length');
        else removeCnt = removing = -1;

        if ('number' === typeof adding) addCnt = adding;
        else if (adding) addCnt = get(adding, 'length');
        else addCnt = adding = -1;

        hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;

        if (removing === -1) removing = null;
        if (adding === -1) adding = null;

        Ember.sendEvent(this, '@enumerable:change', removing, adding);
        if (hasDelta) Ember.propertyDidChange(this, 'length');
        Ember.propertyDidChange(this, '[]');

        return this;
    }

});




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    // ..........................................................
    // HELPERS
    //

    var get = Ember.get, set = Ember.set, meta = Ember.meta, map = Ember.ArrayUtils.map, cacheFor = Ember.cacheFor;

    /** @private */
    function none(obj) { return obj === null || obj === undefined; }

    /** @private */
    function xform(target, method, params) {
        method.call(target, params[0], params[2], params[3], params[4]);
    }

    // ..........................................................
    // ARRAY
    //
    /**
    @namespace

    This module implements Observer-friendly Array-like behavior.  This mixin is
    picked up by the Array class as well as other controllers, etc. that want to
    appear to be arrays.

    Unlike Ember.Enumerable, this mixin defines methods specifically for
    collections that provide index-ordered access to their contents.  When you
    are designing code that needs to accept any kind of Array-like object, you
    should use these methods instead of Array primitives because these will
    properly notify observers of changes to the array.

    Although these methods are efficient, they do add a layer of indirection to
    your application so it is a good idea to use them only when you need the
    flexibility of using both true JavaScript arrays and "virtual" arrays such
    as controllers and collections.

    You can use the methods defined in this module to access and modify array
    contents in a KVO-friendly way.  You can also be notified whenever the
    membership if an array changes by changing the syntax of the property to
    .observes('*myProperty.[]') .

    To support Ember.Array in your own class, you must override two
    primitives to use it: replace() and objectAt().

    Note that the Ember.Array mixin also incorporates the Ember.Enumerable mixin.  All
    Ember.Array-like objects are also enumerable.

    @extends Ember.Enumerable
    @since Ember 0.9.0
    */
    Ember.Array = Ember.Mixin.create(Ember.Enumerable, /** @scope Ember.Array.prototype */{

    /** @private - compatibility */
    isSCArray: true,

    /**
    @field {Number} length

    Your array must support the length property.  Your replace methods should
    set this property whenever it changes.
    */
    length: Ember.required(),

    /**
    This is one of the primitives you must implement to support Ember.Array.
    Returns the object at the named index.  If your object supports retrieving
    the value of an array item using get() (i.e. myArray.get(0)), then you do
    not need to implement this method yourself.

    @param {Number} idx
    The index of the item to return.  If idx exceeds the current length,
    return null.
    */
    objectAt: function (idx) {
        if ((idx < 0) || (idx >= get(this, 'length'))) return undefined;
        return get(this, idx);
    },

    /**
    This returns the objects at the specified indexes, using objectAt.

    @param {Array} indexes
    An array of indexes of items to return.
    */
    objectsAt: function (indexes) {
        var self = this;
        return map(indexes, function (idx) { return self.objectAt(idx); });
    },

    /** @private (nodoc) - overrides Ember.Enumerable version */
    nextObject: function (idx) {
        return this.objectAt(idx);
    },

    /**
    @field []

    This is the handler for the special array content property.  If you get
    this property, it will return this.  If you set this property it a new
    array, it will replace the current content.

    This property overrides the default property defined in Ember.Enumerable.
    */
    '[]': Ember.computed(function (key, value) {
        if (value !== undefined) this.replace(0, get(this, 'length'), value);
        return this;
    }).property().cacheable(),

    firstObject: Ember.computed(function () {
        return this.objectAt(0);
    }).property().cacheable(),

    lastObject: Ember.computed(function () {
        return this.objectAt(get(this, 'length') - 1);
    }).property().cacheable(),

    /** @private (nodoc) - optimized version from Enumerable */
    contains: function (obj) {
        return this.indexOf(obj) >= 0;
    },

    // Add any extra methods to Ember.Array that are native to the built-in Array.
    /**
    Returns a new array that is a slice of the receiver.  This implementation
    uses the observable array methods to retrieve the objects for the new
    slice.

    var arr = ['red', 'green', 'blue'];
    arr.slice(0);      => ['red', 'green', 'blue']
    arr.slice(0, 2);   => ['red', 'green']
    arr.slice(1, 100); => ['green', 'blue']

    @param beginIndex {Integer} (Optional) index to begin slicing from.
    @param endIndex {Integer} (Optional) index to end the slice at.
    @returns {Array} New array with specified slice
    */
    slice: function (beginIndex, endIndex) {
        var ret = [];
        var length = get(this, 'length');
        if (none(beginIndex)) beginIndex = 0;
        if (none(endIndex) || (endIndex > length)) endIndex = length;
        while (beginIndex < endIndex) {
            ret[ret.length] = this.objectAt(beginIndex++);
        }
        return ret;
    },

    /**
    Returns the index of the given object's first occurrence.
    If no startAt argument is given, the starting location to
    search is 0. If it's negative, will count backward from
    the end of the array. Returns -1 if no match is found.

    var arr = ["a", "b", "c", "d", "a"];
    arr.indexOf("a");      =>  0
    arr.indexOf("z");      => -1
    arr.indexOf("a", 2);   =>  4
    arr.indexOf("a", -1);  =>  4
    arr.indexOf("b", 3);   => -1
    arr.indexOf("a", 100); => -1

    @param {Object} object the item to search for
    @param {Number} startAt optional starting location to search, default 0
    @returns {Number} index or -1 if not found
    */
    indexOf: function (object, startAt) {
        var idx, len = get(this, 'length');

        if (startAt === undefined) startAt = 0;
        if (startAt < 0) startAt += len;

        for (idx = startAt; idx < len; idx++) {
            if (this.objectAt(idx, true) === object) return idx;
        }
        return -1;
    },

    /**
    Returns the index of the given object's last occurrence.
    If no startAt argument is given, the search starts from
    the last position. If it's negative, will count backward
    from the end of the array. Returns -1 if no match is found.

    var arr = ["a", "b", "c", "d", "a"];
    arr.lastIndexOf("a");      =>  4
    arr.lastIndexOf("z");      => -1
    arr.lastIndexOf("a", 2);   =>  0
    arr.lastIndexOf("a", -1);  =>  4
    arr.lastIndexOf("b", 3);   =>  1
    arr.lastIndexOf("a", 100); =>  4

    @param {Object} object the item to search for
    @param {Number} startAt optional starting location to search, default 0
    @returns {Number} index or -1 if not found
    */
    lastIndexOf: function (object, startAt) {
        var idx, len = get(this, 'length');

        if (startAt === undefined || startAt >= len) startAt = len - 1;
        if (startAt < 0) startAt += len;

        for (idx = startAt; idx >= 0; idx--) {
            if (this.objectAt(idx) === object) return idx;
        }
        return -1;
    },

    // ..........................................................
    // ARRAY OBSERVERS
    //

    /**
    Adds an array observer to the receiving array.  The array observer object
    normally must implement two methods:

    * `arrayWillChange(start, removeCount, addCount)` - This method will be
    called just before the array is modified.
    * `arrayDidChange(start, removeCount, addCount)` - This method will be
    called just after the array is modified.

    Both callbacks will be passed the starting index of the change as well a
    a count of the items to be removed and added.  You can use these callbacks
    to optionally inspect the array during the change, clear caches, or do
    any other bookkeeping necessary.

    In addition to passing a target, you can also include an options hash
    which you can use to override the method names that will be invoked on the
    target.

    @param {Object} target
    The observer object.

    @param {Hash} opts
    Optional hash of configuration options including willChange, didChange,
    and a context option.

    @returns {Ember.Array} receiver
    */
    addArrayObserver: function (target, opts) {
        var willChange = (opts && opts.willChange) || 'arrayWillChange',
        didChange = (opts && opts.didChange) || 'arrayDidChange';

        var hasObservers = get(this, 'hasArrayObservers');
        if (!hasObservers) Ember.propertyWillChange(this, 'hasArrayObservers');
        Ember.addListener(this, '@array:before', target, willChange, xform);
        Ember.addListener(this, '@array:change', target, didChange, xform);
        if (!hasObservers) Ember.propertyDidChange(this, 'hasArrayObservers');
        return this;
    },

    /**
    Removes an array observer from the object if the observer is current
    registered.  Calling this method multiple times with the same object will
    have no effect.

    @param {Object} target
    The object observing the array.

    @returns {Ember.Array} receiver
    */
    removeArrayObserver: function (target, opts) {
        var willChange = (opts && opts.willChange) || 'arrayWillChange',
        didChange = (opts && opts.didChange) || 'arrayDidChange';

        var hasObservers = get(this, 'hasArrayObservers');
        if (hasObservers) Ember.propertyWillChange(this, 'hasArrayObservers');
        Ember.removeListener(this, '@array:before', target, willChange, xform);
        Ember.removeListener(this, '@array:change', target, didChange, xform);
        if (hasObservers) Ember.propertyDidChange(this, 'hasArrayObservers');
        return this;
    },

    /**
    Becomes true whenever the array currently has observers watching changes
    on the array.

    @property {Boolean}
    */
    hasArrayObservers: Ember.computed(function () {
        return Ember.hasListeners(this, '@array:change') || Ember.hasListeners(this, '@array:before');
    }).property().cacheable(),

    /**
    If you are implementing an object that supports Ember.Array, call this
    method just before the array content changes to notify any observers and
    invalidate any related properties.  Pass the starting index of the change
    as well as a delta of the amounts to change.

    @param {Number} startIdx
    The starting index in the array that will change.

    @param {Number} removeAmt
    The number of items that will be removed.  If you pass null assumes 0

    @param {Number} addAmt
    The number of items that will be added.  If you pass null assumes 0.

    @returns {Ember.Array} receiver
    */
    arrayContentWillChange: function (startIdx, removeAmt, addAmt) {

        // if no args are passed assume everything changes
        if (startIdx === undefined) {
            startIdx = 0;
            removeAmt = addAmt = -1;
        } else {
            if (removeAmt === undefined) removeAmt = -1;
            if (addAmt === undefined) addAmt = -1;
        }

        Ember.sendEvent(this, '@array:before', startIdx, removeAmt, addAmt);

        var removing, lim;
        if (startIdx >= 0 && removeAmt >= 0 && get(this, 'hasEnumerableObservers')) {
            removing = [];
            lim = startIdx + removeAmt;
            for (var idx = startIdx; idx < lim; idx++) removing.push(this.objectAt(idx));
        } else {
            removing = removeAmt;
        }

        this.enumerableContentWillChange(removing, addAmt);

        // Make sure the @each proxy is set up if anyone is observing @each
        if (Ember.isWatching(this, '@each')) { get(this, '@each'); }

        return this;
    },

    arrayContentDidChange: function (startIdx, removeAmt, addAmt) {

        // if no args are passed assume everything changes
        if (startIdx === undefined) {
            startIdx = 0;
            removeAmt = addAmt = -1;
        } else {
            if (removeAmt === undefined) removeAmt = -1;
            if (addAmt === undefined) addAmt = -1;
        }

        var adding, lim;
        if (startIdx >= 0 && addAmt >= 0 && get(this, 'hasEnumerableObservers')) {
            adding = [];
            lim = startIdx + addAmt;
            for (var idx = startIdx; idx < lim; idx++) adding.push(this.objectAt(idx));
        } else {
            adding = addAmt;
        }

        this.enumerableContentDidChange(removeAmt, adding);
        Ember.sendEvent(this, '@array:change', startIdx, removeAmt, addAmt);

        var length = get(this, 'length'),
        cachedFirst = cacheFor(this, 'firstObject'),
        cachedLast = cacheFor(this, 'lastObject');
        if (this.objectAt(0) !== cachedFirst) {
            Ember.propertyWillChange(this, 'firstObject');
            Ember.propertyDidChange(this, 'firstObject');
        }
        if (this.objectAt(length - 1) !== cachedLast) {
            Ember.propertyWillChange(this, 'lastObject');
            Ember.propertyDidChange(this, 'lastObject');
        }

        return this;
    },

    // ..........................................................
    // ENUMERATED PROPERTIES
    //

    /**
    Returns a special object that can be used to observe individual properties
    on the array.  Just get an equivalent property on this object and it will
    return an enumerable that maps automatically to the named key on the
    member objects.
    */
    '@each': Ember.computed(function () {
        if (!this.__each) this.__each = new Ember.EachProxy(this);
        return this.__each;
    }).property().cacheable()



});




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /**
    @namespace

    Implements some standard methods for comparing objects. Add this mixin to
    any class you create that can compare its instances.

    You should implement the compare() method.

    @since Ember 0.9
    */
    Ember.Comparable = Ember.Mixin.create( /** @scope Ember.Comparable.prototype */{

    /**
    walk like a duck. Indicates that the object can be compared.

    @type Boolean
    @default true
    @constant
    */
    isComparable: true,

    /**
    Override to return the result of the comparison of the two parameters. The
    compare method should return:

    - `-1` if `a < b`
    - `0` if `a == b`
    - `1` if `a > b`

    Default implementation raises an exception.

    @param a {Object} the first object to compare
    @param b {Object} the second object to compare
    @returns {Integer} the result of the comparison
    */
    compare: Ember.required(Function)

});


})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2010 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    /**
    @namespace

    Implements some standard methods for copying an object.  Add this mixin to
    any object you create that can create a copy of itself.  This mixin is
    added automatically to the built-in array.

    You should generally implement the copy() method to return a copy of the
    receiver.

    Note that frozenCopy() will only work if you also implement Ember.Freezable.

    @since Ember 0.9
    */
    Ember.Copyable = Ember.Mixin.create(
    /** @scope Ember.Copyable.prototype */{

    /**
    Override to return a copy of the receiver.  Default implementation raises
    an exception.

    @param deep {Boolean} if true, a deep copy of the object should be made
    @returns {Object} copy of receiver
    */
    copy: Ember.required(Function),

    /**
    If the object implements Ember.Freezable, then this will return a new copy
    if the object is not frozen and the receiver if the object is frozen.

    Raises an exception if you try to call this method on a object that does
    not support freezing.

    You should use this method whenever you want a copy of a freezable object
    since a freezable object can simply return itself without actually
    consuming more memory.

    @returns {Object} copy of receiver or receiver
    */
    frozenCopy: function () {
        if (Ember.Freezable && Ember.Freezable.detect(this)) {
            return get(this, 'isFrozen') ? this : this.copy().freeze();
        } else {
            throw new Error(Ember.String.fmt("%@ does not support freezing", [this]));
        }
    }
});




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2010 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================





    var get = Ember.get, set = Ember.set;

    /**
    @namespace

    The Ember.Freezable mixin implements some basic methods for marking an object
    as frozen. Once an object is frozen it should be read only. No changes
    may be made the internal state of the object.

    ## Enforcement

    To fully support freezing in your subclass, you must include this mixin and
    override any method that might alter any property on the object to instead
    raise an exception. You can check the state of an object by checking the
    isFrozen property.

    Although future versions of JavaScript may support language-level freezing
    object objects, that is not the case today. Even if an object is freezable,
    it is still technically possible to modify the object, even though it could
    break other parts of your application that do not expect a frozen object to
    change. It is, therefore, very important that you always respect the
    isFrozen property on all freezable objects.

    ## Example Usage

    The example below shows a simple object that implement the Ember.Freezable
    protocol.

    Contact = Ember.Object.extend(Ember.Freezable, {

    firstName: null,

    lastName: null,

    // swaps the names
    swapNames: function() {
    if (this.get('isFrozen')) throw Ember.FROZEN_ERROR;
    var tmp = this.get('firstName');
    this.set('firstName', this.get('lastName'));
    this.set('lastName', tmp);
    return this;
    }

    });

    c = Context.create({ firstName: "John", lastName: "Doe" });
    c.swapNames();  => returns c
    c.freeze();
    c.swapNames();  => EXCEPTION

    ## Copying

    Usually the Ember.Freezable protocol is implemented in cooperation with the
    Ember.Copyable protocol, which defines a frozenCopy() method that will return
    a frozen object, if the object implements this method as well.

    @since Ember 0.9
    */
    Ember.Freezable = Ember.Mixin.create(
    /** @scope Ember.Freezable.prototype */{

    /**
    Set to true when the object is frozen.  Use this property to detect whether
    your object is frozen or not.

    @property {Boolean}
    */
    isFrozen: false,

    /**
    Freezes the object.  Once this method has been called the object should
    no longer allow any properties to be edited.

    @returns {Object} receiver
    */
    freeze: function () {
        if (get(this, 'isFrozen')) return this;
        set(this, 'isFrozen', true);
        return this;
    }

});

Ember.FROZEN_ERROR = "Frozen object cannot be modified.";




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var forEach = Ember.ArrayUtils.forEach;

    /**
    @class

    This mixin defines the API for modifying generic enumerables.  These methods
    can be applied to an object regardless of whether it is ordered or
    unordered.

    Note that an Enumerable can change even if it does not implement this mixin.
    For example, a MappedEnumerable cannot be directly modified but if its
    underlying enumerable changes, it will change also.

    ## Adding Objects

    To add an object to an enumerable, use the addObject() method.  This
    method will only add the object to the enumerable if the object is not
    already present and the object if of a type supported by the enumerable.

    set.addObject(contact);

    ## Removing Objects

    To remove an object form an enumerable, use the removeObject() method.  This
    will only remove the object if it is already in the enumerable, otherwise
    this method has no effect.

    set.removeObject(contact);

    ## Implementing In Your Own Code

    If you are implementing an object and want to support this API, just include
    this mixin in your class and implement the required methods.  In your unit
    tests, be sure to apply the Ember.MutableEnumerableTests to your object.

    @extends Ember.Mixin
    @extends Ember.Enumerable
    */
    Ember.MutableEnumerable = Ember.Mixin.create(Ember.Enumerable,
    /** @scope Ember.MutableEnumerable.prototype */{

    /**
    __Required.__ You must implement this method to apply this mixin.

    Attempts to add the passed object to the receiver if the object is not
    already present in the collection. If the object is present, this method
    has no effect.

    If the passed object is of a type not supported by the receiver
    then this method should raise an exception.

    @param {Object} object
    The object to add to the enumerable.

    @returns {Object} the passed object
    */
    addObject: Ember.required(Function),

    /**
    Adds each object in the passed enumerable to the receiver.

    @param {Ember.Enumerable} objects the objects to add.
    @returns {Object} receiver
    */
    addObjects: function (objects) {
        Ember.beginPropertyChanges(this);
        forEach(objects, function (obj) { this.addObject(obj); }, this);
        Ember.endPropertyChanges(this);
        return this;
    },

    /**
    __Required.__ You must implement this method to apply this mixin.

    Attempts to remove the passed object from the receiver collection if the
    object is in present in the collection.  If the object is not present,
    this method has no effect.

    If the passed object is of a type not supported by the receiver
    then this method should raise an exception.

    @param {Object} object
    The object to remove from the enumerable.

    @returns {Object} the passed object
    */
    removeObject: Ember.required(Function),


    /**
    Removes each objects in the passed enumerable from the receiver.

    @param {Ember.Enumerable} objects the objects to remove
    @returns {Object} receiver
    */
    removeObjects: function (objects) {
        Ember.beginPropertyChanges(this);
        forEach(objects, function (obj) { this.removeObject(obj); }, this);
        Ember.endPropertyChanges(this);
        return this;
    }

});

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    // ..........................................................
    // CONSTANTS
    //

    var OUT_OF_RANGE_EXCEPTION = "Index out of range";
    var EMPTY = [];

    // ..........................................................
    // HELPERS
    //

    var get = Ember.get, set = Ember.set, forEach = Ember.ArrayUtils.forEach;

    /**
    @class

    This mixin defines the API for modifying array-like objects.  These methods
    can be applied only to a collection that keeps its items in an ordered set.

    Note that an Array can change even if it does not implement this mixin.
    For example, one might implement a SparseArray that cannot be directly
    modified, but if its underlying enumerable changes, it will change also.

    @extends Ember.Mixin
    @extends Ember.Array
    @extends Ember.MutableEnumerable
    */
    Ember.MutableArray = Ember.Mixin.create(Ember.Array, Ember.MutableEnumerable,
    /** @scope Ember.MutableArray.prototype */{

    /**
    __Required.__ You must implement this method to apply this mixin.

    This is one of the primitives you must implement to support Ember.Array.  You
    should replace amt objects started at idx with the objects in the passed
    array.  You should also call this.enumerableContentDidChange() ;

    @param {Number} idx
    Starting index in the array to replace.  If idx >= length, then append
    to the end of the array.

    @param {Number} amt
    Number of elements that should be removed from the array, starting at
    *idx*.

    @param {Array} objects
    An array of zero or more objects that should be inserted into the array
    at *idx*
    */
    replace: Ember.required(),

    /**
    Remove all elements from self. This is useful if you
    want to reuse an existing array without having to recreate it.

    var colors = ["red", "green", "blue"];
    color.length();  => 3
    colors.clear();  => []
    colors.length(); => 0

    @returns {Ember.Array} An empty Array. 
    */
    clear: function () {
        var len = get(this, 'length');
        if (len === 0) return this;
        this.replace(0, len, EMPTY);
        return this;
    },

    /**
    This will use the primitive replace() method to insert an object at the
    specified index.

    var colors = ["red", "green", "blue"];
    colors.insertAt(2, "yellow"); => ["red", "green", "yellow", "blue"]
    colors.insertAt(5, "orange"); => Error: Index out of range

    @param {Number} idx index of insert the object at.
    @param {Object} object object to insert
    */
    insertAt: function (idx, object) {
        if (idx > get(this, 'length')) throw new Error(OUT_OF_RANGE_EXCEPTION);
        this.replace(idx, 0, [object]);
        return this;
    },

    /**
    Remove an object at the specified index using the replace() primitive
    method.  You can pass either a single index, or a start and a length.

    If you pass a start and length that is beyond the
    length this method will throw an Ember.OUT_OF_RANGE_EXCEPTION

    var colors = ["red", "green", "blue", "yellow", "orange"];
    colors.removeAt(0); => ["green", "blue", "yellow", "orange"]
    colors.removeAt(2, 2); => ["green", "blue"]
    colors.removeAt(4, 2); => Error: Index out of range

    @param {Number} start index, start of range
    @param {Number} len length of passing range
    @returns {Object} receiver
    */
    removeAt: function (start, len) {

        var delta = 0;

        if ('number' === typeof start) {

            if ((start < 0) || (start >= get(this, 'length'))) {
                throw new Error(OUT_OF_RANGE_EXCEPTION);
            }

            // fast case
            if (len === undefined) len = 1;
            this.replace(start, len, EMPTY);
        }

        return this;
    },

    /**
    Push the object onto the end of the array.  Works just like push() but it
    is KVO-compliant.

    var colors = ["red", "green", "blue"];
    colors.pushObject("black"); => ["red", "green", "blue", "black"]
    colors.pushObject(["yellow", "orange"]); => ["red", "green", "blue", "black", ["yellow", "orange"]]

    */
    pushObject: function (obj) {
        this.insertAt(get(this, 'length'), obj);
        return obj;
    },

    /**
    Add the objects in the passed numerable to the end of the array.  Defers
    notifying observers of the change until all objects are added.

    var colors = ["red", "green", "blue"];
    colors.pushObjects("black"); => ["red", "green", "blue", "black"]
    colors.pushObjects(["yellow", "orange"]); => ["red", "green", "blue", "black", "yellow", "orange"]

    @param {Ember.Enumerable} objects the objects to add
    @returns {Ember.Array} receiver
    */
    pushObjects: function (objects) {
        this.replace(get(this, 'length'), 0, objects);
        return this;
    },

    /**
    Pop object from array or nil if none are left.  Works just like pop() but
    it is KVO-compliant.

    var colors = ["red", "green", "blue"];
    colors.popObject(); => "blue"
    console.log(colors); => ["red", "green"]

    */
    popObject: function () {
        var len = get(this, 'length');
        if (len === 0) return null;

        var ret = this.objectAt(len - 1);
        this.removeAt(len - 1, 1);
        return ret;
    },

    /**
    Shift an object from start of array or nil if none are left.  Works just
    like shift() but it is KVO-compliant.

    var colors = ["red", "green", "blue"];
    colors.shiftObject(); => "red"
    console.log(colors); => ["green", "blue"]

    */
    shiftObject: function () {
        if (get(this, 'length') === 0) return null;
        var ret = this.objectAt(0);
        this.removeAt(0);
        return ret;
    },

    /**
    Unshift an object to start of array.  Works just like unshift() but it is
    KVO-compliant.

    var colors = ["red", "green", "blue"];
    colors.unshiftObject("yellow"); => ["yellow", "red", "green", "blue"]
    colors.unshiftObject(["black", "white"]); => [["black", "white"], "yellow", "red", "green", "blue"]

    */
    unshiftObject: function (obj) {
        this.insertAt(0, obj);
        return obj;
    },

    /**
    Adds the named objects to the beginning of the array.  Defers notifying
    observers until all objects have been added.

    var colors = ["red", "green", "blue"];
    colors.unshiftObjects(["black", "white"]); => ["black", "white", "red", "green", "blue"]
    colors.unshiftObjects("yellow"); => Type Error: 'undefined' is not a function

    @param {Ember.Enumerable} objects the objects to add
    @returns {Ember.Array} receiver
    */
    unshiftObjects: function (objects) {
        this.replace(0, 0, objects);
        return this;
    },

    // ..........................................................
    // IMPLEMENT Ember.MutableEnumerable
    //

    /** @private (nodoc) */
    removeObject: function (obj) {
        var loc = get(this, 'length') || 0;
        while (--loc >= 0) {
            var curObject = this.objectAt(loc);
            if (curObject === obj) this.removeAt(loc);
        }
        return this;
    },

    /** @private (nodoc) */
    addObject: function (obj) {
        if (!this.contains(obj)) this.pushObject(obj);
        return this;
    }

});


})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    var get = Ember.get, set = Ember.set;

    /**
    @class

    ## Overview
  
    This mixin provides properties and property observing functionality, core
    features of the Ember object model.
  
    Properties and observers allow one object to observe changes to a
    property on another object. This is one of the fundamental ways that
    models, controllers and views communicate with each other in an Ember
    application.
  
    Any object that has this mixin applied can be used in observer
    operations. That includes Ember.Object and most objects you will
    interact with as you write your Ember application.

    Note that you will not generally apply this mixin to classes yourself,
    but you will use the features provided by this module frequently, so it
    is important to understand how to use it.
  
    ## Using get() and set()
  
    Because of Ember's support for bindings and observers, you will always
    access properties using the get method, and set properties using the
    set method. This allows the observing objects to be notified and
    computed properties to be handled properly.
  
    More documentation about `get` and `set` are below.
  
    ## Observing Property Changes

    You typically observe property changes simply by adding the `observes`
    call to the end of your method declarations in classes that you write.
    For example:

    Ember.Object.create({
    valueObserver: function() {
    // Executes whenever the "value" property changes
    }.observes('value')
    });
    
    Although this is the most common way to add an observer, this capability
    is actually built into the Ember.Object class on top of two methods
    defined in this mixin: `addObserver` and `removeObserver`. You can use
    these two methods to add and remove observers yourself if you need to
    do so at runtime.

    To add an observer for a property, call:

    object.addObserver('propertyKey', targetObject, targetAction)

    This will call the `targetAction` method on the `targetObject` to be called
    whenever the value of the `propertyKey` changes.
  
    Note that if `propertyKey` is a computed property, the observer will be 
    called when any of the property dependencies are changed, even if the 
    resulting value of the computed property is unchanged. This is necessary
    because computed properties are not computed until `get` is called.
  
    @extends Ember.Mixin
    */
    Ember.Observable = Ember.Mixin.create(/** @scope Ember.Observable.prototype */{

    /** @private - compatibility */
    isObserverable: true,

    /**
    Retrieves the value of a property from the object.

    This method is usually similar to using object[keyName] or object.keyName,
    however it supports both computed properties and the unknownProperty
    handler.
    
    Because `get` unifies the syntax for accessing all these kinds
    of properties, it can make many refactorings easier, such as replacing a
    simple property with a computed property, or vice versa.

    ### Computed Properties

    Computed properties are methods defined with the `property` modifier
    declared at the end, such as:

    fullName: function() {
    return this.getEach('firstName', 'lastName').compact().join(' ');
    }.property('firstName', 'lastName')

    When you call `get` on a computed property, the function will be
    called and the return value will be returned instead of the function
    itself.

    ### Unknown Properties

    Likewise, if you try to call `get` on a property whose value is
    undefined, the unknownProperty() method will be called on the object.
    If this method returns any value other than undefined, it will be returned
    instead. This allows you to implement "virtual" properties that are
    not defined upfront.

    @param {String} key The property to retrieve
    @returns {Object} The property value or undefined.
    */
    get: function (keyName) {
        return get(this, keyName);
    },

    /**
    To get multiple properties at once, call getProperties
    with a list of strings or an array:

    record.getProperties('firstName', 'lastName', 'zipCode'); // => { firstName: 'John', lastName: 'Doe', zipCode: '10011' }

    is equivalent to:

    record.getProperties(['firstName', 'lastName', 'zipCode']); // => { firstName: 'John', lastName: 'Doe', zipCode: '10011' }

    @param {String...|Array} list of keys to get
    @returns {Hash}
    */
    getProperties: function () {
        var ret = {};
        var propertyNames = arguments;
        if (arguments.length === 1 && Ember.typeOf(arguments[0]) === 'array') {
            propertyNames = arguments[0];
        }
        for (var i = 0; i < propertyNames.length; i++) {
            ret[propertyNames[i]] = get(this, propertyNames[i]);
        }
        return ret;
    },

    /**
    Sets the key equal to value.

    This method is generally very similar to calling object[key] = value or
    object.key = value, except that it provides support for computed
    properties, the unknownProperty() method and property observers.

    ### Computed Properties

    If you try to set a value on a key that has a computed property handler
    defined (see the get() method for an example), then set() will call
    that method, passing both the value and key instead of simply changing
    the value itself. This is useful for those times when you need to
    implement a property that is composed of one or more member
    properties.

    ### Unknown Properties

    If you try to set a value on a key that is undefined in the target
    object, then the unknownProperty() handler will be called instead. This
    gives you an opportunity to implement complex "virtual" properties that
    are not predefined on the object. If unknownProperty() returns
    undefined, then set() will simply set the value on the object.

    ### Property Observers

    In addition to changing the property, set() will also register a
    property change with the object. Unless you have placed this call
    inside of a beginPropertyChanges() and endPropertyChanges(), any "local"
    observers (i.e. observer methods declared on the same object), will be
    called immediately. Any "remote" observers (i.e. observer methods
    declared on another object) will be placed in a queue and called at a
    later time in a coalesced manner.

    ### Chaining

    In addition to property changes, set() returns the value of the object
    itself so you can do chaining like this:

    record.set('firstName', 'Charles').set('lastName', 'Jolley');

    @param {String} key The property to set
    @param {Object} value The value to set or null.
    @returns {Ember.Observable}
    */
    set: function (keyName, value) {
        set(this, keyName, value);
        return this;
    },

    /**
    To set multiple properties at once, call setProperties
    with a Hash:

    record.setProperties({ firstName: 'Charles', lastName: 'Jolley' });

    @param {Hash} hash the hash of keys and values to set
    @returns {Ember.Observable}
    */
    setProperties: function (hash) {
        return Ember.setProperties(this, hash);
    },

    /**
    Begins a grouping of property changes.

    You can use this method to group property changes so that notifications
    will not be sent until the changes are finished. If you plan to make a
    large number of changes to an object at one time, you should call this
    method at the beginning of the changes to begin deferring change
    notifications. When you are done making changes, call endPropertyChanges()
    to deliver the deferred change notifications and end deferring.

    @returns {Ember.Observable}
    */
    beginPropertyChanges: function () {
        Ember.beginPropertyChanges();
        return this;
    },

    /**
    Ends a grouping of property changes.

    You can use this method to group property changes so that notifications
    will not be sent until the changes are finished. If you plan to make a
    large number of changes to an object at one time, you should call
    beginPropertyChanges() at the beginning of the changes to defer change
    notifications. When you are done making changes, call this method to
    deliver the deferred change notifications and end deferring.

    @returns {Ember.Observable}
    */
    endPropertyChanges: function () {
        Ember.endPropertyChanges();
        return this;
    },

    /**
    Notify the observer system that a property is about to change.

    Sometimes you need to change a value directly or indirectly without
    actually calling get() or set() on it. In this case, you can use this
    method and propertyDidChange() instead. Calling these two methods
    together will notify all observers that the property has potentially
    changed value.

    Note that you must always call propertyWillChange and propertyDidChange as
    a pair. If you do not, it may get the property change groups out of order
    and cause notifications to be delivered more often than you would like.

    @param {String} key The property key that is about to change.
    @returns {Ember.Observable}
    */
    propertyWillChange: function (keyName) {
        Ember.propertyWillChange(this, keyName);
        return this;
    },

    /**
    Notify the observer system that a property has just changed.

    Sometimes you need to change a value directly or indirectly without
    actually calling get() or set() on it. In this case, you can use this
    method and propertyWillChange() instead. Calling these two methods
    together will notify all observers that the property has potentially
    changed value.

    Note that you must always call propertyWillChange and propertyDidChange as
    a pair. If you do not, it may get the property change groups out of order
    and cause notifications to be delivered more often than you would like.

    @param {String} keyName The property key that has just changed.
    @returns {Ember.Observable}
    */
    propertyDidChange: function (keyName) {
        Ember.propertyDidChange(this, keyName);
        return this;
    },

    /**
    Convenience method to call `propertyWillChange` and `propertyDidChange` in
    succession.
  
    @param {String} keyName The property key to be notified about.
    @returns {Ember.Observable}
    */
    notifyPropertyChange: function (keyName) {
        this.propertyWillChange(keyName);
        this.propertyDidChange(keyName);
        return this;
    },

    /**
    Adds an observer on a property.

    This is the core method used to register an observer for a property.

    Once you call this method, anytime the key's value is set, your observer
    will be notified. Note that the observers are triggered anytime the
    value is set, regardless of whether it has actually changed. Your
    observer should be prepared to handle that.

    You can also pass an optional context parameter to this method. The
    context will be passed to your observer method whenever it is triggered.
    Note that if you add the same target/method pair on a key multiple times
    with different context parameters, your observer will only be called once
    with the last context you passed.

    ### Observer Methods

    Observer methods you pass should generally have the following signature if
    you do not pass a "context" parameter:

    fooDidChange: function(sender, key, value, rev);

    The sender is the object that changed. The key is the property that
    changes. The value property is currently reserved and unused. The rev
    is the last property revision of the object when it changed, which you can
    use to detect if the key value has really changed or not.

    If you pass a "context" parameter, the context will be passed before the
    revision like so:

    fooDidChange: function(sender, key, value, context, rev);

    Usually you will not need the value, context or revision parameters at
    the end. In this case, it is common to write observer methods that take
    only a sender and key value as parameters or, if you aren't interested in
    any of these values, to write an observer that has no parameters at all.

    @param {String} key The key to observer
    @param {Object} target The target object to invoke
    @param {String|Function} method The method to invoke.
    @returns {Ember.Object} self
    */
    addObserver: function (key, target, method) {
        Ember.addObserver(this, key, target, method);
    },

    /**
    Remove an observer you have previously registered on this object. Pass
    the same key, target, and method you passed to addObserver() and your
    target will no longer receive notifications.

    @param {String} key The key to observer
    @param {Object} target The target object to invoke
    @param {String|Function} method The method to invoke.
    @returns {Ember.Observable} receiver
    */
    removeObserver: function (key, target, method) {
        Ember.removeObserver(this, key, target, method);
    },

    /**
    Returns true if the object currently has observers registered for a
    particular key. You can use this method to potentially defer performing
    an expensive action until someone begins observing a particular property
    on the object.

    @param {String} key Key to check
    @returns {Boolean}
    */
    hasObserverFor: function (key) {
        return Ember.hasListeners(this, key + ':change');
    },

    /**
    This method will be called when a client attempts to get the value of a
    property that has not been defined in one of the typical ways. Override
    this method to create "virtual" properties.
    
    @param {String} key The name of the unknown property that was requested.
    @returns {Object} The property value or undefined. Default is undefined.
    */
    unknownProperty: function (key) {
        return undefined;
    },

    /**
    This method will be called when a client attempts to set the value of a
    property that has not been defined in one of the typical ways. Override
    this method to create "virtual" properties.
    
    @param {String} key The name of the unknown property to be set.
    @param {Object} value The value the unknown property is to be set to.
    */
    setUnknownProperty: function (key, value) {
        this[key] = value;
    },

    /**
    This is like `get`, but allows you to pass in a dot-separated property
    path.
    
    person.getPath('address.zip'); // return the zip
    person.getPath('children.firstObject.age'); // return the first kid's age

    This reads much better than chained `get` calls.

    @param {String} path The property path to retrieve
    @returns {Object} The property value or undefined.
    */
    getPath: function (path) {
        return Ember.getPath(this, path);
    },

    /**
    This is like `set`, but allows you to specify the property you want to
    set as a dot-separated property path.
    
    person.setPath('address.zip', 10011); // set the zip to 10011
    person.setPath('children.firstObject.age', 6); // set the first kid's age to 6

    This is not as commonly used as `getPath`, but it can be useful.

    @param {String} path The path to the property that will be set
    @param {Object} value The value to set or null.
    @returns {Ember.Observable}
    */
    setPath: function (path, value) {
        Ember.setPath(this, path, value);
        return this;
    },

    /**
    Retrieves the value of a property, or a default value in the case that the property
    returns undefined.
    
    person.getWithDefault('lastName', 'Doe');
    
    @param {String} keyName The name of the property to retrieve
    @param {Object} defaultValue The value to return if the property value is undefined
    @returns {Object} The property value or the defaultValue.
    */
    getWithDefault: function (keyName, defaultValue) {
        return Ember.getWithDefault(this, keyName, defaultValue);
    },

    /**
    Set the value of a property to the current value plus some amount.
    
    person.incrementProperty('age');
    team.incrementProperty('score', 2);
    
    @param {String} keyName The name of the property to increment
    @param {Object} increment The amount to increment by. Defaults to 1
    @returns {Object} The new property value
    */
    incrementProperty: function (keyName, increment) {
        if (!increment) { increment = 1; }
        set(this, keyName, (get(this, keyName) || 0) + increment);
        return get(this, keyName);
    },

    /**
    Set the value of a property to the current value minus some amount.
    
    player.decrementProperty('lives');
    orc.decrementProperty('health', 5);
    
    @param {String} keyName The name of the property to decrement
    @param {Object} increment The amount to decrement by. Defaults to 1
    @returns {Object} The new property value
    */
    decrementProperty: function (keyName, increment) {
        if (!increment) { increment = 1; }
        set(this, keyName, (get(this, keyName) || 0) - increment);
        return get(this, keyName);
    },

    /**
    Set the value of a boolean property to the opposite of it's
    current value.
    
    starship.toggleProperty('warpDriveEnaged');
    
    @param {String} keyName The name of the property to toggle
    @returns {Object} The new property value
    */
    toggleProperty: function (keyName) {
        set(this, keyName, !get(this, keyName));
        return get(this, keyName);
    },

    /**
    Returns the cached value of a computed property, if it exists.
    This allows you to inspect the value of a computed property
    without accidentally invoking it if it is intended to be
    generated lazily.

    @param {String} keyName
    @returns {Object} The cached value of the computed property, if any
    */
    cacheFor: function (keyName) {
        return Ember.cacheFor(this, keyName);
    },

    /** @private - intended for debugging purposes */
    observersForKey: function (keyName) {
        return Ember.observersFor(this, keyName);
    }
});




})();



(function () {
    var get = Ember.get, set = Ember.set, getPath = Ember.getPath;

    Ember.TargetActionSupport = Ember.Mixin.create({
        target: null,
        action: null,

        targetObject: Ember.computed(function () {
            var target = get(this, 'target');

            if (Ember.typeOf(target) === "string") {
                var value = getPath(this, target);
                if (value === undefined) { value = getPath(window, target); }
                return value;
            } else {
                return target;
            }
        }).property('target').cacheable(),

        triggerAction: function () {
            var action = get(this, 'action'),
        target = get(this, 'targetObject');

            if (target && action) {
                var ret;

                if (typeof target.send === 'function') {
                    ret = target.send(action, this);
                } else {
                    if (typeof action === 'string') {
                        action = target[action];
                    }
                    ret = action.call(target, this);
                }
                if (ret !== false) ret = true;

                return ret;
            } else {
                return false;
            }
        }
    });

})();



(function () {
    var get = Ember.get, set = Ember.set, a_slice = Array.prototype.slice;

    /** @private */
    function xform(target, method, params) {
        var args = a_slice.call(params, 2);
        method.apply(target, args);
    }

    Ember.Evented = Ember.Mixin.create({
        on: function (name, target, method) {
            if (!method) {
                method = target;
                target = null;
            }

            Ember.addListener(this, name, target, method, xform);
        },

        fire: function (name) {
            Ember.sendEvent.apply(null, [this, name].concat(a_slice.call(arguments, 1)));
        },

        off: function (name, target, method) {
            Ember.removeListener(this, name, target, method);
        }
    });

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================



    // NOTE: this object should never be included directly.  Instead use Ember.
    // Ember.Object.  We only define this separately so that Ember.Set can depend on it



    var rewatch = Ember.rewatch;
    var classToString = Ember.Mixin.prototype.toString;
    var set = Ember.set, get = Ember.get;
    var o_create = Ember.platform.create,
    o_defineProperty = Ember.platform.defineProperty,
    a_slice = Array.prototype.slice,
    meta = Ember.meta;

    /** @private */
    function makeCtor() {

        // Note: avoid accessing any properties on the object since it makes the
        // method a lot faster.  This is glue code so we want it to be as fast as
        // possible.

        var wasApplied = false, initMixins, init = false, hasChains = false;

        var Class = function () {
            if (!wasApplied) { Class.proto(); } // prepare prototype...
            if (initMixins) {
                this.reopen.apply(this, initMixins);
                initMixins = null;
                rewatch(this); // always rewatch just in case
                Ember.Mixin.finishPartial(this);
                this.init.apply(this, arguments);
            } else {
                if (hasChains) {
                    rewatch(this);
                } else {
                    Ember.GUID_DESC.value = undefined;
                    o_defineProperty(this, Ember.GUID_KEY, Ember.GUID_DESC);
                }
                if (init === false) { init = this.init; } // cache for later instantiations
                Ember.GUID_DESC.value = undefined;
                o_defineProperty(this, '_super', Ember.GUID_DESC);
                Ember.Mixin.finishPartial(this);
                init.apply(this, arguments);
            }
        };

        Class.toString = classToString;
        Class.willReopen = function () {
            if (wasApplied) {
                Class.PrototypeMixin = Ember.Mixin.create(Class.PrototypeMixin);
            }

            wasApplied = false;
        };
        Class._initMixins = function (args) { initMixins = args; };

        Class.proto = function () {
            var superclass = Class.superclass;
            if (superclass) { superclass.proto(); }

            if (!wasApplied) {
                wasApplied = true;
                Class.PrototypeMixin.applyPartial(Class.prototype);
                Ember.rewatch(Class.prototype); // setup watch chains if needed.
                hasChains = !!meta(Class.prototype, false).chains; // avoid rewatch
            }

            return this.prototype;
        };

        return Class;

    }

    var CoreObject = makeCtor();

    CoreObject.PrototypeMixin = Ember.Mixin.create(
    /** @scope Ember.CoreObject */{

    reopen: function () {
        Ember.Mixin._apply(this, arguments, true);
        return this;
    },

    isInstance: true,

    /** @private */
    init: function () { },

    /** @field */
    isDestroyed: false,

    /** @field */
    isDestroying: false,

    /**
    Destroys an object by setting the isDestroyed flag and removing its
    metadata, which effectively destroys observers and bindings.

    If you try to set a property on a destroyed object, an exception will be
    raised.

    Note that destruction is scheduled for the end of the run loop and does not
    happen immediately.

    @returns {Ember.Object} receiver
    */
    destroy: function () {
        if (this.isDestroying) { return; }

        this.isDestroying = true;

        if (this.willDestroy) { this.willDestroy(); }

        set(this, 'isDestroyed', true);
        Ember.run.schedule('destroy', this, this._scheduledDestroy);
        return this;
    },

    /**
    Invoked by the run loop to actually destroy the object. This is
    scheduled for execution by the `destroy` method.

    @private
    */
    _scheduledDestroy: function () {
        Ember.destroy(this);
        if (this.didDestroy) { this.didDestroy(); }
    },

    bind: function (to, from) {
        if (!(from instanceof Ember.Binding)) { from = Ember.Binding.from(from); }
        from.to(to).connect(this);
        return from;
    },

    toString: function () {
        return '<' + this.constructor.toString() + ':' + Ember.guidFor(this) + '>';
    }
});

CoreObject.__super__ = null;

var ClassMixin = Ember.Mixin.create({

    ClassMixin: Ember.required(),

    PrototypeMixin: Ember.required(),

    isClass: true,

    isMethod: false,

    extend: function () {
        var Class = makeCtor(), proto;
        Class.ClassMixin = Ember.Mixin.create(this.ClassMixin);
        Class.PrototypeMixin = Ember.Mixin.create(this.PrototypeMixin);

        Class.ClassMixin.ownerConstructor = Class;
        Class.PrototypeMixin.ownerConstructor = Class;

        var PrototypeMixin = Class.PrototypeMixin;
        PrototypeMixin.reopen.apply(PrototypeMixin, arguments);

        Class.superclass = this;
        Class.__super__ = this.prototype;

        proto = Class.prototype = o_create(this.prototype);
        proto.constructor = Class;
        Ember.generateGuid(proto, 'ember');
        meta(proto).proto = proto; // this will disable observers on prototype


        Class.subclasses = Ember.Set ? new Ember.Set() : null;
        if (this.subclasses) { this.subclasses.add(Class); }

        Class.ClassMixin.apply(Class);
        return Class;
    },

    create: function () {
        var C = this;
        if (arguments.length > 0) { this._initMixins(arguments); }
        return new C();
    },

    reopen: function () {
        this.willReopen();
        var PrototypeMixin = this.PrototypeMixin;
        PrototypeMixin.reopen.apply(PrototypeMixin, arguments);
        return this;
    },

    reopenClass: function () {
        var ClassMixin = this.ClassMixin;
        ClassMixin.reopen.apply(ClassMixin, arguments);
        Ember.Mixin._apply(this, arguments, false);
        return this;
    },

    detect: function (obj) {
        if ('function' !== typeof obj) { return false; }
        while (obj) {
            if (obj === this) { return true; }
            obj = obj.superclass;
        }
        return false;
    },

    detectInstance: function (obj) {
        return obj instanceof this;
    },

    /**
    In some cases, you may want to annotate computed properties with additional
    metadata about how they function or what values they operate on. For example,
    computed property functions may close over variables that are then no longer
    available for introspection.

    You can pass a hash of these values to a computed property like this:

    person: function() {
    var personId = this.get('personId');
    return App.Person.create({ id: personId });
    }.property().meta({ type: App.Person })

    Once you've done this, you can retrieve the values saved to the computed
    property from your class like this:

    MyClass.metaForProperty('person');

    This will return the original hash that was passed to `meta()`.
    */
    metaForProperty: function (key) {
        var desc = meta(this.proto(), false).descs[key];

        Ember.assert("metaForProperty() could not find a computed property with key '" + key + "'.", !!desc && desc instanceof Ember.ComputedProperty);
        return desc._meta || {};
    },

    /**
    Iterate over each computed property for the class, passing its name
    and any associated metadata (see `metaForProperty`) to the callback.
    */
    eachComputedProperty: function (callback, binding) {
        var proto = this.proto(),
        descs = meta(proto).descs,
        empty = {},
        property;

        for (var name in descs) {
            property = descs[name];

            if (property instanceof Ember.ComputedProperty) {
                callback.call(binding || this, name, property._meta || empty);
            }
        }
    }

});

CoreObject.ClassMixin = ClassMixin;
ClassMixin.apply(CoreObject);

/**
@class
*/
Ember.CoreObject = CoreObject;




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, none = Ember.none;

    /**
    @class

    An unordered collection of objects.

    A Set works a bit like an array except that its items are not ordered.
    You can create a set to efficiently test for membership for an object. You
    can also iterate through a set just like an array, even accessing objects
    by index, however there is no guarantee as to their order.

    All Sets are observable via the Enumerable Observer API - which works
    on any enumerable object including both Sets and Arrays.

    ## Creating a Set

    You can create a set like you would most objects using
    `new Ember.Set()`.  Most new sets you create will be empty, but you can
    also initialize the set with some content by passing an array or other
    enumerable of objects to the constructor.

    Finally, you can pass in an existing set and the set will be copied. You
    can also create a copy of a set by calling `Ember.Set#copy()`.

    #js
    // creates a new empty set
    var foundNames = new Ember.Set();

    // creates a set with four names in it.
    var names = new Ember.Set(["Charles", "Tom", "Juan", "Alex"]); // :P

    // creates a copy of the names set.
    var namesCopy = new Ember.Set(names);

    // same as above.
    var anotherNamesCopy = names.copy();

    ## Adding/Removing Objects

    You generally add or remove objects from a set using `add()` or
    `remove()`. You can add any type of object including primitives such as
    numbers, strings, and booleans.

    Unlike arrays, objects can only exist one time in a set. If you call `add()`
    on a set with the same object multiple times, the object will only be added
    once. Likewise, calling `remove()` with the same object multiple times will
    remove the object the first time and have no effect on future calls until
    you add the object to the set again.

    NOTE: You cannot add/remove null or undefined to a set. Any attempt to do so
    will be ignored.

    In addition to add/remove you can also call `push()`/`pop()`. Push behaves
    just like `add()` but `pop()`, unlike `remove()` will pick an arbitrary
    object, remove it and return it. This is a good way to use a set as a job
    queue when you don't care which order the jobs are executed in.

    ## Testing for an Object

    To test for an object's presence in a set you simply call
    `Ember.Set#contains()`.

    ## Observing changes

    When using `Ember.Set`, you can observe the `"[]"` property to be
    alerted whenever the content changes.  You can also add an enumerable
    observer to the set to be notified of specific objects that are added and
    removed from the set.  See `Ember.Enumerable` for more information on
    enumerables.

    This is often unhelpful. If you are filtering sets of objects, for instance,
    it is very inefficient to re-filter all of the items each time the set
    changes. It would be better if you could just adjust the filtered set based
    on what was changed on the original set. The same issue applies to merging
    sets, as well.

    ## Other Methods

    `Ember.Set` primary implements other mixin APIs.  For a complete reference
    on the methods you will use with `Ember.Set`, please consult these mixins.
    The most useful ones will be `Ember.Enumerable` and
    `Ember.MutableEnumerable` which implement most of the common iterator
    methods you are used to on Array.

    Note that you can also use the `Ember.Copyable` and `Ember.Freezable`
    APIs on `Ember.Set` as well.  Once a set is frozen it can no longer be
    modified.  The benefit of this is that when you call frozenCopy() on it,
    Ember will avoid making copies of the set.  This allows you to write
    code that can know with certainty when the underlying set data will or
    will not be modified.

    @extends Ember.Enumerable
    @extends Ember.MutableEnumerable
    @extends Ember.Copyable
    @extends Ember.Freezable

    @since Ember 0.9
    */
    Ember.Set = Ember.CoreObject.extend(Ember.MutableEnumerable, Ember.Copyable, Ember.Freezable,
    /** @scope Ember.Set.prototype */{

    // ..........................................................
    // IMPLEMENT ENUMERABLE APIS
    //

    /**
    This property will change as the number of objects in the set changes.

    @property Number
    @default 0
    */
    length: 0,

    /**
    Clears the set. This is useful if you want to reuse an existing set
    without having to recreate it.

    var colors = new Ember.Set(["red", "green", "blue"]);
    colors.length;  => 3
    colors.clear();
    colors.length;  => 0

    @returns {Ember.Set} An empty Set
    */
    clear: function () {
        if (this.isFrozen) { throw new Error(Ember.FROZEN_ERROR); }

        var len = get(this, 'length');
        if (len === 0) { return this; }

        var guid;

        this.enumerableContentWillChange(len, 0);
        Ember.propertyWillChange(this, 'firstObject');
        Ember.propertyWillChange(this, 'lastObject');

        for (var i = 0; i < len; i++) {
            guid = guidFor(this[i]);
            delete this[guid];
            delete this[i];
        }

        set(this, 'length', 0);

        Ember.propertyDidChange(this, 'firstObject');
        Ember.propertyDidChange(this, 'lastObject');
        this.enumerableContentDidChange(len, 0);

        return this;
    },

    /**
    Returns true if the passed object is also an enumerable that contains the
    same objects as the receiver.

    var colors = ["red", "green", "blue"],
    same_colors = new Ember.Set(colors);
    same_colors.isEqual(colors); => true
    same_colors.isEqual(["purple", "brown"]); => false

    @param {Ember.Set} obj the other object.
    @returns {Boolean}
    */
    isEqual: function (obj) {
        // fail fast
        if (!Ember.Enumerable.detect(obj)) return false;

        var loc = get(this, 'length');
        if (get(obj, 'length') !== loc) return false;

        while (--loc >= 0) {
            if (!obj.contains(this[loc])) return false;
        }

        return true;
    },

    /**
    Adds an object to the set. Only non-null objects can be added to a set
    and those can only be added once. If the object is already in the set or
    the passed value is null this method will have no effect.

    This is an alias for `Ember.MutableEnumerable.addObject()`.

    var colors = new Ember.Set();
    colors.add("blue");    => ["blue"]
    colors.add("blue");    => ["blue"]
    colors.add("red");     => ["blue", "red"]
    colors.add(null);      => ["blue", "red"]
    colors.add(undefined); => ["blue", "red"]

    @function
    @param {Object} obj The object to add.
    @returns {Ember.Set} The set itself.
    */
    add: Ember.alias('addObject'),

    /**
    Removes the object from the set if it is found.  If you pass a null value
    or an object that is already not in the set, this method will have no
    effect. This is an alias for `Ember.MutableEnumerable.removeObject()`.

    var colors = new Ember.Set(["red", "green", "blue"]);
    colors.remove("red");    => ["blue", "green"]
    colors.remove("purple"); => ["blue", "green"]
    colors.remove(null);     => ["blue", "green"]

    @function
    @param {Object} obj The object to remove
    @returns {Ember.Set} The set itself.
    */
    remove: Ember.alias('removeObject'),

    /**
    Removes the last element from the set and returns it, or null if it's empty.

    var colors = new Ember.Set(["green", "blue"]);
    colors.pop(); => "blue"
    colors.pop(); => "green"
    colors.pop(); => null

    @returns {Object} The removed object from the set or null.
    */
    pop: function () {
        if (get(this, 'isFrozen')) throw new Error(Ember.FROZEN_ERROR);
        var obj = this.length > 0 ? this[this.length - 1] : null;
        this.remove(obj);
        return obj;
    },

    /**
    Inserts the given object on to the end of the set. It returns
    the set itself.

    This is an alias for `Ember.MutableEnumerable.addObject()`.

    var colors = new Ember.Set();
    colors.push("red");   => ["red"]
    colors.push("green"); => ["red", "green"]
    colors.push("blue");  => ["red", "green", "blue"]

    @function
    @returns {Ember.Set} The set itself.
    */
    push: Ember.alias('addObject'),

    /**
    Removes the last element from the set and returns it, or null if it's empty.

    This is an alias for `Ember.Set.pop()`.

    var colors = new Ember.Set(["green", "blue"]);
    colors.shift(); => "blue"
    colors.shift(); => "green"
    colors.shift(); => null

    @function
    @returns {Object} The removed object from the set or null.
    */
    shift: Ember.alias('pop'),

    /**
    Inserts the given object on to the end of the set. It returns
    the set itself.

    This is an alias of `Ember.Set.push()`

    var colors = new Ember.Set();
    colors.unshift("red");   => ["red"]
    colors.unshift("green"); => ["red", "green"]
    colors.unshift("blue");  => ["red", "green", "blue"]

    @function
    @returns {Ember.Set} The set itself.
    */
    unshift: Ember.alias('push'),

    /**
    Adds each object in the passed enumerable to the set.

    This is an alias of `Ember.MutableEnumerable.addObjects()`

    var colors = new Ember.Set();
    colors.addEach(["red", "green", "blue"]); => ["red", "green", "blue"]

    @function
    @param {Ember.Enumerable} objects the objects to add.
    @returns {Ember.Set} The set itself.
    */
    addEach: Ember.alias('addObjects'),

    /**
    Removes each object in the passed enumerable to the set.

    This is an alias of `Ember.MutableEnumerable.removeObjects()`

    var colors = new Ember.Set(["red", "green", "blue"]);
    colors.removeEach(["red", "blue"]); => ["green"]

    @function
    @param {Ember.Enumerable} objects the objects to remove.
    @returns {Ember.Set} The set itself.
    */
    removeEach: Ember.alias('removeObjects'),

    // ..........................................................
    // PRIVATE ENUMERABLE SUPPORT
    //

    /** @private */
    init: function (items) {
        this._super();
        if (items) this.addObjects(items);
    },

    /** @private (nodoc) - implement Ember.Enumerable */
    nextObject: function (idx) {
        return this[idx];
    },

    /** @private - more optimized version */
    firstObject: Ember.computed(function () {
        return this.length > 0 ? this[0] : undefined;
    }).property().cacheable(),

    /** @private - more optimized version */
    lastObject: Ember.computed(function () {
        return this.length > 0 ? this[this.length - 1] : undefined;
    }).property().cacheable(),

    /** @private (nodoc) - implements Ember.MutableEnumerable */
    addObject: function (obj) {
        if (get(this, 'isFrozen')) throw new Error(Ember.FROZEN_ERROR);
        if (none(obj)) return this; // nothing to do

        var guid = guidFor(obj),
        idx = this[guid],
        len = get(this, 'length'),
        added;

        if (idx >= 0 && idx < len && (this[idx] === obj)) return this; // added

        added = [obj];

        this.enumerableContentWillChange(null, added);
        Ember.propertyWillChange(this, 'lastObject');

        len = get(this, 'length');
        this[guid] = len;
        this[len] = obj;
        set(this, 'length', len + 1);

        Ember.propertyDidChange(this, 'lastObject');
        this.enumerableContentDidChange(null, added);

        return this;
    },

    /** @private (nodoc) - implements Ember.MutableEnumerable */
    removeObject: function (obj) {
        if (get(this, 'isFrozen')) throw new Error(Ember.FROZEN_ERROR);
        if (none(obj)) return this; // nothing to do

        var guid = guidFor(obj),
        idx = this[guid],
        len = get(this, 'length'),
        isFirst = idx === 0,
        isLast = idx === len - 1,
        last, removed;


        if (idx >= 0 && idx < len && (this[idx] === obj)) {
            removed = [obj];

            this.enumerableContentWillChange(removed, null);
            if (isFirst) { Ember.propertyWillChange(this, 'firstObject'); }
            if (isLast) { Ember.propertyWillChange(this, 'lastObject'); }

            // swap items - basically move the item to the end so it can be removed
            if (idx < len - 1) {
                last = this[len - 1];
                this[idx] = last;
                this[guidFor(last)] = idx;
            }

            delete this[guid];
            delete this[len - 1];
            set(this, 'length', len - 1);

            if (isFirst) { Ember.propertyDidChange(this, 'firstObject'); }
            if (isLast) { Ember.propertyDidChange(this, 'lastObject'); }
            this.enumerableContentDidChange(removed, null);
        }

        return this;
    },

    /** @private (nodoc) - optimized version */
    contains: function (obj) {
        return this[guidFor(obj)] >= 0;
    },

    /** @private (nodoc) */
    copy: function () {
        var C = this.constructor, ret = new C(), loc = get(this, 'length');
        set(ret, 'length', loc);
        while (--loc >= 0) {
            ret[loc] = this[loc];
            ret[guidFor(this[loc])] = loc;
        }
        return ret;
    },

    /** @private */
    toString: function () {
        var len = this.length, idx, array = [];
        for (idx = 0; idx < len; idx++) {
            array[idx] = this[idx];
        }
        return "Ember.Set<%@>".fmt(array.join(','));
    }

});

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    Ember.CoreObject.subclasses = new Ember.Set();

    /**
    @class
    @extends Ember.CoreObject
    @extends Ember.Observable
    */
    Ember.Object = Ember.CoreObject.extend(Ember.Observable);




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var indexOf = Ember.ArrayUtils.indexOf;

    /**
    @private
    A Namespace is an object usually used to contain other objects or methods
    such as an application or framework.  Create a namespace anytime you want
    to define one of these new containers.

    # Example Usage

    MyFramework = Ember.Namespace.create({
    VERSION: '1.0.0'
    });

    */
    Ember.Namespace = Ember.Object.extend({
        isNamespace: true,

        init: function () {
            Ember.Namespace.NAMESPACES.push(this);
            Ember.Namespace.PROCESSED = false;
        },

        toString: function () {
            Ember.identifyNamespaces();
            return this[Ember.GUID_KEY + '_name'];
        },

        destroy: function () {
            var namespaces = Ember.Namespace.NAMESPACES;
            window[this.toString()] = undefined;
            namespaces.splice(indexOf(namespaces, this), 1);
            this._super();
        }
    });

    Ember.Namespace.NAMESPACES = [Ember];
    Ember.Namespace.PROCESSED = false;

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /**
    @private

    Defines a namespace that will contain an executable application.  This is
    very similar to a normal namespace except that it is expected to include at
    least a 'ready' function which can be run to initialize the application.

    Currently Ember.Application is very similar to Ember.Namespace.  However, this
    class may be augmented by additional frameworks so it is important to use
    this instance when building new applications.

    # Example Usage

    MyApp = Ember.Application.create({
    VERSION: '1.0.0',
    store: Ember.Store.create().from(Ember.fixtures)
    });

    MyApp.ready = function() {
    //..init code goes here...
    }

    */
    Ember.Application = Ember.Namespace.extend();


})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    /**
    @class

    An ArrayProxy wraps any other object that implements Ember.Array and/or
    Ember.MutableArray, forwarding all requests. This makes it very useful for
    a number of binding use cases or other cases where being able to swap
    out the underlying array is useful.

    A simple example of usage:

    var pets = ['dog', 'cat', 'fish'];
    var ap = Ember.ArrayProxy.create({ content: Ember.A(pets) });
    ap.get('firstObject'); // => 'dog'
    ap.set('content', ['amoeba', 'paramecium']);
    ap.get('firstObject'); // => 'amoeba'

    This class can also be useful as a layer to transform the contents of
    an array, as they are accessed. This can be done by overriding
    `objectAtContent`:

    var pets = ['dog', 'cat', 'fish'];
    var ap = Ember.ArrayProxy.create({
    content: Ember.A(pets),
    objectAtContent: function(idx) {
    return this.get('content').objectAt(idx).toUpperCase();
    }
    });
    ap.get('firstObject'); // => 'DOG'


    @extends Ember.Object
    @extends Ember.Array
    @extends Ember.MutableArray
    */
    Ember.ArrayProxy = Ember.Object.extend(Ember.MutableArray,
    /** @scope Ember.ArrayProxy.prototype */{

    /**
    The content array.  Must be an object that implements Ember.Array and/or
    Ember.MutableArray.

    @property {Ember.Array}
    */
    content: null,

    /**
    Should actually retrieve the object at the specified index from the
    content. You can override this method in subclasses to transform the
    content item to something new.

    This method will only be called if content is non-null.

    @param {Number} idx
    The index to retrieve.

    @returns {Object} the value or undefined if none found
    */
    objectAtContent: function (idx) {
        return get(this, 'content').objectAt(idx);
    },

    /**
    Should actually replace the specified objects on the content array.
    You can override this method in subclasses to transform the content item
    into something new.

    This method will only be called if content is non-null.

    @param {Number} idx
    The starting index

    @param {Number} amt
    The number of items to remove from the content.

    @param {Array} objects
    Optional array of objects to insert or null if no objects.

    @returns {void}
    */
    replaceContent: function (idx, amt, objects) {
        get(this, 'content').replace(idx, amt, objects);
    },

    /**
    Invoked when the content property is about to change. Notifies observers that the
    entire array content will change.
    */
    contentWillChange: Ember.beforeObserver(function () {
        var content = get(this, 'content'),
        len = content ? get(content, 'length') : 0;
        this.arrayWillChange(content, 0, len, undefined);
        if (content) content.removeArrayObserver(this);
    }, 'content'),

    /**
    Invoked when the content property changes.  Notifies observers that the
    entire array content has changed.
    */
    contentDidChange: Ember.observer(function () {
        var content = get(this, 'content'),
        len = content ? get(content, 'length') : 0;
        if (content) content.addArrayObserver(this);
        this.arrayDidChange(content, 0, undefined, len);
    }, 'content'),

    /** @private (nodoc) */
    objectAt: function (idx) {
        return get(this, 'content') && this.objectAtContent(idx);
    },

    /** @private (nodoc) */
    length: Ember.computed(function () {
        var content = get(this, 'content');
        return content ? get(content, 'length') : 0;
        // No dependencies since Enumerable notifies length of change
    }).property().cacheable(),

    /** @private (nodoc) */
    replace: function (idx, amt, objects) {
        if (get(this, 'content')) this.replaceContent(idx, amt, objects);
        return this;
    },

    /** @private (nodoc) */
    arrayWillChange: function (item, idx, removedCnt, addedCnt) {
        this.arrayContentWillChange(idx, removedCnt, addedCnt);
    },

    /** @private (nodoc) */
    arrayDidChange: function (item, idx, removedCnt, addedCnt) {
        this.arrayContentDidChange(idx, removedCnt, addedCnt);
    },

    /** @private (nodoc) */
    init: function () {
        this._super();
        this.contentWillChange();
        this.contentDidChange();
    }

});




})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var set = Ember.set, get = Ember.get, guidFor = Ember.guidFor;
    var forEach = Ember.ArrayUtils.forEach;

    var EachArray = Ember.Object.extend(Ember.Array, {

        init: function (content, keyName, owner) {
            this._super();
            this._keyName = keyName;
            this._owner = owner;
            this._content = content;
        },

        objectAt: function (idx) {
            var item = this._content.objectAt(idx);
            return item && get(item, this._keyName);
        },

        length: Ember.computed(function () {
            var content = this._content;
            return content ? get(content, 'length') : 0;
        }).property().cacheable()

    });

    var IS_OBSERVER = /^.+:(before|change)$/;

    /** @private */
    function addObserverForContentKey(content, keyName, proxy, idx, loc) {
        var objects = proxy._objects, guid;
        if (!objects) objects = proxy._objects = {};

        while (--loc >= idx) {
            var item = content.objectAt(loc);
            if (item) {
                Ember.addBeforeObserver(item, keyName, proxy, 'contentKeyWillChange');
                Ember.addObserver(item, keyName, proxy, 'contentKeyDidChange');

                // keep track of the indicies each item was found at so we can map
                // it back when the obj changes.
                guid = guidFor(item);
                if (!objects[guid]) objects[guid] = [];
                objects[guid].push(loc);
            }
        }
    }

    /** @private */
    function removeObserverForContentKey(content, keyName, proxy, idx, loc) {
        var objects = proxy._objects;
        if (!objects) objects = proxy._objects = {};
        var indicies, guid;

        while (--loc >= idx) {
            var item = content.objectAt(loc);
            if (item) {
                Ember.removeBeforeObserver(item, keyName, proxy, 'contentKeyWillChange');
                Ember.removeObserver(item, keyName, proxy, 'contentKeyDidChange');

                guid = guidFor(item);
                indicies = objects[guid];
                indicies[indicies.indexOf(loc)] = null;
            }
        }
    }

    /**
    @private
    @class

    This is the object instance returned when you get the @each property on an
    array.  It uses the unknownProperty handler to automatically create
    EachArray instances for property names.

    @extends Ember.Object
    */
    Ember.EachProxy = Ember.Object.extend({

        init: function (content) {
            this._super();
            this._content = content;
            content.addArrayObserver(this);

            // in case someone is already observing some keys make sure they are
            // added
            forEach(Ember.watchedEvents(this), function (eventName) {
                this.didAddListener(eventName);
            }, this);
        },

        /**
        You can directly access mapped properties by simply requesting them.
        The unknownProperty handler will generate an EachArray of each item.
        */
        unknownProperty: function (keyName, value) {
            var ret;
            ret = new EachArray(this._content, keyName, this);
            new Ember.Descriptor().setup(this, keyName, ret);
            this.beginObservingContentKey(keyName);
            return ret;
        },

        // ..........................................................
        // ARRAY CHANGES
        // Invokes whenever the content array itself changes.

        arrayWillChange: function (content, idx, removedCnt, addedCnt) {
            var keys = this._keys, key, array, lim;

            lim = removedCnt > 0 ? idx + removedCnt : -1;
            Ember.beginPropertyChanges(this);

            for (key in keys) {
                if (!keys.hasOwnProperty(key)) { continue; }

                if (lim > 0) removeObserverForContentKey(content, key, this, idx, lim);

                Ember.propertyWillChange(this, key);
            }

            Ember.propertyWillChange(this._content, '@each');
            Ember.endPropertyChanges(this);
        },

        arrayDidChange: function (content, idx, removedCnt, addedCnt) {
            var keys = this._keys, key, array, lim;

            lim = addedCnt > 0 ? idx + addedCnt : -1;
            Ember.beginPropertyChanges(this);

            for (key in keys) {
                if (!keys.hasOwnProperty(key)) { continue; }

                if (lim > 0) addObserverForContentKey(content, key, this, idx, lim);

                Ember.propertyDidChange(this, key);
            }

            Ember.propertyDidChange(this._content, '@each');
            Ember.endPropertyChanges(this);
        },

        // ..........................................................
        // LISTEN FOR NEW OBSERVERS AND OTHER EVENT LISTENERS
        // Start monitoring keys based on who is listening...

        didAddListener: function (eventName) {
            if (IS_OBSERVER.test(eventName)) {
                this.beginObservingContentKey(eventName.slice(0, -7));
            }
        },

        didRemoveListener: function (eventName) {
            if (IS_OBSERVER.test(eventName)) {
                this.stopObservingContentKey(eventName.slice(0, -7));
            }
        },

        // ..........................................................
        // CONTENT KEY OBSERVING
        // Actual watch keys on the source content.

        beginObservingContentKey: function (keyName) {
            var keys = this._keys;
            if (!keys) keys = this._keys = {};
            if (!keys[keyName]) {
                keys[keyName] = 1;
                var content = this._content,
          len = get(content, 'length');
                addObserverForContentKey(content, keyName, this, 0, len);
            } else {
                keys[keyName]++;
            }
        },

        stopObservingContentKey: function (keyName) {
            var keys = this._keys;
            if (keys && (keys[keyName] > 0) && (--keys[keyName] <= 0)) {
                var content = this._content,
          len = get(content, 'length');
                removeObserverForContentKey(content, keyName, this, 0, len);
            }
        },

        contentKeyWillChange: function (obj, keyName) {
            Ember.propertyWillChange(this, keyName);
        },

        contentKeyDidChange: function (obj, keyName) {
            Ember.propertyDidChange(this, keyName);
        }

    });



})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    // Add Ember.Array to Array.prototype.  Remove methods with native
    // implementations and supply some more optimized versions of generic methods
    // because they are so common.
    var NativeArray = Ember.Mixin.create(Ember.MutableArray, Ember.Observable, Ember.Copyable, {

        // because length is a built-in property we need to know to just get the
        // original property.
        get: function (key) {
            if (key === 'length') return this.length;
            else if ('number' === typeof key) return this[key];
            else return this._super(key);
        },

        objectAt: function (idx) {
            return this[idx];
        },

        // primitive for array support.
        replace: function (idx, amt, objects) {

            if (this.isFrozen) throw Ember.FROZEN_ERROR;

            // if we replaced exactly the same number of items, then pass only the
            // replaced range.  Otherwise, pass the full remaining array length
            // since everything has shifted
            var len = objects ? get(objects, 'length') : 0;
            this.arrayContentWillChange(idx, amt, len);

            if (!objects || objects.length === 0) {
                this.splice(idx, amt);
            } else {
                var args = [idx, amt].concat(objects);
                this.splice.apply(this, args);
            }

            this.arrayContentDidChange(idx, amt, len);
            return this;
        },

        // If you ask for an unknown property, then try to collect the value
        // from member items.
        unknownProperty: function (key, value) {
            var ret; // = this.reducedProperty(key, value) ;
            if ((value !== undefined) && ret === undefined) {
                ret = this[key] = value;
            }
            return ret;
        },

        // If browser did not implement indexOf natively, then override with
        // specialized version
        indexOf: function (object, startAt) {
            var idx, len = this.length;

            if (startAt === undefined) startAt = 0;
            else startAt = (startAt < 0) ? Math.ceil(startAt) : Math.floor(startAt);
            if (startAt < 0) startAt += len;

            for (idx = startAt; idx < len; idx++) {
                if (this[idx] === object) return idx;
            }
            return -1;
        },

        lastIndexOf: function (object, startAt) {
            var idx, len = this.length;

            if (startAt === undefined) startAt = len - 1;
            else startAt = (startAt < 0) ? Math.ceil(startAt) : Math.floor(startAt);
            if (startAt < 0) startAt += len;

            for (idx = startAt; idx >= 0; idx--) {
                if (this[idx] === object) return idx;
            }
            return -1;
        },

        copy: function () {
            return this.slice();
        }
    });

    // Remove any methods implemented natively so we don't override them
    var ignore = ['length'];
    Ember.ArrayUtils.forEach(NativeArray.keys(), function (methodName) {
        if (Array.prototype[methodName]) ignore.push(methodName);
    });

    if (ignore.length > 0) {
        NativeArray = NativeArray.without.apply(NativeArray, ignore);
    }

    /**
    The NativeArray mixin contains the properties needed to to make the native
    Array support Ember.MutableArray and all of its dependent APIs.  Unless you
    have Ember.EXTEND_PROTOTYPES set to false, this will be applied automatically.
    Otherwise you can apply the mixin at anytime by calling
    `Ember.NativeArray.activate`.

    @namespace
    @extends Ember.MutableArray
    @extends Ember.Array
    @extends Ember.Enumerable
    @extends Ember.MutableEnumerable
    @extends Ember.Copyable
    @extends Ember.Freezable
    */
    Ember.NativeArray = NativeArray;

    /**
    Creates an Ember.NativeArray from an Array like object.
    Does not modify the original object.

    @returns {Ember.NativeArray}
    */
    Ember.A = function (arr) {
        if (arr === undefined) { arr = []; }
        return Ember.NativeArray.apply(arr);
    };

    /**
    Activates the mixin on the Array.prototype if not already applied.  Calling
    this method more than once is safe.

    @returns {void}
    */
    Ember.NativeArray.activate = function () {
        NativeArray.apply(Array.prototype);

        Ember.A = function (arr) { return arr || []; };
    };

    if (Ember.EXTEND_PROTOTYPES) Ember.NativeArray.activate();



})();



(function () {
    /**
    JavaScript (before ES6) does not have a Map implementation. Objects,
    which are often used as dictionaries, may only have Strings as keys.

    Because Ember has a way to get a unique identifier for every object
    via `Ember.guidFor`, we can implement a performant Map with arbitrary
    keys. Because it is commonly used in low-level bookkeeping, Map is
    implemented as a pure JavaScript object for performance.

    This implementation follows the current iteration of the ES6 proposal
    for maps (http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets),
    with two exceptions. First, because we need our implementation to be
    pleasant on older browsers, we do not use the `delete` name (using
    `remove` instead). Second, as we do not have the luxury of in-VM
    iteration, we implement a forEach method for iteration.

    Map is mocked out to look like an Ember object, so you can do
    `Ember.Map.create()` for symmetry with other Ember classes.
    */

    /** @private */
    var guidFor = Ember.guidFor;
    var indexOf = Ember.ArrayUtils.indexOf;

    // This class is used internally by Ember.js and Ember Data.
    // Please do not use it at this time. We plan to clean it up
    // and add many tests soon.
    var OrderedSet = Ember.OrderedSet = function () {
        this.clear();
    };

    OrderedSet.create = function () {
        return new OrderedSet();
    };

    OrderedSet.prototype = {
        clear: function () {
            this.presenceSet = {};
            this.list = [];
        },

        add: function (obj) {
            var guid = guidFor(obj),
        presenceSet = this.presenceSet,
        list = this.list;

            if (guid in presenceSet) { return; }

            presenceSet[guid] = true;
            list.push(obj);
        },

        remove: function (obj) {
            var guid = guidFor(obj),
        presenceSet = this.presenceSet,
        list = this.list;

            delete presenceSet[guid];

            var index = indexOf(list, obj);
            if (index > -1) {
                list.splice(index, 1);
            }
        },

        isEmpty: function () {
            return this.list.length === 0;
        },

        forEach: function (fn, self) {
            // allow mutation during iteration
            var list = this.list.slice();

            for (var i = 0, j = list.length; i < j; i++) {
                fn.call(self, list[i]);
            }
        },

        toArray: function () {
            return this.list.slice();
        }
    };

    /**
    A Map stores values indexed by keys. Unlike JavaScript's
    default Objects, the keys of a Map can be any JavaScript
    object.

    Internally, a Map has two data structures:

    `keys`: an OrderedSet of all of the existing keys
    `values`: a JavaScript Object indexed by the
    Ember.guidFor(key)

    When a key/value pair is added for the first time, we
    add the key to the `keys` OrderedSet, and create or
    replace an entry in `values`. When an entry is deleted,
    we delete its entry in `keys` and `values`.
    */

    /** @private */
    var Map = Ember.Map = function () {
        this.keys = Ember.OrderedSet.create();
        this.values = {};
    };

    Map.create = function () {
        return new Map();
    };

    Map.prototype = {
        /**
        Retrieve the value associated with a given key.

        @param {anything} key
        @return {anything} the value associated with the key, or undefined
        */
        get: function (key) {
            var values = this.values,
        guid = guidFor(key);

            return values[guid];
        },

        /**
        Adds a value to the map. If a value for the given key has already been
        provided, the new value will replace the old value.

        @param {anything} key
        @param {anything} value
        */
        set: function (key, value) {
            var keys = this.keys,
        values = this.values,
        guid = guidFor(key);

            keys.add(key);
            values[guid] = value;
        },

        /**
        Removes a value from the map for an associated key.

        @param {anything} key
        @returns {Boolean} true if an item was removed, false otherwise
        */
        remove: function (key) {
            // don't use ES6 "delete" because it will be annoying
            // to use in browsers that are not ES6 friendly;
            var keys = this.keys,
        values = this.values,
        guid = guidFor(key),
        value;

            if (values.hasOwnProperty(guid)) {
                keys.remove(key);
                value = values[guid];
                delete values[guid];
                return true;
            } else {
                return false;
            }
        },

        /**
        Check whether a key is present.

        @param {anything} key
        @returns {Boolean} true if the item was present, false otherwise
        */
        has: function (key) {
            var values = this.values,
        guid = guidFor(key);

            return values.hasOwnProperty(guid);
        },

        /**
        Iterate over all the keys and values. Calls the function once
        for each key, passing in the key and value, in that order.

        The keys are guaranteed to be iterated over in insertion order.

        @param {Function} callback
        @param {anything} self if passed, the `this` value inside the
        callback. By default, `this` is the map.
        */
        forEach: function (callback, self) {
            var keys = this.keys,
        values = this.values;

            keys.forEach(function (key) {
                var guid = guidFor(key);
                callback.call(self, key, values[guid]);
            });
        }
    };

})();



(function () {
    var loadHooks = {};
    var loaded = {};

    Ember.onLoad = function (name, callback) {
        var object;

        loadHooks[name] = loadHooks[name] || Ember.A();
        loadHooks[name].pushObject(callback);

        if (object = loaded[name]) {
            callback(object);
        }
    };

    Ember.runLoadHooks = function (name, object) {
        var hooks;

        loaded[name] = object;

        if (hooks = loadHooks[name]) {
            loadHooks[name].forEach(function (callback) {
                callback(object);
            });
        }
    };

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /**
    @class

    Ember.ArrayController provides a way for you to publish a collection of objects
    so that you can easily bind to the collection from a Handlebars #each helper,
    an Ember.CollectionView, or other controllers.

    The advantage of using an ArrayController is that you only have to set up
    your view bindings once; to change what's displayed, simply swap out the
    `content` property on the controller.

    For example, imagine you wanted to display a list of items fetched via an XHR
    request. Create an Ember.ArrayController and set its `content` property:

    MyApp.listController = Ember.ArrayController.create();

    $.get('people.json', function(data) {
    MyApp.listController.set('content', data);
    });

    Then, create a view that binds to your new controller:

    {{#each MyApp.listController}}
    {{firstName}} {{lastName}}
    {{/each}}

    Although you are binding to the controller, the behavior of this controller
    is to pass through any methods or properties to the underlying array. This
    capability comes from `Ember.ArrayProxy`, which this class inherits from.

    Note: As of this writing, `ArrayController` does not add any functionality
    to its superclass, `ArrayProxy`. The Ember team plans to add additional
    controller-specific functionality in the future, e.g. single or multiple
    selection support. If you are creating something that is conceptually a
    controller, use this class.

    @extends Ember.ArrayProxy
    */

    Ember.ArrayController = Ember.ArrayProxy.extend();

})();



(function () {

})();



(function () {
    // ==========================================================================
    // Project:  Ember Runtime
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();

(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    var get = Ember.get, set = Ember.set;

    /**
    @class

    An Ember.Application instance serves as the namespace in which you define your
    application's classes. You can also override the configuration of your
    application.

    By default, Ember.Application will begin listening for events on the document.
    If your application is embedded inside a page, instead of controlling the
    entire document, you can specify which DOM element to attach to by setting
    the `rootElement` property:

    MyApp = Ember.Application.create({
    rootElement: $('#my-app')
    });

    The root of an Ember.Application must not be removed during the course of the
    page's lifetime. If you have only a single conceptual application for the
    entire page, and are not embedding any third-party Ember applications
    in your page, use the default document root for your application.

    You only need to specify the root if your page contains multiple instances
    of Ember.Application.

    @extends Ember.Object
    */
    Ember.Application = Ember.Namespace.extend(
    /** @scope Ember.Application.prototype */{

    /**
    The root DOM element of the Application.

    Can be specified as DOMElement or a selector string.

    @type DOMElement
    @default 'body'
    */
    rootElement: 'body',

    /**
    @type Ember.EventDispatcher
    @default null
    */
    eventDispatcher: null,

    /**
    @type Object
    @default null
    */
    customEvents: null,

    /** @private */
    init: function () {
        var eventDispatcher,
        rootElement = get(this, 'rootElement');
        this._super();

        eventDispatcher = Ember.EventDispatcher.create({
            rootElement: rootElement
        });

        set(this, 'eventDispatcher', eventDispatcher);

        // jQuery 1.7 doesn't call the ready callback if already ready
        if (Ember.$.isReady) {
            Ember.run.once(this, this.didBecomeReady);
        } else {
            var self = this;
            Ember.$(document).ready(function () {
                Ember.run.once(self, self.didBecomeReady);
            });
        }
    },

    /**
    Instantiate all controllers currently available on the namespace
    and inject them onto a state manager.

    Example:

    App.PostsController = Ember.ArrayController.extend();
    App.CommentsController = Ember.ArrayController.extend();

    var stateManager = Ember.StateManager.create({
    ...
    });

    App.initialize(stateManager);

    stateManager.get('postsController')     // <App.PostsController:ember1234>
    stateManager.get('commentsController')  // <App.CommentsController:ember1235>

    stateManager.getPath('postsController.stateManager') // stateManager
    */
    initialize: function (stateManager) {
        var properties = Ember.A(Ember.keys(this)),
        injections = get(this.constructor, 'injections'),
        namespace = this, controller, name;

        Ember.runLoadHooks('application', this);

        properties.forEach(function (property) {
            injections.forEach(function (injection) {
                injection(namespace, stateManager, property);
            });
        });
    },

    /** @private */
    didBecomeReady: function () {
        var eventDispatcher = get(this, 'eventDispatcher'),
        stateManager = get(this, 'stateManager'),
        customEvents = get(this, 'customEvents');

        eventDispatcher.setup(customEvents);

        this.ready();

        if (stateManager && stateManager instanceof Ember.Router) {
            this.setupStateManager(stateManager);
        }
    },

    /**
    @private

    If the application has a state manager, use it to route
    to the current URL, and trigger a new call to `route`
    whenever the URL changes.
    */
    setupStateManager: function (stateManager) {
        var location = get(stateManager, 'location');

        stateManager.route(location.getURL());
        location.onUpdateURL(function (url) {
            stateManager.route(url);
        });
    },

    /**
    Called when the Application has become ready.
    The call will be delayed until the DOM has become ready.
    */
    ready: Ember.K,

    /** @private */
    destroy: function () {
        get(this, 'eventDispatcher').destroy();
        return this._super();
    },

    registerInjection: function (callback) {
        this.constructor.registerInjection(callback);
    }
});

Ember.Application.reopenClass({
    concatenatedProperties: ['injections'],
    injections: Ember.A(),
    registerInjection: function (callback) {
        get(this, 'injections').pushObject(callback);
    }
});

Ember.Application.registerInjection(function (app, stateManager, property) {
    if (!/^[A-Z].*Controller$/.test(property)) { return; }

    var name = property[0].toLowerCase() + property.substr(1),
      controller = app[property].create();

    stateManager.set(name, controller);
    controller.set('target', stateManager);
});

})();



(function () {
    var get = Ember.get, set = Ember.set;

    /**
    This file implements the `location` API used by Ember's router.

    That API is:

    getURL: returns the current URL
    setURL(path): sets the current URL
    onUpdateURL(callback): triggers the callback when the URL changes

    Calling setURL will not trigger onUpdateURL callbacks.
    */

    /**
    Ember.HashLocation implements the location API using the browser's
    hash. At present, it relies on a hashchange event existing in the
    browser.
    */
    Ember.HashLocation = Ember.Object.extend({
        init: function () {
            set(this, 'location', get(this, 'location') || window.location);
            set(this, 'callbacks', Ember.A());
        },

        /**
        @private

        Returns the current `location.hash`, minus the '#' at the front.
        */
        getURL: function () {
            return get(this, 'location').hash.substr(1);
        },

        /**
        @private

        Set the `location.hash` and remembers what was set. This prevents
        `onUpdateURL` callbacks from triggering when the hash was set by
        `HashLocation`.
        */
        setURL: function (path) {
            get(this, 'location').hash = path;
            set(this, 'lastSetURL', path);
        },

        /**
        @private

        Register a callback to be invoked when the hash changes. These
        callbacks will execute when the user presses the back or forward
        button, but not after `setURL` is invoked.
        */
        onUpdateURL: function (callback) {
            var self = this;

            var hashchange = function () {
                var path = location.hash.substr(1);
                if (get(self, 'lastSetURL') === path) { return; }

                set(self, 'lastSetURL', null);

                callback(location.hash.substr(1));
            };

            get(this, 'callbacks').pushObject(hashchange);
            window.addEventListener('hashchange', hashchange);
        },

        willDestroy: function () {
            get(this, 'callbacks').forEach(function (callback) {
                window.removeEventListener('hashchange', callback);
            });
            set(this, 'callbacks', null);
        }
    });

    /**
    Ember.Location returns an instance of the correct implementation of
    the `location` API.

    You can pass it a `style` ('hash', 'html5', 'none') to force a
    particular implementation.
    */
    Ember.Location = {
        create: function (options) {
            var style = options && options.style;
            Ember.assert("you must provide a style to Ember.Location.create", !!style);

            if (style === "hash") {
                return Ember.HashLocation.create.apply(Ember.HashLocation, arguments);
            }
        }
    };

})();



(function () {

})();



(function () {

})();

(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    Ember.assert("Ember Views require jQuery 1.6, 1.7, or 1.8", window.jQuery && window.jQuery().jquery.match(/^1\.[678](\.\d+)?(pre|rc\d?)?/));
    Ember.$ = window.jQuery;

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    var get = Ember.get, set = Ember.set;
    var forEach = Ember.ArrayUtils.forEach;
    var indexOf = Ember.ArrayUtils.indexOf;

    /** @private */
    var ClassSet = function () {
        this.seen = {};
        this.list = [];
    };

    ClassSet.prototype = {
        add: function (string) {
            if (string in this.seen) { return; }
            this.seen[string] = true;

            this.list.push(string);
        },

        toDOM: function () {
            return this.list.join(" ");
        }
    };

    /**
    @class

    Ember.RenderBuffer gathers information regarding the a view and generates the
    final representation. Ember.RenderBuffer will generate HTML which can be pushed
    to the DOM.

    @extends Ember.Object
    */
    Ember.RenderBuffer = function (tagName) {
        return new Ember._RenderBuffer(tagName);
    };

    Ember._RenderBuffer = function (tagName) {
        this.elementTag = tagName;
        this.childBuffers = [];
    };

    Ember._RenderBuffer.prototype =
    /** @scope Ember.RenderBuffer.prototype */{

    /**
    Array of class-names which will be applied in the class="" attribute

    You should not maintain this array yourself, rather, you should use
    the addClass() method of Ember.RenderBuffer.

    @type Array
    @default []
    */
    elementClasses: null,

    /**
    The id in of the element, to be applied in the id="" attribute

    You should not set this property yourself, rather, you should use
    the id() method of Ember.RenderBuffer.

    @type String
    @default null
    */
    elementId: null,

    /**
    A hash keyed on the name of the attribute and whose value will be
    applied to that attribute. For example, if you wanted to apply a
    data-view="Foo.bar" property to an element, you would set the
    elementAttributes hash to {'data-view':'Foo.bar'}

    You should not maintain this hash yourself, rather, you should use
    the attr() method of Ember.RenderBuffer.

    @type Hash
    @default {}
    */
    elementAttributes: null,

    /**
    The tagname of the element an instance of Ember.RenderBuffer represents.

    Usually, this gets set as the first parameter to Ember.RenderBuffer. For
    example, if you wanted to create a `p` tag, then you would call

    Ember.RenderBuffer('p')

    @type String
    @default null
    */
    elementTag: null,

    /**
    A hash keyed on the name of the style attribute and whose value will
    be applied to that attribute. For example, if you wanted to apply a
    background-color:black;" style to an element, you would set the
    elementStyle hash to {'background-color':'black'}

    You should not maintain this hash yourself, rather, you should use
    the style() method of Ember.RenderBuffer.

    @type Hash
    @default {}
    */
    elementStyle: null,

    /**
    Nested RenderBuffers will set this to their parent RenderBuffer
    instance.

    @type Ember._RenderBuffer
    */
    parentBuffer: null,

    /**
    Adds a string of HTML to the RenderBuffer.

    @param {String} string HTML to push into the buffer
    @returns {Ember.RenderBuffer} this
    */
    push: function (string) {
        this.childBuffers.push(String(string));
        return this;
    },

    /**
    Adds a class to the buffer, which will be rendered to the class attribute.

    @param {String} className Class name to add to the buffer
    @returns {Ember.RenderBuffer} this
    */
    addClass: function (className) {
        // lazily create elementClasses
        var elementClasses = this.elementClasses = (this.elementClasses || new ClassSet());
        this.elementClasses.add(className);

        return this;
    },

    /**
    Sets the elementID to be used for the element.

    @param {String} id
    @returns {Ember.RenderBuffer} this
    */
    id: function (id) {
        this.elementId = id;
        return this;
    },

    // duck type attribute functionality like jQuery so a render buffer
    // can be used like a jQuery object in attribute binding scenarios.

    /**
    Adds an attribute which will be rendered to the element.

    @param {String} name The name of the attribute
    @param {String} value The value to add to the attribute
    @returns {Ember.RenderBuffer|String} this or the current attribute value
    */
    attr: function (name, value) {
        var attributes = this.elementAttributes = (this.elementAttributes || {});

        if (arguments.length === 1) {
            return attributes[name];
        } else {
            attributes[name] = value;
        }

        return this;
    },

    /**
    Remove an attribute from the list of attributes to render.

    @param {String} name The name of the attribute
    @returns {Ember.RenderBuffer} this
    */
    removeAttr: function (name) {
        var attributes = this.elementAttributes;
        if (attributes) { delete attributes[name]; }

        return this;
    },

    /**
    Adds a style to the style attribute which will be rendered to the element.

    @param {String} name Name of the style
    @param {String} value
    @returns {Ember.RenderBuffer} this
    */
    style: function (name, value) {
        var style = this.elementStyle = (this.elementStyle || {});

        this.elementStyle[name] = value;
        return this;
    },

    /**
    Create a new child render buffer from a parent buffer. Optionally set
    additional properties on the buffer. Optionally invoke a callback
    with the newly created buffer.

    This is a primitive method used by other public methods: `begin`,
    `prepend`, `replaceWith`, `insertAfter`.

    @private
    @param {String} tagName Tag name to use for the child buffer's element
    @param {Ember._RenderBuffer} parent The parent render buffer that this
    buffer should be appended to.
    @param {Function} fn A callback to invoke with the newly created buffer.
    @param {Object} other Additional properties to add to the newly created
    buffer.
    */
    newBuffer: function (tagName, parent, fn, other) {
        var buffer = new Ember._RenderBuffer(tagName);
        buffer.parentBuffer = parent;

        if (other) { buffer.setProperties(other); }
        if (fn) { fn.call(this, buffer); }

        return buffer;
    },

    /**
    Replace the current buffer with a new buffer. This is a primitive
    used by `remove`, which passes `null` for `newBuffer`, and `replaceWith`,
    which passes the new buffer it created.

    @private
    @param {Ember._RenderBuffer} buffer The buffer to insert in place of
    the existing buffer.
    */
    replaceWithBuffer: function (newBuffer) {
        var parent = this.parentBuffer;
        if (!parent) { return; }

        var childBuffers = parent.childBuffers;

        var index = indexOf(childBuffers, this);

        if (newBuffer) {
            childBuffers.splice(index, 1, newBuffer);
        } else {
            childBuffers.splice(index, 1);
        }
    },

    /**
    Creates a new Ember.RenderBuffer object with the provided tagName as
    the element tag and with its parentBuffer property set to the current
    Ember.RenderBuffer.

    @param {String} tagName Tag name to use for the child buffer's element
    @returns {Ember.RenderBuffer} A new RenderBuffer object
    */
    begin: function (tagName) {
        return this.newBuffer(tagName, this, function (buffer) {
            this.childBuffers.push(buffer);
        });
    },

    /**
    Prepend a new child buffer to the current render buffer.

    @param {String} tagName Tag name to use for the child buffer's element
    */
    prepend: function (tagName) {
        return this.newBuffer(tagName, this, function (buffer) {
            this.childBuffers.splice(0, 0, buffer);
        });
    },

    /**
    Replace the current buffer with a new render buffer.

    @param {String} tagName Tag name to use for the new buffer's element
    */
    replaceWith: function (tagName) {
        var parentBuffer = this.parentBuffer;

        return this.newBuffer(tagName, parentBuffer, function (buffer) {
            this.replaceWithBuffer(buffer);
        });
    },

    /**
    Insert a new render buffer after the current render buffer.

    @param {String} tagName Tag name to use for the new buffer's element
    */
    insertAfter: function (tagName) {
        var parentBuffer = get(this, 'parentBuffer');

        return this.newBuffer(tagName, parentBuffer, function (buffer) {
            var siblings = parentBuffer.childBuffers;
            var index = indexOf(siblings, this);
            siblings.splice(index + 1, 0, buffer);
        });
    },

    /**
    Closes the current buffer and adds its content to the parentBuffer.

    @returns {Ember.RenderBuffer} The parentBuffer, if one exists. Otherwise, this
    */
    end: function () {
        var parent = this.parentBuffer;
        return parent || this;
    },

    remove: function () {
        this.replaceWithBuffer(null);
    },

    /**
    @returns {DOMElement} The element corresponding to the generated HTML
    of this buffer
    */
    element: function () {
        return Ember.$(this.string())[0];
    },

    /**
    Generates the HTML content for this buffer.

    @returns {String} The generated HTMl
    */
    string: function () {
        var content = '', tag = this.elementTag, openTag;

        if (tag) {
            var id = this.elementId,
          classes = this.elementClasses,
          attrs = this.elementAttributes,
          style = this.elementStyle,
          styleBuffer = '', prop;

            openTag = ["<" + tag];

            if (id) { openTag.push('id="' + this._escapeAttribute(id) + '"'); }
            if (classes) { openTag.push('class="' + this._escapeAttribute(classes.toDOM()) + '"'); }

            if (style) {
                for (prop in style) {
                    if (style.hasOwnProperty(prop)) {
                        styleBuffer += (prop + ':' + this._escapeAttribute(style[prop]) + ';');
                    }
                }

                openTag.push('style="' + styleBuffer + '"');
            }

            if (attrs) {
                for (prop in attrs) {
                    if (attrs.hasOwnProperty(prop)) {
                        openTag.push(prop + '="' + this._escapeAttribute(attrs[prop]) + '"');
                    }
                }
            }

            openTag = openTag.join(" ") + '>';
        }

        var childBuffers = this.childBuffers;

        forEach(childBuffers, function (buffer) {
            var stringy = typeof buffer === 'string';
            content += (stringy ? buffer : buffer.string());
        });

        if (tag) {
            return openTag + content + "</" + tag + ">";
        } else {
            return content;
        }
    },

    _escapeAttribute: function (value) {
        // Stolen shamelessly from Handlebars

        var escape = {
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        };

        var badChars = /&(?!\w+;)|[<>"'`]/g;
        var possible = /[&<>"'`]/;

        var escapeChar = function (chr) {
            return escape[chr] || "&amp;";
        };

        var string = value.toString();

        if (!possible.test(string)) { return string; }
        return string.replace(badChars, escapeChar);
    }

};

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    var get = Ember.get, set = Ember.set, fmt = Ember.String.fmt;

    /**
    @ignore

    Ember.EventDispatcher handles delegating browser events to their corresponding
    Ember.Views. For example, when you click on a view, Ember.EventDispatcher ensures
    that that view's `mouseDown` method gets called.
    */
    Ember.EventDispatcher = Ember.Object.extend(
    /** @scope Ember.EventDispatcher.prototype */{

    /**
    @private

    The root DOM element to which event listeners should be attached. Event
    listeners will be attached to the document unless this is overridden.

    Can be specified as a DOMElement or a selector string.

    The default body is a string since this may be evaluated before document.body
    exists in the DOM.

    @type DOMElement
    @default 'body'
    */
    rootElement: 'body',

    /**
    @private

    Sets up event listeners for standard browser events.

    This will be called after the browser sends a DOMContentReady event. By
    default, it will set up all of the listeners on the document body. If you
    would like to register the listeners on a different element, set the event
    dispatcher's `root` property.
    */
    setup: function (addedEvents) {
        var event, events = {
            touchstart: 'touchStart',
            touchmove: 'touchMove',
            touchend: 'touchEnd',
            touchcancel: 'touchCancel',
            keydown: 'keyDown',
            keyup: 'keyUp',
            keypress: 'keyPress',
            mousedown: 'mouseDown',
            mouseup: 'mouseUp',
            contextmenu: 'contextMenu',
            click: 'click',
            dblclick: 'doubleClick',
            mousemove: 'mouseMove',
            focusin: 'focusIn',
            focusout: 'focusOut',
            mouseenter: 'mouseEnter',
            mouseleave: 'mouseLeave',
            submit: 'submit',
            input: 'input',
            change: 'change',
            dragstart: 'dragStart',
            drag: 'drag',
            dragenter: 'dragEnter',
            dragleave: 'dragLeave',
            dragover: 'dragOver',
            drop: 'drop',
            dragend: 'dragEnd'
        };

        Ember.$.extend(events, addedEvents || {});

        var rootElement = Ember.$(get(this, 'rootElement'));

        Ember.assert(fmt('You cannot use the same root element (%@) multiple times in an Ember.Application', [rootElement.selector || rootElement[0].tagName]), !rootElement.is('.ember-application'));
        Ember.assert('You cannot make a new Ember.Application using a root element that is a descendent of an existing Ember.Application', !rootElement.closest('.ember-application').length);
        Ember.assert('You cannot make a new Ember.Application using a root element that is an ancestor of an existing Ember.Application', !rootElement.find('.ember-application').length);

        rootElement.addClass('ember-application');

        Ember.assert('Unable to add "ember-application" class to rootElement. Make sure you set rootElement to the body or an element in the body.', rootElement.is('.ember-application'));

        for (event in events) {
            if (events.hasOwnProperty(event)) {
                this.setupHandler(rootElement, event, events[event]);
            }
        }
    },

    /**
    @private

    Registers an event listener on the document. If the given event is
    triggered, the provided event handler will be triggered on the target
    view.

    If the target view does not implement the event handler, or if the handler
    returns false, the parent view will be called. The event will continue to
    bubble to each successive parent view until it reaches the top.

    For example, to have the `mouseDown` method called on the target view when
    a `mousedown` event is received from the browser, do the following:

    setupHandler('mousedown', 'mouseDown');

    @param {String} event the browser-originated event to listen to
    @param {String} eventName the name of the method to call on the view
    */
    setupHandler: function (rootElement, event, eventName) {
        var self = this;

        rootElement.delegate('.ember-view', event + '.ember', function (evt, triggeringManager) {

            var view = Ember.View.views[this.id],
          result = true, manager = null;

            manager = self._findNearestEventManager(view, eventName);

            if (manager && manager !== triggeringManager) {
                result = self._dispatchEvent(manager, evt, eventName, view);
            } else if (view) {
                result = self._bubbleEvent(view, evt, eventName);
            } else {
                evt.stopPropagation();
            }

            return result;
        });

        rootElement.delegate('[data-ember-action]', event + '.ember', function (evt) {
            var actionId = Ember.$(evt.currentTarget).attr('data-ember-action'),
          action = Ember.Handlebars.ActionHelper.registeredActions[actionId],
          handler = action.handler;

            if (action.eventName === eventName) {
                return handler(evt);
            }
        });
    },

    /** @private */
    _findNearestEventManager: function (view, eventName) {
        var manager = null;

        while (view) {
            manager = get(view, 'eventManager');
            if (manager && manager[eventName]) { break; }

            view = get(view, 'parentView');
        }

        return manager;
    },

    /** @private */
    _dispatchEvent: function (object, evt, eventName, view) {
        var result = true;

        var handler = object[eventName];
        if (Ember.typeOf(handler) === 'function') {
            result = handler.call(object, evt, view);
            evt.stopPropagation();
        }
        else {
            result = this._bubbleEvent(view, evt, eventName);
        }

        return result;
    },

    /** @private */
    _bubbleEvent: function (view, evt, eventName) {
        return Ember.run(function () {
            return view.handleEvent(eventName, evt);
        });
    },

    /** @private */
    destroy: function () {
        var rootElement = get(this, 'rootElement');
        Ember.$(rootElement).undelegate('.ember').removeClass('ember-application');
        return this._super();
    }
});

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    // Add a new named queue for rendering views that happens
    // after bindings have synced.
    var queues = Ember.run.queues;
    queues.splice(Ember.$.inArray('actions', queues) + 1, 0, 'render');

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, addObserver = Ember.addObserver;
    var getPath = Ember.getPath, meta = Ember.meta, fmt = Ember.String.fmt;
    var a_slice = Array.prototype.slice;
    var a_forEach = Ember.ArrayUtils.forEach;

    var childViewsProperty = Ember.computed(function () {
        var childViews = get(this, '_childViews');

        var ret = Ember.A();

        a_forEach(childViews, function (view) {
            if (view.isVirtual) {
                ret.pushObjects(get(view, 'childViews'));
            } else {
                ret.push(view);
            }
        });

        return ret;
    }).property().cacheable();

    var VIEW_PRESERVES_CONTEXT = Ember.VIEW_PRESERVES_CONTEXT;
    Ember.warn("The way that the {{view}} helper affects templates is about to change. Previously, templates inside child views would use the new view as the context. Soon, views will preserve their parent context when rendering their template. You can opt-in early to the new behavior by setting `ENV.VIEW_PRESERVES_CONTEXT = true`. For more information, see https://gist.github.com/2494968. You should update your templates as soon as possible; this default will change soon, and the option will be eliminated entirely before the 1.0 release.", VIEW_PRESERVES_CONTEXT);

    /**
    @static

    Global hash of shared templates. This will automatically be populated
    by the build tools so that you can store your Handlebars templates in
    separate files that get loaded into JavaScript at buildtime.

    @type Hash
    */
    Ember.TEMPLATES = {};

    var invokeForState = {
        preRender: {},
        inBuffer: {},
        hasElement: {},
        inDOM: {},
        destroyed: {}
    };

    /**
    @class

    `Ember.View` is the class in Ember responsible for encapsulating templates of HTML
    content, combining templates with data to render as sections of a page's DOM, and
    registering and responding to user-initiated events.
  
    ## HTML Tag
    The default HTML tag name used for a view's DOM representation is `div`. This can be
    customized by setting the `tagName` property. The following view class:

    ParagraphView = Ember.View.extend({
    tagName: 'em'
    })

    Would result in instances with the following HTML:

    <em id="ember1" class="ember-view"></em>

    ## HTML `class` Attribute
    The HTML `class` attribute of a view's tag can be set by providing a `classNames` property
    that is set to an array of strings:

    MyView = Ember.View.extend({
    classNames: ['my-class', 'my-other-class']
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view my-class my-other-class"></div>

    `class` attribute values can also be set by providing a `classNameBindings` property
    set to an array of properties names for the view. The return value of these properties 
    will be added as part of the value for the view's `class` attribute. These properties
    can be computed properties:

    MyView = Ember.View.extend({
    classNameBindings: ['propertyA', 'propertyB'],
    propertyA: 'from-a',
    propertyB: function(){
    if(someLogic){ return 'from-b'; }
    }.property()
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view from-a from-b"></div>

    If the value of a class name binding returns a boolean the property name itself
    will be used as the class name if the property is true. The class name will
    not be added if the value is `false` or `undefined`.

    MyView = Ember.View.extend({
    classNameBindings: ['hovered'],
    hovered: true
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view hovered"></div>

    When using boolean class name bindings you can supply a string value other than the 
    property name for use as the `class` HTML attribute by appending the preferred value after
    a ":" character when defining the binding:

    MyView = Ember.View.extend({
    classNameBindings: ['awesome:so-very-cool'],
    awesome: true
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view so-very-cool"></div>


    Boolean value class name bindings whose property names are in a camelCase-style
    format will be converted to a dasherized format:

    MyView = Ember.View.extend({
    classNameBindings: ['isUrgent'],
    isUrgent: true
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view is-urgent"></div>


    Class name bindings can also refer to object values that are found by
    traversing a path relative to the view itself:

    MyView = Ember.View.extend({
    classNameBindings: ['messages.empty']
    messages: Ember.Object.create({
    empty: true
    })
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view empty"></div>

    Updates to the the value of a class name binding will result in automatic update 
    of the  HTML `class` attribute in the view's rendered HTML representation.
    If the value becomes  `false` or `undefined` the class name will be removed.

    Both `classNames` and `classNameBindings` are concatenated properties. 
    See `Ember.Object` documentation for more information about concatenated properties.

    ## HTML Attributes
    The HTML attribute section of a view's tag can be set by providing an `attributeBindings`
    property set to an array of property names on the view. The return value of these properties
    will be used as the value of the view's HTML associated attribute:

    AnchorView = Ember.View.extend({
    tagName: 'a',
    attributeBindings: ['href'],
    href: 'http://google.com'
    })

    Will result in view instances with an HTML representation of:

    <a id="ember1" class="ember-view" href="http://google.com"></a>

    If the return value of an `attributeBindings` monitored property is a boolean
    the property will follow HTML's pattern of repeating the attribute's name as
    its value:

    MyTextInput = Ember.View.extend({
    tagName: 'input',
    attributeBindings: ['disabled'],
    disabled: true
    })

    Will result in view instances with an HTML representation of:

    <input id="ember1" class="ember-view" disabled="disabled" />

    `attributeBindings` can refer to computed properties:

    MyTextInput = Ember.View.extend({
    tagName: 'input',
    attributeBindings: ['disabled'],
    disabled: function(){
    if (someLogic) {
    return true;
    } else {
    return false;
    }
    }.property()
    })

    Updates to the the property of an attribute binding will result in automatic update 
    of the  HTML attribute in the view's rendered HTML representation.

    `attributeBindings` is a concatenated property. See `Ember.Object` documentation
    for more information about concatenated properties.

    ## Templates
    The HTML contents of a view's rendered representation are determined by its template.
    Templates can be any function that accepts an optional context parameter and returns
    a string of HTML that will be inserted within the view's tag. Most
    typically in Ember this function will be a compiled Ember.Handlebars template.

    AView = Ember.View.extend({
    template: Ember.Handlebars.compile('I am the template')
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view">I am the template</div>

    The default context of the compiled template will be the view instance itself:

    AView = Ember.View.extend({
    template: Ember.Handlebars.compile('Hello {{excitedGreeting}}')
    })

    aView = AView.create({
    content: Ember.Object.create({
    firstName: 'Barry'
    })
    excitedGreeting: function(){
    return this.getPath("content.firstName") + "!!!"
    }
    })

    Will result in an HTML representation of:

    <div id="ember1" class="ember-view">Hello Barry!!!</div>

    Within an Ember application is more common to define a Handlebars templates as
    part of a page:

    <script type='text/x-handlebars' data-template-name='some-template'>
    Hello
    </script>

    And associate it by name using a view's `templateName` property:

    AView = Ember.View.extend({
    templateName: 'some-template'
    })

    Using a value for `templateName` that does not have a Handlebars template with a
    matching `data-template-name` attribute will throw an error.

    Assigning a value to both `template` and `templateName` properties will throw an error.

    For views classes that may have a template later defined (e.g. as the block portion of a `{{view}}`
    Handlebars helper call in another template or in a subclass), you can provide a `defaultTemplate`
    property set to compiled template function. If a template is not later provided for the view
    instance the `defaultTemplate` value will be used:

    AView = Ember.View.extend({
    defaultTemplate: Ember.Handlebars.compile('I was the default'),
    template: null,
    templateName: null
    })

    Will result in instances with an HTML representation of:

    <div id="ember1" class="ember-view">I was the default</div>

    If a `template` or `templateName` is provided it will take precedence over `defaultTemplate`:

    AView = Ember.View.extend({
    defaultTemplate: Ember.Handlebars.compile('I was the default')
    })

    aView = AView.create({
    template: Ember.Handlebars.compile('I was the template, not default')
    })

    Will result in the following HTML representation when rendered:

    <div id="ember1" class="ember-view">I was the template, not default</div>

    ## Layouts
    Views can have a secondary outer template that wraps their main template. Like
    primary templates, layouts can be any function that  accepts an optional context
    parameter and returns a string of HTML that will be inserted a view's tag.
    Most typically in Ember this function will be a compiled Ember.Handlebars template.

    A view's layout can be set directly with the `layout` property or reference an
    existing Handlebars template by name with the `layoutName` property.

    A template used as a layout must contain a single use of the Handlebars `{{yield}}`
    helper. The HTML contents of a view's rendered `template` will be inserted at this location:

    AViewWithLayout = Ember.View.extend({
    layout: Ember.Handlebars.compile("<div class='my-decorative-class'>{{yield}}</div>")
    template: Ember.Handlebars.compile("I got wrapped"),
    })

    Will result in view instances with an HTML representation of:

    <div id="ember1" class="ember-view">
    <div class="my-decorative-class">
    I got wrapped
    </div>
    </div>

    See `Handlebars.helpers.yield` for more information.

    ## Responding to Browser Events
    Views can respond to user-initiated events in one of three ways: method implementation, 
    through an event manager, and through `{{action}}` helper use in their template or layout.

    ### Method Implementation
    Views can respond to user-initiated events by implementing a method that matches the
    event name. A `jQuery.Event` object will be passed as the argument to this method.

    AView = Ember.View.extend({
    click: function(event){
    // will be called when when an instance's
    // rendered element is clicked
    }
    })

    ### Event Managers
    Views can define an object as their `eventManager` property. This object can then
    implement methods that match the desired event names. Matching events that occur
    on the view's rendered HTML or the rendered HTML of any of its DOM descendants 
    will trigger this method.  A `jQuery.Event` object will be passed as the first 
    argument to the method and an  `Ember.View` object as the second. The `Ember.View`
    will be the view whose rendered HTML was interacted with. This may be the view with
    the `eventManager` property or one of its descendent views.

    AView = Ember.View.extend({
    eventManager: Ember.Object.create({
    doubleClick: function(event, view){
    // will be called when when an instance's
    // rendered element or any rendering
    // of this views's descendent
    // elements is clicked
    }
    })
    })


    An event defined for an event manager takes precedence over events of the same
    name handled through methods on the view.


    AView = Ember.View.extend({
    mouseEnter: function(event){
    // will never trigger.
    },
    eventManager: Ember.Object.create({
    mouseEnter: function(event, view){
    // takes presedence over AView#mouseEnter
    }
    })
    })

    Similarly a view's event manager will take precedence for events of any views
    rendered as a descendent. A method name that matches an event name will not be called
    if the view instance was rendered inside the HTML representation of a view that has 
    an `eventManager` property defined that handles events of the name.  Events not handled
    by the event manager will still trigger method calls on the descendent.

    OuterView = Ember.View.extend({
    eventManager: Ember.Object.create({
    template: Ember.Handlebars.compile("outer {{#view InnerView}}inner{{/view}} outer"),
    mouseEnter: function(event, view){
    // view might be instance of either
    // OutsideView or InnerView depending on
    // where on the page the user interaction occured
    }
    })
    })

    InnerView = Ember.View.extend({
    click: function(event){
    // will be called if rendered inside
    // an OuterView because OuterView's
    // eventManager doesn't handle click events
    },
    mouseEnter: function(event){
    // will never be called if rendered inside 
    // an OuterView.
    }
    })

    ### Handlebars `{{action}}` Helper
    See `Handlebars.helpers.action`.

    ### Event Names
    Possible events names for any of the responding approaches described above are:

    Touch events: 'touchStart', 'touchMove', 'touchEnd', 'touchCancel'

    Keyboard events: 'keyDown', 'keyUp', 'keyPress'

    Mouse events: 'mouseDown', 'mouseUp', 'contextMenu', 'click', 'doubleClick', 'mouseMove',
    'focusIn', 'focusOut', 'mouseEnter', 'mouseLeave'

    Form events: 'submit', 'change', 'focusIn', 'focusOut', 'input'

    HTML5 drag and drop events: 'dragStart', 'drag', 'dragEnter', 'dragLeave', 'drop', 'dragEnd'
  
    ## Handlebars `{{view}}` Helper
    Other `Ember.View` instances can be included as part of a view's template by using the `{{view}}`
    Handlebars helper. See `Handlebars.helpers.view` for additional information.

    @extends Ember.Object
    */
    Ember.View = Ember.Object.extend(Ember.Evented,
    /** @scope Ember.View.prototype */{

    /** @private */
    concatenatedProperties: ['classNames', 'classNameBindings', 'attributeBindings'],

    /**
    @type Boolean
    @default true
    @constant
    */
    isView: true,

    // ..........................................................
    // TEMPLATE SUPPORT
    //

    /**
    The name of the template to lookup if no template is provided.

    Ember.View will look for a template with this name in this view's
    `templates` object. By default, this will be a global object
    shared in `Ember.TEMPLATES`.

    @type String
    @default null
    */
    templateName: null,

    /**
    The name of the layout to lookup if no layout is provided.

    Ember.View will look for a template with this name in this view's
    `templates` object. By default, this will be a global object
    shared in `Ember.TEMPLATES`.

    @type String
    @default null
    */
    layoutName: null,

    /**
    The hash in which to look for `templateName`.

    @type Ember.Object
    @default Ember.TEMPLATES
    */
    templates: Ember.TEMPLATES,

    /**
    The template used to render the view. This should be a function that
    accepts an optional context parameter and returns a string of HTML that
    will be inserted into the DOM relative to its parent view.

    In general, you should set the `templateName` property instead of setting
    the template yourself.

    @field
    @type Function
    */
    template: Ember.computed(function (key, value) {
        if (value !== undefined) { return value; }

        var templateName = get(this, 'templateName'),
        template = this.templateForName(templateName, 'template');

        return template || get(this, 'defaultTemplate');
    }).property('templateName').cacheable(),

    /**
    The controller managing this view. If this property is set, it will be
    made available for use by the template.

    @type Object
    */
    controller: null,

    /**
    A view may contain a layout. A layout is a regular template but
    supersedes the `template` property during rendering. It is the
    responsibility of the layout template to retrieve the `template`
    property from the view and render it in the correct location.

    This is useful for a view that has a shared wrapper, but which delegates
    the rendering of the contents of the wrapper to the `template` property
    on a subclass.

    @field
    @type Function
    */
    layout: Ember.computed(function (key, value) {
        if (arguments.length === 2) { return value; }

        var layoutName = get(this, 'layoutName'),
        layout = this.templateForName(layoutName, 'layout');

        return layout || get(this, 'defaultLayout');
    }).property('layoutName').cacheable(),

    templateForName: function (name, type) {
        if (!name) { return; }

        var templates = get(this, 'templates'),
        template = get(templates, name);

        if (!template) {
            throw new Ember.Error(fmt('%@ - Unable to find %@ "%@".', [this, type, name]));
        }

        return template;
    },

    /**
    The object from which templates should access properties.

    This object will be passed to the template function each time the render
    method is called, but it is up to the individual function to decide what
    to do with it.

    By default, this will be the view itself.

    @type Object
    */
    templateContext: Ember.computed(function (key, value) {
        if (arguments.length === 2) {
            set(this, '_templateContext', value);
            return value;
        } else {
            return get(this, '_templateContext');
        }
    }).cacheable(),

    /**
    @private

    Private copy of the view's template context. This can be set directly
    by Handlebars without triggering the observer that causes the view
    to be re-rendered.
    */
    _templateContext: Ember.computed(function (key, value) {
        var parentView;

        if (arguments.length === 2) {
            return value;
        }

        if (VIEW_PRESERVES_CONTEXT) {
            parentView = get(this, '_parentView');
            if (parentView) {
                return get(parentView, '_templateContext');
            }
        }

        return this;
    }).cacheable(),

    /**
    If a value that affects template rendering changes, the view should be
    re-rendered to reflect the new value.

    @private
    */
    _displayPropertyDidChange: Ember.observer(function () {
        this.rerender();
    }, 'templateContext', 'controller'),

    /**
    If the view is currently inserted into the DOM of a parent view, this
    property will point to the parent of the view.

    @type Ember.View
    @default null
    */
    parentView: Ember.computed(function () {
        var parent = get(this, '_parentView');

        if (parent && parent.isVirtual) {
            return get(parent, 'parentView');
        } else {
            return parent;
        }
    }).property('_parentView').volatile(),

    _parentView: null,

    // return the current view, not including virtual views
    concreteView: Ember.computed(function () {
        if (!this.isVirtual) { return this; }
        else { return get(this, 'parentView'); }
    }).property('_parentView').volatile(),

    /**
    If false, the view will appear hidden in DOM.

    @type Boolean
    @default null
    */
    isVisible: true,

    /**
    Array of child views. You should never edit this array directly.
    Instead, use appendChild and removeFromParent.

    @private
    @type Array
    @default []
    */
    childViews: childViewsProperty,

    _childViews: [],

    /**
    When it's a virtual view, we need to notify the parent that their
    childViews will change.
    */
    _childViewsWillChange: Ember.beforeObserver(function () {
        if (this.isVirtual) {
            var parentView = get(this, 'parentView');
            if (parentView) { Ember.propertyWillChange(parentView, 'childViews'); }
        }
    }, 'childViews'),

    /**
    When it's a virtual view, we need to notify the parent that their
    childViews did change.
    */
    _childViewsDidChange: Ember.observer(function () {
        if (this.isVirtual) {
            var parentView = get(this, 'parentView');
            if (parentView) { Ember.propertyDidChange(parentView, 'childViews'); }
        }
    }, 'childViews'),

    /**
    Return the nearest ancestor that is an instance of the provided
    class.

    @param {Class} klass Subclass of Ember.View (or Ember.View itself)
    @returns Ember.View
    */
    nearestInstanceOf: function (klass) {
        var view = get(this, 'parentView');

        while (view) {
            if (view instanceof klass) { return view; }
            view = get(view, 'parentView');
        }
    },

    /**
    Return the nearest ancestor that has a given property.

    @param {String} property A property name
    @returns Ember.View
    */
    nearestWithProperty: function (property) {
        var view = get(this, 'parentView');

        while (view) {
            if (property in view) { return view; }
            view = get(view, 'parentView');
        }
    },

    /**
    Return the nearest ancestor whose parent is an instance of
    `klass`.

    @param {Class} klass Subclass of Ember.View (or Ember.View itself)
    @returns Ember.View
    */
    nearestChildOf: function (klass) {
        var view = get(this, 'parentView');

        while (view) {
            if (get(view, 'parentView') instanceof klass) { return view; }
            view = get(view, 'parentView');
        }
    },

    /**
    Return the nearest ancestor that is an Ember.CollectionView

    @returns Ember.CollectionView
    */
    collectionView: Ember.computed(function () {
        return this.nearestInstanceOf(Ember.CollectionView);
    }).cacheable(),

    /**
    Return the nearest ancestor that is a direct child of
    an Ember.CollectionView

    @returns Ember.View
    */
    itemView: Ember.computed(function () {
        return this.nearestChildOf(Ember.CollectionView);
    }).cacheable(),

    /**
    Return the nearest ancestor that has the property
    `content`.

    @returns Ember.View
    */
    contentView: Ember.computed(function () {
        return this.nearestWithProperty('content');
    }).cacheable(),

    /**
    @private

    When the parent view changes, recursively invalidate
    collectionView, itemView, and contentView
    */
    _parentViewDidChange: Ember.observer(function () {
        if (this.isDestroying) { return; }

        this.invokeRecursively(function (view) {
            view.propertyDidChange('collectionView');
            view.propertyDidChange('itemView');
            view.propertyDidChange('contentView');
        });
    }, '_parentView'),

    cloneKeywords: function () {
        var templateData = get(this, 'templateData'),
        controller = get(this, 'controller');

        var keywords = templateData ? Ember.copy(templateData.keywords) : {};
        keywords.view = get(this, 'concreteView');

        // If the view has a controller specified, make it available to the
        // template. If not, pass along the parent template's controller,
        // if it exists.
        if (controller) {
            keywords.controller = controller;
        }

        return keywords;
    },

    /**
    Called on your view when it should push strings of HTML into a
    Ember.RenderBuffer. Most users will want to override the `template`
    or `templateName` properties instead of this method.

    By default, Ember.View will look for a function in the `template`
    property and invoke it with the value of `templateContext`. The value of
    `templateContext` will be the view itself unless you override it.

    @param {Ember.RenderBuffer} buffer The render buffer
    */
    render: function (buffer) {
        // If this view has a layout, it is the responsibility of the
        // the layout to render the view's template. Otherwise, render the template
        // directly.
        var template = get(this, 'layout') || get(this, 'template');

        if (template) {
            var context = get(this, '_templateContext');
            var keywords = this.cloneKeywords();

            var data = {
                view: this,
                buffer: buffer,
                isRenderData: true,
                keywords: keywords
            };

            // Invoke the template with the provided template context, which
            // is the view by default. A hash of data is also passed that provides
            // the template with access to the view and render buffer.

            Ember.assert('template must be a function. Did you mean to specify templateName instead?', typeof template === 'function');
            // The template should write directly to the render buffer instead
            // of returning a string.
            var output = template(context, { data: data });

            // If the template returned a string instead of writing to the buffer,
            // push the string onto the buffer.
            if (output !== undefined) { buffer.push(output); }
        }
    },

    invokeForState: function (name) {
        var stateName = this.state, args;

        // try to find the function for the state in the cache
        if (fn = invokeForState[stateName][name]) {
            args = a_slice.call(arguments);
            args[0] = this;

            return fn.apply(this, args);
        }

        // otherwise, find and cache the function for this state
        var parent = this, states = parent.states, state;

        while (states) {
            state = states[stateName];

            while (state) {
                var fn = state[name];

                if (fn) {
                    invokeForState[stateName][name] = fn;

                    args = a_slice.call(arguments, 1);
                    args.unshift(this);

                    return fn.apply(this, args);
                }

                state = state.parentState;
            }

            states = states.parent;
        }
    },

    /**
    Renders the view again. This will work regardless of whether the
    view is already in the DOM or not. If the view is in the DOM, the
    rendering process will be deferred to give bindings a chance
    to synchronize.

    If children were added during the rendering process using `appendChild`,
    `rerender` will remove them, because they will be added again
    if needed by the next `render`.

    In general, if the display of your view changes, you should modify
    the DOM element directly instead of manually calling `rerender`, which can
    be slow.
    */
    rerender: function () {
        return this.invokeForState('rerender');
    },

    clearRenderedChildren: function () {
        var lengthBefore = this.lengthBeforeRender,
        lengthAfter = this.lengthAfterRender;

        // If there were child views created during the last call to render(),
        // remove them under the assumption that they will be re-created when
        // we re-render.

        // VIEW-TODO: Unit test this path.
        var childViews = get(this, '_childViews');
        for (var i = lengthAfter - 1; i >= lengthBefore; i--) {
            if (childViews[i]) { childViews[i].destroy(); }
        }
    },

    /**
    @private

    Iterates over the view's `classNameBindings` array, inserts the value
    of the specified property into the `classNames` array, then creates an
    observer to update the view's element if the bound property ever changes
    in the future.
    */
    _applyClassNameBindings: function () {
        var classBindings = get(this, 'classNameBindings'),
        classNames = get(this, 'classNames'),
        elem, newClass, dasherizedClass;

        if (!classBindings) { return; }

        // Loop through all of the configured bindings. These will be either
        // property names ('isUrgent') or property paths relative to the view
        // ('content.isUrgent')
        a_forEach(classBindings, function (binding) {

            // Variable in which the old class value is saved. The observer function
            // closes over this variable, so it knows which string to remove when
            // the property changes.
            var oldClass, property;

            // Set up an observer on the context. If the property changes, toggle the
            // class name.
            var observer = function () {
                // Get the current value of the property
                newClass = this._classStringForProperty(binding);
                elem = this.$();

                // If we had previously added a class to the element, remove it.
                if (oldClass) {
                    elem.removeClass(oldClass);
                    // Also remove from classNames so that if the view gets rerendered,
                    // the class doesn't get added back to the DOM.
                    classNames.removeObject(oldClass);
                }

                // If necessary, add a new class. Make sure we keep track of it so
                // it can be removed in the future.
                if (newClass) {
                    elem.addClass(newClass);
                    oldClass = newClass;
                } else {
                    oldClass = null;
                }
            };

            // Get the class name for the property at its current value
            dasherizedClass = this._classStringForProperty(binding);

            if (dasherizedClass) {
                // Ensure that it gets into the classNames array
                // so it is displayed when we render.
                classNames.push(dasherizedClass);

                // Save a reference to the class name so we can remove it
                // if the observer fires. Remember that this variable has
                // been closed over by the observer.
                oldClass = dasherizedClass;
            }

            // Extract just the property name from bindings like 'foo:bar'
            property = binding.split(':')[0];
            addObserver(this, property, observer);
        }, this);
    },

    /**
    Iterates through the view's attribute bindings, sets up observers for each,
    then applies the current value of the attributes to the passed render buffer.

    @param {Ember.RenderBuffer} buffer
    */
    _applyAttributeBindings: function (buffer) {
        var attributeBindings = get(this, 'attributeBindings'),
        attributeValue, elem, type;

        if (!attributeBindings) { return; }

        a_forEach(attributeBindings, function (binding) {
            var split = binding.split(':'),
          property = split[0],
          attributeName = split[1] || property;

            // Create an observer to add/remove/change the attribute if the
            // JavaScript property changes.
            var observer = function () {
                elem = this.$();
                attributeValue = get(this, property);

                Ember.View.applyAttributeBindings(elem, attributeName, attributeValue);
            };

            addObserver(this, property, observer);

            // Determine the current value and add it to the render buffer
            // if necessary.
            attributeValue = get(this, property);
            Ember.View.applyAttributeBindings(buffer, attributeName, attributeValue);
        }, this);
    },

    /**
    @private

    Given a property name, returns a dasherized version of that
    property name if the property evaluates to a non-falsy value.

    For example, if the view has property `isUrgent` that evaluates to true,
    passing `isUrgent` to this method will return `"is-urgent"`.
    */
    _classStringForProperty: function (property) {
        var split = property.split(':'),
        className = split[1];

        property = split[0];

        // TODO: Remove this `false` when the `getPath` globals support is removed
        var val = Ember.getPath(this, property, false);
        if (val === undefined && Ember.isGlobalPath(property)) {
            val = Ember.getPath(window, property);
        }

        // If the value is truthy and we're using the colon syntax,
        // we should return the className directly
        if (!!val && className) {
            return className;

            // If value is a Boolean and true, return the dasherized property
            // name.
        } else if (val === true) {
            // Normalize property path to be suitable for use
            // as a class name. For exaple, content.foo.barBaz
            // becomes bar-baz.
            var parts = property.split('.');
            return Ember.String.dasherize(parts[parts.length - 1]);

            // If the value is not false, undefined, or null, return the current
            // value of the property.
        } else if (val !== false && val !== undefined && val !== null) {
            return val;

            // Nothing to display. Return null so that the old class is removed
            // but no new class is added.
        } else {
            return null;
        }
    },

    // ..........................................................
    // ELEMENT SUPPORT
    //

    /**
    Returns the current DOM element for the view.

    @field
    @type DOMElement
    */
    element: Ember.computed(function (key, value) {
        if (value !== undefined) {
            return this.invokeForState('setElement', value);
        } else {
            return this.invokeForState('getElement');
        }
    }).property('_parentView').cacheable(),

    /**
    Returns a jQuery object for this view's element. If you pass in a selector
    string, this method will return a jQuery object, using the current element
    as its buffer.

    For example, calling `view.$('li')` will return a jQuery object containing
    all of the `li` elements inside the DOM element of this view.

    @param {String} [selector] a jQuery-compatible selector string
    @returns {Ember.CoreQuery} the CoreQuery object for the DOM node
    */
    $: function (sel) {
        return this.invokeForState('$', sel);
    },

    /** @private */
    mutateChildViews: function (callback) {
        var childViews = get(this, '_childViews'),
        idx = get(childViews, 'length'),
        view;

        while (--idx >= 0) {
            view = childViews[idx];
            callback.call(this, view, idx);
        }

        return this;
    },

    /** @private */
    forEachChildView: function (callback) {
        var childViews = get(this, '_childViews');

        if (!childViews) { return this; }

        var len = get(childViews, 'length'),
        view, idx;

        for (idx = 0; idx < len; idx++) {
            view = childViews[idx];
            callback.call(this, view);
        }

        return this;
    },

    /**
    Appends the view's element to the specified parent element.

    If the view does not have an HTML representation yet, `createElement()`
    will be called automatically.

    Note that this method just schedules the view to be appended; the DOM
    element will not be appended to the given element until all bindings have
    finished synchronizing.

    This is not typically a function that you will need to call directly
    when building your application. You might consider using Ember.ContainerView
    instead. If you do need to use appendTo, be sure that the target element you
    are providing is associated with an Ember.Application and does not have an
    ancestor element that is associated with an Ember view.

    @param {String|DOMElement|jQuery} A selector, element, HTML string, or jQuery object
    @returns {Ember.View} receiver
    */
    appendTo: function (target) {
        Ember.assert("You cannot append to an existing Ember.View. Consider using Ember.ContainerView instead.", !Ember.$(target).is('.ember-view') && !Ember.$(target).parents().is('.ember-view'));

        // Schedule the DOM element to be created and appended to the given
        // element after bindings have synchronized.
        this._insertElementLater(function () {
            this.$().appendTo(target);
        });

        return this;
    },

    /**
    Replaces the content of the specified parent element with this view's element.
    If the view does not have an HTML representation yet, `createElement()`
    will be called automatically.

    Note that this method just schedules the view to be appended; the DOM
    element will not be appended to the given element until all bindings have
    finished synchronizing

    @param {String|DOMElement|jQuery} A selector, element, HTML string, or jQuery object
    @returns {Ember.View} received
    */
    replaceIn: function (target) {
        Ember.assert("You cannot replace an existing Ember.View. Consider using Ember.ContainerView instead.", !Ember.$(target).is('.ember-view') && !Ember.$(target).parents().is('.ember-view'));

        this._insertElementLater(function () {
            Ember.$(target).empty();
            this.$().appendTo(target);
        });

        return this;
    },

    /**
    @private

    Schedules a DOM operation to occur during the next render phase. This
    ensures that all bindings have finished synchronizing before the view is
    rendered.

    To use, pass a function that performs a DOM operation..

    Before your function is called, this view and all child views will receive
    the `willInsertElement` event. After your function is invoked, this view
    and all of its child views will receive the `didInsertElement` event.

    view._insertElementLater(function() {
    this.createElement();
    this.$().appendTo('body');
    });

    @param {Function} fn the function that inserts the element into the DOM
    */
    _insertElementLater: function (fn) {
        this._lastInsert = Ember.guidFor(fn);
        Ember.run.schedule('render', this, this.invokeForState, 'insertElement', fn);
    },

    /**
    Appends the view's element to the document body. If the view does
    not have an HTML representation yet, `createElement()` will be called
    automatically.

    Note that this method just schedules the view to be appended; the DOM
    element will not be appended to the document body until all bindings have
    finished synchronizing.

    @returns {Ember.View} receiver
    */
    append: function () {
        return this.appendTo(document.body);
    },

    /**
    Removes the view's element from the element to which it is attached.

    @returns {Ember.View} receiver
    */
    remove: function () {
        // What we should really do here is wait until the end of the run loop
        // to determine if the element has been re-appended to a different
        // element.
        // In the interim, we will just re-render if that happens. It is more
        // important than elements get garbage collected.
        this.destroyElement();
        this.invokeRecursively(function (view) {
            view.clearRenderedChildren();
        });
    },

    /**
    The ID to use when trying to locate the element in the DOM. If you do not
    set the elementId explicitly, then the view's GUID will be used instead.
    This ID must be set at the time the view is created.

    @type String
    @readOnly
    */
    elementId: Ember.computed(function (key, value) {
        return value !== undefined ? value : Ember.guidFor(this);
    }).cacheable(),

    /**
    @private

    TODO: Perhaps this should be removed from the production build somehow.
    */
    _elementIdDidChange: Ember.beforeObserver(function () {
        throw "Changing a view's elementId after creation is not allowed.";
    }, 'elementId'),

    /**
    Attempts to discover the element in the parent element. The default
    implementation looks for an element with an ID of elementId (or the view's
    guid if elementId is null). You can override this method to provide your
    own form of lookup. For example, if you want to discover your element
    using a CSS class name instead of an ID.

    @param {DOMElement} parentElement The parent's DOM element
    @returns {DOMElement} The discovered element
    */
    findElementInParentElement: function (parentElem) {
        var id = "#" + get(this, 'elementId');
        return Ember.$(id)[0] || Ember.$(id, parentElem)[0];
    },

    /**
    Creates a new renderBuffer with the passed tagName. You can override this
    method to provide further customization to the buffer if needed. Normally
    you will not need to call or override this method.

    @returns {Ember.RenderBuffer}
    */
    renderBuffer: function (tagName) {
        tagName = tagName || get(this, 'tagName');

        // Explicitly check for null or undefined, as tagName
        // may be an empty string, which would evaluate to false.
        if (tagName === null || tagName === undefined) {
            tagName = 'div';
        }

        return Ember.RenderBuffer(tagName);
    },

    /**
    Creates a DOM representation of the view and all of its
    child views by recursively calling the `render()` method.

    After the element has been created, `didInsertElement` will
    be called on this view and all of its child views.

    @returns {Ember.View} receiver
    */
    createElement: function () {
        if (get(this, 'element')) { return this; }

        var buffer = this.renderToBuffer();
        set(this, 'element', buffer.element());

        return this;
    },

    /**
    Called when a view is going to insert an element into the DOM.
    */
    willInsertElement: Ember.K,

    /**
    Called when the element of the view has been inserted into the DOM.
    Override this function to do any set up that requires an element in the
    document body.
    */
    didInsertElement: Ember.K,

    /**
    Called when the view is about to rerender, but before anything has
    been torn down. This is a good opportunity to tear down any manual
    observers you have installed based on the DOM state
    */
    willRerender: Ember.K,

    /**
    Run this callback on the current view and recursively on child views.

    @private
    */
    invokeRecursively: function (fn) {
        fn.call(this, this);

        this.forEachChildView(function (view) {
            view.invokeRecursively(fn);
        });
    },

    /**
    Invalidates the cache for a property on all child views.
    */
    invalidateRecursively: function (key) {
        this.forEachChildView(function (view) {
            view.propertyDidChange(key);
        });
    },

    /**
    @private

    Invokes the receiver's willInsertElement() method if it exists and then
    invokes the same on all child views.

    NOTE: In some cases this was called when the element existed. This no longer
    works so we let people know. We can remove this warning code later.
    */
    _notifyWillInsertElement: function () {
        this.invokeRecursively(function (view) {
            view.fire('willInsertElement');
        });
    },

    /**
    @private

    Invokes the receiver's didInsertElement() method if it exists and then
    invokes the same on all child views.
    */
    _notifyDidInsertElement: function () {
        this.invokeRecursively(function (view) {
            view.fire('didInsertElement');
        });
    },

    /**
    @private

    Invokes the receiver's willRerender() method if it exists and then
    invokes the same on all child views.
    */
    _notifyWillRerender: function () {
        this.invokeRecursively(function (view) {
            view.fire('willRerender');
        });
    },

    /**
    Destroys any existing element along with the element for any child views
    as well. If the view does not currently have a element, then this method
    will do nothing.

    If you implement willDestroyElement() on your view, then this method will
    be invoked on your view before your element is destroyed to give you a
    chance to clean up any event handlers, etc.

    If you write a willDestroyElement() handler, you can assume that your
    didInsertElement() handler was called earlier for the same element.

    Normally you will not call or override this method yourself, but you may
    want to implement the above callbacks when it is run.

    @returns {Ember.View} receiver
    */
    destroyElement: function () {
        return this.invokeForState('destroyElement');
    },

    /**
    Called when the element of the view is going to be destroyed. Override
    this function to do any teardown that requires an element, like removing
    event listeners.
    */
    willDestroyElement: function () { },

    /**
    @private

    Invokes the `willDestroyElement` callback on the view and child views.
    */
    _notifyWillDestroyElement: function () {
        this.invokeRecursively(function (view) {
            view.fire('willDestroyElement');
        });
    },

    /** @private (nodoc) */
    _elementWillChange: Ember.beforeObserver(function () {
        this.forEachChildView(function (view) {
            Ember.propertyWillChange(view, 'element');
        });
    }, 'element'),

    /**
    @private

    If this view's element changes, we need to invalidate the caches of our
    child views so that we do not retain references to DOM elements that are
    no longer needed.

    @observes element
    */
    _elementDidChange: Ember.observer(function () {
        this.forEachChildView(function (view) {
            Ember.propertyDidChange(view, 'element');
        });
    }, 'element'),

    /**
    Called when the parentView property has changed.

    @function
    */
    parentViewDidChange: Ember.K,

    /**
    @private

    Invoked by the view system when this view needs to produce an HTML
    representation. This method will create a new render buffer, if needed,
    then apply any default attributes, such as class names and visibility.
    Finally, the `render()` method is invoked, which is responsible for
    doing the bulk of the rendering.

    You should not need to override this method; instead, implement the
    `template` property, or if you need more control, override the `render`
    method.

    @param {Ember.RenderBuffer} buffer the render buffer. If no buffer is
    passed, a default buffer, using the current view's `tagName`, will
    be used.
    */
    renderToBuffer: function (parentBuffer, bufferOperation) {
        var buffer;

        Ember.run.sync();

        // Determine where in the parent buffer to start the new buffer.
        // By default, a new buffer will be appended to the parent buffer.
        // The buffer operation may be changed if the child views array is
        // mutated by Ember.ContainerView.
        bufferOperation = bufferOperation || 'begin';

        // If this is the top-most view, start a new buffer. Otherwise,
        // create a new buffer relative to the original using the
        // provided buffer operation (for example, `insertAfter` will
        // insert a new buffer after the "parent buffer").
        if (parentBuffer) {
            var tagName = get(this, 'tagName');
            if (tagName === null || tagName === undefined) {
                tagName = 'div';
            }

            buffer = parentBuffer[bufferOperation](tagName);
        } else {
            buffer = this.renderBuffer();
        }

        this.buffer = buffer;
        this.transitionTo('inBuffer', false);

        this.lengthBeforeRender = get(get(this, '_childViews'), 'length');

        this.beforeRender(buffer);
        this.render(buffer);
        this.afterRender(buffer);

        this.lengthAfterRender = get(get(this, '_childViews'), 'length');

        return buffer;
    },

    beforeRender: function (buffer) {
        this.applyAttributesToBuffer(buffer);
    },

    afterRender: Ember.K,

    /**
    @private
    */
    applyAttributesToBuffer: function (buffer) {
        // Creates observers for all registered class name and attribute bindings,
        // then adds them to the element.
        this._applyClassNameBindings();

        // Pass the render buffer so the method can apply attributes directly.
        // This isn't needed for class name bindings because they use the
        // existing classNames infrastructure.
        this._applyAttributeBindings(buffer);


        a_forEach(get(this, 'classNames'), function (name) { buffer.addClass(name); });
        buffer.id(get(this, 'elementId'));

        var role = get(this, 'ariaRole');
        if (role) {
            buffer.attr('role', role);
        }

        if (get(this, 'isVisible') === false) {
            buffer.style('display', 'none');
        }
    },

    // ..........................................................
    // STANDARD RENDER PROPERTIES
    //

    /**
    Tag name for the view's outer element. The tag name is only used when
    an element is first created. If you change the tagName for an element, you
    must destroy and recreate the view element.

    By default, the render buffer will use a `<div>` tag for views.

    @type String
    @default null
    */

    // We leave this null by default so we can tell the difference between
    // the default case and a user-specified tag.
    tagName: null,

    /**
    The WAI-ARIA role of the control represented by this view. For example, a
    button may have a role of type 'button', or a pane may have a role of
    type 'alertdialog'. This property is used by assistive software to help
    visually challenged users navigate rich web applications.

    The full list of valid WAI-ARIA roles is available at:
    http://www.w3.org/TR/wai-aria/roles#roles_categorization

    @type String
    @default null
    */
    ariaRole: null,

    /**
    Standard CSS class names to apply to the view's outer element. This
    property automatically inherits any class names defined by the view's
    superclasses as well.

    @type Array
    @default ['ember-view']
    */
    classNames: ['ember-view'],

    /**
    A list of properties of the view to apply as class names. If the property
    is a string value, the value of that string will be applied as a class
    name.

    // Applies the 'high' class to the view element
    Ember.View.create({
    classNameBindings: ['priority']
    priority: 'high'
    });

    If the value of the property is a Boolean, the name of that property is
    added as a dasherized class name.

    // Applies the 'is-urgent' class to the view element
    Ember.View.create({
    classNameBindings: ['isUrgent']
    isUrgent: true
    });

    If you would prefer to use a custom value instead of the dasherized
    property name, you can pass a binding like this:

    // Applies the 'urgent' class to the view element
    Ember.View.create({
    classNameBindings: ['isUrgent:urgent']
    isUrgent: true
    });

    This list of properties is inherited from the view's superclasses as well.

    @type Array
    @default []
    */
    classNameBindings: [],

    /**
    A list of properties of the view to apply as attributes. If the property is
    a string value, the value of that string will be applied as the attribute.

    // Applies the type attribute to the element
    // with the value "button", like <div type="button">
    Ember.View.create({
    attributeBindings: ['type'],
    type: 'button'
    });

    If the value of the property is a Boolean, the name of that property is
    added as an attribute.

    // Renders something like <div enabled="enabled">
    Ember.View.create({
    attributeBindings: ['enabled'],
    enabled: true
    });
    */
    attributeBindings: [],

    state: 'preRender',

    // .......................................................
    // CORE DISPLAY METHODS
    //

    /**
    @private

    Setup a view, but do not finish waking it up.
    - configure childViews
    - register the view with the global views hash, which is used for event
    dispatch
    */
    init: function () {
        this._super();

        // Register the view for event handling. This hash is used by
        // Ember.RootResponder to dispatch incoming events.
        Ember.View.views[get(this, 'elementId')] = this;

        var childViews = get(this, '_childViews').slice();

        // setup child views. be sure to clone the child views array first
        set(this, '_childViews', childViews);

        Ember.assert("Only arrays are allowed for 'classNameBindings'", Ember.typeOf(this.classNameBindings) === 'array');
        this.classNameBindings = Ember.A(this.classNameBindings.slice());

        Ember.assert("Only arrays are allowed for 'classNames'", Ember.typeOf(this.classNames) === 'array');
        this.classNames = Ember.A(this.classNames.slice());

        var viewController = get(this, 'viewController');
        if (viewController) {
            viewController = Ember.getPath(viewController);
            if (viewController) {
                set(viewController, 'view', this);
            }
        }
    },

    appendChild: function (view, options) {
        return this.invokeForState('appendChild', view, options);
    },

    /**
    Removes the child view from the parent view.

    @param {Ember.View} view
    @returns {Ember.View} receiver
    */
    removeChild: function (view) {
        // If we're destroying, the entire subtree will be
        // freed, and the DOM will be handled separately,
        // so no need to mess with childViews.
        if (this.isDestroying) { return; }

        // update parent node
        set(view, '_parentView', null);

        // remove view from childViews array.
        var childViews = get(this, '_childViews');
        Ember.ArrayUtils.removeObject(childViews, view);

        this.propertyDidChange('childViews');

        return this;
    },

    /**
    Removes all children from the parentView.

    @returns {Ember.View} receiver
    */
    removeAllChildren: function () {
        return this.mutateChildViews(function (view) {
            this.removeChild(view);
        });
    },

    destroyAllChildren: function () {
        return this.mutateChildViews(function (view) {
            view.destroy();
        });
    },

    /**
    Removes the view from its parentView, if one is found. Otherwise
    does nothing.

    @returns {Ember.View} receiver
    */
    removeFromParent: function () {
        var parent = get(this, '_parentView');

        // Remove DOM element from parent
        this.remove();

        if (parent) { parent.removeChild(this); }
        return this;
    },

    /**
    You must call `destroy` on a view to destroy the view (and all of its
    child views). This will remove the view from any parent node, then make
    sure that the DOM element managed by the view can be released by the
    memory manager.
    */
    willDestroy: function () {
        // calling this._super() will nuke computed properties and observers,
        // so collect any information we need before calling super.
        var childViews = get(this, '_childViews'),
        parent = get(this, '_parentView'),
        elementId = get(this, 'elementId'),
        childLen;

        // destroy the element -- this will avoid each child view destroying
        // the element over and over again...
        if (!this.removedFromDOM) { this.destroyElement(); }

        // remove from non-virtual parent view if viewName was specified
        if (this.viewName) {
            var nonVirtualParentView = get(this, 'parentView');
            if (nonVirtualParentView) {
                set(nonVirtualParentView, this.viewName, null);
            }
        }

        // remove from parent if found. Don't call removeFromParent,
        // as removeFromParent will try to remove the element from
        // the DOM again.
        if (parent) { parent.removeChild(this); }

        this.state = 'destroyed';

        childLen = get(childViews, 'length');
        for (var i = childLen - 1; i >= 0; i--) {
            childViews[i].removedFromDOM = true;
            childViews[i].destroy();
        }

        // next remove view from global hash
        delete Ember.View.views[get(this, 'elementId')];
    },

    /**
    Instantiates a view to be added to the childViews array during view
    initialization. You generally will not call this method directly unless
    you are overriding createChildViews(). Note that this method will
    automatically configure the correct settings on the new view instance to
    act as a child of the parent.

    @param {Class} viewClass
    @param {Hash} [attrs] Attributes to add
    @returns {Ember.View} new instance
    @test in createChildViews
    */
    createChildView: function (view, attrs) {
        var coreAttrs, templateData;

        if (Ember.View.detect(view)) {
            coreAttrs = { _parentView: this, templateData: get(this, 'templateData') };

            if (attrs) {
                view = view.create(coreAttrs, attrs);
            } else {
                view = view.create(coreAttrs);
            }

            var viewName = view.viewName;

            // don't set the property on a virtual view, as they are invisible to
            // consumers of the view API
            if (viewName) { set(get(this, 'concreteView'), viewName, view); }
        } else {
            Ember.assert('You must pass instance or subclass of View', view instanceof Ember.View);
            Ember.assert("You can only pass attributes when a class is provided", !attrs);

            if (!get(view, 'templateData')) {
                set(view, 'templateData', get(this, 'templateData'));
            }

            set(view, '_parentView', this);
        }

        return view;
    },

    becameVisible: Ember.K,
    becameHidden: Ember.K,

    /**
    @private

    When the view's `isVisible` property changes, toggle the visibility
    element of the actual DOM element.
    */
    _isVisibleDidChange: Ember.observer(function () {
        var isVisible = get(this, 'isVisible');

        this.$().toggle(isVisible);

        if (this._isAncestorHidden()) { return; }

        if (isVisible) {
            this._notifyBecameVisible();
        } else {
            this._notifyBecameHidden();
        }
    }, 'isVisible'),

    _notifyBecameVisible: function () {
        this.fire('becameVisible');

        this.forEachChildView(function (view) {
            var isVisible = get(view, 'isVisible');

            if (isVisible || isVisible === null) {
                view._notifyBecameVisible();
            }
        });
    },

    _notifyBecameHidden: function () {
        this.fire('becameHidden');
        this.forEachChildView(function (view) {
            var isVisible = get(view, 'isVisible');

            if (isVisible || isVisible === null) {
                view._notifyBecameHidden();
            }
        });
    },

    _isAncestorHidden: function () {
        var parent = get(this, 'parentView');

        while (parent) {
            if (get(parent, 'isVisible') === false) { return true; }

            parent = get(parent, 'parentView');
        }

        return false;
    },

    clearBuffer: function () {
        this.invokeRecursively(function (view) {
            this.buffer = null;
        });
    },

    transitionTo: function (state, children) {
        this.state = state;

        if (children !== false) {
            this.forEachChildView(function (view) {
                view.transitionTo(state);
            });
        }
    },

    /**
    @private

    Override the default event firing from Ember.Evented to
    also call methods with the given name.
    */
    fire: function (name) {
        if (this[name]) {
            this[name].apply(this, [].slice.call(arguments, 1));
        }
        this._super.apply(this, arguments);
    },

    // .......................................................
    // EVENT HANDLING
    //

    /**
    @private

    Handle events from `Ember.EventDispatcher`
    */
    handleEvent: function (eventName, evt) {
        return this.invokeForState('handleEvent', eventName, evt);
    }

});

/**
Describe how the specified actions should behave in the various
states that a view can exist in. Possible states:

* preRender: when a view is first instantiated, and after its
element was destroyed, it is in the preRender state
* inBuffer: once a view has been rendered, but before it has
been inserted into the DOM, it is in the inBuffer state
* inDOM: once a view has been inserted into the DOM it is in
the inDOM state. A view spends the vast majority of its
existence in this state.
* destroyed: once a view has been destroyed (using the destroy
method), it is in this state. No further actions can be invoked
on a destroyed view.
*/

// in the destroyed state, everything is illegal

// before rendering has begun, all legal manipulations are noops.

// inside the buffer, legal manipulations are done on the buffer

// once the view has been inserted into the DOM, legal manipulations
// are done on the DOM element.

/** @private */
var DOMManager = {
    prepend: function (view, childView) {
        childView._insertElementLater(function () {
            var element = view.$();
            element.prepend(childView.$());
        });
    },

    after: function (view, nextView) {
        nextView._insertElementLater(function () {
            var element = view.$();
            element.after(nextView.$());
        });
    },

    replace: function (view) {
        var element = get(view, 'element');

        set(view, 'element', null);

        view._insertElementLater(function () {
            Ember.$(element).replaceWith(get(view, 'element'));
        });
    },

    remove: function (view) {
        var elem = get(view, 'element');

        set(view, 'element', null);
        view._lastInsert = null;

        Ember.$(elem).remove();
    },

    empty: function (view) {
        view.$().empty();
    }
};

Ember.View.reopen({
    states: Ember.View.states,
    domManager: DOMManager
});

// Create a global view hash.
Ember.View.views = {};

// If someone overrides the child views computed property when
// defining their class, we want to be able to process the user's
// supplied childViews and then restore the original computed property
// at view initialization time. This happens in Ember.ContainerView's init
// method.
Ember.View.childViewsProperty = childViewsProperty;

Ember.View.applyAttributeBindings = function (elem, name, value) {
    var type = Ember.typeOf(value);
    var currentValue = elem.attr(name);

    // if this changes, also change the logic in ember-handlebars/lib/helpers/binding.js
    if ((type === 'string' || (type === 'number' && !isNaN(value))) && value !== currentValue) {
        elem.attr(name, value);
    } else if (value && type === 'boolean') {
        elem.attr(name, name);
    } else if (!value) {
        elem.removeAttr(name);
    }
};

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    Ember.View.states = {
        _default: {
            // appendChild is only legal while rendering the buffer.
            appendChild: function () {
                throw "You can't use appendChild outside of the rendering process";
            },

            $: function () {
                return Ember.$();
            },

            getElement: function () {
                return null;
            },

            // Handle events from `Ember.EventDispatcher`
            handleEvent: function () {
                return true; // continue event propagation
            },

            destroyElement: function (view) {
                set(view, 'element', null);
                view._lastInsert = null;
                return view;
            }
        }
    };

    Ember.View.reopen({
        states: Ember.View.states
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    Ember.View.states.preRender = {
        parentState: Ember.View.states._default,

        // a view leaves the preRender state once its element has been
        // created (createElement).
        insertElement: function (view, fn) {
            if (view._lastInsert !== Ember.guidFor(fn)) {
                return;
            }
            view.createElement();
            view._notifyWillInsertElement();
            // after createElement, the view will be in the hasElement state.
            fn.call(view);
            view.transitionTo('inDOM');
            view._notifyDidInsertElement();
        },

        empty: Ember.K,

        setElement: function (view, value) {
            view.beginPropertyChanges();
            view.invalidateRecursively('element');

            if (value !== null) {
                view.transitionTo('hasElement');
            }

            view.endPropertyChanges();

            return value;
        }
    };

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, meta = Ember.meta;

    Ember.View.states.inBuffer = {
        parentState: Ember.View.states._default,

        $: function (view, sel) {
            // if we don't have an element yet, someone calling this.$() is
            // trying to update an element that isn't in the DOM. Instead,
            // rerender the view to allow the render method to reflect the
            // changes.
            view.rerender();
            return Ember.$();
        },

        // when a view is rendered in a buffer, rerendering it simply
        // replaces the existing buffer with a new one
        rerender: function (view) {
            Ember.deprecate("Something you did caused a view to re-render after it rendered but before it was inserted into the DOM. Because this is avoidable and the cause of significant performance issues in applications, this behavior is deprecated. If you want to use the debugger to find out what caused this, you can set ENV.RAISE_ON_DEPRECATION to true.");

            view._notifyWillRerender();

            view.clearRenderedChildren();
            view.renderToBuffer(view.buffer, 'replaceWith');
        },

        // when a view is rendered in a buffer, appending a child
        // view will render that view and append the resulting
        // buffer into its buffer.
        appendChild: function (view, childView, options) {
            var buffer = view.buffer;

            childView = this.createChildView(childView, options);
            get(view, '_childViews').push(childView);

            childView.renderToBuffer(buffer);

            view.propertyDidChange('childViews');

            return childView;
        },

        // when a view is rendered in a buffer, destroying the
        // element will simply destroy the buffer and put the
        // state back into the preRender state.
        destroyElement: function (view) {
            view.clearBuffer();
            view._notifyWillDestroyElement();
            view.transitionTo('preRender');

            return view;
        },

        empty: function () {
            Ember.assert("Emptying a view in the inBuffer state is not allowed and should not happen under normal circumstances. Most likely there is a bug in your application. This may be due to excessive property change notifications.");
        },

        // It should be impossible for a rendered view to be scheduled for
        // insertion.
        insertElement: function () {
            throw "You can't insert an element that has already been rendered";
        },

        setElement: function (view, value) {
            view.invalidateRecursively('element');

            if (value === null) {
                view.transitionTo('preRender');
            } else {
                view.clearBuffer();
                view.transitionTo('hasElement');
            }

            return value;
        }
    };


})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, meta = Ember.meta;

    Ember.View.states.hasElement = {
        parentState: Ember.View.states._default,

        $: function (view, sel) {
            var elem = get(view, 'element');
            return sel ? Ember.$(sel, elem) : Ember.$(elem);
        },

        getElement: function (view) {
            var parent = get(view, 'parentView');
            if (parent) { parent = get(parent, 'element'); }
            if (parent) { return view.findElementInParentElement(parent); }
            return Ember.$("#" + get(view, 'elementId'))[0];
        },

        setElement: function (view, value) {
            if (value === null) {
                view.invalidateRecursively('element');

                view.transitionTo('preRender');
            } else {
                throw "You cannot set an element to a non-null value when the element is already in the DOM.";
            }

            return value;
        },

        // once the view has been inserted into the DOM, rerendering is
        // deferred to allow bindings to synchronize.
        rerender: function (view) {
            view._notifyWillRerender();

            view.clearRenderedChildren();

            view.domManager.replace(view);
            return view;
        },

        // once the view is already in the DOM, destroying it removes it
        // from the DOM, nukes its element, and puts it back into the
        // preRender state if inDOM.

        destroyElement: function (view) {
            view._notifyWillDestroyElement();
            view.domManager.remove(view);
            return view;
        },

        empty: function (view) {
            var _childViews = get(view, '_childViews'), len, idx;
            if (_childViews) {
                len = get(_childViews, 'length');
                for (idx = 0; idx < len; idx++) {
                    _childViews[idx]._notifyWillDestroyElement();
                }
            }
            view.domManager.empty(view);
        },

        // Handle events from `Ember.EventDispatcher`
        handleEvent: function (view, eventName, evt) {
            var handler = view[eventName];
            if (Ember.typeOf(handler) === 'function') {
                return handler.call(view, evt);
            } else {
                return true; // continue event propagation
            }
        }
    };

    Ember.View.states.inDOM = {
        parentState: Ember.View.states.hasElement,

        insertElement: function (view, fn) {
            if (view._lastInsert !== Ember.guidFor(fn)) {
                return;
            }
            throw "You can't insert an element into the DOM that has already been inserted";
        }
    };

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var destroyedError = "You can't call %@ on a destroyed view", fmt = Ember.String.fmt;

    Ember.View.states.destroyed = {
        parentState: Ember.View.states._default,

        appendChild: function () {
            throw fmt(destroyedError, ['appendChild']);
        },
        rerender: function () {
            throw fmt(destroyedError, ['rerender']);
        },
        destroyElement: function () {
            throw fmt(destroyedError, ['destroyElement']);
        },
        empty: function () {
            throw fmt(destroyedError, ['empty']);
        },

        setElement: function () {
            throw fmt(destroyedError, ["set('element', ...)"]);
        },

        // Since element insertion is scheduled, don't do anything if
        // the view has been destroyed between scheduling and execution
        insertElement: Ember.K
    };


})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, meta = Ember.meta;
    var forEach = Ember.ArrayUtils.forEach;

    var childViewsProperty = Ember.computed(function () {
        return get(this, '_childViews');
    }).property('_childViews').cacheable();

    /**
    @class

    A `ContainerView` is an `Ember.View` subclass that allows for manual or programatic
    management of a view's `childViews` array that will correctly update the `ContainerView`
    instance's rendered DOM representation.

    ## Setting Initial Child Views
    The initial array of child views can be set in one of two ways. You can provide
    a `childViews` property at creation time that contains instance of `Ember.View`:


    aContainer = Ember.ContainerView.create({
    childViews: [Ember.View.create(), Ember.View.create()]
    })

    You can also provide a list of property names whose values are instances of `Ember.View`:

    aContainer = Ember.ContainerView.create({
    childViews: ['aView', 'bView', 'cView'],
    aView: Ember.View.create(),
    bView: Ember.View.create()
    cView: Ember.View.create()
    })

    The two strategies can be combined:

    aContainer = Ember.ContainerView.create({
    childViews: ['aView', Ember.View.create()],
    aView: Ember.View.create()
    })

    Each child view's rendering will be inserted into the container's rendered HTML in the same
    order as its position in the `childViews` property.

    ## Adding and Removing Child Views
    The views in a container's `childViews` array should be added and removed by manipulating
    the `childViews` property directly.

    To remove a view pass that view into a `removeObject` call on the container's `childViews` property. 

    Given an empty `<body>` the following code

    aContainer = Ember.ContainerView.create({
    classNames: ['the-container'],
    childViews: ['aView', 'bView'],
    aView: Ember.View.create({
    template: Ember.Handlebars.compile("A")
    }),
    bView: Ember.View.create({
    template: Ember.Handlebars.compile("B")
    })
    })

    aContainer.appendTo('body')

    Results in the HTML

    <div class="ember-view the-container">
    <div class="ember-view">A</div>
    <div class="ember-view">B</div>
    </div>

    Removing a view

    aContainer.get('childViews') // [aContainer.aView, aContainer.bView]
    aContainer.get('childViews').removeObject(aContainer.get('bView'))
    aContainer.get('childViews') // [aContainer.aView]

    Will result in the following HTML

    <div class="ember-view the-container">
    <div class="ember-view">A</div>
    </div>


    Similarly, adding a child view is accomplished by adding `Ember.View` instances to the 
    container's `childViews` property.

    Given an empty `<body>` the following code

    aContainer = Ember.ContainerView.create({
    classNames: ['the-container'],
    childViews: ['aView', 'bView'],
    aView: Ember.View.create({
    template: Ember.Handlebars.compile("A")
    }),
    bView: Ember.View.create({
    template: Ember.Handlebars.compile("B")
    })
    })

    aContainer.appendTo('body')

    Results in the HTML

    <div class="ember-view the-container">
    <div class="ember-view">A</div>
    <div class="ember-view">B</div>
    </div>

    Adding a view

    AnotherViewClass = Ember.View.extend({
    template: Ember.Handlebars.compile("Another view")
    })

    aContainer.get('childViews') // [aContainer.aView, aContainer.bView]
    aContainer.get('childViews').pushObject(AnotherViewClass.create())
    aContainer.get('childViews') // [aContainer.aView, <AnotherViewClass instance>]

    Will result in the following HTML

    <div class="ember-view the-container">
    <div class="ember-view">A</div>
    <div class="ember-view">Another view</div>
    </div>


    Direct manipulation of childViews presence or absence in the DOM via calls to 
    `remove` or `removeFromParent` or calls to a container's `removeChild` may not behave
    correctly.

    Calling `remove()` on a child view will remove the view's HTML, but it will remain as part of its
    container's `childView`s property.

    Calling `removeChild()` on the container will remove the passed view instance from the container's
    `childView`s but keep its HTML within the container's rendered view.

    Calling `removeFromParent()` behaves as expected but should be avoided in favor of direct
    manipulation of a container's `childViews` property.

    aContainer = Ember.ContainerView.create({
    classNames: ['the-container'],
    childViews: ['aView', 'bView'],
    aView: Ember.View.create({
    template: Ember.Handlebars.compile("A")
    }),
    bView: Ember.View.create({
    template: Ember.Handlebars.compile("B")
    })
    })

    aContainer.appendTo('body')

    Results in the HTML

    <div class="ember-view the-container">
    <div class="ember-view">A</div>
    <div class="ember-view">B</div>
    </div>

    Calling `aContainer.get('aView').removeFromParent()` will result in the following HTML

    <div class="ember-view the-container">
    <div class="ember-view">B</div>
    </div>

    And the `Ember.View` instance stored in `aContainer.aView` will be removed from `aContainer`'s
    `childViews` array.

    ## Templates and Layout
    A `template`, `templateName`, `defaultTemplate`, `layout`, `layoutName` or `defaultLayout`
    property on a container view will not result in the template or layout being rendered. 
    The HTML contents of a `Ember.ContainerView`'s DOM representation will only be the rendered HTML
    of its child views.

    ## Binding a View to Display

    If you would like to display a single view in your ContainerView, you can set its `currentView`
    property. When the `currentView` property is set to a view instance, it will be added to the
    ContainerView's `childViews` array. If the `currentView` property is later changed to a
    different view, the new view will replace the old view. If `currentView` is set to `null`, the
    last `currentView` will be removed.

    This functionality is useful for cases where you want to bind the display of a ContainerView to
    a controller or state manager. For example, you can bind the `currentView` of a container to
    a controller like this:

    // Controller
    App.appController = Ember.Object.create({
    view: Ember.View.create({
    templateName: 'person_template'
    })
    });

    // Handlebars template
    {{view Ember.ContainerView currentViewBinding="App.appController.view"}}

    @extends Ember.View
    */

    Ember.ContainerView = Ember.View.extend({

        init: function () {
            var childViews = get(this, 'childViews');
            Ember.defineProperty(this, 'childViews', childViewsProperty);

            this._super();

            var _childViews = get(this, '_childViews');

            forEach(childViews, function (viewName, idx) {
                var view;

                if ('string' === typeof viewName) {
                    view = get(this, viewName);
                    view = this.createChildView(view);
                    set(this, viewName, view);
                } else {
                    view = this.createChildView(viewName);
                }

                _childViews[idx] = view;
            }, this);

            // Make the _childViews array observable
            Ember.A(_childViews);

            // Sets up an array observer on the child views array. This
            // observer will detect when child views are added or removed
            // and update the DOM to reflect the mutation.
            get(this, 'childViews').addArrayObserver(this, {
                willChange: 'childViewsWillChange',
                didChange: 'childViewsDidChange'
            });
        },

        /**
        Instructs each child view to render to the passed render buffer.

        @param {Ember.RenderBuffer} buffer the buffer to render to
        @private
        */
        render: function (buffer) {
            this.forEachChildView(function (view) {
                view.renderToBuffer(buffer);
            });
        },

        /**
        When the container view is destroyed, tear down the child views
        array observer.

        @private
        */
        willDestroy: function () {
            get(this, 'childViews').removeArrayObserver(this, {
                willChange: 'childViewsWillChange',
                didChange: 'childViewsDidChange'
            });

            this._super();
        },

        /**
        When a child view is removed, destroy its element so that
        it is removed from the DOM.

        The array observer that triggers this action is set up in the
        `renderToBuffer` method.

        @private
        @param {Ember.Array} views the child views array before mutation
        @param {Number} start the start position of the mutation
        @param {Number} removed the number of child views removed
        **/
        childViewsWillChange: function (views, start, removed) {
            if (removed === 0) { return; }

            var changedViews = views.slice(start, start + removed);
            this.initializeViews(changedViews, null, null);

            this.invokeForState('childViewsWillChange', views, start, removed);
        },

        /**
        When a child view is added, make sure the DOM gets updated appropriately.

        If the view has already rendered an element, we tell the child view to
        create an element and insert it into the DOM. If the enclosing container view
        has already written to a buffer, but not yet converted that buffer into an
        element, we insert the string representation of the child into the appropriate
        place in the buffer.

        @private
        @param {Ember.Array} views the array of child views afte the mutation has occurred
        @param {Number} start the start position of the mutation
        @param {Number} removed the number of child views removed
        @param {Number} the number of child views added
        */
        childViewsDidChange: function (views, start, removed, added) {
            var len = get(views, 'length');

            // No new child views were added; bail out.
            if (added === 0) return;

            var changedViews = views.slice(start, start + added);
            this.initializeViews(changedViews, this, get(this, 'templateData'));

            // Let the current state handle the changes
            this.invokeForState('childViewsDidChange', views, start, added);
        },

        initializeViews: function (views, parentView, templateData) {
            forEach(views, function (view) {
                set(view, '_parentView', parentView);

                if (!get(view, 'templateData')) {
                    set(view, 'templateData', templateData);
                }
            });
        },

        /**
        Schedules a child view to be inserted into the DOM after bindings have
        finished syncing for this run loop.

        @param {Ember.View} view the child view to insert
        @param {Ember.View} prev the child view after which the specified view should
        be inserted
        @private
        */
        _scheduleInsertion: function (view, prev) {
            if (prev) {
                prev.domManager.after(prev, view);
            } else {
                this.domManager.prepend(this, view);
            }
        },

        currentView: null,

        _currentViewWillChange: Ember.beforeObserver(function () {
            var childViews = get(this, 'childViews'),
        currentView = get(this, 'currentView');

            if (currentView) {
                childViews.removeObject(currentView);
            }
        }, 'currentView'),

        _currentViewDidChange: Ember.observer(function () {
            var childViews = get(this, 'childViews'),
        currentView = get(this, 'currentView');

            if (currentView) {
                childViews.pushObject(currentView);
            }
        }, 'currentView')
    });

    // Ember.ContainerView extends the default view states to provide different
    // behavior for childViewsWillChange and childViewsDidChange.
    Ember.ContainerView.states = {
        parent: Ember.View.states,

        inBuffer: {
            childViewsDidChange: function (parentView, views, start, added) {
                var buffer = parentView.buffer,
          startWith, prev, prevBuffer, view;

                // Determine where to begin inserting the child view(s) in the
                // render buffer.
                if (start === 0) {
                    // If views were inserted at the beginning, prepend the first
                    // view to the render buffer, then begin inserting any
                    // additional views at the beginning.
                    view = views[start];
                    startWith = start + 1;
                    view.renderToBuffer(buffer, 'prepend');
                } else {
                    // Otherwise, just insert them at the same place as the child
                    // views mutation.
                    view = views[start - 1];
                    startWith = start;
                }

                for (var i = startWith; i < start + added; i++) {
                    prev = view;
                    view = views[i];
                    prevBuffer = prev.buffer;
                    view.renderToBuffer(prevBuffer, 'insertAfter');
                }
            }
        },

        hasElement: {
            childViewsWillChange: function (view, views, start, removed) {
                for (var i = start; i < start + removed; i++) {
                    views[i].remove();
                }
            },

            childViewsDidChange: function (view, views, start, added) {
                // If the DOM element for this container view already exists,
                // schedule each child view to insert its DOM representation after
                // bindings have finished syncing.
                var prev = start === 0 ? null : views[start - 1];

                for (var i = start; i < start + added; i++) {
                    view = views[i];
                    this._scheduleInsertion(view, prev);
                    prev = view;
                }
            }
        }
    };

    Ember.ContainerView.states.inDOM = {
        parentState: Ember.ContainerView.states.hasElement
    };

    Ember.ContainerView.reopen({
        states: Ember.ContainerView.states
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, fmt = Ember.String.fmt;

    /**
    @class

    `Ember.CollectionView` is an `Ember.View` descendent responsible for managing a
    collection (an array or array-like object) by maintaing a child view object and 
    associated DOM representation for each item in the array and ensuring that child
    views and their associated rendered HTML are updated when items in the array
    are added, removed, or replaced.

    ## Setting content
    The managed collection of objects is referenced as the `Ember.CollectionView` instance's
    `content` property.

    someItemsView = Ember.CollectionView.create({
    content: ['A', 'B','C']
    })

    The view for each item in the collection will have its `content` property set
    to the item.

    ## Specifying itemViewClass
    By default the view class for each item in the managed collection will be an instance
    of `Ember.View`. You can supply a different class by setting the `CollectionView`'s
    `itemViewClass` property.

    Given an empty `<body>` and the following code:


    someItemsView = Ember.CollectionView.create({
    classNames: ['a-collection'],
    content: ['A','B','C'],
    itemViewClass: Ember.View.extend({
    template: Ember.Handlebars.compile("the letter: {{content}}")
    })
    })

    someItemsView.appendTo('body')

    Will result in the following HTML structure

    <div class="ember-view a-collection">
    <div class="ember-view">the letter: A</div>
    <div class="ember-view">the letter: B</div>
    <div class="ember-view">the letter: C</div>
    </div>


    ## Automatic matching of parent/child tagNames
    Setting the `tagName` property of a `CollectionView` to any of 
    "ul", "ol", "table", "thead", "tbody", "tfoot", "tr", or "select" will result
    in the item views receiving an appropriately matched `tagName` property.


    Given an empty `<body>` and the following code:

    anUndorderedListView = Ember.CollectionView.create({
    tagName: 'ul',
    content: ['A','B','C'],
    itemViewClass: Ember.View.extend({
    template: Ember.Handlebars.compile("the letter: {{content}}")
    })
    })

    anUndorderedListView.appendTo('body')

    Will result in the following HTML structure

    <ul class="ember-view a-collection">
    <li class="ember-view">the letter: A</li>
    <li class="ember-view">the letter: B</li>
    <li class="ember-view">the letter: C</li>
    </ul>

    Additional tagName pairs can be provided by adding to `Ember.CollectionView.CONTAINER_MAP `

    Ember.CollectionView.CONTAINER_MAP['article'] = 'section'


    ## Empty View
    You can provide an `Ember.View` subclass to the `Ember.CollectionView` instance as its
    `emptyView` property. If the `content` property of a `CollectionView` is set to `null`
    or an empty array, an instance of this view will be the `CollectionView`s only child.

    aListWithNothing = Ember.CollectionView.create({
    classNames: ['nothing']
    content: null,
    emptyView: Ember.View.extend({
    template: Ember.Handlebars.compile("The collection is empty")
    })
    })

    aListWithNothing.appendTo('body')

    Will result in the following HTML structure

    <div class="ember-view nothing">
    <div class="ember-view">
    The collection is empty
    </div>
    </div>

    ## Adding and Removing items
    The `childViews` property of a `CollectionView` should not be directly manipulated. Instead,
    add, remove, replace items from its `content` property. This will trigger
    appropriate changes to its rendered HTML.

    ## Use in templates via the `{{collection}}` Ember.Handlebars helper
    Ember.Handlebars provides a helper specifically for adding `CollectionView`s to templates.
    See `Ember.Handlebars.collection` for more details

    @since Ember 0.9
    @extends Ember.ContainerView
    */
    Ember.CollectionView = Ember.ContainerView.extend(
    /** @scope Ember.CollectionView.prototype */{

    /**
    A list of items to be displayed by the Ember.CollectionView.

    @type Ember.Array
    @default null
    */
    content: null,

    /**
    @private

    This provides metadata about what kind of empty view class this
    collection would like if it is being instantiated from another
    system (like Handlebars)
    */
    emptyViewClass: Ember.View,

    /**
    An optional view to display if content is set to an empty array.

    @type Ember.View
    @default null
    */
    emptyView: null,

    /**
    @type Ember.View
    @default Ember.View
    */
    itemViewClass: Ember.View,

    /** @private */
    init: function () {
        var ret = this._super();
        this._contentDidChange();
        return ret;
    },

    _contentWillChange: Ember.beforeObserver(function () {
        var content = this.get('content');

        if (content) { content.removeArrayObserver(this); }
        var len = content ? get(content, 'length') : 0;
        this.arrayWillChange(content, 0, len);
    }, 'content'),

    /**
    @private

    Check to make sure that the content has changed, and if so,
    update the children directly. This is always scheduled
    asynchronously, to allow the element to be created before
    bindings have synchronized and vice versa.
    */
    _contentDidChange: Ember.observer(function () {
        var content = get(this, 'content');

        if (content) {
            Ember.assert(fmt("an Ember.CollectionView's content must implement Ember.Array. You passed %@", [content]), Ember.Array.detect(content));
            content.addArrayObserver(this);
        }

        var len = content ? get(content, 'length') : 0;
        this.arrayDidChange(content, 0, null, len);
    }, 'content'),

    willDestroy: function () {
        var content = get(this, 'content');
        if (content) { content.removeArrayObserver(this); }

        this._super();
    },

    arrayWillChange: function (content, start, removedCount) {
        // If the contents were empty before and this template collection has an
        // empty view remove it now.
        var emptyView = get(this, 'emptyView');
        if (emptyView && emptyView instanceof Ember.View) {
            emptyView.removeFromParent();
        }

        // Loop through child views that correspond with the removed items.
        // Note that we loop from the end of the array to the beginning because
        // we are mutating it as we go.
        var childViews = get(this, 'childViews'), childView, idx, len;

        len = get(childViews, 'length');

        var removingAll = removedCount === len;

        if (removingAll) {
            this.invokeForState('empty');
        }

        for (idx = start + removedCount - 1; idx >= start; idx--) {
            childView = childViews[idx];
            if (removingAll) { childView.removedFromDOM = true; }
            childView.destroy();
        }
    },

    /**
    Called when a mutation to the underlying content array occurs.

    This method will replay that mutation against the views that compose the
    Ember.CollectionView, ensuring that the view reflects the model.

    This array observer is added in contentDidChange.

    @param {Array} addedObjects
    the objects that were added to the content

    @param {Array} removedObjects
    the objects that were removed from the content

    @param {Number} changeIndex
    the index at which the changes occurred
    */
    arrayDidChange: function (content, start, removed, added) {
        var itemViewClass = get(this, 'itemViewClass'),
        childViews = get(this, 'childViews'),
        addedViews = [], view, item, idx, len, itemTagName;

        if ('string' === typeof itemViewClass) {
            itemViewClass = Ember.getPath(itemViewClass);
        }

        Ember.assert(fmt("itemViewClass must be a subclass of Ember.View, not %@", [itemViewClass]), Ember.View.detect(itemViewClass));

        len = content ? get(content, 'length') : 0;
        if (len) {
            for (idx = start; idx < start + added; idx++) {
                item = content.objectAt(idx);

                view = this.createChildView(itemViewClass, {
                    content: item,
                    contentIndex: idx
                });

                addedViews.push(view);
            }
        } else {
            var emptyView = get(this, 'emptyView');
            if (!emptyView) { return; }

            emptyView = this.createChildView(emptyView);
            addedViews.push(emptyView);
            set(this, 'emptyView', emptyView);
        }
        childViews.replace(start, 0, addedViews);
    },

    createChildView: function (view, attrs) {
        view = this._super(view, attrs);

        var itemTagName = get(view, 'tagName');
        var tagName = (itemTagName === null || itemTagName === undefined) ? Ember.CollectionView.CONTAINER_MAP[get(this, 'tagName')] : itemTagName;

        set(view, 'tagName', tagName);

        return view;
    }
});

/**
@static

A map of parent tags to their default child tags. You can add
additional parent tags if you want collection views that use
a particular parent tag to default to a child tag.

@type Hash
@constant
*/
Ember.CollectionView.CONTAINER_MAP = {
    ul: 'li',
    ol: 'li',
    table: 'tr',
    thead: 'tr',
    tbody: 'tr',
    tfoot: 'tr',
    tr: 'td',
    select: 'option'
};

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:   Ember - JavaScript Application Framework
    // Copyright: 漏2006-2011 Strobe Inc. and contributors.
    //            Portions 漏2008-2011 Apple Inc. All rights reserved.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    /*globals jQuery*/

})();

(function () {
    var get = Ember.get, set = Ember.set, getPath = Ember.getPath;

    Ember.State = Ember.Object.extend(Ember.Evented, {
        isState: true,
        parentState: null,
        start: null,
        name: null,
        path: Ember.computed(function () {
            var parentPath = getPath(this, 'parentState.path'),
        path = get(this, 'name');

            if (parentPath) {
                path = parentPath + '.' + path;
            }

            return path;
        }).property().cacheable(),

        /**
        @private

        Override the default event firing from Ember.Evented to
        also call methods with the given name.
        */
        fire: function (name) {
            if (this[name]) {
                this[name].apply(this, [].slice.call(arguments, 1));
            }
            this._super.apply(this, arguments);
        },

        init: function () {
            var states = get(this, 'states'), foundStates;
            set(this, 'childStates', Ember.A());

            var name;

            // As a convenience, loop over the properties
            // of this state and look for any that are other
            // Ember.State instances or classes, and move them
            // to the `states` hash. This avoids having to
            // create an explicit separate hash.

            if (!states) {
                states = {};

                for (name in this) {
                    if (name === "constructor") { continue; }
                    this.setupChild(states, name, this[name]);
                }

                set(this, 'states', states);
            } else {
                for (name in states) {
                    this.setupChild(states, name, states[name]);
                }
            }

            set(this, 'routes', {});
        },

        setupChild: function (states, name, value) {
            if (!value) { return false; }

            if (Ember.State.detect(value)) {
                value = value.create({
                    name: name
                });
            } else if (value.isState) {
                set(value, 'name', name);
            }

            if (value.isState) {
                set(value, 'parentState', this);
                get(this, 'childStates').pushObject(value);
                states[name] = value;
            }
        },

        /**
        A Boolean value indicating whether the state is a leaf state
        in the state hierarchy. This is false if the state has child
        states; otherwise it is true.

        @property {Boolean}
        */
        isLeaf: Ember.computed(function () {
            return !get(this, 'childStates').length;
        }).cacheable(),

        setupControllers: Ember.K,
        enter: Ember.K,
        exit: Ember.K
    });

})();



(function () {
    var get = Ember.get, set = Ember.set, getPath = Ember.getPath, fmt = Ember.String.fmt;
    /**
    @class
  
    StateManager is part of Ember's implementation of a finite state machine. A StateManager
    instance manages a number of properties that are instances of `Ember.State`,
    tracks the current active state, and triggers callbacks when states have changed.

    ## Defining States

    The states of StateManager can be declared in one of two ways. First, you can define
    a `states` property that contains all the states:

    managerA = Ember.StateManager.create({
    states: {
    stateOne: Ember.State.create(),
    stateTwo: Ember.State.create()
    }
    })

    managerA.get('states')
    // {
    //   stateOne: Ember.State.create(),
    //   stateTwo: Ember.State.create()
    // }

    You can also add instances of `Ember.State` (or an `Ember.State` subclass) directly as properties
    of a StateManager. These states will be collected into the `states` property for you.

    managerA = Ember.StateManager.create({
    stateOne: Ember.State.create(),
    stateTwo: Ember.State.create()
    })

    managerA.get('states')
    // {
    //   stateOne: Ember.State.create(),
    //   stateTwo: Ember.State.create()
    // }

    ## The Initial State
    When created a StateManager instance will immediately enter into the state
    defined as its `start` property or the state referenced by name in its 
    `initialState` property:

    managerA = Ember.StateManager.create({
    start: Ember.State.create({})
    })

    managerA.getPath('currentState.name') // 'start'

    managerB = Ember.StateManager.create({
    initialState: 'beginHere',
    beginHere: Ember.State.create({})
    })

    managerB.getPath('currentState.name') // 'beginHere'

    Because it is a property you may also provided a computed function if you wish to derive
    an `initialState` programmatically:

    managerC = Ember.StateManager.create({
    initialState: function(){
    if (someLogic) {
    return 'active';
    } else {
    return 'passive';
    }
    }.property(),
    active: Ember.State.create({}),
    passive: Ember.State.create({})
    })

    ## Moving Between States
    A StateManager can have any number of Ember.State objects as properties
    and can have a single one of these states as its current state.

    Calling `goToState` transitions between states:

    robotManager = Ember.StateManager.create({
    initialState: 'poweredDown',
    poweredDown: Ember.State.create({}),
    poweredUp: Ember.State.create({})
    })

    robotManager.getPath('currentState.name') // 'poweredDown'
    robotManager.goToState('poweredUp')
    robotManager.getPath('currentState.name') // 'poweredUp'

    Before transitioning into a new state the existing `currentState` will have its
    `exit` method called with the StateManager instance as its first argument and 
    an object representing the transition as its second argument.

    After transitioning into a new state the new `currentState` will have its
    `enter` method called with the StateManager instance as its first argument and 
    an object representing the transition as its second argument.

    robotManager = Ember.StateManager.create({
    initialState: 'poweredDown',
    poweredDown: Ember.State.create({
    exit: function(stateManager, transition){
    console.log("exiting the poweredDown state")
    }
    }),
    poweredUp: Ember.State.create({
    enter: function(stateManager, transition){
    console.log("entering the poweredUp state. Destroy all humans.")
    }
    })
    })

    robotManager.getPath('currentState.name') // 'poweredDown'
    robotManager.goToState('poweredUp')
    // will log
    // 'exiting the poweredDown state'
    // 'entering the poweredUp state. Destroy all humans.'


    Once a StateManager is already in a state, subsequent attempts to enter that state will
    not trigger enter or exit method calls. Attempts to transition into a state that the 
    manager does not have will result in no changes in the StateManager's current state:

    robotManager = Ember.StateManager.create({
    initialState: 'poweredDown',
    poweredDown: Ember.State.create({
    exit: function(stateManager, transition){
    console.log("exiting the poweredDown state")
    }
    }),
    poweredUp: Ember.State.create({
    enter: function(stateManager, transition){
    console.log("entering the poweredUp state. Destroy all humans.")
    }
    })
    })

    robotManager.getPath('currentState.name') // 'poweredDown'
    robotManager.goToState('poweredUp')
    // will log
    // 'exiting the poweredDown state'
    // 'entering the poweredUp state. Destroy all humans.'
    robotManager.goToState('poweredUp') // no logging, no state change

    robotManager.goToState('someUnknownState') // silently fails
    robotManager.getPath('currentState.name') // 'poweredUp'


    Each state property may itself contain properties that are instances of Ember.State. 
    The StateManager can transition to specific sub-states in a series of goToState method calls or
    via a single goToState with the full path to the specific state. The StateManager will also 
    keep track of the full path to its currentState

    robotManager = Ember.StateManager.create({
    initialState: 'poweredDown',
    poweredDown: Ember.State.create({
    charging: Ember.State.create(),
    charged: Ember.State.create()
    }),
    poweredUp: Ember.State.create({
    mobile: Ember.State.create(),
    stationary: Ember.State.create()
    })
    })

    robotManager.getPath('currentState.name') // 'poweredDown'

    robotManager.goToState('poweredUp')
    robotManager.getPath('currentState.name') // 'poweredUp'

    robotManager.goToState('mobile')
    robotManager.getPath('currentState.name') // 'mobile'

    // transition via a state path
    robotManager.goToState('poweredDown.charging')
    robotManager.getPath('currentState.name') // 'charging'

    robotManager.getPath('currentState.get.path') // 'poweredDown.charging'

    Enter transition methods will be called for each state and nested child state in their
    hierarchical order.  Exit methods will be called for each state and its nested states in
    reverse hierarchical order.

    Exit transitions for a parent state are not called when entering into one of its child states,
    only when transitioning to a new section of possible states in the hierarchy.

    robotManager = Ember.StateManager.create({
    initialState: 'poweredDown',
    poweredDown: Ember.State.create({
    enter: function(){},
    exit: function(){
    console.log("exited poweredDown state")
    },
    charging: Ember.State.create({
    enter: function(){},
    exit: function(){}
    }),
    charged: Ember.State.create({
    enter: function(){
    console.log("entered charged state")
    },
    exit: function(){
    console.log("exited charged state")
    }
    })
    }),
    poweredUp: Ember.State.create({
    enter: function(){
    console.log("entered poweredUp state")
    },
    exit: function(){},
    mobile: Ember.State.create({
    enter: function(){
    console.log("entered mobile state")
    },
    exit: function(){}
    }),
    stationary: Ember.State.create({
    enter: function(){},
    exit: function(){}
    })
    })
    })


    robotManager.get('currentState.get.path') // 'poweredDown'
    robotManager.goToState('charged')
    // logs 'entered charged state'
    // but does *not* log  'exited poweredDown state'
    robotManager.getPath('currentState.name') // 'charged

    robotManager.goToState('poweredUp.mobile')
    // logs
    // 'exited charged state'
    // 'exited poweredDown state'
    // 'entered poweredUp state'
    // 'entered mobile state'

    During development you can set a StateManager's `enableLogging` property to `true` to
    receive console messages of state transitions.

    robotManager = Ember.StateManager.create({
    enableLogging: true
    })

    ## Managing currentState with Actions
    To control which transitions between states are possible for a given state, StateManager
    can receive and route action messages to its states via the `send` method.  Calling to `send` with
    an action name will begin searching for a method with the same name starting at the current state
    and moving up through the parent states in a state hierarchy until an appropriate method is found
    or the StateManager instance itself is reached. 

    If an appropriately named method is found it will be called with the state manager as the first
    argument and an optional `context` object as the second argument.

    managerA = Ember.StateManager.create({
    initialState: 'stateOne.substateOne.subsubstateOne',
    stateOne: Ember.State.create({
    substateOne: Ember.State.create({
    anAction: function(manager, context){
    console.log("an action was called")
    },
    subsubstateOne: Ember.State.create({})
    })
    })
    })

    managerA.getPath('currentState.name') // 'subsubstateOne'
    managerA.send('anAction')
    // 'stateOne.substateOne.subsubstateOne' has no anAction method
    // so the 'anAction' method of 'stateOne.substateOne' is called
    // and logs "an action was called"
    // with managerA as the first argument
    // and no second argument

    someObject = {}
    managerA.send('anAction', someObject)
    // the 'anAction' method of 'stateOne.substateOne' is called again
    // with managerA as the first argument and
    // someObject as the second argument.


    If the StateManager attempts to send an action but does not find an appropriately named
    method in the current state or while moving upwards through the state hierarchy
    it will throw a new Ember.Error. Action detection only moves upwards through the state hierarchy
    from the current state. It does not search in other portions of the hierarchy.

    managerB = Ember.StateManager.create({
    initialState: 'stateOne.substateOne.subsubstateOne',
    stateOne: Ember.State.create({
    substateOne: Ember.State.create({
    subsubstateOne: Ember.State.create({})
    })
    }),
    stateTwo: Ember.State.create({
    anAction: function(manager, context){
    // will not be called below because it is
    // not a parent of the current state
    }
    })
    })

    managerB.getPath('currentState.name') // 'subsubstateOne'
    managerB.send('anAction')
    // Error: <Ember.StateManager:ember132> could not
    // respond to event anAction in state stateOne.substateOne.subsubstateOne.

    Inside of an action method the given state should delegate `goToState` calls on its
    StateManager.

    robotManager = Ember.StateManager.create({
    initialState: 'poweredDown.charging',
    poweredDown: Ember.State.create({
    charging: Ember.State.create({
    chargeComplete: function(manager, context){
    manager.goToState('charged')
    }
    }),
    charged: Ember.State.create({
    boot: function(manager, context){
    manager.goToState('poweredUp')
    }
    })
    }),
    poweredUp: Ember.State.create({
    beginExtermination: function(manager, context){
    manager.goToState('rampaging')
    },
    rampaging: Ember.State.create()
    })
    })

    robotManager.getPath('currentState.name') // 'charging'
    robotManager.send('boot') // throws error, no boot action
    // in current hierarchy
    robotManager.getPath('currentState.name') // remains 'charging'

    robotManager.send('beginExtermination') // throws error, no beginExtermination
    // action in current hierarchy
    robotManager.getPath('currentState.name') // remains 'charging'

    robotManager.send('chargeComplete')
    robotManager.getPath('currentState.name') // 'charged'

    robotManager.send('boot')
    robotManager.getPath('currentState.name') // 'poweredUp'

    robotManager.send('beginExtermination', allHumans)
    robotManager.getPath('currentState.name') // 'rampaging'

    **/
    Ember.StateManager = Ember.State.extend(
    /** @scope Ember.StateManager.prototype */{

    /**
    When creating a new statemanager, look for a default state to transition
    into. This state can either be named `start`, or can be specified using the
    `initialState` property.
    */
    init: function () {
        this._super();

        set(this, 'stateMeta', Ember.Map.create());

        var initialState = get(this, 'initialState');

        if (!initialState && getPath(this, 'states.start')) {
            initialState = 'start';
        }

        if (initialState) {
            this.goToState(initialState);
        }
    },

    currentState: null,

    /**
    If set to true, `errorOnUnhandledEvents` will cause an exception to be
    raised if you attempt to send an event to a state manager that is not
    handled by the current state or any of its parent states.

    @property {Boolean}
    */
    errorOnUnhandledEvent: true,

    send: function (event, context) {
        this.sendRecursively(event, get(this, 'currentState'), context);
    },

    sendRecursively: function (event, currentState, context) {
        var log = this.enableLogging;

        var action = currentState[event];

        // Test to see if the action is a method that
        // can be invoked. Don't blindly check just for
        // existence, because it is possible the state
        // manager has a child state of the given name,
        // and we should still raise an exception in that
        // case.
        if (typeof action === 'function') {
            if (log) { Ember.Logger.log(fmt("STATEMANAGER: Sending event '%@' to state %@.", [event, get(currentState, 'path')])); }
            action.call(currentState, this, context);
        } else {
            var parentState = get(currentState, 'parentState');
            if (parentState) {
                this.sendRecursively(event, parentState, context);
            } else if (get(this, 'errorOnUnhandledEvent')) {
                throw new Ember.Error(this.toString() + " could not respond to event " + event + " in state " + getPath(this, 'currentState.path') + ".");
            }
        }
    },

    findStatesByRoute: function (state, route) {
        if (!route || route === "") { return undefined; }
        var r = route.split('.'), ret = [];

        for (var i = 0, len = r.length; i < len; i += 1) {
            var states = get(state, 'states');

            if (!states) { return undefined; }

            var s = get(states, r[i]);
            if (s) { state = s; ret.push(s); }
            else { return undefined; }
        }

        return ret;
    },

    goToState: function () {
        // not deprecating this yet so people don't constantly need to
        // make trivial changes for little reason.
        return this.transitionTo.apply(this, arguments);
    },

    pathForSegments: function (array) {
        return Ember.ArrayUtils.map(array, function (tuple) {
            Ember.assert("A segment passed to transitionTo must be an Array", Ember.typeOf(tuple) === "array");
            return tuple[0];
        }).join(".");
    },

    transitionTo: function (name, context) {
        // 1. Normalize arguments
        // 2. Ensure that we are in the correct state
        // 3. Map provided path to context objects and send
        //    appropriate setupControllers events

        if (Ember.empty(name)) { return; }

        var segments;

        if (Ember.typeOf(name) === "array") {
            segments = Array.prototype.slice.call(arguments);
        } else {
            segments = [[name, context]];
        }

        var path = this.pathForSegments(segments);

        var currentState = get(this, 'currentState') || this, state, newState;

        var exitStates = [], enterStates, resolveState;

        state = currentState;

        if (state.routes[path]) {
            // cache hit

            var route = state.routes[path];
            exitStates = route.exitStates;
            enterStates = route.enterStates;
            state = route.futureState;
            resolveState = route.resolveState;
        } else {
            // cache miss

            newState = this.findStatesByRoute(currentState, path);

            while (state && !newState) {
                exitStates.unshift(state);

                state = get(state, 'parentState');
                if (!state) {
                    newState = this.findStatesByRoute(this, path);
                    if (!newState) { return; }
                }
                newState = this.findStatesByRoute(state, path);
            }

            resolveState = state;

            enterStates = newState.slice(0);
            exitStates = exitStates.slice(0);

            if (enterStates.length > 0) {
                state = enterStates[enterStates.length - 1];

                while (enterStates.length > 0 && enterStates[0] === exitStates[0]) {
                    enterStates.shift();
                    exitStates.shift();
                }
            }

            currentState.routes[path] = {
                exitStates: exitStates,
                enterStates: enterStates,
                futureState: state,
                resolveState: resolveState
            };
        }

        this.enterState(exitStates, enterStates, state);
        this.triggerSetupContext(resolveState, segments);
    },

    triggerSetupContext: function (root, segments) {
        var state = root;

        Ember.ArrayUtils.forEach(segments, function (tuple) {
            var path = tuple[0], context = tuple[1];

            state = this.findStatesByRoute(state, path);
            state = state[state.length - 1];

            state.fire('setupControllers', this, context);
        }, this);
        //getPath(root, path).setupControllers(this, context);
    },

    getState: function (name) {
        var state = get(this, name),
        parentState = get(this, 'parentState');

        if (state) {
            return state;
        } else if (parentState) {
            return parentState.getState(name);
        }
    },

    asyncEach: function (list, callback, doneCallback) {
        var async = false, self = this;

        if (!list.length) {
            if (doneCallback) { doneCallback.call(this); }
            return;
        }

        var head = list[0];
        var tail = list.slice(1);

        var transition = {
            async: function () { async = true; },
            resume: function () {
                self.asyncEach(tail, callback, doneCallback);
            }
        };

        callback.call(this, head, transition);

        if (!async) { transition.resume(); }
    },

    enterState: function (exitStates, enterStates, state) {
        var log = this.enableLogging;

        var stateManager = this;

        exitStates = exitStates.slice(0).reverse();
        this.asyncEach(exitStates, function (state, transition) {
            state.fire('exit', stateManager, transition);
        }, function () {
            this.asyncEach(enterStates, function (state, transition) {
                if (log) { Ember.Logger.log("STATEMANAGER: Entering " + get(state, 'path')); }
                state.fire('enter', stateManager, transition);
            }, function () {
                var startState = state, enteredState, initialState;

                initialState = get(startState, 'initialState');

                if (!initialState) {
                    initialState = 'start';
                }

                // right now, start states cannot be entered asynchronously
                while (startState = get(get(startState, 'states'), initialState)) {
                    enteredState = startState;

                    if (log) { Ember.Logger.log("STATEMANAGER: Entering " + get(startState, 'path')); }
                    startState.fire('enter', stateManager);

                    initialState = get(startState, 'initialState');

                    if (!initialState) {
                        initialState = 'start';
                    }
                }

                set(this, 'currentState', enteredState || state);
            });
        });
    }
});

})();



(function () {
    var escapeForRegex = function (text) {
        return text.replace(/[\-\[\]{}()*+?.,\\\^\$|#\s]/g, "\\$&");
    };

    Ember._RouteMatcher = Ember.Object.extend({
        state: null,

        init: function () {
            var route = this.route,
        identifiers = [],
        count = 1,
        escaped;

            // Strip off leading slash if present
            if (route.charAt(0) === '/') {
                route = this.route = route.substr(1);
            }

            escaped = escapeForRegex(route);

            var regex = escaped.replace(/:([a-z_]+)(?=$|\/)/gi, function (match, id) {
                identifiers[count++] = id;
                return "([^/]+)";
            });

            this.identifiers = identifiers;
            this.regex = new RegExp("^/?" + regex);
        },

        match: function (path) {
            var match = path.match(this.regex);

            if (match) {
                var identifiers = this.identifiers,
          hash = {};

                for (var i = 1, l = identifiers.length; i < l; i++) {
                    hash[identifiers[i]] = match[i];
                }

                return {
                    remaining: path.substr(match[0].length),
                    hash: hash
                };
            }
        },

        generate: function (hash) {
            var identifiers = this.identifiers, route = this.route, id;
            for (var i = 1, l = identifiers.length; i < l; i++) {
                id = identifiers[i];
                route = route.replace(new RegExp(":" + id), hash[id]);
            }
            return route;
        }
    });

})();



(function () {
    var get = Ember.get, getPath = Ember.getPath;

    // The Ember Routable mixin assumes the existance of a simple
    // routing shim that supports the following three behaviors:
    //
    // * .getURL() - this is called when the page loads
    // * .setURL(newURL) - this is called from within the state
    //   manager when the state changes to a routable state
    // * .onURLChange(callback) - this happens when the user presses
    //   the back or forward button

    Ember.Routable = Ember.Mixin.create({
        init: function () {
            this.on('setupControllers', this, this.stashContext);

            this._super();
        },

        stashContext: function (manager, context) {
            var meta = get(manager, 'stateMeta'),
        serialized = this.serialize(manager, context);

            meta.set(this, serialized);

            if (get(this, 'isRoutable')) {
                this.updateRoute(manager, get(manager, 'location'));
            }
        },

        updateRoute: function (manager, location) {
            if (location && get(this, 'isLeaf')) {
                var path = this.absoluteRoute(manager);
                location.setURL(path);
            }
        },

        absoluteRoute: function (manager) {
            var parentState = get(this, 'parentState');
            var path = '';

            if (get(parentState, 'isRoutable')) {
                path = parentState.absoluteRoute(manager);
            }

            var matcher = get(this, 'routeMatcher'),
        hash = get(manager, 'stateMeta').get(this);

            var generated = matcher.generate(hash);

            if (generated !== "") {
                return path + '/' + matcher.generate(hash);
            } else {
                return path;
            }
        },

        isRoutable: Ember.computed(function () {
            return typeof this.route === "string";
        }).cacheable(),

        routeMatcher: Ember.computed(function () {
            return Ember._RouteMatcher.create({ route: get(this, 'route') });
        }).cacheable(),

        deserialize: function (manager, context) {
            return context;
        },

        serialize: function (manager, context) {
            return context;
        },

        routePath: function (manager, path) {
            if (get(this, 'isLeaf')) { return; }

            var childStates = get(this, 'childStates'), match;

            childStates = childStates.sort(function (a, b) {
                return getPath(b, 'route.length') - getPath(a, 'route.length');
            });

            var state = childStates.find(function (state) {
                var matcher = get(state, 'routeMatcher');
                if (match = matcher.match(path)) { return true; }
            });

            Ember.assert("Could not find state for path " + path, !!state);

            var object = state.deserialize(manager, match.hash) || {};
            manager.transitionTo(get(state, 'path'), object);
            manager.send('routePath', match.remaining);
        }
    });

    Ember.State.reopen(Ember.Routable);

})();



(function () {
    Ember.Router = Ember.StateManager.extend({
        route: function (path) {
            if (path.charAt(0) === '/') {
                path = path.substr(1);
            }

            this.send('routePath', path);
        }
    });

})();



(function () {
    // ==========================================================================
    // Project:  Ember Statecharts
    // Copyright: 漏2011 Living Social Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();

(function () {
    var get = Ember.get, set = Ember.set, getPath = Ember.getPath, fmt = Ember.String.fmt;

    /**
    @class
  
    ## Interactions with Ember's View System.
    When combined with instances of `Ember.ViewState`, StateManager is designed to 
    interact with Ember's view system to control which views are added to 
    and removed from the DOM based on the manager's current state.

    By default, a StateManager will manage views inside the 'body' element. This can be
    customized by setting the `rootElement` property to a CSS selector of an existing 
    HTML element you would prefer to receive view rendering.


    viewStates = Ember.StateManager.create({
    rootElement: '#some-other-element'
    })

    You can also specify a particular instance of `Ember.ContainerView` you would like to receive
    view rendering by setting the `rootView` property. You will be responsible for placing
    this element into the DOM yourself.

    aLayoutView = Ember.ContainerView.create()

    // make sure this view instance is added to the browser
    aLayoutView.appendTo('body') 

    App.viewStates = Ember.StateManager.create({
    rootView: aLayoutView
    })


    Once you have an instance of StateManager controlling a view, you can provide states
    that are instances of `Ember.ViewState`.  When the StateManager enters a state
    that is an instance of `Ember.ViewState` that `ViewState`'s `view` property will be
    instantiated and inserted into the StateManager's `rootView` or `rootElement`.
    When a state is exited, the `ViewState`'s view will be removed from the StateManager's
    view.

    ContactListView = Ember.View.extend({
    classNames: ['my-contacts-css-class'],
    template: Ember.Handlebars.compile('<h2>People</h2>')
    })

    PhotoListView = Ember.View.extend({
    classNames: ['my-photos-css-class'],
    template: Ember.Handlebars.compile('<h2>Photos</h2>')
    })

    viewStates = Ember.StateManager.create({
    showingPeople: Ember.ViewState.create({
    view: ContactListView
    }),
    showingPhotos: Ember.ViewState.create({
    view: PhotoListView
    })
    })

    viewStates.goToState('showingPeople')

    The above code will change the rendered HTML from

    <body></body>

    to

    <body>
    <div id="ember1" class="ember-view my-contacts-css-class">
    <h2>People</h2>
    </div>
    </body>

    Changing the current state via `goToState` from `showingPeople` to
    `showingPhotos` will remove the `showingPeople` view and add the `showingPhotos` view:

    viewStates.goToState('showingPhotos')

    will change the rendered HTML to

    <body>
    <div id="ember2" class="ember-view my-photos-css-class">
    <h2>Photos</h2>
    </div>
    </body>


    When entering nested `ViewState`s, each state's view will be draw into the the StateManager's
    `rootView` or `rootElement` as siblings.


    ContactListView = Ember.View.extend({
    classNames: ['my-contacts-css-class'],
    template: Ember.Handlebars.compile('<h2>People</h2>')
    })

    EditAContactView = Ember.View.extend({
    classNames: ['editing-a-contact-css-class'],
    template: Ember.Handlebars.compile('Editing...')
    })

    viewStates = Ember.StateManager.create({
    showingPeople: Ember.ViewState.create({
    view: ContactListView,

    withEditingPanel: Ember.ViewState.create({
    view: EditAContactView
    })
    })
    })


    viewStates.goToState('showingPeople.withEditingPanel')


    Will result in the following rendered HTML:

    <body>
    <div id="ember2" class="ember-view my-contacts-css-class">
    <h2>People</h2>
    </div>

    <div id="ember2" class="ember-view editing-a-contact-css-class">
    Editing...
    </div>
    </body>


    ViewState views are added and removed from their StateManager's view via their
    `enter` and `exit` methods. If you need to override these methods, be sure to call
    `_super` to maintain the adding and removing behavior:

    viewStates = Ember.StateManager.create({
    aState: Ember.ViewState.create({
    view: Ember.View.extend({}),
    enter: function(manager, transition){
    // calling _super ensures this view will be
    // properly inserted
    this._super(manager, transition);

    // now you can do other things
    }
    })
    })

    ## Managing Multiple Sections of A Page With States
    Multiple StateManagers can be combined to control multiple areas of an application's rendered views.
    Given the following HTML body:

    <body>
    <div id='sidebar-nav'>
    </div>
    <div id='content-area'>
    </div>
    </body>

    You could separately manage view state for each section with two StateManagers

    navigationStates = Ember.StateManager.create({
    rootElement: '#sidebar-nav',
    userAuthenticated: Em.ViewState.create({
    view: Ember.View.extend({})
    }),
    userNotAuthenticated: Em.ViewState.create({
    view: Ember.View.extend({})
    })
    })

    contentStates = Ember.StateManager.create({
    rootElement: '#content-area',
    books: Em.ViewState.create({
    view: Ember.View.extend({})
    }),
    music: Em.ViewState.create({
    view: Ember.View.extend({})
    })
    })


    If you prefer to start with an empty body and manage state programmatically you
    can also take advantage of StateManager's `rootView` property and the ability of 
    `Ember.ContainerView`s to manually manage their child views. 


    dashboard = Ember.ContainerView.create({
    childViews: ['navigationAreaView', 'contentAreaView'],
    navigationAreaView: Ember.ContainerView.create({}),
    contentAreaView: Ember.ContainerView.create({})
    })

    navigationStates = Ember.StateManager.create({
    rootView: dashboard.get('navigationAreaView'),
    userAuthenticated: Em.ViewState.create({
    view: Ember.View.extend({})
    }),
    userNotAuthenticated: Em.ViewState.create({
    view: Ember.View.extend({})
    })
    })

    contentStates = Ember.StateManager.create({
    rootView: dashboard.get('contentAreaView'),
    books: Em.ViewState.create({
    view: Ember.View.extend({})
    }),
    music: Em.ViewState.create({
    view: Ember.View.extend({})
    })
    })

    dashboard.appendTo('body')

    ## User Manipulation of State via `{{action}}` Helpers
    The Handlebars `{{action}}` helper is StateManager-aware and will use StateManager action sending 
    to connect user interaction to action-based state transitions.

    Given the following body and handlebars template

    <body>
    <script type='text/x-handlebars'>
    <a href="#" {{action "anAction" target="App.appStates"}}> Go </a>
    </script>
    </body>

    And application code

    App = Ember.Application.create()
    App.appStates = Ember.StateManager.create({
    initialState: 'aState',
    aState: Ember.State.create({
    anAction: function(manager, context){}
    }),
    bState: Ember.State.create({})
    })

    A user initiated click or touch event on "Go" will trigger the 'anAction' method of
    `App.appStates.aState` with `App.appStates` as the first argument and a
    `jQuery.Event` object as the second object. The `jQuery.Event` will include a property
    `view` that references the `Ember.View` object that was interacted with.
  
    **/
    Ember.StateManager.reopen(
    /** @scope Ember.StateManager.prototype */{

    /**
    If the current state is a view state or the descendent of a view state,
    this property will be the view associated with it. If there is no
    view state active in this state manager, this value will be null.

    @property
    */
    currentView: Ember.computed(function () {
        var currentState = get(this, 'currentState'),
        view;

        while (currentState) {
            if (get(currentState, 'isViewState')) {
                view = get(currentState, 'view');
                if (view) { return view; }
            }

            currentState = get(currentState, 'parentState');
        }

        return null;
    }).property('currentState').cacheable()

});

})();



(function () {
    var get = Ember.get, set = Ember.set;

    Ember.ViewState = Ember.State.extend({
        isViewState: true,

        enter: function (stateManager) {
            var view = get(this, 'view'), root, childViews;

            if (view) {
                if (Ember.View.detect(view)) {
                    view = view.create();
                    set(this, 'view', view);
                }

                Ember.assert('view must be an Ember.View', view instanceof Ember.View);

                root = stateManager.get('rootView');

                if (root) {
                    childViews = get(root, 'childViews');
                    childViews.pushObject(view);
                } else {
                    root = stateManager.get('rootElement') || 'body';
                    view.appendTo(root);
                }
            }
        },

        exit: function (stateManager) {
            var view = get(this, 'view');

            if (view) {
                // If the view has a parent view, then it is
                // part of a view hierarchy and should be removed
                // from its parent.
                if (get(view, 'parentView')) {
                    view.removeFromParent();
                } else {

                    // Otherwise, the view is a "root view" and
                    // was appended directly to the DOM.
                    view.remove();
                }
            }
        }
    });

})();



(function () {
    // ==========================================================================
    // Project:  Ember Statecharts
    // Copyright: 漏2011 Living Social Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();

(function () {
    // ==========================================================================
    // Project:   metamorph
    // Copyright: 漏2011 My Company Inc. All rights reserved.
    // ==========================================================================

    (function (window) {

        var K = function () { },
      guid = 0,
      document = window.document,

        // Feature-detect the W3C range API, the extended check is for IE9 which only partially supports ranges
      supportsRange = ('createRange' in document) && (typeof Range !== 'undefined') && Range.prototype.createContextualFragment,

        // Internet Explorer prior to 9 does not allow setting innerHTML if the first element
        // is a "zero-scope" element. This problem can be worked around by making
        // the first node an invisible text node. We, like Modernizr, use &shy;
      needsShy = (function () {
          var testEl = document.createElement('div');
          testEl.innerHTML = "<div></div>";
          testEl.firstChild.innerHTML = "<script></script>";
          return testEl.firstChild.innerHTML === '';
      })();

        // Constructor that supports either Metamorph('foo') or new
        // Metamorph('foo');
        //
        // Takes a string of HTML as the argument.

        var Metamorph = function (html) {
            var self;

            if (this instanceof Metamorph) {
                self = this;
            } else {
                self = new K();
            }

            self.innerHTML = html;
            var myGuid = 'metamorph-' + (guid++);
            self.start = myGuid + '-start';
            self.end = myGuid + '-end';

            return self;
        };

        K.prototype = Metamorph.prototype;

        var rangeFor, htmlFunc, removeFunc, outerHTMLFunc, appendToFunc, afterFunc, prependFunc, startTagFunc, endTagFunc;

        outerHTMLFunc = function () {
            return this.startTag() + this.innerHTML + this.endTag();
        };

        startTagFunc = function () {
            return "<script id='" + this.start + "' type='text/x-placeholder'></script>";
        };

        endTagFunc = function () {
            return "<script id='" + this.end + "' type='text/x-placeholder'></script>";
        };

        // If we have the W3C range API, this process is relatively straight forward.
        if (supportsRange) {

            // Get a range for the current morph. Optionally include the starting and
            // ending placeholders.
            rangeFor = function (morph, outerToo) {
                var range = document.createRange();
                var before = document.getElementById(morph.start);
                var after = document.getElementById(morph.end);

                if (outerToo) {
                    range.setStartBefore(before);
                    range.setEndAfter(after);
                } else {
                    range.setStartAfter(before);
                    range.setEndBefore(after);
                }

                return range;
            };

            htmlFunc = function (html, outerToo) {
                // get a range for the current metamorph object
                var range = rangeFor(this, outerToo);

                // delete the contents of the range, which will be the
                // nodes between the starting and ending placeholder.
                range.deleteContents();

                // create a new document fragment for the HTML
                var fragment = range.createContextualFragment(html);

                // insert the fragment into the range
                range.insertNode(fragment);
            };

            removeFunc = function () {
                // get a range for the current metamorph object including
                // the starting and ending placeholders.
                var range = rangeFor(this, true);

                // delete the entire range.
                range.deleteContents();
            };

            appendToFunc = function (node) {
                var range = document.createRange();
                range.setStart(node);
                range.collapse(false);
                var frag = range.createContextualFragment(this.outerHTML());
                node.appendChild(frag);
            };

            afterFunc = function (html) {
                var range = document.createRange();
                var after = document.getElementById(this.end);

                range.setStartAfter(after);
                range.setEndAfter(after);

                var fragment = range.createContextualFragment(html);
                range.insertNode(fragment);
            };

            prependFunc = function (html) {
                var range = document.createRange();
                var start = document.getElementById(this.start);

                range.setStartAfter(start);
                range.setEndAfter(start);

                var fragment = range.createContextualFragment(html);
                range.insertNode(fragment);
            };

        } else {
            /**
            * This code is mostly taken from jQuery, with one exception. In jQuery's case, we
            * have some HTML and we need to figure out how to convert it into some nodes.
            *
            * In this case, jQuery needs to scan the HTML looking for an opening tag and use
            * that as the key for the wrap map. In our case, we know the parent node, and
            * can use its type as the key for the wrap map.
            **/
            var wrapMap = {
                select: [1, "<select multiple='multiple'>", "</select>"],
                fieldset: [1, "<fieldset>", "</fieldset>"],
                table: [1, "<table>", "</table>"],
                tbody: [2, "<table><tbody>", "</tbody></table>"],
                tr: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                colgroup: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                map: [1, "<map>", "</map>"],
                _default: [0, "", ""]
            };

            /**
            * Given a parent node and some HTML, generate a set of nodes. Return the first
            * node, which will allow us to traverse the rest using nextSibling.
            *
            * We need to do this because innerHTML in IE does not really parse the nodes.
            **/
            var firstNodeFor = function (parentNode, html) {
                var arr = wrapMap[parentNode.tagName.toLowerCase()] || wrapMap._default;
                var depth = arr[0], start = arr[1], end = arr[2];

                if (needsShy) { html = '&shy;' + html; }

                var element = document.createElement('div');
                element.innerHTML = start + html + end;

                for (var i = 0; i <= depth; i++) {
                    element = element.firstChild;
                }

                // Look for &shy; to remove it.
                if (needsShy) {
                    var shyElement = element;

                    // Sometimes we get nameless elements with the shy inside
                    while (shyElement.nodeType === 1 && !shyElement.nodeName) {
                        shyElement = shyElement.firstChild;
                    }

                    // At this point it's the actual unicode character.
                    if (shyElement.nodeType === 3 && shyElement.nodeValue.charAt(0) === "\u00AD") {
                        shyElement.nodeValue = shyElement.nodeValue.slice(1);
                    }
                }

                return element;
            };

            /**
            * In some cases, Internet Explorer can create an anonymous node in
            * the hierarchy with no tagName. You can create this scenario via:
            *
            *     div = document.createElement("div");
            *     div.innerHTML = "<table>&shy<script></script><tr><td>hi</td></tr></table>";
            *     div.firstChild.firstChild.tagName //=> ""
            *
            * If our script markers are inside such a node, we need to find that
            * node and use *it* as the marker.
            **/
            var realNode = function (start) {
                while (start.parentNode.tagName === "") {
                    start = start.parentNode;
                }

                return start;
            };

            /**
            * When automatically adding a tbody, Internet Explorer inserts the
            * tbody immediately before the first <tr>. Other browsers create it
            * before the first node, no matter what.
            *
            * This means the the following code:
            *
            *     div = document.createElement("div");
            *     div.innerHTML = "<table><script id='first'></script><tr><td>hi</td></tr><script id='last'></script></table>
            *
            * Generates the following DOM in IE:
            *
            *     + div
            *       + table
            *         - script id='first'
            *         + tbody
            *           + tr
            *             + td
            *               - "hi"
            *           - script id='last'
            *
            * Which means that the two script tags, even though they were
            * inserted at the same point in the hierarchy in the original
            * HTML, now have different parents.
            *
            * This code reparents the first script tag by making it the tbody's
            * first child.
            **/
            var fixParentage = function (start, end) {
                if (start.parentNode !== end.parentNode) {
                    end.parentNode.insertBefore(start, end.parentNode.firstChild);
                }
            };

            htmlFunc = function (html, outerToo) {
                // get the real starting node. see realNode for details.
                var start = realNode(document.getElementById(this.start));
                var end = document.getElementById(this.end);
                var parentNode = end.parentNode;
                var node, nextSibling, last;

                // make sure that the start and end nodes share the same
                // parent. If not, fix it.
                fixParentage(start, end);

                // remove all of the nodes after the starting placeholder and
                // before the ending placeholder.
                node = start.nextSibling;
                while (node) {
                    nextSibling = node.nextSibling;
                    last = node === end;

                    // if this is the last node, and we want to remove it as well,
                    // set the `end` node to the next sibling. This is because
                    // for the rest of the function, we insert the new nodes
                    // before the end (note that insertBefore(node, null) is
                    // the same as appendChild(node)).
                    //
                    // if we do not want to remove it, just break.
                    if (last) {
                        if (outerToo) { end = node.nextSibling; } else { break; }
                    }

                    node.parentNode.removeChild(node);

                    // if this is the last node and we didn't break before
                    // (because we wanted to remove the outer nodes), break
                    // now.
                    if (last) { break; }

                    node = nextSibling;
                }

                // get the first node for the HTML string, even in cases like
                // tables and lists where a simple innerHTML on a div would
                // swallow some of the content.
                node = firstNodeFor(start.parentNode, html);

                // copy the nodes for the HTML between the starting and ending
                // placeholder.
                while (node) {
                    nextSibling = node.nextSibling;
                    parentNode.insertBefore(node, end);
                    node = nextSibling;
                }
            };

            // remove the nodes in the DOM representing this metamorph.
            //
            // this includes the starting and ending placeholders.
            removeFunc = function () {
                var start = realNode(document.getElementById(this.start));
                var end = document.getElementById(this.end);

                this.html('');
                start.parentNode.removeChild(start);
                end.parentNode.removeChild(end);
            };

            appendToFunc = function (parentNode) {
                var node = firstNodeFor(parentNode, this.outerHTML());

                while (node) {
                    nextSibling = node.nextSibling;
                    parentNode.appendChild(node);
                    node = nextSibling;
                }
            };

            afterFunc = function (html) {
                // get the real starting node. see realNode for details.
                var end = document.getElementById(this.end);
                var insertBefore = end.nextSibling;
                var parentNode = end.parentNode;
                var nextSibling;
                var node;

                // get the first node for the HTML string, even in cases like
                // tables and lists where a simple innerHTML on a div would
                // swallow some of the content.
                node = firstNodeFor(parentNode, html);

                // copy the nodes for the HTML between the starting and ending
                // placeholder.
                while (node) {
                    nextSibling = node.nextSibling;
                    parentNode.insertBefore(node, insertBefore);
                    node = nextSibling;
                }
            };

            prependFunc = function (html) {
                var start = document.getElementById(this.start);
                var parentNode = start.parentNode;
                var nextSibling;
                var node;

                node = firstNodeFor(parentNode, html);
                var insertBefore = start.nextSibling;

                while (node) {
                    nextSibling = node.nextSibling;
                    parentNode.insertBefore(node, insertBefore);
                    node = nextSibling;
                }
            }
        }

        Metamorph.prototype.html = function (html) {
            this.checkRemoved();
            if (html === undefined) { return this.innerHTML; }

            htmlFunc.call(this, html);

            this.innerHTML = html;
        };

        Metamorph.prototype.replaceWith = function (html) {
            this.checkRemoved();
            htmlFunc.call(this, html, true);
        };

        Metamorph.prototype.remove = removeFunc;
        Metamorph.prototype.outerHTML = outerHTMLFunc;
        Metamorph.prototype.appendTo = appendToFunc;
        Metamorph.prototype.after = afterFunc;
        Metamorph.prototype.prepend = prependFunc;
        Metamorph.prototype.startTag = startTagFunc;
        Metamorph.prototype.endTag = endTagFunc;

        Metamorph.prototype.isRemoved = function () {
            var before = document.getElementById(this.start);
            var after = document.getElementById(this.end);

            return !before || !after;
        };

        Metamorph.prototype.checkRemoved = function () {
            if (this.isRemoved()) {
                throw new Error("Cannot perform operations on a Metamorph that is not in the DOM.");
            }
        };

        window.Metamorph = Metamorph;
    })(this);


})();

(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Handlebars */
    /**
    @namespace
    @name Handlebars
    @private
    */

    /**
    @namespace
    @name Handlebars.helpers
    @description Helpers for Handlebars templates
    */

    /**
    @class

    Prepares the Handlebars templating library for use inside Ember's view
    system.

    The Ember.Handlebars object is the standard Handlebars library, extended to use
    Ember's get() method instead of direct property access, which allows
    computed properties to be used inside templates.

    To create an Ember.Handlebars template, call Ember.Handlebars.compile().  This will
    return a function that can be used by Ember.View for rendering.
    */
    Ember.Handlebars = Ember.create(Handlebars);

    Ember.Handlebars.helpers = Ember.create(Handlebars.helpers);

    /**
    Override the the opcode compiler and JavaScript compiler for Handlebars.
    */
    Ember.Handlebars.Compiler = function () { };
    Ember.Handlebars.Compiler.prototype = Ember.create(Handlebars.Compiler.prototype);
    Ember.Handlebars.Compiler.prototype.compiler = Ember.Handlebars.Compiler;

    Ember.Handlebars.JavaScriptCompiler = function () { };
    Ember.Handlebars.JavaScriptCompiler.prototype = Ember.create(Handlebars.JavaScriptCompiler.prototype);
    Ember.Handlebars.JavaScriptCompiler.prototype.compiler = Ember.Handlebars.JavaScriptCompiler;
    Ember.Handlebars.JavaScriptCompiler.prototype.namespace = "Ember.Handlebars";


    Ember.Handlebars.JavaScriptCompiler.prototype.initializeBuffer = function () {
        return "''";
    };

    /**
    Override the default buffer for Ember Handlebars. By default, Handlebars creates
    an empty String at the beginning of each invocation and appends to it. Ember's
    Handlebars overrides this to append to a single shared buffer.

    @private
    */
    Ember.Handlebars.JavaScriptCompiler.prototype.appendToBuffer = function (string) {
        return "data.buffer.push(" + string + ");";
    };

    /**
    Rewrite simple mustaches from {{foo}} to {{bind "foo"}}. This means that all simple
    mustaches in Ember's Handlebars will also set up an observer to keep the DOM
    up to date when the underlying property changes.

    @private
    */
    Ember.Handlebars.Compiler.prototype.mustache = function (mustache) {
        if (mustache.params.length || mustache.hash) {
            return Handlebars.Compiler.prototype.mustache.call(this, mustache);
        } else {
            var id = new Handlebars.AST.IdNode(['_triageMustache']);

            // Update the mustache node to include a hash value indicating whether the original node
            // was escaped. This will allow us to properly escape values when the underlying value
            // changes and we need to re-render the value.
            if (mustache.escaped) {
                mustache.hash = mustache.hash || new Handlebars.AST.HashNode([]);
                mustache.hash.pairs.push(["escaped", new Handlebars.AST.StringNode("true")]);
            }
            mustache = new Handlebars.AST.MustacheNode([id].concat([mustache.id]), mustache.hash, !mustache.escaped);
            return Handlebars.Compiler.prototype.mustache.call(this, mustache);
        }
    };

    /**
    Used for precompilation of Ember Handlebars templates. This will not be used during normal
    app execution.

    @param {String} string The template to precompile
    */
    Ember.Handlebars.precompile = function (string) {
        var ast = Handlebars.parse(string);
        var options = { data: true, stringParams: true };
        var environment = new Ember.Handlebars.Compiler().compile(ast, options);
        return new Ember.Handlebars.JavaScriptCompiler().compile(environment, options, undefined, true);
    };

    /**
    The entry point for Ember Handlebars. This replaces the default Handlebars.compile and turns on
    template-local data and String parameters.

    @param {String} string The template to compile
    */
    Ember.Handlebars.compile = function (string) {
        var ast = Handlebars.parse(string);
        var options = { data: true, stringParams: true };
        var environment = new Ember.Handlebars.Compiler().compile(ast, options);
        var templateSpec = new Ember.Handlebars.JavaScriptCompiler().compile(environment, options, undefined, true);

        return Handlebars.template(templateSpec);
    };

    /**
    If a path starts with a reserved keyword, returns the root
    that should be used.

    @private
    */
    var normalizePath = Ember.Handlebars.normalizePath = function (root, path, data) {
        var keywords = (data && data.keywords) || {},
      keyword, isKeyword;

        // Get the first segment of the path. For example, if the
        // path is "foo.bar.baz", returns "foo".
        keyword = path.split('.', 1)[0];

        // Test to see if the first path is a keyword that has been
        // passed along in the view's data hash. If so, we will treat
        // that object as the new root.
        if (keywords.hasOwnProperty(keyword)) {
            // Look up the value in the template's data hash.
            root = keywords[keyword];
            isKeyword = true;

            // Handle cases where the entire path is the reserved
            // word. In that case, return the object itself.
            if (path === keyword) {
                path = '';
            } else {
                // Strip the keyword from the path and look up
                // the remainder from the newly found root.
                path = path.substr(keyword.length);
            }
        }

        return { root: root, path: path, isKeyword: isKeyword };
    };
    /**
    Lookup both on root and on window. If the path starts with
    a keyword, the corresponding object will be looked up in the
    template's data hash and used to resolve the path.

    @param {Object} root The object to look up the property on
    @param {String} path The path to be lookedup
    @param {Object} options The template's option hash
    */

    Ember.Handlebars.getPath = function (root, path, options) {
        var data = options && options.data,
      normalizedPath = normalizePath(root, path, data),
      value;

        // In cases where the path begins with a keyword, change the
        // root to the value represented by that keyword, and ensure
        // the path is relative to it.
        root = normalizedPath.root;
        path = normalizedPath.path;

        value = Ember.getPath(root, path);

        if (value === undefined && root !== window && Ember.isGlobalPath(path)) {
            value = Ember.getPath(window, path);
        }
        return value;
    };

    /**
    Registers a helper in Handlebars that will be called if no property with the
    given name can be found on the current context object, and no helper with
    that name is registered.

    This throws an exception with a more helpful error message so the user can
    track down where the problem is happening.

    @name Handlebars.helpers.helperMissing
    @param {String} path
    @param {Hash} options
    */
    Ember.Handlebars.registerHelper('helperMissing', function (path, options) {
        var error, view = "";

        error = "%@ Handlebars error: Could not find property '%@' on object %@.";
        if (options.data) {
            view = options.data.view;
        }
        throw new Ember.Error(Ember.String.fmt(error, [view, path, this]));
    });


})();



(function () {

    Ember.String.htmlSafe = function (str) {
        return new Handlebars.SafeString(str);
    };

    var htmlSafe = Ember.String.htmlSafe;

    if (Ember.EXTEND_PROTOTYPES) {

        /**
        @see Ember.String.htmlSafe
        */
        String.prototype.htmlSafe = function () {
            return htmlSafe(this);
        };

    }

})();



(function () {
    /*jshint newcap:false*/
    var set = Ember.set, get = Ember.get, getPath = Ember.getPath;

    var DOMManager = {
        remove: function (view) {
            var morph = view.morph;
            if (morph.isRemoved()) { return; }
            set(view, 'element', null);
            view._lastInsert = null;
            morph.remove();
        },

        prepend: function (view, childView) {
            childView._insertElementLater(function () {
                var morph = view.morph;
                morph.prepend(childView.outerHTML);
                childView.outerHTML = null;
            });
        },

        after: function (view, nextView) {
            nextView._insertElementLater(function () {
                var morph = view.morph;
                morph.after(nextView.outerHTML);
                nextView.outerHTML = null;
            });
        },

        replace: function (view) {
            var morph = view.morph;

            view.transitionTo('preRender');
            view.clearRenderedChildren();
            var buffer = view.renderToBuffer();

            Ember.run.schedule('render', this, function () {
                if (get(view, 'isDestroyed')) { return; }
                view.invalidateRecursively('element');
                view._notifyWillInsertElement();
                morph.replaceWith(buffer.string());
                view.transitionTo('inDOM');
                view._notifyDidInsertElement();
            });
        },

        empty: function (view) {
            view.morph.html("");
        }
    };

    // The `morph` and `outerHTML` properties are internal only
    // and not observable.

    Ember._Metamorph = Ember.Mixin.create({
        isVirtual: true,
        tagName: '',

        init: function () {
            this._super();
            this.morph = Metamorph();
        },

        beforeRender: function (buffer) {
            buffer.push(this.morph.startTag());
        },

        afterRender: function (buffer) {
            buffer.push(this.morph.endTag());
        },

        createElement: function () {
            var buffer = this.renderToBuffer();
            this.outerHTML = buffer.string();
            this.clearBuffer();
        },

        domManager: DOMManager
    });

    Ember._MetamorphView = Ember.View.extend(Ember._Metamorph);


})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Handlebars */

    var get = Ember.get, set = Ember.set, getPath = Ember.Handlebars.getPath;
    /**
    @ignore
    @private
    @class

    Ember._HandlebarsBoundView is a private view created by the Handlebars `{{bind}}`
    helpers that is used to keep track of bound properties.

    Every time a property is bound using a `{{mustache}}`, an anonymous subclass
    of Ember._HandlebarsBoundView is created with the appropriate sub-template and
    context set up. When the associated property changes, just the template for
    this view will re-render.
    */
    Ember._HandlebarsBoundView = Ember._MetamorphView.extend({
        /** @scope Ember._HandlebarsBoundView.prototype */

        /**
        The function used to determine if the `displayTemplate` or
        `inverseTemplate` should be rendered. This should be a function that takes
        a value and returns a Boolean.

        @type Function
        @default null
        */
        shouldDisplayFunc: null,

        /**
        Whether the template rendered by this view gets passed the context object
        of its parent template, or gets passed the value of retrieving `path`
        from the `pathRoot`.

        For example, this is true when using the `{{#if}}` helper, because the
        template inside the helper should look up properties relative to the same
        object as outside the block. This would be false when used with `{{#with
        foo}}` because the template should receive the object found by evaluating
        `foo`.

        @type Boolean
        @default false
        */
        preserveContext: false,

        /**
        If `preserveContext` is true, this is the object that will be used
        to render the template.

        @type Object
        */
        previousContext: null,

        /**
        The template to render when `shouldDisplayFunc` evaluates to true.

        @type Function
        @default null
        */
        displayTemplate: null,

        /**
        The template to render when `shouldDisplayFunc` evaluates to false.

        @type Function
        @default null
        */
        inverseTemplate: null,


        /**
        The path to look up on `pathRoot` that is passed to
        `shouldDisplayFunc` to determine which template to render.

        In addition, if `preserveContext` is false, the object at this path will
        be passed to the template when rendering.

        @type String
        @default null
        */
        path: null,

        /**
        The object from which the `path` will be looked up. Sometimes this is the
        same as the `previousContext`, but in cases where this view has been generated
        for paths that start with a keyword such as `view` or `controller`, the
        path root will be that resolved object.

        @type Object
        */
        pathRoot: null,

        normalizedValue: Ember.computed(function () {
            var path = get(this, 'path'),
        pathRoot = get(this, 'pathRoot'),
        valueNormalizer = get(this, 'valueNormalizerFunc'),
        result, templateData;

            // Use the pathRoot as the result if no path is provided. This
            // happens if the path is `this`, which gets normalized into
            // a `pathRoot` of the current Handlebars context and a path
            // of `''`.
            if (path === '') {
                result = pathRoot;
            } else {
                templateData = get(this, 'templateData');
                result = getPath(pathRoot, path, { data: templateData });
            }

            return valueNormalizer ? valueNormalizer(result) : result;
        }).property('path', 'pathRoot', 'valueNormalizerFunc').volatile(),

        rerenderIfNeeded: function () {
            if (!get(this, 'isDestroyed') && get(this, 'normalizedValue') !== this._lastNormalizedValue) {
                this.rerender();
            }
        },

        /**
        Determines which template to invoke, sets up the correct state based on
        that logic, then invokes the default Ember.View `render` implementation.

        This method will first look up the `path` key on `pathRoot`,
        then pass that value to the `shouldDisplayFunc` function. If that returns
        true, the `displayTemplate` function will be rendered to DOM. Otherwise,
        `inverseTemplate`, if specified, will be rendered.

        For example, if this Ember._BindableSpan represented the {{#with foo}}
        helper, it would look up the `foo` property of its context, and
        `shouldDisplayFunc` would always return true. The object found by looking
        up `foo` would be passed to `displayTemplate`.

        @param {Ember.RenderBuffer} buffer
        */
        render: function (buffer) {
            // If not invoked via a triple-mustache ({{{foo}}}), escape
            // the content of the template.
            var escape = get(this, 'isEscaped');

            var shouldDisplay = get(this, 'shouldDisplayFunc'),
        preserveContext = get(this, 'preserveContext'),
        context = get(this, 'previousContext');

            var inverseTemplate = get(this, 'inverseTemplate'),
        displayTemplate = get(this, 'displayTemplate');

            var result = get(this, 'normalizedValue');
            this._lastNormalizedValue = result;

            // First, test the conditional to see if we should
            // render the template or not.
            if (shouldDisplay(result)) {
                set(this, 'template', displayTemplate);

                // If we are preserving the context (for example, if this
                // is an #if block, call the template with the same object.
                if (preserveContext) {
                    set(this, '_templateContext', context);
                } else {
                    // Otherwise, determine if this is a block bind or not.
                    // If so, pass the specified object to the template
                    if (displayTemplate) {
                        set(this, '_templateContext', result);
                    } else {
                        // This is not a bind block, just push the result of the
                        // expression to the render context and return.
                        if (result === null || result === undefined) {
                            result = "";
                        } else if (!(result instanceof Handlebars.SafeString)) {
                            result = String(result);
                        }

                        if (escape) { result = Handlebars.Utils.escapeExpression(result); }
                        buffer.push(result);
                        return;
                    }
                }
            } else if (inverseTemplate) {
                set(this, 'template', inverseTemplate);

                if (preserveContext) {
                    set(this, '_templateContext', context);
                } else {
                    set(this, '_templateContext', result);
                }
            } else {
                set(this, 'template', function () { return ''; });
            }

            return this._super(buffer);
        }
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set, fmt = Ember.String.fmt;
    var getPath = Ember.Handlebars.getPath, normalizePath = Ember.Handlebars.normalizePath;
    var forEach = Ember.ArrayUtils.forEach;

    var EmberHandlebars = Ember.Handlebars, helpers = EmberHandlebars.helpers;

    // Binds a property into the DOM. This will create a hook in DOM that the
    // KVO system will look for and update if the property changes.
    /** @private */
    var bind = function (property, options, preserveContext, shouldDisplay, valueNormalizer) {
        var data = options.data,
      fn = options.fn,
      inverse = options.inverse,
      view = data.view,
      currentContext = this,
      pathRoot, path, normalized;

        normalized = normalizePath(currentContext, property, data);

        pathRoot = normalized.root;
        path = normalized.path;

        // Set up observers for observable objects
        if ('object' === typeof this) {
            // Create the view that will wrap the output of this template/property
            // and add it to the nearest view's childViews array.
            // See the documentation of Ember._HandlebarsBoundView for more.
            var bindView = view.createChildView(Ember._HandlebarsBoundView, {
                preserveContext: preserveContext,
                shouldDisplayFunc: shouldDisplay,
                valueNormalizerFunc: valueNormalizer,
                displayTemplate: fn,
                inverseTemplate: inverse,
                path: path,
                pathRoot: pathRoot,
                previousContext: currentContext,
                isEscaped: options.hash.escaped,
                templateData: options.data
            });

            view.appendChild(bindView);

            /** @private */
            var observer = function () {
                Ember.run.once(bindView, 'rerenderIfNeeded');
            };

            // Observes the given property on the context and
            // tells the Ember._BindableSpan to re-render. If property
            // is an empty string, we are printing the current context
            // object ({{this}}) so updating it is not our responsibility.
            if (path !== '') {
                Ember.addObserver(pathRoot, path, observer);
            }
        } else {
            // The object is not observable, so just render it out and
            // be done with it.
            data.buffer.push(getPath(pathRoot, path, options));
        }
    };

    /**
    '_triageMustache' is used internally select between a binding and helper for
    the given context. Until this point, it would be hard to determine if the
    mustache is a property reference or a regular helper reference. This triage
    helper resolves that.

    This would not be typically invoked by directly.

    @private
    @name Handlebars.helpers._triageMustache
    @param {String} property Property/helperID to triage
    @param {Function} fn Context to provide for rendering
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('_triageMustache', function (property, fn) {
        Ember.assert("You cannot pass more than one argument to the _triageMustache helper", arguments.length <= 2);
        if (helpers[property]) {
            return helpers[property].call(this, fn);
        }
        else {
            return helpers.bind.apply(this, arguments);
        }
    });

    /**
    `bind` can be used to display a value, then update that value if it
    changes. For example, if you wanted to print the `title` property of
    `content`:

    {{bind "content.title"}}

    This will return the `title` property as a string, then create a new
    observer at the specified path. If it changes, it will update the value in
    DOM. Note that if you need to support IE7 and IE8 you must modify the
    model objects properties using Ember.get() and Ember.set() for this to work as
    it relies on Ember's KVO system.  For all other browsers this will be handled
    for you automatically.

    @private
    @name Handlebars.helpers.bind
    @param {String} property Property to bind
    @param {Function} fn Context to provide for rendering
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('bind', function (property, fn) {
        Ember.assert("You cannot pass more than one argument to the bind helper", arguments.length <= 2);

        var context = (fn.contexts && fn.contexts[0]) || this;

        return bind.call(context, property, fn, false, function (result) {
            return !Ember.none(result);
        });
    });

    /**
    Use the `boundIf` helper to create a conditional that re-evaluates
    whenever the bound value changes.

    {{#boundIf "content.shouldDisplayTitle"}}
    {{content.title}}
    {{/boundIf}}

    @private
    @name Handlebars.helpers.boundIf
    @param {String} property Property to bind
    @param {Function} fn Context to provide for rendering
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('boundIf', function (property, fn) {
        var context = (fn.contexts && fn.contexts[0]) || this;
        var func = function (result) {
            if (Ember.typeOf(result) === 'array') {
                return get(result, 'length') !== 0;
            } else {
                return !!result;
            }
        };

        return bind.call(context, property, fn, true, func, func);
    });

    /**
    @name Handlebars.helpers.with
    @param {Function} context
    @param {Hash} options
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('with', function (context, options) {
        if (arguments.length === 4) {
            var keywordName, path;

            Ember.assert("If you pass more than one argument to the with helper, it must be in the form #with foo as bar", arguments[1] === "as");
            options = arguments[3];
            keywordName = arguments[2];
            path = arguments[0];

            Ember.assert("You must pass a block to the with helper", options.fn && options.fn !== Handlebars.VM.noop);

            // This is a workaround for the fact that you cannot bind separate objects
            // together. When we implement that functionality, we should use it here.
            var contextKey = Ember.$.expando + Ember.guidFor(this);
            options.data.keywords[contextKey] = this;
            Ember.bind(options.data.keywords, keywordName, contextKey + '.' + path);

            return bind.call(this, path, options.fn, true, function (result) {
                return !Ember.none(result);
            });
        } else {
            Ember.assert("You must pass exactly one argument to the with helper", arguments.length === 2);
            Ember.assert("You must pass a block to the with helper", options.fn && options.fn !== Handlebars.VM.noop);
            return helpers.bind.call(options.contexts[0], context, options);
        }
    });


    /**
    @name Handlebars.helpers.if
    @param {Function} context
    @param {Hash} options
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('if', function (context, options) {
        Ember.assert("You must pass exactly one argument to the if helper", arguments.length === 2);
        Ember.assert("You must pass a block to the if helper", options.fn && options.fn !== Handlebars.VM.noop);

        return helpers.boundIf.call(options.contexts[0], context, options);
    });

    /**
    @name Handlebars.helpers.unless
    @param {Function} context
    @param {Hash} options
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('unless', function (context, options) {
        Ember.assert("You must pass exactly one argument to the unless helper", arguments.length === 2);
        Ember.assert("You must pass a block to the unless helper", options.fn && options.fn !== Handlebars.VM.noop);

        var fn = options.fn, inverse = options.inverse;

        options.fn = inverse;
        options.inverse = fn;

        return helpers.boundIf.call(options.contexts[0], context, options);
    });

    /**
    `bindAttr` allows you to create a binding between DOM element attributes and
    Ember objects. For example:

    <img {{bindAttr src="imageUrl" alt="imageTitle"}}>

    @name Handlebars.helpers.bindAttr
    @param {Hash} options
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('bindAttr', function (options) {

        var attrs = options.hash;

        Ember.assert("You must specify at least one hash argument to bindAttr", !!Ember.keys(attrs).length);

        var view = options.data.view;
        var ret = [];
        var ctx = this;

        // Generate a unique id for this element. This will be added as a
        // data attribute to the element so it can be looked up when
        // the bound property changes.
        var dataId = ++Ember.$.uuid;

        // Handle classes differently, as we can bind multiple classes
        var classBindings = attrs['class'];
        if (classBindings !== null && classBindings !== undefined) {
            var classResults = EmberHandlebars.bindClasses(this, classBindings, view, dataId, options);
            ret.push('class="' + Handlebars.Utils.escapeExpression(classResults.join(' ')) + '"');
            delete attrs['class'];
        }

        var attrKeys = Ember.keys(attrs);

        // For each attribute passed, create an observer and emit the
        // current value of the property as an attribute.
        forEach(attrKeys, function (attr) {
            var path = attrs[attr],
        pathRoot, normalized;

            Ember.assert(fmt("You must provide a String for a bound attribute, not %@", [path]), typeof path === 'string');

            normalized = normalizePath(ctx, path, options.data);

            pathRoot = normalized.root;
            path = normalized.path;

            var value = (path === 'this') ? pathRoot : getPath(pathRoot, path, options),
        type = Ember.typeOf(value);

            Ember.assert(fmt("Attributes must be numbers, strings or booleans, not %@", [value]), value === null || value === undefined || type === 'number' || type === 'string' || type === 'boolean');

            var observer, invoker;

            /** @private */
            observer = function observer() {
                var result = getPath(pathRoot, path, options);

                Ember.assert(fmt("Attributes must be numbers, strings or booleans, not %@", [result]), result === null || result === undefined || typeof result === 'number' || typeof result === 'string' || typeof result === 'boolean');

                var elem = view.$("[data-bindattr-" + dataId + "='" + dataId + "']");

                // If we aren't able to find the element, it means the element
                // to which we were bound has been removed from the view.
                // In that case, we can assume the template has been re-rendered
                // and we need to clean up the observer.
                if (elem.length === 0) {
                    Ember.removeObserver(pathRoot, path, invoker);
                    return;
                }

                Ember.View.applyAttributeBindings(elem, attr, result);
            };

            /** @private */
            invoker = function () {
                Ember.run.once(observer);
            };

            // Add an observer to the view for when the property changes.
            // When the observer fires, find the element using the
            // unique data id and update the attribute to the new value.
            if (path !== 'this') {
                Ember.addObserver(pathRoot, path, invoker);
            }

            // if this changes, also change the logic in ember-views/lib/views/view.js
            if ((type === 'string' || (type === 'number' && !isNaN(value)))) {
                ret.push(attr + '="' + Handlebars.Utils.escapeExpression(value) + '"');
            } else if (value && type === 'boolean') {
                // The developer controls the attr name, so it should always be safe
                ret.push(attr + '="' + attr + '"');
            }
        }, this);

        // Add the unique identifier
        // NOTE: We use all lower-case since Firefox has problems with mixed case in SVG
        ret.push('data-bindattr-' + dataId + '="' + dataId + '"');
        return new EmberHandlebars.SafeString(ret.join(' '));
    });

    /**
    Helper that, given a space-separated string of property paths and a context,
    returns an array of class names. Calling this method also has the side
    effect of setting up observers at those property paths, such that if they
    change, the correct class name will be reapplied to the DOM element.

    For example, if you pass the string "fooBar", it will first look up the
    "fooBar" value of the context. If that value is true, it will add the
    "foo-bar" class to the current element (i.e., the dasherized form of
    "fooBar"). If the value is a string, it will add that string as the class.
    Otherwise, it will not add any new class name.

    @param {Ember.Object} context
    The context from which to lookup properties

    @param {String} classBindings
    A string, space-separated, of class bindings to use

    @param {Ember.View} view
    The view in which observers should look for the element to update

    @param {Srting} bindAttrId
    Optional bindAttr id used to lookup elements

    @returns {Array} An array of class names to add
    */
    EmberHandlebars.bindClasses = function (context, classBindings, view, bindAttrId, options) {
        var ret = [], newClass, value, elem;

        // Helper method to retrieve the property from the context and
        // determine which class string to return, based on whether it is
        // a Boolean or not.
        var classStringForPath = function (root, path, className, options) {
            var val = path !== '' ? getPath(root, path, options) : true;

            // If the value is truthy and we're using the colon syntax,
            // we should return the className directly
            if (!!val && className) {
                return className;

                // If value is a Boolean and true, return the dasherized property
                // name.
            } else if (val === true) {
                // Normalize property path to be suitable for use
                // as a class name. For exaple, content.foo.barBaz
                // becomes bar-baz.
                var parts = path.split('.');
                return Ember.String.dasherize(parts[parts.length - 1]);

                // If the value is not false, undefined, or null, return the current
                // value of the property.
            } else if (val !== false && val !== undefined && val !== null) {
                return val;

                // Nothing to display. Return null so that the old class is removed
                // but no new class is added.
            } else {
                return null;
            }
        };

        // For each property passed, loop through and setup
        // an observer.
        forEach(classBindings.split(' '), function (binding) {

            // Variable in which the old class value is saved. The observer function
            // closes over this variable, so it knows which string to remove when
            // the property changes.
            var oldClass;

            var observer, invoker;

            var split = binding.split(':'),
        path = split[0],
        className = split[1],
        pathRoot = context,
        normalized;

            if (path !== '') {
                normalized = normalizePath(context, path, options.data);

                pathRoot = normalized.root;
                path = normalized.path;
            }

            // Set up an observer on the context. If the property changes, toggle the
            // class name.
            /** @private */
            observer = function () {
                // Get the current value of the property
                newClass = classStringForPath(pathRoot, path, className, options);
                elem = bindAttrId ? view.$("[data-bindattr-" + bindAttrId + "='" + bindAttrId + "']") : view.$();

                // If we can't find the element anymore, a parent template has been
                // re-rendered and we've been nuked. Remove the observer.
                if (elem.length === 0) {
                    Ember.removeObserver(pathRoot, path, invoker);
                } else {
                    // If we had previously added a class to the element, remove it.
                    if (oldClass) {
                        elem.removeClass(oldClass);
                    }

                    // If necessary, add a new class. Make sure we keep track of it so
                    // it can be removed in the future.
                    if (newClass) {
                        elem.addClass(newClass);
                        oldClass = newClass;
                    } else {
                        oldClass = null;
                    }
                }
            };

            /** @private */
            invoker = function () {
                Ember.run.once(observer);
            };

            if (path !== '') {
                Ember.addObserver(pathRoot, path, invoker);
            }

            // We've already setup the observer; now we just need to figure out the
            // correct behavior right now on the first pass through.
            value = classStringForPath(pathRoot, path, className, options);

            if (value) {
                ret.push(value);

                // Make sure we save the current value so that it can be removed if the
                // observer fires.
                oldClass = value;
            }
        });

        return ret;
    };


})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Handlebars */

    // TODO: Don't require the entire module
    var get = Ember.get, set = Ember.set;
    var indexOf = Ember.ArrayUtils.indexOf;
    var PARENT_VIEW_PATH = /^parentView\./;
    var EmberHandlebars = Ember.Handlebars;

    /** @private */
    EmberHandlebars.ViewHelper = Ember.Object.create({

        viewClassFromHTMLOptions: function (viewClass, options, thisContext) {
            var hash = options.hash, data = options.data;
            var extensions = {},
        classes = hash['class'],
        dup = false;

            if (hash.id) {
                extensions.elementId = hash.id;
                dup = true;
            }

            if (classes) {
                classes = classes.split(' ');
                extensions.classNames = classes;
                dup = true;
            }

            if (hash.classBinding) {
                extensions.classNameBindings = hash.classBinding.split(' ');
                dup = true;
            }

            if (hash.classNameBindings) {
                extensions.classNameBindings = hash.classNameBindings.split(' ');
                dup = true;
            }

            if (hash.attributeBindings) {
                Ember.assert("Setting 'attributeBindings' via Handlebars is not allowed. Please subclass Ember.View and set it there instead.");
                extensions.attributeBindings = null;
                dup = true;
            }

            if (dup) {
                hash = Ember.$.extend({}, hash);
                delete hash.id;
                delete hash['class'];
                delete hash.classBinding;
            }

            // Look for bindings passed to the helper and, if they are
            // local, make them relative to the current context instead of the
            // view.
            var path, normalized;

            for (var prop in hash) {
                if (!hash.hasOwnProperty(prop)) { continue; }

                // Test if the property ends in "Binding"
                if (Ember.IS_BINDING.test(prop)) {
                    path = hash[prop];

                    normalized = Ember.Handlebars.normalizePath(null, path, data);
                    if (normalized.isKeyword) {
                        hash[prop] = 'templateData.keywords.' + path;
                    } else if (!Ember.isGlobalPath(path)) {
                        if (path === 'this') {
                            hash[prop] = 'bindingContext';
                        } else {
                            hash[prop] = 'bindingContext.' + path;
                        }
                    }
                }
            }

            // Make the current template context available to the view
            // for the bindings set up above.
            extensions.bindingContext = thisContext;

            return viewClass.extend(hash, extensions);
        },

        helper: function (thisContext, path, options) {
            var inverse = options.inverse,
        data = options.data,
        view = data.view,
        fn = options.fn,
        hash = options.hash,
        newView;

            if ('string' === typeof path) {
                newView = EmberHandlebars.getPath(thisContext, path, options);
                Ember.assert("Unable to find view at path '" + path + "'", !!newView);
            } else {
                newView = path;
            }

            Ember.assert(Ember.String.fmt('You must pass a view class to the #view helper, not %@ (%@)', [path, newView]), Ember.View.detect(newView));

            newView = this.viewClassFromHTMLOptions(newView, options, thisContext);
            var currentView = data.view;
            var viewOptions = {
                templateData: options.data
            };

            if (fn) {
                Ember.assert("You cannot provide a template block if you also specified a templateName", !get(viewOptions, 'templateName') && !get(newView.proto(), 'templateName'));
                viewOptions.template = fn;
            }

            currentView.appendChild(newView, viewOptions);
        }
    });

    /**
    `{{view}}` inserts a new instance of `Ember.View` into a template passing its options
    to the `Ember.View`'s `create` method and using the supplied block as the view's own template.

    An empty `<body>` and the following template:

    <script type="text/x-handlebars">
    A span:
    {{#view tagName="span"}}
    hello.
    {{/view}}
    </script>

    Will result in HTML structure:

    <body>
    <!-- Note: the handlebars template script 
    also results in a rendered Ember.View
    which is the outer <div> here -->

    <div class="ember-view">
    A span:
    <span id="ember1" class="ember-view">
    Hello.
    </span>
    </div>
    </body>

    ### parentView setting

    The `parentView` property of the new `Ember.View` instance created through `{{view}}`
    will be set to the `Ember.View` instance of the template where `{{view}}` was called.

    aView = Ember.View.create({
    template: Ember.Handlebars.compile("{{#view}} my parent: {{parentView.elementId}} {{/view}}")
    })

    aView.appendTo('body')
    
    Will result in HTML structure:

    <div id="ember1" class="ember-view">
    <div id="ember2" class="ember-view">
    my parent: ember1
    </div>
    </div>

    ### Setting CSS id and class attributes

    The HTML `id` attribute can be set on the `{{view}}`'s resulting element with the `id` option.
    This option will _not_ be passed to `Ember.View.create`.

    <script type="text/x-handlebars">
    {{#view tagName="span" id="a-custom-id"}}
    hello.
    {{/view}}
    </script>

    Results in the following HTML structure:

    <div class="ember-view">
    <span id="a-custom-id" class="ember-view">
    hello.
    </span>
    </div>

    The HTML `class` attribute can be set on the `{{view}}`'s resulting element with
    the `class` or `classNameBindings` options. The `class` option
    will directly set the CSS `class` attribute and will not be passed to
    `Ember.View.create`. `classNameBindings` will be passed to `create` and use
    `Ember.View`'s class name binding functionality:

    <script type="text/x-handlebars">
    {{#view tagName="span" class="a-custom-class"}}
    hello.
    {{/view}}
    </script>

    Results in the following HTML structure:

    <div class="ember-view">
    <span id="ember2" class="ember-view a-custom-class">
    hello.
    </span>
    </div>

    ### Supplying a different view class
    `{{view}}` can take an optional first argument before its supplied options to specify a
    path to a custom view class.

    <script type="text/x-handlebars">
    {{#view "MyApp.CustomView"}}
    hello.
    {{/view}}
    </script>

    The first argument can also be a relative path. Ember will search for the view class
    starting at the `Ember.View` of the template where `{{view}}` was used as the root object:

    MyApp = Ember.Application.create({})
    MyApp.OuterView = Ember.View.extend({
    innerViewClass: Ember.View.extend({
    classNames: ['a-custom-view-class-as-property']
    }),
    template: Ember.Handlebars.compile('{{#view "innerViewClass"}} hi {{/view}}')
    })

    MyApp.OuterView.create().appendTo('body')

    Will result in the following HTML:

    <div id="ember1" class="ember-view">
    <div id="ember2" class="ember-view a-custom-view-class-as-property"> 
    hi
    </div>
    </div>

    ### Blockless use

    If you supply a custom `Ember.View` subclass that specifies its own template
    or provide a `templateName` option to `{{view}}` it can be used without supplying a block.
    Attempts to use both a `templateName` option and supply a block will throw an error.

    <script type="text/x-handlebars">
    {{view "MyApp.ViewWithATemplateDefined"}}
    </script>

    ### viewName property

    You can supply a `viewName` option to `{{view}}`. The `Ember.View` instance will
    be referenced as a property of its parent view by this name.

    aView = Ember.View.create({
    template: Ember.Handlebars.compile('{{#view viewName="aChildByName"}} hi {{/view}}')
    })

    aView.appendTo('body')
    aView.get('aChildByName') // the instance of Ember.View created by {{view}} helper

    @name Handlebars.helpers.view
    @param {String} path
    @param {Hash} options
    @returns {String} HTML string
    */
    EmberHandlebars.registerHelper('view', function (path, options) {
        Ember.assert("The view helper only takes a single argument", arguments.length <= 2);

        // If no path is provided, treat path param as options.
        if (path && path.data && path.data.isRenderData) {
            options = path;
            path = "Ember.View";
        }

        return EmberHandlebars.ViewHelper.helper(this, path, options);
    });


})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Handlebars */

    // TODO: Don't require all of this module
    var get = Ember.get, getPath = Ember.Handlebars.getPath, fmt = Ember.String.fmt;

    /**
    `{{collection}}` is a `Ember.Handlebars` helper for adding instances of
    `Ember.CollectionView` to a template.  See `Ember.CollectionView` for additional
    information on how a `CollectionView` functions.

    `{{collection}}`'s primary use is as a block helper with a `contentBinding` option
    pointing towards an `Ember.Array`-compatible object.  An `Ember.View` instance will
    be created for each item in its `content` property. Each view will have its own
    `content` property set to the appropriate item in the collection.

    The provided block will be applied as the template for each item's view.

    Given an empty `<body>` the following template:

    <script type="text/x-handlebars">
    {{#collection contentBinding="App.items"}}
    Hi {{content.name}}
    {{/collection}}
    </script>

    And the following application code

    App = Ember.Application.create()
    App.items = [
    Ember.Object.create({name: 'Dave'}),
    Ember.Object.create({name: 'Mary'}),
    Ember.Object.create({name: 'Sara'})
    ]

    Will result in the HTML structure below

    <div class="ember-view">
    <div class="ember-view">Hi Dave</div>
    <div class="ember-view">Hi Mary</div>
    <div class="ember-view">Hi Sara</div>
    </div>

    ### Blockless Use
    If you provide an `itemViewClass` option that has its own `template` you can omit
    the block.

    The following template:

    <script type="text/x-handlebars">
    {{collection contentBinding="App.items" itemViewClass="App.AnItemView"}}
    </script>

    And application code

    App = Ember.Application.create()
    App.items = [
    Ember.Object.create({name: 'Dave'}),
    Ember.Object.create({name: 'Mary'}),
    Ember.Object.create({name: 'Sara'})
    ]

    App.AnItemView = Ember.View.extend({
    template: Ember.Handlebars.compile("Greetings {{content.name}}")
    })

    Will result in the HTML structure below

    <div class="ember-view">
    <div class="ember-view">Greetings Dave</div>
    <div class="ember-view">Greetings Mary</div>
    <div class="ember-view">Greetings Sara</div>
    </div>

    ### Specifying a CollectionView subclass
    By default the `{{collection}}` helper will create an instance of `Ember.CollectionView`.
    You can supply a `Ember.CollectionView` subclass to the helper by passing it
    as the first argument:

    <script type="text/x-handlebars">
    {{#collection App.MyCustomCollectionClass contentBinding="App.items"}}
    Hi {{content.name}}
    {{/collection}}
    </script>


    ### Forwarded `item.*`-named Options
    As with the `{{view}}`, helper options passed to the `{{collection}}` will be set on
    the resulting `Ember.CollectionView` as properties. Additionally, options prefixed with
    `item` will be applied to the views rendered for each item (note the camelcasing):

    <script type="text/x-handlebars">
    {{#collection contentBinding="App.items"
    itemTagName="p"
    itemClassNames="greeting"}}
    Howdy {{content.name}}
    {{/collection}}
    </script>

    Will result in the following HTML structure:

    <div class="ember-view">
    <p class="ember-view greeting">Howdy Dave</p>
    <p class="ember-view greeting">Howdy Mary</p>
    <p class="ember-view greeting">Howdy Sara</p>
    </div>
  
    @name Handlebars.helpers.collection
    @param {String} path
    @param {Hash} options
    @returns {String} HTML string
    */
    Ember.Handlebars.registerHelper('collection', function (path, options) {
        // If no path is provided, treat path param as options.
        if (path && path.data && path.data.isRenderData) {
            options = path;
            path = undefined;
            Ember.assert("You cannot pass more than one argument to the collection helper", arguments.length === 1);
        } else {
            Ember.assert("You cannot pass more than one argument to the collection helper", arguments.length === 2);
        }

        var fn = options.fn;
        var data = options.data;
        var inverse = options.inverse;

        // If passed a path string, convert that into an object.
        // Otherwise, just default to the standard class.
        var collectionClass;
        collectionClass = path ? getPath(this, path, options) : Ember.CollectionView;
        Ember.assert(fmt("%@ #collection: Could not find %@", data.view, path), !!collectionClass);

        var hash = options.hash, itemHash = {}, match;

        // Extract item view class if provided else default to the standard class
        var itemViewClass, itemViewPath = hash.itemViewClass;
        var collectionPrototype = collectionClass.proto();
        delete hash.itemViewClass;
        itemViewClass = itemViewPath ? getPath(collectionPrototype, itemViewPath, options) : collectionPrototype.itemViewClass;
        Ember.assert(fmt("%@ #collection: Could not find %@", data.view, itemViewPath), !!itemViewClass);

        // Go through options passed to the {{collection}} helper and extract options
        // that configure item views instead of the collection itself.
        for (var prop in hash) {
            if (hash.hasOwnProperty(prop)) {
                match = prop.match(/^item(.)(.*)$/);

                if (match) {
                    // Convert itemShouldFoo -> shouldFoo
                    itemHash[match[1].toLowerCase() + match[2]] = hash[prop];
                    // Delete from hash as this will end up getting passed to the
                    // {{view}} helper method.
                    delete hash[prop];
                }
            }
        }

        var tagName = hash.tagName || collectionPrototype.tagName;

        if (fn) {
            itemHash.template = fn;
            delete options.fn;
        }

        if (inverse && inverse !== Handlebars.VM.noop) {
            var emptyViewClass = get(collectionPrototype, 'emptyViewClass');

            hash.emptyView = emptyViewClass.extend({
                template: inverse,
                tagName: itemHash.tagName
            });
        }

        if (hash.eachHelper === 'each') {
            itemHash._templateContext = Ember.computed(function () {
                return get(this, 'content');
            }).property('content');
            delete hash.eachHelper;
        }

        hash.itemViewClass = Ember.Handlebars.ViewHelper.viewClassFromHTMLOptions(itemViewClass, { data: data, hash: itemHash }, this);

        return Ember.Handlebars.helpers.view.call(this, collectionClass, options);
    });




})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Handlebars */
    var getPath = Ember.Handlebars.getPath;

    /**
    `unbound` allows you to output a property without binding. *Important:* The
    output will not be updated if the property changes. Use with caution.

    <div>{{unbound somePropertyThatDoesntChange}}</div>

    @name Handlebars.helpers.unbound
    @param {String} property
    @returns {String} HTML string
    */
    Ember.Handlebars.registerHelper('unbound', function (property, fn) {
        var context = (fn.contexts && fn.contexts[0]) || this;
        return getPath(context, property, fn);
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

    /*jshint debug:true*/
    var getPath = Ember.getPath;

    /**
    `log` allows you to output the value of a value in the current rendering
    context.

    {{log myVariable}}

    @name Handlebars.helpers.log
    @param {String} property
    */
    Ember.Handlebars.registerHelper('log', function (property, fn) {
        var context = (fn.contexts && fn.contexts[0]) || this;
        Ember.Logger.log(getPath(context, property));
    });

    /**
    The `debugger` helper executes the `debugger` statement in the current
    context.

    {{debugger}}

    @name Handlebars.helpers.debugger
    @param {String} property
    */
    Ember.Handlebars.registerHelper('debugger', function () {
        debugger;
    });

})();



(function () {
    var get = Ember.get, set = Ember.set;

    Ember.Handlebars.EachView = Ember.CollectionView.extend(Ember._Metamorph, {
        itemViewClass: Ember._MetamorphView,
        emptyViewClass: Ember._MetamorphView,

        createChildView: function (view, attrs) {
            view = this._super(view, attrs);

            // At the moment, if a container view subclass wants
            // to insert keywords, it is responsible for cloning
            // the keywords hash. This will be fixed momentarily.
            var keyword = get(this, 'keyword');

            if (keyword) {
                var data = get(view, 'templateData');

                data = Ember.copy(data);
                data.keywords = view.cloneKeywords();
                set(view, 'templateData', data);

                var content = get(view, 'content');

                // In this case, we do not bind, because the `content` of
                // a #each item cannot change.
                data.keywords[keyword] = content;
            }

            return view;
        }
    });

    Ember.Handlebars.registerHelper('each', function (path, options) {
        if (arguments.length === 4) {
            Ember.assert("If you pass more than one argument to the each helper, it must be in the form #each foo in bar", arguments[1] === "in");

            var keywordName = arguments[0];

            options = arguments[3];
            path = arguments[2];

            options.hash.keyword = keywordName;
        } else {
            options.hash.eachHelper = 'each';
        }

        Ember.assert("You must pass a block to the each helper", options.fn && options.fn !== Handlebars.VM.noop);

        options.hash.contentBinding = path;
        // Set up emptyView as a metamorph with no tag
        //options.hash.emptyViewClass = Ember._MetamorphView;

        return Ember.Handlebars.helpers.collection.call(this, 'Ember.Handlebars.EachView', options);
    });

})();



(function () {
    /**
    `template` allows you to render a template from inside another template.
    This allows you to re-use the same template in multiple places. For example:

    <script type="text/x-handlebars">
    {{#with loggedInUser}}
    Last Login: {{lastLogin}}
    User Info: {{template "user_info"}}
    {{/with}}
    </script>

    <script type="text/x-handlebars" data-template-name="user_info">
    Name: <em>{{name}}</em>
    Karma: <em>{{karma}}</em>
    </script>

    This helper looks for templates in the global Ember.TEMPLATES hash. If you
    add &lt;script&gt; tags to your page with the `data-template-name` attribute set,
    they will be compiled and placed in this hash automatically.

    You can also manually register templates by adding them to the hash:

    Ember.TEMPLATES["my_cool_template"] = Ember.Handlebars.compile('<b>{{user}}</b>');

    @name Handlebars.helpers.template
    @param {String} templateName the template to render
    */

    Ember.Handlebars.registerHelper('template', function (name, options) {
        var template = Ember.TEMPLATES[name];

        Ember.assert("Unable to find template with name '" + name + "'.", !!template);

        Ember.TEMPLATES[name](this, { data: options.data });
    });

})();



(function () {
    var EmberHandlebars = Ember.Handlebars, getPath = EmberHandlebars.getPath, get = Ember.get;

    var ActionHelper = EmberHandlebars.ActionHelper = {
        registeredActions: {}
    };

    ActionHelper.registerAction = function (actionName, eventName, target, view, context) {
        var actionId = (++Ember.$.uuid).toString();

        ActionHelper.registeredActions[actionId] = {
            eventName: eventName,
            handler: function (event) {
                event.view = view;
                event.context = context;

                // Check for StateManager (or compatible object)
                if (target.isState && typeof target.send === 'function') {
                    return target.send(actionName, event);
                } else {
                    return target[actionName].call(target, event);
                }
            }
        };

        view.on('willRerender', function () {
            delete ActionHelper.registeredActions[actionId];
        });

        return actionId;
    };

    /**
    The `{{action}}` helper registers an HTML element within a template for
    DOM event handling.  User interaction with that element will call the method
    on the template's associated `Ember.View` instance that has the same name
    as the first provided argument to `{{action}}`:

    Given the following Handlebars template on the page

    <script type="text/x-handlebars" data-template-name='a-template'>
    <div {{action "anActionName"}}>
    click me
    </div>
    </script>

    And application code

    AView = Ember.View.extend({
    templateName; 'a-template',
    anActionName: function(event){}
    })

    aView = AView.create()
    aView.appendTo('body')

    Will results in the following rendered HTML

    <div class="ember-view">
    <div data-ember-action="1">
    click me
    </div>
    </div>

    Clicking "click me" will trigger the `anActionName` method of the `aView` object with a 
    `jQuery.Event` object as its argument. The `jQuery.Event` object will be extended to include
    a `view` property that is set to the original view interacted with (in this case the `aView` object).


    ### Specifying an Action Target
    A `target` option can be provided to change which object will receive the method call. This option must be
    a string representing a path to an object:

    <script type="text/x-handlebars" data-template-name='a-template'>
    <div {{action "anActionName" target="MyApplication.someObject"}}>
    click me
    </div>
    </script>

    Clicking "click me" in the rendered HTML of the above template will trigger the 
    `anActionName` method of the object at `MyApplication.someObject`.  The first argument 
    to this method will be a `jQuery.Event` extended to include a `view` property that is 
    set to the original view interacted with.

    A path relative to the template's `Ember.View` instance can also be used as a target:

    <script type="text/x-handlebars" data-template-name='a-template'>
    <div {{action "anActionName" target="parentView"}}>
    click me
    </div>
    </script>

    Clicking "click me" in the rendered HTML of the above template will trigger the 
    `anActionName` method of the view's parent view.

    The `{{action}}` helper is `Ember.StateManager` aware. If the target of
    the action is an `Ember.StateManager` instance `{{action}}` will use the `send`
    functionality of StateManagers. The documentation for `Ember.StateManager` has additional
    information about this use.

    If an action's target does not implement a method that matches the supplied action name
    an error will be thrown.

    <script type="text/x-handlebars" data-template-name='a-template'>
    <div {{action "aMethodNameThatIsMissing"}}>
    click me
    </div>
    </script>

    With the following application code

    AView = Ember.View.extend({
    templateName; 'a-template',
    // note: no method 'aMethodNameThatIsMissing'
    anActionName: function(event){}
    })

    aView = AView.create()
    aView.appendTo('body')

    Will throw `Uncaught TypeError: Cannot call method 'call' of undefined` when "click me" is clicked.


    ### Specifying DOM event type
    By default the `{{action}}` helper registers for DOM `click` events. You can supply an
    `on` option to the helper to specify a different DOM event name:

    <script type="text/x-handlebars" data-template-name='a-template'>
    <div {{action "aMethodNameThatIsMissing" on="doubleClick"}}>
    click me
    </div>
    </script>

    See `Ember.EventDispatcher` for a list of acceptable DOM event names.

    Because `{{action}}` depends on Ember's event dispatch system it will only function if
    an `Ember.EventDispatcher` instance is available. An `Ember.EventDispatcher` instance 
    will be created when a new `Ember.Application` is created. Having an instance of
    `Ember.Application` will satisfy this requirement.

    ### Specifying a context
    By default the `{{action}}` helper passes the current Handlebars context along in the
    `jQuery.Event` object. You may specify an alternative object to pass as the context by
    providing a property path:

    <script type="text/x-handlebars" data-template-name='a-template'>
    {{#each person in people}}
    <div {{action "edit" context="person"}}>
    click me
    </div>
    {{/each}}
    </script>

    @name Handlebars.helpers.action
    @param {String} actionName
    @param {Hash} options
    */
    EmberHandlebars.registerHelper('action', function (actionName, options) {
        var hash = options.hash || {},
      eventName = hash.on || "click",
      view = options.data.view,
      target, context, controller;

        if (view.isVirtual) { view = view.get('parentView'); }

        if (hash.target) {
            target = getPath(this, hash.target, options);
        } else if (controller = options.data.keywords.controller) {
            target = get(controller, 'target');
        }

        target = target || view;

        context = hash.context ? getPath(this, hash.context, options) : options.contexts[0];

        var actionId = ActionHelper.registerAction(actionName, eventName, target, view, context);
        return new EmberHandlebars.SafeString('data-ember-action="' + actionId + '"');
    });

})();



(function () {
    var get = Ember.get, set = Ember.set;

    /**

    When used in a Handlebars template that is assigned to an `Ember.View` instance's
    `layout` property Ember will render the layout template first, inserting the view's
    own rendered output at the `{{ yield }}` location.

    An empty `<body>` and the following application code:

    AView = Ember.View.extend({
    classNames: ['a-view-with-layout'],
    layout: Ember.Handlebars.compile('<div class="wrapper">{{ yield }}</div>'),
    template: Ember.Handlebars.compile('<span>I am wrapped</span>')
    })

    aView = AView.create()
    aView.appendTo('body')

    Will result in the following HTML output:

    <body>
    <div class='ember-view a-view-with-layout'>
    <div class="wrapper">
    <span>I am wrapped</span>
    </div>
    </div>
    </body>

    The yield helper cannot be used outside of a template assigned to an `Ember.View`'s `layout` property
    and will throw an error if attempted.

    BView = Ember.View.extend({
    classNames: ['a-view-with-layout'],
    template: Ember.Handlebars.compile('{{yield}}')
    })

    bView = BView.create()
    bView.appendTo('body')

    // throws
    // Uncaught Error: assertion failed: You called yield in a template that was not a layout

    @name Handlebars.helpers.yield
    @param {Hash} options
    @returns {String} HTML string
    */
    Ember.Handlebars.registerHelper('yield', function (options) {
        var view = options.data.view, template;

        while (view && !get(view, 'layout')) {
            view = get(view, 'parentView');
        }

        Ember.assert("You called yield in a template that was not a layout", !!view);

        template = get(view, 'template');

        if (template) { template(this, options); }
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var set = Ember.set, get = Ember.get;

    /**
    @class

    Creates an HTML input view in one of two formats.

    If a `title` property or binding is provided the input will be wrapped in
    a `div` and `label` tag. View properties like `classNames` will be applied to
    the outermost `div`. This behavior is deprecated and will issue a warning in development.


    {{view Ember.Checkbox classNames="applicaton-specific-checkbox" title="Some title"}}


    <div id="ember1" class="ember-view ember-checkbox applicaton-specific-checkbox">
    <label><input type="checkbox" />Some title</label>
    </div>

    If `title` isn't provided the view will render as an input element of the 'checkbox' type and HTML
    related properties will be applied directly to the input.

    {{view Ember.Checkbox classNames="applicaton-specific-checkbox"}}

    <input id="ember1" class="ember-view ember-checkbox applicaton-specific-checkbox" type="checkbox">

    You can add a `label` tag yourself in the template where the Ember.Checkbox is being used.

    <label>
    Some Title
    {{view Ember.Checkbox classNames="applicaton-specific-checkbox"}}
    </label>


    The `checked` attribute of an Ember.Checkbox object should always be set
    through the Ember object or by interacting with its rendered element representation
    via the mouse, keyboard, or touch.  Updating the value of the checkbox via jQuery will
    result in the checked value of the object and its element losing synchronization.

    */
    Ember.Checkbox = Ember.View.extend({
        classNames: ['ember-checkbox'],

        tagName: 'input',

        attributeBindings: ['type', 'checked', 'disabled'],

        type: "checkbox",
        checked: false,
        disabled: false,

        /** @deprecated */
        title: null,

        value: Ember.computed(function (propName, value) {
            Ember.deprecate("Ember.Checkbox's 'value' property has been renamed to 'checked' to match the html element attribute name");
            if (value !== undefined) {
                return set(this, 'checked', value);
            } else {
                return get(this, 'checked');
            }
        }).property('checked').volatile(),

        change: function () {
            Ember.run.once(this, this._updateElementValue);
            // returning false will cause IE to not change checkbox state
        },

        /**
        @private
        */
        _updateElementValue: function () {
            var input = get(this, 'title') ? this.$('input:checkbox') : this.$();
            set(this, 'checked', input.prop('checked'));
        },

        init: function () {
            if (get(this, 'title') || get(this, 'titleBinding')) {
                Ember.deprecate("Automatically surrounding Ember.Checkbox inputs with a label by providing a 'title' property is deprecated");
                this.tagName = undefined;
                this.attributeBindings = [];
                this.defaultTemplate = Ember.Handlebars.compile('<label><input type="checkbox" {{bindAttr checked="checked" disabled="disabled"}}>{{title}}</label>');
            }

            this._super();
        }
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    /** @class */
    Ember.TextSupport = Ember.Mixin.create(
    /** @scope Ember.TextSupport.prototype */{

    value: "",

    attributeBindings: ['placeholder', 'disabled', 'maxlength'],
    placeholder: null,
    disabled: false,
    maxlength: null,

    insertNewline: Ember.K,
    cancel: Ember.K,

    focusOut: function (event) {
        this._elementValueDidChange();
    },

    change: function (event) {
        this._elementValueDidChange();
    },

    keyUp: function (event) {
        this.interpretKeyEvents(event);
    },

    /**
    @private
    */
    interpretKeyEvents: function (event) {
        var map = Ember.TextSupport.KEY_EVENTS;
        var method = map[event.keyCode];

        this._elementValueDidChange();
        if (method) { return this[method](event); }
    },

    _elementValueDidChange: function () {
        set(this, 'value', this.$().val());
    }

});

Ember.TextSupport.KEY_EVENTS = {
    13: 'insertNewline',
    27: 'cancel'
};

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    /**
    @class

    The `Ember.TextField` view class renders a text
    [input](https://developer.mozilla.org/en/HTML/Element/Input) element. It
    allows for binding Ember properties to the text field contents (`value`),
    live-updating as the user inputs text.

    Example:

    {{view Ember.TextField valueBinding="firstName"}}

    @extends Ember.TextSupport
    */
    Ember.TextField = Ember.View.extend(Ember.TextSupport,
    /** @scope Ember.TextField.prototype */{

    classNames: ['ember-text-field'],
    tagName: "input",
    attributeBindings: ['type', 'value', 'size'],

    /**
    The value attribute of the input element. As the user inputs text, this
    property is updated live.

    @type String
    @default ""
    */
    value: "",

    /**
    The type attribute of the input element.

    @type String
    @default "text"
    */
    type: "text",

    /**
    The size of the text field in characters.

    @type String
    @default null
    */
    size: null
});

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    Ember.Button = Ember.View.extend(Ember.TargetActionSupport, {
        classNames: ['ember-button'],
        classNameBindings: ['isActive'],

        tagName: 'button',

        propagateEvents: false,

        attributeBindings: ['type', 'disabled', 'href'],

        /** @private
        Overrides TargetActionSupport's targetObject computed
        property to use Handlebars-specific path resolution.
        */
        targetObject: Ember.computed(function () {
            var target = get(this, 'target'),
        root = get(this, 'templateContext'),
        data = get(this, 'templateData');

            if (typeof target !== 'string') { return target; }

            return Ember.Handlebars.getPath(root, target, { data: data });
        }).property('target').cacheable(),

        // Defaults to 'button' if tagName is 'input' or 'button'
        type: Ember.computed(function (key, value) {
            var tagName = this.get('tagName');
            if (value !== undefined) { this._type = value; }
            if (this._type !== undefined) { return this._type; }
            if (tagName === 'input' || tagName === 'button') { return 'button'; }
        }).property('tagName').cacheable(),

        disabled: false,

        // Allow 'a' tags to act like buttons
        href: Ember.computed(function () {
            return this.get('tagName') === 'a' ? '#' : null;
        }).property('tagName').cacheable(),

        mouseDown: function () {
            if (!get(this, 'disabled')) {
                set(this, 'isActive', true);
                this._mouseDown = true;
                this._mouseEntered = true;
            }
            return get(this, 'propagateEvents');
        },

        mouseLeave: function () {
            if (this._mouseDown) {
                set(this, 'isActive', false);
                this._mouseEntered = false;
            }
        },

        mouseEnter: function () {
            if (this._mouseDown) {
                set(this, 'isActive', true);
                this._mouseEntered = true;
            }
        },

        mouseUp: function (event) {
            if (get(this, 'isActive')) {
                // Actually invoke the button's target and action.
                // This method comes from the Ember.TargetActionSupport mixin.
                this.triggerAction();
                set(this, 'isActive', false);
            }

            this._mouseDown = false;
            this._mouseEntered = false;
            return get(this, 'propagateEvents');
        },

        keyDown: function (event) {
            // Handle space or enter
            if (event.keyCode === 13 || event.keyCode === 32) {
                this.mouseDown();
            }
        },

        keyUp: function (event) {
            // Handle space or enter
            if (event.keyCode === 13 || event.keyCode === 32) {
                this.mouseUp();
            }
        },

        // TODO: Handle proper touch behavior.  Including should make inactive when
        // finger moves more than 20x outside of the edge of the button (vs mouse
        // which goes inactive as soon as mouse goes out of edges.)

        touchStart: function (touch) {
            return this.mouseDown(touch);
        },

        touchEnd: function (touch) {
            return this.mouseUp(touch);
        },

        init: function () {
            Ember.deprecate("Ember.Button is deprecated and will be removed from future releases. Consider using the `{{action}}` helper.");
            this._super();
        }
    });

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    var get = Ember.get, set = Ember.set;

    /**
    @class
    @extends Ember.TextSupport
    */
    Ember.TextArea = Ember.View.extend(Ember.TextSupport,
    /** @scope Ember.TextArea.prototype */{

    classNames: ['ember-text-area'],

    tagName: "textarea",
    attributeBindings: ['rows', 'cols'],
    rows: null,
    cols: null,

    _updateElementValue: Ember.observer(function () {
        this.$().val(get(this, 'value'));
    }, 'value'),

    init: function () {
        this._super();
        this.on("didInsertElement", this, this._updateElementValue);
    }

});

})();



(function () {
    Ember.TabContainerView = Ember.View.extend();

})();



(function () {
    var get = Ember.get, getPath = Ember.getPath;

    Ember.TabPaneView = Ember.View.extend({
        tabsContainer: Ember.computed(function () {
            return this.nearestInstanceOf(Ember.TabContainerView);
        }).property().volatile(),

        isVisible: Ember.computed(function () {
            return get(this, 'viewName') === getPath(this, 'tabsContainer.currentView');
        }).property('tabsContainer.currentView').volatile()
    });

})();



(function () {
    var get = Ember.get, setPath = Ember.setPath;

    Ember.TabView = Ember.View.extend({
        tabsContainer: Ember.computed(function () {
            return this.nearestInstanceOf(Ember.TabContainerView);
        }).property().volatile(),

        mouseUp: function () {
            setPath(this, 'tabsContainer.currentView', get(this, 'value'));
        }
    });

})();



(function () {

})();



(function () {
    /*jshint eqeqeq:false */

    var set = Ember.set, get = Ember.get, getPath = Ember.getPath;
    var indexOf = Ember.ArrayUtils.indexOf, indexesOf = Ember.ArrayUtils.indexesOf;

    /**
    @class

    The Ember.Select view class renders a
    [select](https://developer.mozilla.org/en/HTML/Element/select) HTML element,
    allowing the user to choose from a list of options. The selected option(s)
    are updated live in the `selection` property.

    @extends Ember.View
    */
    Ember.Select = Ember.View.extend(
    /** @scope Ember.Select.prototype */{

    tagName: 'select',
    defaultTemplate: Ember.Handlebars.compile('{{#if view.prompt}}<option>{{view.prompt}}</option>{{/if}}{{#each view.content}}{{view Ember.SelectOption contentBinding="this"}}{{/each}}'),
    attributeBindings: ['multiple'],

    /**
    The `multiple` attribute of the select element. Indicates whether multiple
    options can be selected.

    @type Boolean
    @default false
    */
    multiple: false,

    /**
    The list of options.

    If `optionLabelPath` and `optionValuePath` are not overridden, this should
    be a list of strings, which will serve simultaneously as labels and values.

    Otherwise, this should be a list of objects. For instance:

    content: Ember.A([
    { id: 1, firstName: 'Yehuda' },
    { id: 2, firstName: 'Tom' }
    ])),
    optionLabelPath: 'content.firstName',
    optionValuePath: 'content.id'

    @type Array
    @default null
    */
    content: null,

    /**
    When `multiple` is false, the element of `content` that is currently
    selected, if any.

    When `multiple` is true, an array of such elements.

    @type Object or Array
    @default null
    */
    selection: null,

    /**
    If given, a top-most dummy option will be rendered to serve as a user
    prompt.

    @type String
    @default null
    */
    prompt: null,

    /**
    The path of the option labels. See `content`.

    @type String
    @default 'content'
    */
    optionLabelPath: 'content',

    /**
    The path of the option values. See `content`.

    @type String
    @default 'content'
    */
    optionValuePath: 'content',

    change: function () {
        if (get(this, 'multiple')) {
            this._changeMultiple();
        } else {
            this._changeSingle();
        }
    },

    selectionDidChange: Ember.observer(function () {
        var selection = get(this, 'selection'),
        isArray = Ember.isArray(selection);
        if (get(this, 'multiple')) {
            if (!isArray) {
                set(this, 'selection', Ember.A([selection]));
                return;
            }
            this._selectionDidChangeMultiple();
        } else {
            this._selectionDidChangeSingle();
        }
    }, 'selection'),

    _triggerChange: function () {
        var selection = get(this, 'selection');

        if (selection) { this.selectionDidChange(); }

        this.change();
    },

    _changeSingle: function () {
        var selectedIndex = this.$()[0].selectedIndex,
        content = get(this, 'content'),
        prompt = get(this, 'prompt');

        if (!content) { return; }
        if (prompt && selectedIndex === 0) { set(this, 'selection', null); return; }

        if (prompt) { selectedIndex -= 1; }
        set(this, 'selection', content.objectAt(selectedIndex));
    },

    _changeMultiple: function () {
        var options = this.$('option:selected'),
        prompt = get(this, 'prompt'),
        offset = prompt ? 1 : 0,
        content = get(this, 'content');

        if (!content) { return; }
        if (options) {
            var selectedIndexes = options.map(function () {
                return this.index - offset;
            }).toArray();
            set(this, 'selection', content.objectsAt(selectedIndexes));
        }
    },

    _selectionDidChangeSingle: function () {
        var el = this.$()[0],
        content = get(this, 'content'),
        selection = get(this, 'selection'),
        selectionIndex = content ? indexOf(content, selection) : -1,
        prompt = get(this, 'prompt');

        if (prompt && selectionIndex > -1) { selectionIndex += 1; }
        if (el) { el.selectedIndex = selectionIndex; }
    },

    _selectionDidChangeMultiple: function () {
        var content = get(this, 'content'),
        selection = get(this, 'selection'),
        selectedIndexes = content ? indexesOf(content, selection) : [-1],
        prompt = get(this, 'prompt'),
        offset = prompt ? 1 : 0,
        options = this.$('option'),
        adjusted;

        if (options) {
            options.each(function () {
                adjusted = this.index > -1 ? this.index + offset : -1;
                this.selected = indexOf(selectedIndexes, adjusted) > -1;
            });
        }
    },

    init: function () {
        this._super();
        this.on("didInsertElement", this, this._triggerChange);
    }

});

Ember.SelectOption = Ember.View.extend({
    tagName: 'option',
    defaultTemplate: Ember.Handlebars.compile("{{view.label}}"),
    attributeBindings: ['value', 'selected'],

    init: function () {
        this.labelPathDidChange();
        this.valuePathDidChange();

        this._super();
    },

    selected: Ember.computed(function () {
        var content = get(this, 'content'),
        selection = getPath(this, 'parentView.selection');
        if (getPath(this, 'parentView.multiple')) {
            return selection && indexOf(selection, content) > -1;
        } else {
            // Primitives get passed through bindings as objects... since
            // `new Number(4) !== 4`, we use `==` below
            return content == selection;
        }
    }).property('content', 'parentView.selection').volatile(),

    labelPathDidChange: Ember.observer(function () {
        var labelPath = getPath(this, 'parentView.optionLabelPath');

        if (!labelPath) { return; }

        Ember.defineProperty(this, 'label', Ember.computed(function () {
            return getPath(this, labelPath);
        }).property(labelPath).cacheable());
    }, 'parentView.optionLabelPath'),

    valuePathDidChange: Ember.observer(function () {
        var valuePath = getPath(this, 'parentView.optionValuePath');

        if (!valuePath) { return; }

        Ember.defineProperty(this, 'value', Ember.computed(function () {
            return getPath(this, valuePath);
        }).property(valuePath).cacheable());
    }, 'parentView.optionValuePath')
});


})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================
    /*globals Handlebars */
    // Find templates stored in the head tag as script tags and make them available
    // to Ember.CoreView in the global Ember.TEMPLATES object. This will be run as as
    // jQuery DOM-ready callback.
    //
    // Script tags with "text/x-handlebars" will be compiled
    // with Ember's Handlebars and are suitable for use as a view's template.
    // Those with type="text/x-raw-handlebars" will be compiled with regular
    // Handlebars and are suitable for use in views' computed properties.
    Ember.Handlebars.bootstrap = function (ctx) {
        var selectors = 'script[type="text/x-handlebars"], script[type="text/x-raw-handlebars"]';

        if (Ember.ENV.LEGACY_HANDLEBARS_TAGS) { selectors += ', script[type="text/html"]'; }

        Ember.warn("Ember no longer parses text/html script tags by default. Set ENV.LEGACY_HANDLEBARS_TAGS = true to restore this functionality.", Ember.ENV.LEGACY_HANDLEBARS_TAGS || Ember.$('script[type="text/html"]').length === 0);

        Ember.$(selectors, ctx)
    .each(function () {
        // Get a reference to the script tag
        var script = Ember.$(this),
        type = script.attr('type');

        var compile = (script.attr('type') === 'text/x-raw-handlebars') ?
                  Ember.$.proxy(Handlebars.compile, Handlebars) :
                  Ember.$.proxy(Ember.Handlebars.compile, Ember.Handlebars),
        // Get the name of the script, used by Ember.View's templateName property.
        // First look for data-template-name attribute, then fall back to its
        // id if no name is found.
      templateName = script.attr('data-template-name') || script.attr('id'),
      template = compile(script.html()),
      view, viewPath, elementId, tagName, options;

        if (templateName) {
            // For templates which have a name, we save them and then remove them from the DOM
            Ember.TEMPLATES[templateName] = template;

            // Remove script tag from DOM
            script.remove();
        } else {
            if (script.parents('head').length !== 0) {
                // don't allow inline templates in the head
                throw new Ember.Error("Template found in <head> without a name specified. " +
                         "Please provide a data-template-name attribute.\n" +
                         script.html());
            }

            // For templates which will be evaluated inline in the HTML document, instantiates a new
            // view, and replaces the script tag holding the template with the new
            // view's DOM representation.
            //
            // Users can optionally specify a custom view subclass to use by setting the
            // data-view attribute of the script tag.
            viewPath = script.attr('data-view');
            view = viewPath ? Ember.getPath(viewPath) : Ember.View;

            // Get the id of the script, used by Ember.View's elementId property,
            // Look for data-element-id attribute.
            elementId = script.attr('data-element-id');

            // Users can optionally specify a custom tag name to use by setting the
            // data-tag-name attribute on the script tag.
            tagName = script.attr('data-tag-name');

            options = { template: template };
            if (elementId) { options.elementId = elementId; }
            if (tagName) { options.tagName = tagName; }

            view = view.create(options);

            view._insertElementLater(function () {
                script.replaceWith(this.$());

                // Avoid memory leak in IE
                script = null;
            });
        }
    });
    };

    Ember.$(document).ready(
  function () {
      Ember.Handlebars.bootstrap(Ember.$(document));
  }
);

})();



(function () {
    // ==========================================================================
    // Project:   Ember Handlebar Views
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();

(function () {
    // ==========================================================================
    // Project:   Ember
    // Copyright: 漏2011 Strobe Inc. and contributors.
    // License:   Licensed under MIT license (see license.js)
    // ==========================================================================

})();


define("ember", ["configure-ember", "jquery"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Ember;
    };
} (this)));

define('desmos', [], function () {
    var Desmos = {};
    Desmos.Templates = {};
    window.Desmos = Desmos;
    return Desmos;  //Used as top-level Desmos namespace
});

define('main/url_prefix', ['require'], function (require) {
    var URL_PREFIX = window.location.href.split('/calculator')[0] + '/calculator';
    // if we're on the file:// protocol we don't want to look at pathname. It'll
    // be a really ugly path listing all the directories we need to go through to
    // get to the index.html file. Just pretend like we're on a live server.
    if (window.location.protocol === 'file:') URL_PREFIX = '/calculator';
    return URL_PREFIX;
});


// RandomHashFactory takes a seed, and constructs an object with a .next()
// method that returns random 10 character alphanumeric strings. The seed is
// designed to be a hex string representing a 128 bit random UUID, but is
// allowed to be any non-empty string.
//
// Usage:
// > randomHashFactory = new Desmos.RandomHashFactory('570a95d1f9a6455ab4b9c76bbd2509b6')
// > randomHashFactory.next()
// 'medjqzoa4t'
// > randomHashFactory.next()
// 'phgn5qzrm0'
//
// Implementation Notes:
// Behind the scenes, uses an ARC4 implementation by David Bau.
// http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html
// http://davidbau.com/encode/seedrandom.js

define('lib/random_hash', ['require', 'exports', 'module'], function (require, exports) {

    // ARC4 wraps BauARC4 (taken from seedrandom.js) to make an object that
    // takes a string seed instead of a key as a constructor, and returns an
    // array of integers between 0 and 255 instead of a large integer.
    //
    // The seed is designed to be the hex representation of a 128 bit random
    // UUID, but is allowed to be any string.
    //
    // Usage:
    // var arc4 = new ARC4('this is a seed')
    // arc4.g(4) // returns an array of 4 integers between 0 and 256
    function ARC4(seed) {
        this.bauArc4 = new BauARC4(toKey(seed));
    }

    ARC4.prototype.g = function (count) {
        digits = Array(count);
        for (var i = 0; i < count; i++) {
            digits[i] = this.bauArc4.g(1);
        }
        return digits;
    };

    // Helpers used by ARC4
    var width = 256;
    function lowbits(n) { return n & (width - 1); }

    //
    // tokey()
    // Converts a string seed into a key that is an array of integers
    function toKey(seed) {
        var stringSeed = seed + ''; // Ensure the seed is a string
        var key = [];
        var smear = 0;
        var j;
        for (j = 0; j < stringSeed.length; j++) {
            key[lowbits(j)] =
        lowbits((smear ^= key[lowbits(j)] * 19) + stringSeed.charCodeAt(j));
        }
        return key;
    }

    // BauARC4, cribbed from http://davidbau.com/encode/seedrandom.js
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    /** @constructor */
    function BauARC4(key) {
        var t, u, me = this, keylen = key.length;
        var i = 0, j = me.i = me.j = me.m = 0;
        me.S = [];
        me.c = [];

        // The empty key [] is treated as [0].
        if (!keylen) { key = [keylen++]; }

        // Set up S using the standard key scheduling algorithm.
        while (i < width) { me.S[i] = i++; }
        for (i = 0; i < width; i++) {
            t = me.S[i];
            j = lowbits(j + t + key[i % keylen]);
            u = me.S[j];
            me.S[i] = u;
            me.S[j] = t;
        }

        // The "g" method returns the next (count) outputs as one number.
        me.g = function getnext(count) {
            var s = me.S;
            var i = lowbits(me.i + 1); var t = s[i];
            var j = lowbits(me.j + t); var u = s[j];
            s[i] = u;
            s[j] = t;
            var r = s[lowbits(t + u)];
            while (--count) {
                i = lowbits(i + 1); t = s[i];
                j = lowbits(j + t); u = s[j];
                s[i] = u;
                s[j] = t;
                r = r * width + s[lowbits(t + u)];
            }
            me.i = i;
            me.j = j;
            return r;
        };
        // For robust unpredictability discard an initial batch of values.
        // See http://www.rsa.com/rsalabs/node.asp?id=2009
        me.g(width);
    }

    // We're using a somewhat odd distribution of random hashes, but this
    // follows existing server side behavior. Draw characters from downcased
    // alphanumeric set. Weights each alphabetical character twice as heavily as
    // each digit.
    var upperLowerDigits =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var codex = upperLowerDigits.toLowerCase();
    // Hardcoded because the below algorithm relies on this number not changing.
    var codexLength = 62;

    var nchars = 10;
    var RandomHashFactory = function (seed) {
        if (!seed) throw 'You must supply a seed to RandomHashFactory. It should have at least 128 bits of entropy.';

        var arc4 = new ARC4(seed);

        this.next = function () {
            chars = Array(nchars);
            var n = 0;
            var trialIndex;

            // Rejection sampling. Want uniform samples between 0 and 61, the
            // valid indices into our codex. arc4 returns integers between 0 and
            // 255, so we shift two bits off them to get integers between 0 and 63,
            // and then reject the samples larger than 61.
            while (n < nchars) {
                trialIndex = arc4.g(1)[0] >> 2;
                if (trialIndex < codexLength) {
                    chars[n] = codex[trialIndex];
                    n++;
                }
            }
            return chars.join("");
        };

        // Return a new random 128-bit hex value
        this.nextSeed = function () {
            var nbytes = 16;
            var bytes = arc4.g(nbytes);
            hexCodes = Array(nbytes);
            for (var i = 0; i < nbytes; i++) {
                hexCodes[i] = bytes[i].toString(16);
                // Pad each byte representation to 2 hex characters
                if (hexCodes[i].length === 1) {
                    hexCodes[i] = "0" + hexCodes[i];
                }
            }
            return hexCodes.join("");
        };
    };

    var factory;

    exports.next = function () {
        if (!factory) throw "Random Hash Factory not initialized";
        return factory.next();
    };

    exports.nextSeed = function () {
        if (!factory) throw "Random Hash Factory not initialized";
        return factory.nextSeed();
    };

    exports.init = function (seed) {
        factory = new RandomHashFactory(seed);
    };

    return exports;
});

define('main/graph', ['require', 'ember', 'main/url_prefix', 'lib/random_hash', 'desmos'], function (require) {
    var Ember = require('ember');
    var URL_PREFIX = require('main/url_prefix');
    var RandomHash = require('lib/random_hash');
    var Desmos = require('desmos');

    var Graph = Desmos.Graph = Ember.Object.extend({
        title: undefined,
        thumbData: undefined,
        thumbURL: undefined,
        thumbURI: Ember.computed(function () {
            return this.get('thumbURL') || this.get('thumbData');
        }).property('thumbData', 'thumbURL'),
        hash: undefined,
        graphData: undefined,
        access: 'all',
        created: undefined,
        now: new Date(),

        //this is flipped to false when we call an updateData,
        //and then reset to true when we hear back from the server
        isSynced: true,

        copy: function () {
            return Graph.copy(this);
        },

        // Calls out to grapher to update graphData and screenshots.
        updateData: function () {
            this.set('graphData', window.getState('escaped'));
            this.set('hash', RandomHash.next());
            this.set('isSynced', false);

            var thumbData = grapher.thumbnail(200, 200);
            this.set('thumbData', thumbData);
            this.set('thumbURL', thumbData); // In case we're offline.
        },

        accessAllChecked: Ember.computed(function () {
            return this.get('access') === "all";
        }).property('access'),

        accessLinkChecked: Ember.computed(function () {
            return this.get('access') === "link";
        }).property('access'),

        accessMeChecked: Ember.computed(function () {
            return this.get('access') === "me";
        }).property('access'),

        displayTitle: Ember.computed(function () {
            return this.get('title') || '[Untitled Graph]';
        }).property('title'),

        displayDate: function () {
            var now = this.get('now');
            var created = this.get('created');
            var seconds = (now - created) / 1000;
            var minutes = seconds / 60;
            var hours = minutes / 60;
            var days = hours / 24;
            var weeks = days / 7;
            var monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            if (weeks >= 5) return 'on ' + monthNames[created.getMonth()] + ' ' + created.getDate() + ', ' + created.getFullYear();
            if (weeks >= 2) return String(Math.floor(weeks)) + ' weeks ago';
            if (days >= 7) return 'last week';
            if (days >= 2) return String(Math.floor(days)) + ' days ago';
            if (hours >= 24) return 'yesterday';
            if (hours >= 2) return String(Math.floor(hours)) + ' hours ago';
            if (minutes >= 60) return 'one hour ago';
            if (minutes >= 2) return String(Math.floor(minutes)) + ' minutes ago';
            if (seconds >= 60) return 'one minute ago';
            return 'just now';

        } .property('now', 'created'),

        titleChanged: function () {
            document.title = this.get("title") ? this.get("title") : "Desmos Graphing Calculator";
        } .observes("title"),

        updateDisplayDate: function () {
            this.set('now', new Date());
        },

        path: Ember.computed(function () {
            var hash = this.get('hash');
            var path = URL_PREFIX;

            if (hash) path += ("/" + hash);

            return path;
        }).property('hash')

    });

    // the JSON.parse(JSON.stringify(this)) thing refuses to work on
    // safari when using file:// . This way is a lot more robust, it's
    // just also a lot more verbose.
    Graph.copy = function (obj) {
        var copy = Graph.create(obj.getProperties([
    'title',
    'thumbData',
    'thumbURL',
    'screenshotData',
    'hash',
    'graphData',
    'access',
    'created'
  ]));

        return copy;
    };

    Graph.fromAjax = function (obj) {
        return Graph.create({
            title: obj.title,
            thumbURL: obj.thumbUrl,
            graphData: JSON.stringify(obj.state),
            hash: obj.hash,
            access: obj.access,
            created: new Date(obj.created)
        });
    };

    Graph.updateFromSync = function (obj, resp) {
        obj.setProperties({
            isSynced: true,
            title: resp.title,
            hash: resp.hash,
            thumbURL: resp.thumbUrl,
            created: new Date(resp.created)
        });
    };

    return Graph;
});

/*
* formerly in desmos_user, now placed on the Desmos scope.
* this seems to do a lot and to be entangled with the particular user,
* but basically this communicates with our backend regarding any changes to graphs
*/

define('main/calculator_backend', ['require', 'ember', 'main/graph'], function (require) {
    var Ember = require('ember');
    var Graph = require('main/graph');

    var calculatorBackend = Ember.Object.create({
        apiPath: function (path) {
            return ['/api/v1/calculator', path].join('/');
        },

        // Helper for saveGraph and shareGraph that lets them make different
        // decision about whether to add the graph to the list of the user's graphs.
        _saveGraph: function (graph, my_graphs) {
            //detect if we should push to drive
            var push_to_drive = ($('input[name="push_to_drive"]').attr("checked") ? "push_to_drive" : undefined);
            var access = ($('input[name="access"]').attr("checked") ? "all" : "link");
            var formData = {
                parent_hash: graph.get('parentHash'),
                thumb_data: graph.get('thumbData'),
                calc_state: graph.get('graphData'),
                graph_hash: graph.get('hash'),
                version: 'h2',
                access: access,
                my_graphs: my_graphs,
                // Use all these undefineds so that the data doesn't go to the server
                // if it is blank or null.
                title: graph.get('title') || undefined,
                push_to_drive: push_to_drive
            };

            return $.post(this.apiPath('save'), formData).pipe(function (resp) {
                Graph.updateFromSync(graph, resp);
                return graph;
            });
        },

        saveGraph: function (graph) {
            return this._saveGraph(graph, true);
        },

        shareGraph: function (graph) {
            return this._saveGraph(graph, false);
        },

        emailGraph: function (data) {
            return $.post(this.apiPath('email_graph'), data);
        },

        emailFeedback: function (data) {
            return $.post(this.apiPath('email_feedback'), data);
        },

        allowFeature: function (data) {
            return $.post(this.apiPath('allow_feature'), data);
        },

        getGraphs: function () {
            return $.getJSON(this.apiPath('my_graphs')).pipe(function (msg) {
                if (msg.myGraphs) {
                    return Ember.A(msg.myGraphs).map(Graph.fromAjax);
                }
            });
        },

        removeGraph: function (graph) {
            return $.post(this.apiPath('my_graphs/remove'), {
                hash: graph.get('hash')
            });
        },

        undoRemoveGraph: function (graph) {
            return $.post(this.apiPath('my_graphs/undo_remove'), {
                hash: graph.get('hash')
            });
        }

    });

    return calculatorBackend;
});

define('main/graphs_controller', ['require', 'ember', 'main/graph', 'main/calculator_backend'], function (require) {
    var Ember = require('ember');
    var Graph = require('main/graph');
    var calculatorBackend = require('main/calculator_backend');

    var GraphsController = Ember.ArrayController.extend({
        currentGraph: Graph.create(),
        lastLoadedGraph: undefined,
        lastRemovedGraph: undefined,
        content: Ember.required(),
        removeObject: function (graph) {
            this._super(graph);
            this.set('lastRemoved', graph);
            calculatorBackend.removeGraph(graph);
        },
        undoLastRemove: function () {
            var self = this;
            var lastRemoved = self.get('lastRemoved');

            calculatorBackend.undoRemoveGraph(lastRemoved).done(function () {
                self.unshiftObject(lastRemoved);
                self.set('lastRemoved', undefined);
            })
      ;
        },

        // TODO, this is exactly what backbone is good at.
        startSavingCallbacks: [],
        saveSuccessCallbacks: [],
        saveErrorCallbacks: [],
        startUpdatingGraphsCallbacks: [],
        updateGraphsSuccessCallbacks: [],
        updateGraphsErrorCallbacks: [],

        triggerStartSaving: function () {
            _.each(this.startSavingCallbacks, function (cb) { cb() });
        },
        triggerSaveSuccess: function () {
            _.each(this.saveSuccessCallbacks, function (cb) { cb() });
        },
        triggerSaveError: function () {
            _.each(this.saveErrorCallbacks, function (cb) { cb() });
        },
        triggerStartUpdatingGraphs: function () {
            _.each(this.startUpdatingGraphsCallbacks, function (cb) { cb() });
        },
        triggerUpdateGraphsSuccess: function () {
            _.each(this.updateGraphsSuccessCallbacks, function (cb) { cb() });
        },
        triggerupdateGraphsError: function () {
            _.each(this.updateGraphsErrorCallbacks, function (cb) { cb() });
        },

        save: function () {
            var graph = this.get('currentGraph');
            var self = this;

            self.triggerStartSaving();
            graph.updateData(); // Updates screenshots and generates a new hash.
            calculatorBackend.saveGraph(graph).done(function (graph) {
                // copy graph so that what goes into my_graphs list isn't
                // the exact same object as what's stored in currentGraph
                graph = graph.copy();
                self.unshiftObject(graph);
                self.triggerSaveSuccess();
                _kmq.push(['record', 'saved graph']);
            }).fail(function (jqXHR) {
                self.triggerSaveError();
                _kmq.push(['record', 'failed to save graph']);
            });
        },

        updateGraphs: function () {
            var self = this;
            self.triggerStartUpdatingGraphs();
            calculatorBackend.getGraphs().done(function (graphs) {
                self.set('content', graphs);
                self.triggerUpdateGraphsSuccess();
            }).fail(function () {
                self.triggerUpdateGraphsError();
            });
        },

        clearGraph: function () {
            this.set('currentGraph', Graph.create());
        },

        // TODO: callback spaghetti... don't make this call a global method.
        currentGraphDidChange: function () {
            if (!window.setState) return; //TODO - fix this loading order
            window.setState(this.getPath('currentGraph.graphData'));
        } .observes('currentGraph'),

        graphModified: function () {
            var currentGraph = this.get('currentGraph');
            var lastLoadedGraph = this.get('lastLoadedGraph');
            if (!lastLoadedGraph) return true;

            return !(
        ( // Checking whether the title is the same, but when it's unset, it's
            // sometimes null and sometimes undefined. Could use == here, but it
            // seems best to be explicit.
          currentGraph.get('title') === lastLoadedGraph.get('title') ||
          (!currentGraph.get('title') && !lastLoadedGraph.get('title'))
        ) &&
        window.getState('escaped') === lastLoadedGraph.get('graphData')
      );
        },

        currentGraphHashDidChange: Ember.observer(function () {
            var self = this;
            // Settimeout here is because the system appears to do some monkey around
            // with states after they get set (especially the blank state), and we
            // want the state after all that has settled down. Ick...
            // TODO - fix the grossness implied by the above comment
            setTimeout(function () {
                self.set('lastLoadedGraph', self.get('currentGraph').copy());
                // Do this so we know we have an escape state to check against in
                // graphModified
                if (!window.getState) return;
                self.setPath('lastLoadedGraph.graphData', window.getState('escaped'));
            }, 1);

            if (!(window.history && history.pushState)) return;

            var graph = this.get('currentGraph');
            var path = graph.get('path');

            if (window.location.search) path += window.location.search;

            if (path && path !== window.location.href) {
                history.pushState(graph, graph.get('title'), path);
            }
        }).observes('currentGraph.path')
    });

    return GraphsController.create();
});

define('main/user', ['require', 'ember'], function (require) {
    var Ember = require('ember');

    var User = Desmos.User = Ember.Object.extend({
        name: undefined,
        email: undefined,
        isDriveUser: undefined,
        isEdmodoUser: undefined
    });

    return User;
});

define('main/account_backend', ['require', 'ember', 'main/user'], function (require) {
    var Ember = require('ember');
    var User = require('main/user');

    var accountBackend = Ember.Object.create({
        logout: function () {
            return $.post('/account/logout_xhr');
        },

        fetchUser: function (formData) {
            var self = this;

            var login = function () {

                return $.ajax({
                    url: '/account/login_xhr',
                    data: formData,
                    type: 'post',
                    dataType: 'json'
                }).pipe(function (resp) {
                    return self.getUserInfo();
                });
            };

            // do a logout before a login so that cookies are set correctly
            return self.logout().pipe(login, login);
        },

        getUserInfo: function () {
            return $.getJSON('/account/user_info').pipe(function (msg) {
                return User.create({
                    email: msg.email,
                    name: msg.name,
                    isDriveUser: msg.isDriveUser,
                    isEdmodoUser: msg.isEdmodoUser
                });
            });
        },

        registerUser: function (formData) {
            var self = this;

            return $.post('/account/register_xhr', formData).pipe(function () {
                return self.getUserInfo();
            });
        },

        editAccount: function (formData) {
            var self = this;

            return $.post('/account/edit_account_xhr', formData).pipe(function () {
                return self.getUserInfo();
            });
        },

        recoverPassword: function (formData) {
            return $.post('/account/recover_xhr', formData);
        }
    });

    return accountBackend;
});

var _kmq = _kmq || [];
if (window._kmk) {
    var _kms = function (u) {
        setTimeout(function () {
            var d = document, f = d.getElementsByTagName('script')[0],
      s = d.createElement('script');
            s.type = 'text/javascript'; s.async = true; s.src = u;
            f.parentNode.insertBefore(s, f);
        }, 1);
    };
    _kms('//i.kissmetrics.com/i.js');
    _kms('//doug1izaerwt3.cloudfront.net/' + _kmk + '.1.js');
}
;
define("analytics/kissmetrics", function () { });

define('main/user_controller', ['require', 'ember', 'jquery', 'desmos', 'main/graph', 'main/graphs_controller', 'main/account_backend', 'main/calculator_backend', 'analytics/kissmetrics'], function (require) {
    var Ember = require('ember');
    var $ = require('jquery');
    var Desmos = require('desmos');
    var Graph = require('main/graph');
    var graphsController = require('main/graphs_controller');
    var accountBackend = require('main/account_backend');
    var calculatorBackend = require('main/calculator_backend');
    require('analytics/kissmetrics');

    var UserController = Ember.Object.extend({
        currentUser: null,

        isDriveUser: false,
        isEdmodoUser: false,
        nextActionOnLogin: undefined,

        //called at the end of the login process
        completeLogin: function (opts) {
            var user = opts.user;
            this.set('currentUser', user);

            var nextAction = this.get('nextActionOnLogin');
            this.set('nextActionOnLogin', undefined);
            graphsController.updateGraphs();

            if (nextAction) this[nextAction].call(this);

            //Analytics
            _kmq.push(['identify', user.get('email')]);
            _kmq.push(['record', 'logged in', {
                'google user': user.get('isDriveUser'),
                'edmodo user': user.get('isEdmodoUser'),
                'login remembered': !!opts.remembered_login
            }]);
        },

        logout: function () {
            _kmq.push(['clearIdentity']);
            var self = this;
            accountBackend.logout().done(function () {
                self.set('currentUser', null);
                graphsController.clear();
            });
        }
    });

    var userController = UserController.create();

    Desmos.driveCallback = function () {
        accountBackend.getUserInfo().done(function (user) {
            userController.completeLogin({ user: user });
        }).fail(function (user) { // if user denied us API access, log them out
            userController.logout();
        });
    };

    //Always used as a singleton, so just create that here
    return userController;
});

; (function () {

    if (typeof Function.prototype.bind !== 'function') {
        Function.prototype.bind = function bind(this_) {
            var fn = this;

            return function () {
                return fn.apply(this_, arguments);
            };
        };
    }

})();

define("lib/function.bind", function () { });

define('lib/underscore_model', ['require', 'pjs', 'lib/function.bind'], function (require) {
    var P = require('pjs');
    require('lib/function.bind');

    var UnderscoreModel = P(function (model) {

        model.init = function () {
            this.__observers = {};
            this.__oldProperties = {};
            this.__propertyComparators = {};
        };

        model.getProperty = function (property) {
            return this[property];
        };

        model.getOldProperty = function (property) {
            return this.__oldProperties[property];
        };

        model.setProperty = function (property, newValue) {
            var oldValue = this[property];
            var comparator = this.__propertyComparators[property];
            if (comparator) {
                if (comparator(oldValue, newValue)) {
                    return;
                }
            } else if (_.isEqual(oldValue, newValue)) {
                return;
            }

            this.__oldProperties[property] = oldValue;
            this[property] = newValue;
            this.notifyPropertyChange(property);
        };

        model.setPropertyComparator = function (property, comparator) {
            this.__propertyComparators[property] = comparator;
        };

        model.notifyPropertyChange = function (property) {
            var observers = this.__observers[property];
            if (observers) {
                for (var i = 0; i < observers.length; i++) {
                    observers[i].callback(property, this);
                }
            }
        };

        model.unobserve = function (property_string) {

            // get rid of all observers
            if (!property_string) {
                this.__observers = {};
                return;
            }

            var properties = property_string.split(" ");
            for (var i = 0; i < properties.length; i++) {
                var property_parts = properties[i].split(".");
                var property = property_parts[0];
                var namespace = property_parts[1];

                // only keep the ones with a different namespace
                if (property && namespace) {
                    var original = this.__observers[property];
                    var filtered = [];
                    if (!original) continue;
                    for (var j = 0; j < original.length; j++) {
                        var observer = original[j];
                        if (observer.namespace !== namespace) {
                            filtered.push(observer);
                        }
                    }
                    this.__observers[property] = filtered;

                    // get rid of all of observers for this property since no namespace given
                } else if (property) {
                    if (this.__observers[property]) {
                        this.__observers[property] = [];
                    }

                    // we aren't given a property, only a namespace. run through each
                    // property that has observers and call .unobserve(property.namespace)
                } else if (namespace) {
                    for (property in this.__observers) {
                        this.unobserve(property + "." + namespace);
                    }
                }
            }
        };

        model.observe = function (property_string, callback) {
            var properties = property_string.split(" ");
            for (var i = 0; i < properties.length; i++) {
                var property_parts = properties[i].split(".");
                var property = property_parts[0];
                if (!property) throw 'Must supply a property to observe';

                var namespace = property_parts[1];
                var observer = {
                    namespace: namespace,
                    callback: callback
                };

                var observers = this.__observers[property];
                if (!observers) {
                    this.__observers[property] = [observer];
                } else {
                    observers.push(observer);
                }
            }
        };
    });

    return UnderscoreModel;
});

define('main/resize', ['require', 'jquery', 'lib/browser', 'jquery'], function (require) {
    require('jquery');
    var Browser = require('lib/browser');
    var $ = require('jquery');

    // call all the resize callbacks
    function triggerResize() {
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i]();
        }
    }

    // registers a callback to be called when triggerResize is called
    var callbacks = [];
    function registerCallback(callback) {
        callbacks.push(callback);
    }

    function setupResize() {
        // mobileResize calls itself recursively in a setTimeout. It should not be
        // called by others, because that will result in it running more
        // frequently forever.
        var mobileResize = function () {
            var focused = $(document.activeElement);
            if (focused.filter('input,textarea').length === 0) {
                $(window).scrollTop(0).scrollLeft(0);
            }

            if (focused.filter('input:hidden, textarea:hidden').length) {
                // hack to get jquery to remove focus from hidden input.
                // the following steps work for all tested mobile devices.
                //
                // step 1) add an input textbox to body and focus it.
                // step 2) make that textbox disabled and readonly.
                // step 3) blur the textbox and remove from the dom.
                $('<input />').appendTo('body').focus()
      .attr({
          readonly: 'readonly',
          disabled: 'true'
      })
      .blur().remove();
            }

            //Calls onresize when orientation changes since ipad doesn't
            //always do it on it's own.
            var w = window.innerWidth;
            var h = window.innerHeight;
            if (w !== window.lastWidth || h !== window.lastHeight) {
                window.lastWidth = w;
                window.lastHeight = h;
                triggerResize();
            }
            setTimeout(mobileResize, 100);
        };

        var desktopResize = function () {
            $(window).scrollTop(0).scrollLeft(0);
            setTimeout(desktopResize, 100);
        };

        if (Browser.IS_MOBILE) {
            setTimeout(mobileResize, 100);
        } else {
            setTimeout(desktopResize, 100);
            triggerResize();
        }

        // Makes sure that window.resize calls onResize at most once every 100ms
        var resizeWindowTimeout;
        $(window).resize(function () {
            clearTimeout(resizeWindowTimeout);
            resizeWindowTimeout = setTimeout(triggerResize, 100);
        });
    }

    $(function () {
        setupResize();
    });

    return {
        trigger: triggerResize,
        register: registerCallback
    };

});

define('main/graph_settings', ['require', 'pjs', 'desmos', 'lib/underscore_model', 'graphing/viewport', 'main/resize'], function (require) {
    var P = require('pjs');
    var Desmos = require('desmos');
    var UnderscoreModel = require('lib/underscore_model');
    var Viewport = require('graphing/viewport');
    var Resize = require('main/resize');

    Resize.register(function () {
        if (grapher.updateScreenSize()) {
            grapher.redrawAllLayers();
        }

        if (grapher && grapher.settings && grapher.settings.squareAxes) {
            graphSettings.enforceSquareAxes();
        }
    });



    /*
    * graph settings
    */

    var GraphSettings = P(UnderscoreModel, function (settings, _super) {

        //executes a the axes squaring
        settings.enforceSquareAxes = function () {

            if (!this.squareAxes) return;

            var preserveDirection = this.lastChangedAxis;

            var viewport = grapher.viewport.clone();
            if (preserveDirection == 'y') {
                viewport.squareXAxis(grapher.screen);
            } else {
                viewport.squareYAxis(grapher.screen);
            }
            viewport.round(grapher.screen);
            graphController.setViewport(viewport);
        };

        //these are user-defined properties and can be saved in the state
        settings.init = function () {
            _super.init.call(this);

            // stored in state
            this.squareAxes = true;
            this.showLabels = true;
            this.showGrid = true;
            this.showAxes = true;
            this.xAxisPiLabels = false;
            this.yAxisPiLabels = false;
            this.degreeMode = false;

            //non computed -- these are the same for projectorMode and non-projector Mode
            this.labelHangingColor = 'rgba(150,150,150,1)';
            this.labelNormalColor = 'rgba(0,0,0,1)';

            //non-computed and not-stored in state. Just used for squaring Axes
            this.lastChangedAxis = 'x',

            // below here are properties that *are not* stored in the state and can,
            // right now, only be changed by toggling 'projectorMode'
      this.projectorMode = false;

            var self = this;
            function createProjectorProperty(property, offValue, onValue) {

                function computeProperty() {
                    self.setProperty(property, self.projectorMode ? onValue : offValue);
                }

                self.observe('projectorMode', computeProperty);
                computeProperty();
            }

            function createHighlightProperty(property, off_off, off_on, on_off, on_on) {
                function computeProperty() {
                    var value;
                    if (self.projectorMode) {
                        value = self.highlight ? on_on : on_off;
                    } else {
                        value = self.highlight ? off_on : off_off;
                    }

                    self.setProperty(property, value);
                }

                self.observe('projectorMode highlight', computeProperty);
                computeProperty();
            }

            //font size of labels
            createProjectorProperty('labelSize', 12, 18);
            //darker grid lines
            createProjectorProperty('majorAxisOpacity', 0.2, 0.5);

            //lighter grid lines
            createProjectorProperty('minorAxisOpacity', 0.08, 0.15);

            //main axes
            createProjectorProperty('axisOpacity', 0.7, 0.9);

            createProjectorProperty('axisLineWidth', 1, 2);

            //for antialiasing axes
            createProjectorProperty('axisLineOffset', 0.5, 0);

            //minimum separation between major axis lines
            createProjectorProperty('pixelsPerLabel', 70, 100);

            //line width for graphs
            createHighlightProperty('graphLineWidth', 2, 3, 6, 9);

            //line width for points
            createHighlightProperty('pointLineWidth', 7, 11, 15, 22);
        };

        settings.clone = function () {
            var newSettings = GraphSettings();
            newSettings.setProperty('squareAxes', this.squareAxes);
            newSettings.setProperty('showLabels', this.showLabels);
            newSettings.setProperty('showGrid', this.showGrid);
            newSettings.setProperty('squareAxes', this.showAxes);
            newSettings.setProperty('xAxisPiLabels', this.xAxisPiLabels);
            newSettings.setProperty('yAxisPiLabels', this.yAxisPiLabels);
            newSettings.setProperty('degreeMode', this.degreeMode);
            newSettings.setProperty('projectorMode', this.projectorMode);

            return newSettings;
        };
    });

    var graphSettings = GraphSettings();

    var redrawGridLayer = function () { grapher.redrawGridLayer() };
    graphSettings.observe('showLabels', redrawGridLayer);
    graphSettings.observe('showAxes', redrawGridLayer);
    graphSettings.observe('showGrid', redrawGridLayer);
    graphSettings.observe('xAxisPiLabels', redrawGridLayer);
    graphSettings.observe('yAxisPiLabels', redrawGridLayer);

    graphSettings.observe('squareAxes', function () {
        graphSettings.enforceSquareAxes();
    });

    graphSettings.observe('projectorMode', function () {
        grapher.redrawAllLayers();

        //set class on the body for POIs & trace -- see poi.css
        $('body').toggleClass('projector-mode', graphSettings.projectorMode);
    });

    return graphSettings;
});


/*
* TimerModules is a way to setup a function to keep getting called every
* 100ms. This is much cleaner than a lot of individual setTimeout or
* setInterval calls, and it allows you to optionally load/not load the module.
*
* A 'module' is really nothing more than a simple javascript closure. In order
* to 'add' a 'module', you make a call to Desmos.TimerModules.add and pass two
* arguments. The first is the name (string) you want to call the module, and
* the second argument is the module (function) you want to be executed when
* the module is 'loaded.'
*
* When you load a module, you can pass it arguments. This, for instance, would
* load the 'sample' module with the arguments (0,'a'):
*
*    Desmos.TimerModules.load('sample',0,'a')
*
* The 'sample' module will be executed. If the module returns a reference to
* a function, that function will keep getting called every 100ms. It's
* important to realize that the module itself won't be called every 100ms. The
* module is used to setup the function that keeps called every 100ms.
*
* see expressions.overflows.js, expressions.renderviewport, o
* expressions.dragdrop.js for real examples
*/
define('main/timermodules', [], function () {

    var added = {};
    var loaded = {};
    var runnable = {};

    TimerModules = {};
    TimerModules.add = function (name, setup) {
        added[name] = setup;
    };

    TimerModules.load = function (name) {
        if (added[name]) {
            //load the module
            loaded[name] = added[name].apply(this, Array.prototype.slice.call(arguments, 1));

            //add to list of runnable modules
            if (loaded[name]) runnable[name] = loaded[name];
        }
    };

    var run = function () {

        for (var i in runnable) {
            if (runnable.hasOwnProperty(i)) runnable[i]();
        }

        setTimeout(run, 100);
    };

    run();

    return TimerModules;
});

// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license
//
// Modified by Mike Haverstock to work with touchtracking.js to decide when
// to show tooltips and when not to. Problem is that this library doesn't 
// allow you to manually hide/show tooltips that are set with the 'live'
// option. That's because the 'live' option postpones tipsy instantiation for
// a specific node until an event bubbles up for that node. So, when you call
// .tipsy('show') for a live node, it sees that there is no .data('tipsy') set
// for the node and ignores the request. The solution is to not listen for
// mouseenter and mouseleave. Instead of those, you listen for 'tipsyshow' and
// 'tipsyhide'. Then, you manually hide/show tooltips by triggering 'tipsyshow'
// and 'tipsyhide' on that node. Then, the live code works perfectly fine. Now
// the only way to trigger tipsy is by manually triggering those events.
(function ($) {

    var openSticky = null;
    var ignoreStickyOpen = false;

    $(document).on('tap', '.tipsy-sticky', function (evnt) {

        // don't do anything. let the code that hides stickies close it.
        if (ignoreStickyOpen) {
            ignoreStickyOpen = false;
            return;
        }

        var options = $.extend({}, $.fn.tipsy.defaults);
        options.title = 'tooltip';
        options.gravity = 'nw';

        openSticky = new Tipsy(evnt.target, options);
        openSticky.show();
    });

    $(document).on('tapstart keydown', function (evnt) {
        if (openSticky) {
            openSticky.hide();

            if (evnt.type === 'tapstart' && evnt.target === openSticky.$element[0]) {
                $(document).one('tapend', function (evnt2) {
                    if (evnt.target === evnt2.target) {
                        ignoreStickyOpen = true;
                    }
                });
            }

            openSticky = null;
        }
    })

    function maybeCall(thing, ctx) {
        return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
    };

    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = true;
        this.fixTitle();
    };

    Tipsy.prototype = {
        show: function () {
            var title = this.getTitle();
            if (title && this.enabled) {
                var $tip = this.tip();

                $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
                $tip.remove().css({ top: 0, left: 0, visibility: 'hidden', display: 'block' }).prependTo(document.body);

                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });

                var actualWidth = $tip[0].offsetWidth,
                    actualHeight = $tip[0].offsetHeight,
                    gravity = maybeCall(this.options.gravity, this.$element[0]);

                var tp;
                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = { top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2 };
                        break;
                    case 's':
                        tp = { top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2 };
                        break;
                    case 'e':
                        tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset };
                        break;
                    case 'w':
                        tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset };
                        break;
                }

                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }

                $tip.css(tp).addClass('tipsy-' + gravity);
                $tip.find('.tipsy-arrow')[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
                if (this.options.className) {
                    $tip.addClass(maybeCall(this.options.className, this.$element[0]));
                }

                if (this.options.fadeIn) {
                    $tip.stop().css({ opacity: 0, display: 'block', visibility: 'visible' }).animate({ opacity: this.options.opacity }, this.options.fadeIn);
                } else {
                    $tip.css({ visibility: 'visible', opacity: this.options.opacity });
                }

                if (this.options.sticky) {
                    $tip.addClass('sticky');
                }

                var self = this;
                function validateLoop() {
                    self.validate();
                    self.validateTimeout = setTimeout(validateLoop, 100);
                }
                validateLoop();
            }
        },

        hide: function () {
            clearTimeout(this.validateTimeout);

            if (this.options.fadeOut) {
                this.tip().stop().fadeOut(this.options.fadeOut, function () { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },

        fixTitle: function () {
            var $e = this.$element;
            if ($e.attr('title') || typeof ($e.attr('original-title')) != 'string') {
                $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
            }
        },

        getTitle: function () {
            var title, $e = this.$element, o = this.options;
            this.fixTitle();
            var title, o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }

            if (title) title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },

        tip: function () {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"></div>').html('<div class="tipsy-arrow"></div><div class="tipsy-inner"></div>');
            }
            return this.$tip;
        },

        validate: function () {

            var hasTitle = !!this.getTitle();
            var inDom = false;

            if (hasTitle) {
                try {
                    var node = this.$element[0];

                    while (node) {
                        if (node === document) {
                            inDom = true;
                            break;
                        } else {
                            node = node.parentNode;
                        }
                    }
                } catch (e) { }
            }

            if (!inDom) {
                this.hide();
            }
        },

        enable: function () { this.enabled = true; },
        disable: function () { this.enabled = false; },
        toggleEnabled: function () { this.enabled = !this.enabled; }
    };

    $.fn.tipsy = function (options) {

        if (options === true) {
            return this.data('tipsy');
        } else if (typeof options == 'string') {
            var tipsy = this.data('tipsy');
            if (tipsy) tipsy[options]();
            return this;
        }

        options = $.extend({}, $.fn.tipsy.defaults, options);

        options.fadeIn = options.fadeIn || options.fade;
        options.fadeOut = options.fadeOut || options.fade;

        function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
                tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
                $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
        }

        function enter(evnt) {
            // the tipsyshow event bubbles up the dom, so we only want to
            // listen to the event if the target is the same as the element
            // that is responding to the event. If this wasn't here then when
            // you move your mouse from a tipsy-enabled parent to a child, the
            // tipsyshow event would be fired from the child, bubble through
            // the parent, and get caught higher up. That would cause the 
            // already opened tooltip to close and fade in again. With this
            // code, we ignore the tipsyshow event because the target is the
            // the child that isn't tipsy-enabled.
            if (evnt.type === 'tipsyshow' && evnt.target !== this) return;

            // this element has a sticky open already            
            if (openSticky === this) return;

            var tipsy = get(this);
            tipsy.hoverState = 'in';

            if (options.delayIn == 0) {
                tipsy.show();
            } else {
                tipsy.fixTitle();
                setTimeout(function () { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
        };

        function leave(evnt) {
            // we do this for the same reason we do it for the tipsyshow event.
            // look at the comment a few lines above for more information.
            if (evnt.type === 'tipsyhide' && evnt.target !== this) return;

            var tipsy = get(this);

            // if this is a sticky tooltip, don't close it on tapStart. If we
            // closed it now, it would flicker back on when we mouse up and
            // make it permanent. We'd like it to stay on the whole time.
            if (evnt.type === 'tapstart' && tipsy.options.sticky) return;

            tipsy.hoverState = 'out';
            if (options.delayOut == 0) {
                tipsy.hide();
            } else {
                setTimeout(function () { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
        };

        if (!options.live) this.each(function () { get(this); });

        if (options.trigger != 'manual') {
            var eventIn = options.trigger == 'hover' ? 'tipsyshow' : 'focus';
            var eventOut = options.trigger == 'hover' ? 'tipsyhide tapstart tapend tapcancel' : 'blur';

            if (options.live && options.delegate) {
                this.on(eventIn, options.delegate, enter).on(eventOut, options.delegate, leave);
            } else {
                var binder = options.live ? 'on' : 'bind';
                this[binder](eventIn, enter)[binder](eventOut, leave);
            }
        }

        return this;

    };

    $.fn.tipsy.defaults = {
        className: null,
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fadeIn: false,
        fadeOut: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: true,
        offset: 0,
        opacity: 1,
        title: 'title',
        trigger: 'hover'
    };

    // Overwrite this method to provide options on a per-element basis.
    // For example, you could store the gravity in a 'tipsy-gravity' attribute:
    // return $.extend({}, options, {gravity: $(ele).attr('tipsy-gravity') || 'n' });
    // (remember - do not modify 'options' in place!)
    $.fn.tipsy.elementOptions = function (ele, options) {
        return options;
    };

    $.fn.tipsy.autoNS = function () {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };

    $.fn.tipsy.autoWE = function () {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };

    /**
    * yields a closure of the supplied parameters, producing a function that takes
    * no arguments and is suitable for use as an autogravity function like so:
    *
    * @param margin (int) - distance from the viewable region edge that an
    *        element should be before setting its tooltip's gravity to be away
    *        from that edge.
    * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
    *        if there are no viewable region edges effecting the tooltip's
    *        gravity. It will try to vary from this minimally, for example,
    *        if 'sw' is preferred and an element is near the right viewable 
    *        region edge, but not the top edge, it will set the gravity for
    *        that element's tooltip to be 'se', preserving the southern
    *        component.
    */
    $.fn.tipsy.autoBounds = function (margin, prefer) {
        return function () {
            var dir = { ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false) },
			    boundTop = $(document).scrollTop() + margin,
			    boundLeft = $(document).scrollLeft() + margin,
			    $this = $(this);

            if ($this.offset().top < boundTop) dir.ns = 'n';
            if ($this.offset().left < boundLeft) dir.ew = 'w';
            if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
            if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

            return dir.ns + (dir.ew ? dir.ew : '');
        }
    };

    // automatically instantiate tipsy for .tipsy-sticky classes
    $(document).tipsy({
        title: 'tooltip',
        wait: 0,
        live: true,
        delegate: '.tipsy-sticky',
        gravity: 'nw',
        sticky: true,
        fade: false
    });

})(jQuery);

define("vendor/jquery.tipsy", function () { });

define('lib/underscore_view', ['require', './underscore_model', 'pjs'], function (require) {
    var UnderscoreModel = require('./underscore_model');
    var P = require('pjs');

    var UnderscoreView = P(UnderscoreModel, function (view) {

        view.$ = function (selector) {
            var $node = $(this.__domNode);
            if (!selector) {
                return $node;
            } else {
                return $node.filter(selector).add($node.find(selector));
            }
        };

        // methods to adding view to dom. these call .didInsertElement() automatically
        view.appendTo = function (selector) {
            if (!this.__domNode) this.render();

            this.$().appendTo($(selector));
            this.didInsertElement();
            return this.$();
        };
        view.replace = function (selector) {
            if (!this.__domNode) this.render();

            $(selector).replaceWith(this.$());
            this.didInsertElement();
            return this.$();
        };
        view.prependTo = function (selector) {
            if (!this.__domNode) this.render();

            $(selector).prepend(this.$());
            this.didInsertElement();
            return this.$();
        };
        view.insertAfter = function (selector) {
            if (!this.__domNode) this.render();

            $(selector).after(this.$());
            this.didInsertElement();
            return this.$();
        };
        view.insertBefore = function (selector) {
            if (!this.__domNode) this.render();

            $(selector).before(this.$());
            this.didInsertElement();
            return this.$();
        };
        view.remove = function () {
            this.$().remove();
            this.destruct();
        };

        // should be overriden and used to cleanup any resources this view has
        // aquired. Most often, that means remove any observers set and any child
        // views created.
        view.destruct = function () { };

        // for this to be called, must insert this.$() into dom using one of the
        // methods above. If not, you must call .didInsertElement() yourself.
        view.didInsertElement = function () { };

        // this is the information that will be made available to the underscore template
        view.getTemplateParams = function () { return {}; };

        // tap into these if you want deep control of how a complete rerender happens.
        // one thing these are useful for are saving/restoring temporary data within
        // the view that will get wiped out when the html is regenerated.
        view.beforeRerender = function () { };
        view.afterRerender = function () { };

        // will render only if something has changed
        view.rerender = function () {
            var newParams = this.getTemplateParams();
            if (_.isEqual(newParams, this.__lastRenderParams)) return;

            this.beforeRerender();
            this.render();
            this.afterRerender();
        };

        view.setDomNode = function (node) {
            this.__domNode = node[0] ? node[0] : node;
            this.didInsertElement();
        };

        view.render = function () {
            var oldDomNode = this.__domNode;

            var template = Desmos.Templates[this.templateName];
            var params = this.getTemplateParams();
            var html = template(params);
            var $node = $(html);

            this.__domNode = $node[0];
            this.__lastRenderParams = params;

            if (oldDomNode && $.contains(document, oldDomNode)) {
                this.replace(oldDomNode);
            }
        };

    });
    return UnderscoreView;
});

define('undoredo', ['require', 'pjs'], function (require) {
    var P = require('pjs');

    var UndoRedoManager = P(function (manager) {

        manager.CAUSE_OF_CHANGE = 1;
        manager.RESPONSE_TO_CHANGE = 2;
        manager.BATCHED_CHANGE = 3;

        manager.init = function () {
            this.__timeOfLastChange = -1;
            this.undos = [];
            this.redos = [];
            this.__isApplyingTransaction = 0;
        };

        //Default ctrl-z, ctrl-y behavior
        manager.handleKeydown = function (evt) {
            if (evt.ctrlKey || evt.metaKey) {
                switch (evt.which) {
                    case 90: //z
                        this.undo();
                        return false;
                    case 89: //y
                        this.redo();
                        return false;
                }
            }
        };

        manager.clear = function () {
            this.undos = [];
            this.redos = [];
            this.__batchableTransaction = null;
        };

        manager.undo = function () {
            if (this.undos.length === 0) return;
            this.__batchableTransaction = null;

            var action = this.undos.pop();
            this.applyTransaction(action, true);
            this.redos.push(action);
        };

        manager.redo = function () {
            if (this.redos.length === 0) return;
            this.__batchableTransaction = null;

            var action = this.redos.pop();
            this.applyTransaction(action);
            this.undos.push(action);
        };


        //you don't ever need to call this. It's called automatically from within
        //  the undo/redo system. It won't hurt anything though if you do call it.
        //  it'll just act like a change has occured and reset __timeOfLastChange.
        manager.markAsChanged = function () {
            this.__timeOfLastChange = new Date().getTime();
        };

        //you can call timeSinceChange() to see how long it's been
        //  since a change has occured. Note that if no change has occured, it will
        //  return -1.
        manager.timeSinceChange = function () {
            if (this.__timeOfLastChange === -1) return -1;

            return new Date().getTime() - this.__timeOfLastChange;
        };



        manager.isApplyingTransaction = function () {
            return !!this.__isApplyingTransaction;
        };

        manager.__applyTransaction = function (transaction, doUndo) {
            var i;
            var batched = transaction.__batched__ ? transaction.__batched__ : [];

            // apply transactions in reverse
            if (doUndo) {
                for (i = batched.length - 1; i >= 0; i--) {
                    this.__applyTransaction(batched[i], doUndo);
                }

                transaction.undo();
            }

            // apply transactions the way they happened the first time
            else {
                transaction.redo();
                for (i = 0; i < batched.length; i++) {
                    this.__applyTransaction(batched[i], doUndo);
                }
            }
        };

        manager.applyTransaction = function (transaction, doUndo) {
            this.__isApplyingTransaction++;

            try {
                this.__applyTransaction(transaction, doUndo);
            } catch (e) {
                throw e;
            } finally {
                this.__isApplyingTransaction--;
                this.markAsChanged();
            }
        };

        // sometimes, we want to just do multiple things, and we want them to all
        // be grouped into a single transaction. This is different from the
        // BATCHED_CHANGE idea because we don't want to have to care about what
        // sideeffects a certain action might have. Here, we just do stuff, and all
        // that stuff gets grouped together. It might seem like we could supercede
        // the BATCHED_CHANGE property and just always use this. The problem with
        // that is that BATCHED_CHANGE works when the sideeffect happens
        // asynchronously and oneTransaction requires that all side effects happen
        // synchronously.
        manager.oneTransaction = function (func) {
            if (!this.__oneTransactionDepth) {
                this.__oneTransactionDepth = 0;
            }

            this.__oneTransactionDepth++;
            func();
            this.__oneTransactionDepth--;

            if (!this.__oneTransactionDepth) {
                this.__oneTransaction = null;
            }
        };

        manager.isApplyingOneTransaction = function () {
            return this.__oneTransactionDepth > 0;
        };

        manager.addTransaction = function (transaction) {
            var batched;

            // A BATCHED_CHANGE transaction is one that is one that always happens
            // as a sideeffect of a different transaction. For instance, the slider's
            // value updates as a result of the user typing in the latex. The main
            // transaction would be the latex change, and the batched change would
            // be the slider value update.
            if (transaction.type === this.BATCHED_CHANGE) {

                if (!this.__batchableTransaction) return;

                batched = this.__batchableTransaction.__batched__;
                if (!batched) batched = this.__batchableTransaction.__batched__ = [];
                batched.push(transaction);

                this.applyTransaction(transaction);
                return;
            }

            //don't accept changes that are sideffects of applying a transaction.
            //the transaction should've been written in such a way that chained
            //reactions are accounted for.
            if (this.isApplyingTransaction()) return;

            //automatically apply this if it's what's going to cause the initial
            //change.
            if (transaction.type === this.CAUSE_OF_CHANGE)
                this.applyTransaction(transaction);

            //if nothing really changed, then stop.
            if (transaction.ensureChangeOccured && transaction.ensureChangeOccured())
                return;

            this.markAsChanged();
            // was this.redos.clear() in the Ember days. this.redos = [] would be
            // simpler, but has different semantics if someone else has a handle to
            // this array.
            this.redos.splice(0);
            var compressNow = transaction.compressWith;
            var compressBefore = !this.__batchableTransaction ? null :
                          this.__batchableTransaction.compressWith;

            if (!compressNow || compressNow != compressBefore) {

                this.__batchableTransaction = transaction;

                if (this.isApplyingOneTransaction()) {
                    if (!this.__oneTransaction) {
                        this.__oneTransaction = transaction;
                    } else {
                        batched = this.__oneTransaction.__batched__;
                        if (!batched) batched = this.__oneTransaction.__batched__ = [];
                        batched.push(transaction);
                        return;
                    }
                }

                this.undos.push(transaction);
            } else {
                this.__batchableTransaction.redo = transaction.redo;
            }
        };
    });


    return UndoRedoManager();
});

// desmos/public/assets/grapher/compiled_underscore_templates/keypad.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/keypad', ["desmos"], function (Desmos) {
    Desmos.Templates["keypad"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id=\'keys-background\' class=\'do-not-blur\'>\n  <div id=\'keys\'>\n\n    <div id=\'functions-popover\' class=\'popover top\' >\n      <div class=\'popover-interior\'>\n        <div class=\'header\'>\n          <table><tr>\n          ';
            _.each(popups.functionsPopup, function (contents, section) {
                ; __p += '\n            <td>\n              <span id="' +
(contents.tab.id) +
'"class="heading tappable btn btn-inverse' +
((section == "trig" ? " selected" : "")) +
'">\n                ' +
(contents.tab.html) +
'\n              </span>\n            </td>\n          ';
            })
; __p += '\n          </tr></table>\n        </div>\n\n        ';
            _.each(popups.functionsPopup, function (contents, section) {
                ; __p += '\n          <table id=\'funcs-' +
(section) +
'\'>\n            ';
                if (section == "trig") {
                    ; __p += '\n              <tr class=\'section-headings\'>\n                <td>trig</td>\n                <td>inverse</td>\n                <td>hyperb</td>\n              </tr>\n            ';
                }
                ; __p += '\n            <tr>\n\n            ';

                var i = 0;
                _.each(contents.funcs, function (func) {
                    i++;

                    ; __p += '\n              <td>\n                <span\n                  class="option btn tappable' +
(func.aClass ? " " + func.aClass : "") +
'"\n                  id="' +
(func.id) +
'"\n                >\n                  ' +
(func.html) +
'\n                </span>\n              </td>\n            ' +
((i % 3 == 0 ? "</tr><tr>" : "")) +
'\n          ';
                })
; __p += '\n          </tr></table>\n        ';
            })
; __p += '\n      </div>\n      <div class=\'arrow\'></div>\n    </div>\n\n\n    ';
            _.each(buttons, function (keypad, keypadID) {
                ; __p += '\n     <div id="' +
(keypadID) +
'">\n       ';
                _.each(keypad, function (row) {
                    ; __p += '\n         <div class="row">\n           ';
                    _.each(row['keys'], function (key) {
                        ; __p += '<div\n               class="cell ' +
(key.cellClass ? key.cellClass : "") +
'"\n             >\n               ';
                        if (key.html) {
                            ; __p += '\n                 <a\n                   class="' +
(key.aClass ? key.aClass : "") +
'"\n                   id="' +
(key.id) +
'"\n                 >\n                   ' +
(key.html) +
'\n                 </a>\n               ';
                        }
                        ; __p += '\n             </div>';
                    })
; __p += '\n           <div style=\'clear:both\'></div>\n         </div>\n       ';
                })
; __p += '\n     </div>\n    ';
            })
; __p += '\n    <div style=\'clear:both\'></div>\n  </div>\n\n  <div id=\'minimize-keypad\'>\n    <img class=\'keyboard-icon\' src=\'/assets/grapher/img/keyboard.png\' alt=\'\'>\n    <i class=\'icon-caret-down\'></i>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
//from http://www.w3schools.com/js/js_cookies.asp

function getCookie(c_name) {
    // We were having problems with cookies being set on two paths: both
    // / and /calculator. This erases the cookie at /calculator before any
    // reads. Can delete this call (and the definition of eraseCalculatorCookie)
    // one month after it launches, so roughly May 1, 2013.
    eraseCalculatorCookie(c_name);

    encoded_c_name = encodeURIComponent(c_name);
    var i, x, y, ARRcookies = document.cookie.split(";");
    for (i = 0; i < ARRcookies.length; i++) {
        x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="));
        y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1);
        x = x.replace(/^\s+|\s+$/g, "");
        if (x == encoded_c_name) {
            return decodeURIComponent(y);
        }
    }
}

function setCookie(c_name, value, duration) {
    //set a javascript cookie
    var expires = new Date();
    expires.setDate(expires.getDate() + (duration || 30));
    document.cookie = (
    encodeURIComponent(c_name) +
    "=" + encodeURIComponent(value) +
    "; expires=" + expires.toUTCString() +
    "; path=/"
  );
}

function eraseCalculatorCookie(c_name) {
    document.cookie = c_name + "= ;path=/calculator;expires=Thu, 01 Jan 1970 00:00:01 GMT";
}

;
define("main/cookie", function () { });

/**
* Copyleft 2010-2011 Jay and Han (laughinghan@gmail.com)
*   under the GNU Lesser General Public License
*     http://www.gnu.org/licenses/lgpl.html
* Project Website: http://mathquill.com
*/

(function () {

    var $ = jQuery,
  undefined,
  _, //temp variable of prototypes
  mqCmdId = 'mathquill-command-id',
  mqBlockId = 'mathquill-block-id',
  min = Math.min,
  max = Math.max;

    var __slice = [].slice;

    function noop() { }

    /**
    * sugar to make defining lots of commands easier.
    * TODO: rethink this.
    */
    function bind(cons /*, args... */) {
        var args = __slice.call(arguments, 1);
        return function () {
            return cons.apply(this, args);
        };
    }

    /**
    * a development-only debug method.  This definition and all
    * calls to `pray` will be stripped from the minified
    * build of mathquill.
    *
    * This function must be called by name to be removed
    * at compile time.  Do not define another function
    * with the same name, and only call this function by
    * name.
    */
    function pray(message, cond) {
        if (!cond) throw new Error('prayer failed: ' + message);
    }
    var P = (function (prototype, ownProperty, undefined) {
        // helper functions that also help minification
        function isObject(o) { return typeof o === 'object'; }
        function isFunction(f) { return typeof f === 'function'; }

        function P(_superclass /* = Object */, definition) {
            // handle the case where no superclass is given
            if (definition === undefined) {
                definition = _superclass;
                _superclass = Object;
            }

            // C is the class to be returned.
            // There are three ways C will be called:
            //
            // 1) We call `new C` to create a new uninitialized object.
            //    The behavior is similar to Object.create, where the prototype
            //    relationship is set up, but the ::init method is not run.
            //    Note that in this case we have `this instanceof C`, so we don't
            //    spring the first trap. Also, `args` is undefined, so the initializer
            //    doesn't get run.
            //
            // 2) A user will simply call C(a, b, c, ...) to create a new object with
            //    initialization.  This allows the user to create objects without `new`,
            //    and in particular to initialize objects with variable arguments, which
            //    is impossible with the `new` keyword.  Note that in this case,
            //    !(this instanceof C) springs the return trap at the beginning, and
            //    C is called with the `new` keyword and one argument, which is the
            //    Arguments object passed in.
            //
            // 3) For internal use only, if new C(args) is called, where args is an
            //    Arguments object.  In this case, the presence of `new` means the
            //    return trap is not sprung, but the initializer is called if present.
            //
            //    You can also call `new C([a, b, c])`, which is equivalent to `C(a, b, c)`.
            //
            //  TODO: the Chrome inspector shows all created objects as `C` rather than `Object`.
            //        Setting the .name property seems to have no effect.  Is there a way to override
            //        this behavior?
            function C(args) {
                var self = this;
                if (!(self instanceof C)) return new C(arguments);
                if (args && isFunction(self.init)) self.init.apply(self, args);
            }

            // set up the prototype of the new class
            // note that this resolves to `new Object`
            // if the superclass isn't given
            var proto = C[prototype] = new _superclass();

            // other variables, as a minifier optimization
            var _super = _superclass[prototype];
            var extensions;

            // set the constructor property on the prototype, for convenience
            proto.constructor = C;

            C.mixin = function (def) {
                C[prototype] = P(C, def)[prototype];
                return C;
            }

            return (C.open = function (def) {
                extensions = {};

                if (isFunction(def)) {
                    // call the defining function with all the arguments you need
                    // extensions captures the return value.
                    extensions = def.call(C, proto, _super, C, _superclass);
                }
                else if (isObject(def)) {
                    // if you passed an object instead, we'll take it
                    extensions = def;
                }

                // ...and extend it
                if (isObject(extensions)) {
                    for (var ext in extensions) {
                        if (ownProperty.call(extensions, ext)) {
                            proto[ext] = extensions[ext];
                        }
                    }
                }

                // if there's no init, we assume we're inheriting a non-pjs class, so
                // we default to applying the superclass's constructor.
                if (!isFunction(proto.init)) {
                    proto.init = function () { _superclass.apply(this, arguments); };
                }

                return C;
            })(definition);
        }

        // ship it
        return P;

        // as a minifier optimization, we've closured in a few helper functions
        // and the string 'prototype' (C[p] is much shorter than C.prototype)
    })('prototype', ({}).hasOwnProperty);
    /*************************************************
    * Textarea Manager
    *
    * An abstraction layer wrapping the textarea in
    * an object with methods to manipulate and listen
    * to events on, that hides all the nasty cross-
    * browser incompatibilities behind a uniform API.
    *
    * Design goal: This is a *HARD* internal
    * abstraction barrier. Cross-browser
    * inconsistencies are not allowed to leak through
    * and be dealt with by event handlers. All future
    * cross-browser issues that arise must be dealt
    * with here, and if necessary, the API updated.
    *
    * Organization:
    * - key values map and stringify()
    * - manageTextarea()
    *    + defer() and flush()
    *    + event handler logic
    *    + attach event handlers and export methods
    ************************************************/

    var manageTextarea = (function () {
        // The following [key values][1] map was compiled from the
        // [DOM3 Events appendix section on key codes][2] and
        // [a widely cited report on cross-browser tests of key codes][3],
        // except for 10: 'Enter', which I've empirically observed in Safari on iOS
        // and doesn't appear to conflict with any other known key codes.
        //
        // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues
        // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
        // [3]: http://unixpapa.com/js/key.html
        var KEY_VALUES = {
            8: 'Backspace',
            9: 'Tab',

            10: 'Enter', // for Safari on iOS

            13: 'Enter',

            16: 'Shift',
            17: 'Control',
            18: 'Alt',
            20: 'CapsLock',

            27: 'Esc',

            32: 'Spacebar',

            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',

            37: 'Left',
            38: 'Up',
            39: 'Right',
            40: 'Down',

            45: 'Insert',

            46: 'Del',

            144: 'NumLock'
        };

        // To the extent possible, create a normalized string representation
        // of the key combo (i.e., key code and modifier keys).
        function stringify(evt) {
            var which = evt.which || evt.keyCode;
            var keyVal = KEY_VALUES[which];
            var key;
            var modifiers = [];

            if (evt.ctrlKey) modifiers.push('Ctrl');
            if (evt.originalEvent && evt.originalEvent.metaKey) modifiers.push('Meta');
            if (evt.altKey) modifiers.push('Alt');
            if (evt.shiftKey) modifiers.push('Shift');

            key = keyVal || String.fromCharCode(which);

            if (!modifiers.length && !keyVal) return key;

            modifiers.push(key);
            return modifiers.join('-');
        }

        // create a textarea manager that calls callbacks at useful times
        // and exports useful public methods
        return function manageTextarea(el, opts) {
            var keydown = null;
            var keypress = null;

            if (!opts) opts = {};
            var textCallback = opts.text || noop;
            var keyCallback = opts.key || noop;
            var pasteCallback = opts.paste || noop;
            var onCut = opts.cut || noop;

            var textarea = $(el);
            var target = $(opts.container || textarea);

            // defer() runs fn immediately after the current thread.
            // flush() will run it even sooner, if possible.
            // flush always needs to be called before defer, and is called a
            // few other places besides.
            var timeout, deferredFn;

            function defer(fn) {
                timeout = setTimeout(fn);
                deferredFn = fn;
            }

            function flush() {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = undefined;
                    deferredFn();
                }
            }

            target.bind('keydown keypress input keyup focusout paste', flush);


            // -*- public methods -*- //
            function select(text) {
                flush();

                textarea.val(text);
                if (text) textarea[0].select();
            }

            // -*- helper subroutines -*- //

            // Determine whether there's a selection in the textarea.
            // This will always return false in IE < 9, which don't support
            // HTMLTextareaElement::selection{Start,End}.
            function hasSelection() {
                var dom = textarea[0];

                if (!('selectionStart' in dom)) return false;
                return dom.selectionStart !== dom.selectionEnd;
            }

            function popText(callback) {
                var text = textarea.val();
                textarea.val('');
                if (text) callback(text);
            }

            function handleKey() {
                keyCallback(stringify(keydown), keydown);
            }

            // -*- event handlers -*- //
            function onKeydown(e) {
                keydown = e;
                keypress = null;

                handleKey();
            }

            function onKeypress(e) {
                // call the key handler for repeated keypresses.
                // This excludes keypresses that happen directly
                // after keydown.  In that case, there will be
                // no previous keypress, so we skip it here
                if (keydown && keypress) handleKey();

                keypress = e;

                defer(function () {
                    // If there is a selection, the contents of the textarea couldn't
                    // possibly have just been typed in.
                    // This happens in browsers like Firefox and Opera that fire
                    // keypress for keystrokes that are not text entry and leave the
                    // selection in the textarea alone, such as Ctrl-C.
                    // Note: we assume that browsers that don't support hasSelection()
                    // also never fire keypress on keystrokes that are not text entry.
                    // This seems reasonably safe because:
                    // - all modern browsers including IE 9+ support hasSelection(),
                    //   making it extremely unlikely any browser besides IE < 9 won't
                    // - as far as we know IE < 9 never fires keypress on keystrokes
                    //   that aren't text entry, which is only as reliable as our
                    //   tests are comprehensive, but the IE < 9 way to do
                    //   hasSelection() is poorly documented and is also only as
                    //   reliable as our tests are comprehensive
                    // If anything like #40 or #71 is reported in IE < 9, see
                    // b1318e5349160b665003e36d4eedd64101ceacd8

                    //updated by Eli
                    //in Safari, when text is selected inside of the textarea
                    //and then a key is pressed, there's a brief moment where
                    //the new text is selected. This circumvents that problem, by
                    //trying again a moment later
                    //this should be a no-op except in Safari
                    //NOTE / TODO: this still seems to introduce a problem with vertical
                    //alignment. In DCG, try:
                    // * type "1"
                    // * highlight the "1"
                    // * type "/"
                    // note that vertical alignment of the icon is broken
                    // it's only fixed when another action is taken that changes
                    // vertical alignment (i.e. a division inside of one of the
                    // division signs)
                    if (hasSelection()) {
                        setTimeout(function () {
                            if (!hasSelection())
                                popText(textCallback);
                        });
                    } else {
                        popText(textCallback);
                    }

                    if (hasSelection()) return;

                    popText(textCallback);
                });
            }

            function onBlur() { keydown = keypress = null; }

            function onPaste(e) {
                // browsers are dumb.
                //
                // In Linux, middle-click pasting causes onPaste to be called,
                // when the textarea is not necessarily focused.  We focus it
                // here to ensure that the pasted text actually ends up in the
                // textarea.
                //
                // It's pretty nifty that by changing focus in this handler,
                // we can change the target of the default action.  (This works
                // on keydown too, FWIW).
                //
                // And by nifty, we mean dumb (but useful sometimes).
                textarea.focus();

                defer(function () {
                    popText(pasteCallback);
                });
            }

            // -*- attach event handlers -*- //
            target.bind({
                keydown: onKeydown,
                keypress: onKeypress,
                focusout: onBlur,
                cut: onCut,
                paste: onPaste
            });

            // -*- export public methods -*- //
            return {
                select: select
            };
        };
    } ());
    var Parser = P(function (_, _super, Parser) {
        // The Parser object is a wrapper for a parser function.
        // Externally, you use one to parse a string by calling
        //   var result = SomeParser.parse('Me Me Me! Parse Me!');
        // You should never call the constructor, rather you should
        // construct your Parser from the base parsers and the
        // parser combinator methods.

        function parseError(stream, message) {
            if (stream) {
                stream = "'" + stream + "'";
            }
            else {
                stream = 'EOF';
            }

            throw 'Parse Error: ' + message + ' at ' + stream;
        }

        _.init = function (body) { this._ = body; };

        _.parse = function (stream) {
            return this.skip(eof)._(stream, success, parseError);

            function success(stream, result) { return result; }
        };

        // -*- primitive combinators -*- //
        _.or = function (alternative) {
            pray('or is passed a parser', alternative instanceof Parser);

            var self = this;

            return Parser(function (stream, onSuccess, onFailure) {
                return self._(stream, onSuccess, failure);

                function failure(newStream) {
                    return alternative._(stream, onSuccess, onFailure);
                }
            });
        };

        _.then = function (next) {
            var self = this;

            return Parser(function (stream, onSuccess, onFailure) {
                return self._(stream, success, onFailure);

                function success(newStream, result) {
                    var nextParser = (next instanceof Parser ? next : next(result));
                    pray('a parser is returned', nextParser instanceof Parser);
                    return nextParser._(newStream, onSuccess, onFailure);
                }
            });
        };

        // -*- optimized iterative combinators -*- //
        _.many = function () {
            var self = this;

            return Parser(function (stream, onSuccess, onFailure) {
                var xs = [];
                while (self._(stream, success, failure));
                return onSuccess(stream, xs);

                function success(newStream, x) {
                    stream = newStream;
                    xs.push(x);
                    return true;
                }

                function failure() {
                    return false;
                }
            });
        };

        _.times = function (min, max) {
            if (arguments.length < 2) max = min;
            var self = this;

            return Parser(function (stream, onSuccess, onFailure) {
                var xs = [];
                var result = true;
                var failure;

                for (var i = 0; i < min; i += 1) {
                    result = self._(stream, success, firstFailure);
                    if (!result) return onFailure(stream, failure);
                }

                for (; i < max && result; i += 1) {
                    result = self._(stream, success, secondFailure);
                }

                return onSuccess(stream, xs);

                function success(newStream, x) {
                    xs.push(x);
                    stream = newStream;
                    return true;
                }

                function firstFailure(newStream, msg) {
                    failure = msg;
                    stream = newStream;
                    return false;
                }

                function secondFailure(newStream, msg) {
                    return false;
                }
            });
        };

        // -*- higher-level combinators -*- //
        _.result = function (res) { return this.then(succeed(res)); };
        _.atMost = function (n) { return this.times(0, n); };
        _.atLeast = function (n) {
            var self = this;
            return self.times(n).then(function (start) {
                return self.many().map(function (end) {
                    return start.concat(end);
                });
            });
        };

        _.map = function (fn) {
            return this.then(function (result) { return succeed(fn(result)); });
        };

        _.skip = function (two) {
            return this.then(function (result) { return two.result(result); });
        };

        // -*- primitive parsers -*- //
        var string = this.string = function (str) {
            var len = str.length;
            var expected = "expected '" + str + "'";

            return Parser(function (stream, onSuccess, onFailure) {
                var head = stream.slice(0, len);

                if (head === str) {
                    return onSuccess(stream.slice(len), head);
                }
                else {
                    return onFailure(stream, expected);
                }
            });
        };

        var regex = this.regex = function (re) {
            pray('regexp parser is anchored', re.toString().charAt(1) === '^');

            var expected = 'expected ' + re;

            return Parser(function (stream, onSuccess, onFailure) {
                var match = re.exec(stream);

                if (match) {
                    var result = match[0];
                    return onSuccess(stream.slice(result.length), result);
                }
                else {
                    return onFailure(stream, expected);
                }
            });
        };

        var succeed = Parser.succeed = function (result) {
            return Parser(function (stream, onSuccess) {
                return onSuccess(stream, result);
            });
        };

        var fail = Parser.fail = function (msg) {
            return Parser(function (stream, _, onFailure) {
                return onFailure(stream, msg);
            });
        };

        var letter = Parser.letter = regex(/^[a-z]/i);
        var letters = Parser.letters = regex(/^[a-z]*/i);
        var digit = Parser.digit = regex(/^[0-9]/);
        var digits = Parser.digits = regex(/^[0-9]*/);
        var whitespace = Parser.whitespace = regex(/^\s+/);
        var optWhitespace = Parser.optWhitespace = regex(/^\s*/);

        var any = Parser.any = Parser(function (stream, onSuccess, onFailure) {
            if (!stream) return onFailure(stream, 'expected any character');

            return onSuccess(stream.slice(1), stream.charAt(0));
        });

        var all = Parser.all = Parser(function (stream, onSuccess, onFailure) {
            return onSuccess('', stream);
        });

        var eof = Parser.eof = Parser(function (stream, onSuccess, onFailure) {
            if (stream) return onFailure(stream, 'expected EOF');

            return onSuccess(stream, stream);
        });
    });
    /*************************************************
    * Base classes of the MathQuill virtual DOM tree
    *
    * Only doing tree node manipulation via these
    * adopt/ disown methods guarantees well-formedness
    * of the tree.
    ************************************************/

    /**
    * MathQuill virtual-DOM tree-node abstract base class
    */
    var Node = P(function (_) {
        _.prev = 0;
        _.next = 0;
        _.parent = 0;
        _.firstChild = 0;
        _.lastChild = 0;

        _.children = function () {
            return Fragment(this.firstChild, this.lastChild);
        };

        _.eachChild = function (fn) {
            return this.children().each(fn);
        };

        _.foldChildren = function (fold, fn) {
            return this.children().fold(fold, fn);
        };

        _.adopt = function (parent, prev, next) {
            Fragment(this, this).adopt(parent, prev, next);
            return this;
        };

        _.disown = function () {
            Fragment(this, this).disown();
            return this;
        };
    });

    /**
    * An entity outside the virtual tree with one-way pointers (so it's only a
    * "view" of part of the tree, not an actual node/entity in the tree) that
    * delimits a doubly-linked list of sibling nodes.
    * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range
    * classes: like DocumentFragment, its contents must be sibling nodes
    * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),
    * but like Range, it has only one-way pointers to its contents, its contents
    * have no reference to it and in fact may still be in the visible tree (unlike
    * DocumentFragment, whose contents must be detached from the visible tree
    * and have their 'parent' pointers set to the DocumentFragment).
    */
    var Fragment = P(function (_) {
        _.first = 0;
        _.last = 0;

        _.init = function (first, last) {
            pray('no half-empty fragments', !first === !last);

            if (!first) return;

            pray('first node is passed to Fragment', first instanceof Node);
            pray('last node is passed to Fragment', last instanceof Node);
            pray('first and last have the same parent',
         first.parent === last.parent);

            this.first = first;
            this.last = last;
        };

        function prayWellFormed(parent, prev, next) {
            pray('a parent is always present', parent);
            pray('prev is properly set up', (function () {
                // either it's empty and next is the first child (possibly empty)
                if (!prev) return parent.firstChild === next;

                // or it's there and its next and parent are properly set up
                return prev.next === next && prev.parent === parent;
            })());

            pray('next is properly set up', (function () {
                // either it's empty and prev is the last child (possibly empty)
                if (!next) return parent.lastChild === prev;

                // or it's there and its next and parent are properly set up
                return next.prev === prev && next.parent === parent;
            })());
        }

        _.adopt = function (parent, prev, next) {
            prayWellFormed(parent, prev, next);

            var self = this;
            self.disowned = false;

            var first = self.first;
            if (!first) return this;

            var last = self.last;

            if (prev) {
                // NB: this is handled in the ::each() block
                // prev.next = first
            } else {
                parent.firstChild = first;
            }

            if (next) {
                next.prev = last;
            } else {
                parent.lastChild = last;
            }

            self.last.next = next;

            self.each(function (el) {
                el.prev = prev;
                el.parent = parent;
                if (prev) prev.next = el;

                prev = el;
            });

            return self;
        };

        _.disown = function () {
            var self = this;
            var first = self.first;

            // guard for empty and already-disowned fragments
            if (!first || self.disowned) return self;

            self.disowned = true;

            var last = self.last;
            var parent = first.parent;

            prayWellFormed(parent, first.prev, first);
            prayWellFormed(parent, last, last.next);

            if (first.prev) {
                first.prev.next = last.next;
            } else {
                parent.firstChild = last.next;
            }

            if (last.next) {
                last.next.prev = first.prev;
            } else {
                parent.lastChild = first.prev;
            }

            return self;
        };

        _.each = function (fn) {
            var self = this;
            var el = self.first;
            if (!el) return self;

            for (; el !== self.last.next; el = el.next) {
                if (fn.call(self, el) === false) break;
            }

            return self;
        };

        _.fold = function (fold, fn) {
            this.each(function (el) {
                fold = fn.call(this, fold, el);
            });

            return fold;
        };
    });
    /*************************************************
    * Abstract classes of math blocks and commands.
    ************************************************/

    var uuid = (function () {
        var id = 0;

        return function () { return id += 1; };
    })();

    /**
    * Math tree node base class.
    * Some math-tree-specific extensions to Node.
    * Both MathBlock's and MathCommand's descend from it.
    */
    var MathElement = P(Node, function (_) {
        _.init = function (obj) {
            this.id = uuid();
            MathElement[this.id] = this;
        };

        _.toString = function () {
            return '[MathElement ' + this.id + ']';
        };

        _.bubble = function (event /*, args... */) {
            var args = __slice.call(arguments, 1);

            for (var ancestor = this; ancestor; ancestor = ancestor.parent) {
                var res = ancestor[event] && ancestor[event].apply(ancestor, args);
                if (res === false) break;
            }

            return this;
        };

        _.postOrder = function (fn /*, args... */) {
            var args = __slice.call(arguments, 1);

            if (typeof fn === 'string') {
                var methodName = fn;
                fn = function (el) {
                    if (methodName in el) el[methodName].apply(el, arguments);
                };
            }

            (function recurse(desc) {
                desc.eachChild(recurse);
                fn(desc);
            })(this);
        };

        _.jQ = $();
        _.jQadd = function (jQ) { this.jQ = this.jQ.add(jQ); };

        this.jQize = function (html) {
            // Sets the .jQ of the entire math subtree rooted at this command.
            // Expects .createBlocks() to have been called already, since it
            // calls .html().
            var jQ = $(html);
            jQ.find('*').andSelf().each(function () {
                var jQ = $(this),
        cmdId = jQ.attr('mathquill-command-id'),
        blockId = jQ.attr('mathquill-block-id');
                if (cmdId) MathElement[cmdId].jQadd(jQ);
                if (blockId) MathElement[blockId].jQadd(jQ);
            });
            return jQ;
        };

        _.finalizeInsert = function () {
            var self = this;
            self.postOrder('finalizeTree');

            // note: this order is important.
            // empty elements need the empty box provided by blur to
            // be present in order for their dimensions to be measured
            // correctly in redraw.
            self.postOrder('blur');

            // adjust context-sensitive spacing
            self.postOrder('respace');
            if (self.next.respace) self.next.respace();
            if (self.prev.respace) self.prev.respace();

            self.postOrder('redraw');
            self.bubble('redraw');
        };
    });

    /**
    * Commands and operators, like subscripts, exponents, or fractions.
    * Descendant commands are organized into blocks.
    */
    var MathCommand = P(MathElement, function (_, _super) {
        _.init = function (ctrlSeq, htmlTemplate, textTemplate) {
            var cmd = this;
            _super.init.call(cmd);

            if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;
            if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;
            if (textTemplate) cmd.textTemplate = textTemplate;
        };

        // obvious methods
        _.replaces = function (replacedFragment) {
            replacedFragment.disown();
            this.replacedFragment = replacedFragment;
        };
        _.isEmpty = function () {
            return this.foldChildren(true, function (isEmpty, child) {
                return isEmpty && child.isEmpty();
            });
        };

        _.parser = function () {
            var block = latexMathParser.block;
            var self = this;

            return block.times(self.numBlocks()).map(function (blocks) {
                self.blocks = blocks;

                for (var i = 0; i < blocks.length; i += 1) {
                    blocks[i].adopt(self, self.lastChild, 0);
                }

                return self;
            });
        };

        // createBefore(cursor) and the methods it calls
        _.createBefore = function (cursor) {
            var cmd = this;
            var replacedFragment = cmd.replacedFragment;

            cmd.createBlocks();
            MathElement.jQize(cmd.html());
            if (replacedFragment) {
                replacedFragment.adopt(cmd.firstChild, 0, 0);
                replacedFragment.jQ.appendTo(cmd.firstChild.jQ);
            }

            cursor.jQ.before(cmd.jQ);
            cursor.prev = cmd.adopt(cursor.parent, cursor.prev, cursor.next);

            cmd.finalizeInsert(cursor);

            cmd.placeCursor(cursor);
        };
        _.createBlocks = function () {
            var cmd = this,
      numBlocks = cmd.numBlocks(),
      blocks = cmd.blocks = Array(numBlocks);

            for (var i = 0; i < numBlocks; i += 1) {
                var newBlock = blocks[i] = MathBlock();
                newBlock.adopt(cmd, cmd.lastChild, 0);
            }
        };
        _.respace = noop; //placeholder for context-sensitive spacing
        _.placeCursor = function (cursor) {
            //append the cursor to the first empty child, or if none empty, the last one
            cursor.appendTo(this.foldChildren(this.firstChild, function (prev, child) {
                return prev.isEmpty() ? prev : child;
            }));
        };

        // remove()
        _.remove = function () {
            this.disown()
            this.jQ.remove();

            this.postOrder(function (el) { delete MathElement[el.id]; });

            return this;
        };

        // methods involved in creating and cross-linking with HTML DOM nodes
        /*
        They all expect an .htmlTemplate like
        '<span>&0</span>'
        or
        '<span><span>&0</span><span>&1</span></span>'

        See html.test.js for more examples.

        Requirements:
        - For each block of the command, there must be exactly one "block content
        marker" of the form '&<number>' where <number> is the 0-based index of the
        block. (Like the LaTeX \newcommand syntax, but with a 0-based rather than
        1-based index, because JavaScript because C because Dijkstra.)
        - The block content marker must be the sole contents of the containing
        element, there can't even be surrounding whitespace, or else we can't
        guarantee sticking to within the bounds of the block content marker when
        mucking with the HTML DOM.
        - The HTML not only must be well-formed HTML (of course), but also must
        conform to the XHTML requirements on tags, specifically all tags must
        either be self-closing (like '<br/>') or come in matching pairs.
        Close tags are never optional.

        Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',
        your HTML template would have to have '&amp;123'.
        */
        _.numBlocks = function () {
            var matches = this.htmlTemplate.match(/&\d+/g);
            return matches ? matches.length : 0;
        };
        _.html = function () {
            // Render the entire math subtree rooted at this command, as HTML.
            // Expects .createBlocks() to have been called already, since it uses the
            // .blocks array of child blocks.
            //
            // See html.test.js for example templates and intended outputs.
            //
            // Given an .htmlTemplate as described above,
            // - insert the mathquill-command-id attribute into all top-level tags,
            //   which will be used to set this.jQ in .jQize().
            //   This is straightforward:
            //     * tokenize into tags and non-tags
            //     * loop through top-level tokens:
            //         * add #cmdId attribute macro to top-level self-closing tags
            //         * else add #cmdId attribute macro to top-level open tags
            //             * skip the matching top-level close tag and all tag pairs
            //               in between
            // - for each block content marker,
            //     + replace it with the contents of the corresponding block,
            //       rendered as HTML
            //     + insert the mathquill-block-id attribute into the containing tag
            //   This is even easier, a quick regex replace, since block tags cannot
            //   contain anything besides the block content marker.
            //
            // Two notes:
            // - The outermost loop through top-level tokens should never encounter any
            //   top-level close tags, because we should have first encountered a
            //   matching top-level open tag, all inner tags should have appeared in
            //   matching pairs and been skipped, and then we should have skipped the
            //   close tag in question.
            // - All open tags should have matching close tags, which means our inner
            //   loop should always encounter a close tag and drop nesting to 0. If
            //   a close tag is missing, the loop will continue until i >= tokens.length
            //   and token becomes undefined. This will not infinite loop, even in
            //   production without pray(), because it will then TypeError on .slice().

            var cmd = this;
            var blocks = cmd.blocks;
            var cmdId = ' mathquill-command-id=' + cmd.id;
            var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);

            pray('no unmatched angle brackets', tokens.join('') === this.htmlTemplate);

            // add cmdId to all top-level tags
            for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {
                // top-level self-closing tags
                if (token.slice(-2) === '/>') {
                    tokens[i] = token.slice(0, -2) + cmdId + '/>';
                }
                // top-level open tags
                else if (token.charAt(0) === '<') {
                    pray('not an unmatched top-level close tag', token.charAt(1) !== '/');

                    tokens[i] = token.slice(0, -1) + cmdId + '>';

                    // skip matching top-level close tag and all tag pairs in between
                    var nesting = 1;
                    do {
                        i += 1, token = tokens[i];
                        pray('no missing close tags', token);
                        // close tags
                        if (token.slice(0, 2) === '</') {
                            nesting -= 1;
                        }
                        // non-self-closing open tags
                        else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {
                            nesting += 1;
                        }
                    } while (nesting > 0);
                }
            }
            return tokens.join('').replace(/>&(\d+)/g, function ($0, $1) {
                return ' mathquill-block-id=' + blocks[$1].id + '>' + blocks[$1].join('html');
            });
        };

        // methods to export a string representation of the math tree
        _.latex = function () {
            return this.foldChildren(this.ctrlSeq, function (latex, child) {
                return latex + '{' + (child.latex() || ' ') + '}';
            });
        };
        _.textTemplate = [''];
        _.text = function () {
            var i = 0;
            return this.foldChildren(this.textTemplate[i], function (text, child) {
                i += 1;
                var child_text = child.text();
                if (text && this.textTemplate[i] === '('
          && child_text[0] === '(' && child_text.slice(-1) === ')')
                    return text + child_text.slice(1, -1) + this.textTemplate[i];
                return text + child.text() + (this.textTemplate[i] || '');
            });
        };
    });

    /**
    * Lightweight command without blocks or children.
    */
    var Symbol = P(MathCommand, function (_, _super) {
        _.init = function (ctrlSeq, html, text) {
            if (!text) text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;

            _super.init.call(this, ctrlSeq, html, [text]);
        };

        _.parser = function () { return Parser.succeed(this); };
        _.numBlocks = function () { return 0; };

        _.replaces = function (replacedFragment) {
            replacedFragment.remove();
        };
        _.createBlocks = noop;
        _.latex = function () { return this.ctrlSeq; };
        _.text = function () { return this.textTemplate; };
        _.placeCursor = noop;
        _.isEmpty = function () { return true; };
    });

    /**
    * Children and parent of MathCommand's. Basically partitions all the
    * symbols and operators that descend (in the Math DOM tree) from
    * ancestor operators.
    */
    var MathBlock = P(MathElement, function (_) {
        _.join = function (methodName) {
            return this.foldChildren('', function (fold, child) {
                return fold + child[methodName]();
            });
        };
        _.latex = function () { return this.join('latex'); };
        _.text = function () {
            return this.firstChild === this.lastChild ?
      this.firstChild.text() :
      '(' + this.join('text') + ')'
    ;
        };
        _.isEmpty = function () {
            return this.firstChild === 0 && this.lastChild === 0;
        };
        _.focus = function () {
            this.jQ.addClass('hasCursor');
            this.jQ.removeClass('empty');

            return this;
        };
        _.blur = function () {
            this.jQ.removeClass('hasCursor');
            if (this.isEmpty())
                this.jQ.addClass('empty');

            return this;
        };
    });

    /**
    * Math tree fragment base class.
    * Some math-tree-specific extensions to Fragment.
    */
    var MathFragment = P(Fragment, function (_, _super) {
        _.init = function (first, last) {
            // just select one thing if only one argument
            _super.init.call(this, first, last || first);
            this.jQ = this.fold($(), function (jQ, child) { return child.jQ.add(jQ); });
        };
        _.latex = function () {
            return this.fold('', function (latex, el) { return latex + el.latex(); });
        };
        _.remove = function () {
            this.jQ.remove();

            this.each(function (el) {
                el.postOrder(function (desc) {
                    delete MathElement[desc.id];
                });
            });

            return this.disown();
        };
    });
    /*********************************************
    * Root math elements with event delegation.
    ********************************************/

    function createRoot(jQ, root, textbox, editable) {
        var contents = jQ.contents().detach();

        if (!textbox) {
            jQ.addClass('mathquill-rendered-math');
        }

        root.jQ = jQ.attr(mqBlockId, root.id);
        root.revert = function () {
            jQ.empty().unbind('.mathquill')
      .removeClass('mathquill-rendered-math mathquill-editable mathquill-textbox')
      .append(contents);
        };

        var cursor = root.cursor = Cursor(root);

        root.renderLatex(contents.text());

        var is_ios = navigator.userAgent.match(/(iPad|iPhone|iPod)/i) !== null;
        var is_android = navigator.userAgent.match(/(Android|Silk|Kindle)/i) !== null;

        var textareaSpan = root.textarea = (is_ios || is_android) ?
      $('<span class="textarea"><span tabindex=0></span></span>')
    : $('<span class="textarea"><textarea></textarea></span>'),
    textarea = textareaSpan.children();

        /******
        * TODO [Han]: Document this
        */
        var textareaSelectionTimeout, prevLatex;
        root.selectionChanged = function () {
            if (textareaSelectionTimeout === undefined) {
                textareaSelectionTimeout = setTimeout(setTextareaSelection);
            }
            forceIERedraw(jQ[0]);
        };
        function setTextareaSelection() {
            textareaSelectionTimeout = undefined;
            var latex = cursor.selection ? '$' + cursor.selection.latex() + '$' : '';
            if (latex === prevLatex) return;
            textareaManager.select(latex);
            prevLatex = latex;
            root.triggerSpecialEvent('selectionChanged');
        }

        //prevent native selection except textarea
        jQ.bind('selectstart.mathquill', function (e) {
            if (e.target !== textarea[0]) e.preventDefault();
            e.stopPropagation();
        });

        //drag-to-select event handling
        var anticursor, blink = cursor.blink;
        jQ.bind('mousedown.mathquill', function (e) {
            function mousemove(e) {
                cursor.seek($(e.target), e.pageX, e.pageY);

                if (cursor.prev !== anticursor.prev
          || cursor.parent !== anticursor.parent) {
                    cursor.selectFrom(anticursor);
                }

                e.preventDefault();
            }

            // docmousemove is attached to the document, so that
            // selection still works when the mouse leaves the window.
            function docmousemove(e) {
                // [Han]: i delete the target because of the way seek works.
                // it will not move the mouse to the target, but will instead
                // just seek those X and Y coordinates.  If there is a target,
                // it will try to move the cursor to document, which will not work.
                // cursor.seek needs to be refactored.
                delete e.target;

                return mousemove(e);
            }

            function mouseup(e) {
                anticursor = undefined;
                cursor.blink = blink;
                if (!cursor.selection) {
                    if (editable) {
                        cursor.show();
                    }
                    else {
                        textareaSpan.detach();
                    }
                }

                // delete the mouse handlers now that we're not dragging anymore
                jQ.unbind('mousemove', mousemove);
                $(e.target.ownerDocument).unbind('mousemove', docmousemove).unbind('mouseup', mouseup);
            }

            setTimeout(function () { if (root.blurred) textarea.focus(); });
            // preventDefault won't prevent focus on mousedown in IE<9
            // that means immediately after this mousedown, whatever was
            // mousedown-ed will receive focus
            // http://bugs.jquery.com/ticket/10345

            cursor.blink = noop;
            cursor.seek($(e.target), e.pageX, e.pageY);

            anticursor = { parent: cursor.parent, prev: cursor.prev, next: cursor.next };

            if (!editable) jQ.prepend(textareaSpan);

            jQ.mousemove(mousemove);
            $(e.target.ownerDocument).mousemove(docmousemove).mouseup(mouseup);

            e.preventDefault();
        });

        if (!editable) {
            var textareaManager = manageTextarea(textarea, { container: jQ });
            jQ.bind('cut paste', false).bind('copy', setTextareaSelection)
      .prepend('<span class="selectable">$' + root.latex() + '$</span>');
            textarea.blur(function () {
                cursor.clearSelection();
                setTimeout(detach); //detaching during blur explodes in WebKit
            });
            function detach() {
                textareaSpan.detach();
            }
            return;
        }

        var textareaManager = manageTextarea(textarea, {
            container: jQ,
            key: function (key, evt) {
                cursor.parent.bubble('onKey', key, evt);
            },
            text: function (text) {
                cursor.parent.bubble('onText', text);
            },
            cut: function (e) {
                if (cursor.selection) {
                    setTimeout(function () {
                        cursor.prepareEdit();
                        cursor.parent.bubble('redraw');
                        root.triggerSpecialEvent('render');
                    });
                }

                e.stopPropagation();
                root.triggerSpecialEvent('render');
            },
            paste: function (text) {
                // FIXME HACK the parser in RootTextBlock needs to be moved to
                // Cursor::writeLatex or something so this'll work with
                // MathQuill textboxes
                if (text.slice(0, 1) === '$' && text.slice(-1) === '$') {
                    text = text.slice(1, -1);
                }

                cursor.writeLatex(text).show();
                root.triggerSpecialEvent('render');
            }
        });

        jQ.prepend(textareaSpan);

        //root CSS classes
        jQ.addClass('mathquill-editable');
        if (textbox)
            jQ.addClass('mathquill-textbox');

        //focus and blur handling
        textarea.focus(function (e) {
            root.blurred = false;
            if (!cursor.parent)
                cursor.appendTo(root);
            cursor.parent.jQ.addClass('hasCursor');
            if (cursor.selection) {
                cursor.selection.jQ.removeClass('blur');
                setTimeout(root.selectionChanged); //re-select textarea contents after tabbing away and back
            }
            else
                cursor.show();
        }).blur(function (e) {
            root.blurred = true;
            cursor.hide().parent.blur();
            if (cursor.selection)
                cursor.selection.jQ.addClass('blur');
        }).blur();

        jQ.bind('select_all', function (e) {
            cursor.prepareMove().appendTo(root);
            while (cursor.prev) cursor.selectLeft();
        })
  .bind('custom_paste', function (e, text) {
      if (text.slice(0, 1) === '$' && text.slice(-1) === '$') {
          text = text.slice(1, -1);
      }

      cursor.writeLatex(text).show();
      root.triggerSpecialEvent('render');
  });
    }

    var RootMathBlock = P(MathBlock, function (_, _super) {
        _.latex = function () {
            return _super.latex.call(this).replace(/(\\[a-z]+) (?![a-z])/ig, '$1');
        };
        _.text = function () {
            return this.foldChildren('', function (text, child) {
                return text + child.text();
            });
        };
        _.renderLatex = function (latex) {
            var jQ = this.jQ;

            jQ.children().slice(1).remove();
            this.firstChild = this.lastChild = 0;

            this.cursor.appendTo(this).writeLatex(latex);
        };
        _.up = function () { this.triggerSpecialEvent('upPressed'); };
        _.down = function () { this.triggerSpecialEvent('downPressed'); };
        _.moveOutOf = function (dir) { this.triggerSpecialEvent(dir + 'Pressed'); };
        _.onKey = function (key, e) {
            switch (key) {
                case 'Ctrl-Shift-Backspace':
                case 'Ctrl-Backspace':
                    while (this.cursor.prev || this.cursor.selection) {
                        this.cursor.backspace();
                    }
                    break;

                case 'Shift-Backspace':
                case 'Backspace':
                    this.cursor.backspace();
                    this.triggerSpecialEvent('render');
                    break;

                // Tab or Esc -> go one block right if it exists, else escape right. 
                case 'Esc':
                case 'Tab':
                    var parent = this.cursor.parent;
                    // cursor is in root editable, continue default
                    if (parent === this.cursor.root) return;

                    this.cursor.prepareMove();
                    if (parent.next) {
                        // go one block right
                        this.cursor.prependTo(parent.next);
                    } else {
                        // get out of the block
                        this.cursor.insertAfter(parent.parent);
                    }
                    break;

                // Shift-Tab -> go one block left if it exists, else escape left. 
                case 'Shift-Tab':
                case 'Shift-Esc':
                    var parent = this.cursor.parent;
                    //cursor is in root editable, continue default
                    if (parent === this.cursor.root) return;

                    this.cursor.prepareMove();
                    if (parent.prev) {
                        // go one block left
                        this.cursor.appendTo(parent.prev);
                    } else {
                        //get out of the block
                        this.cursor.insertBefore(parent.parent);
                    }
                    break;

                // Prevent newlines from showing up 
                case 'Enter': this.triggerSpecialEvent('enterPressed'); break;


                // End -> move to the end of the current block. 
                case 'End':
                    this.cursor.prepareMove().appendTo(this.cursor.parent);
                    break;

                // Ctrl-End -> move all the way to the end of the root block. 
                case 'Ctrl-End':
                    this.cursor.prepareMove().appendTo(this);
                    break;

                // Shift-End -> select to the end of the current block. 
                case 'Shift-End':
                    while (this.cursor.next) {
                        this.cursor.selectRight();
                    }
                    break;

                // Ctrl-Shift-End -> select to the end of the root block. 
                case 'Ctrl-Shift-End':
                    while (this.cursor.next || this.cursor.parent !== this) {
                        this.cursor.selectRight();
                    }
                    break;

                // Home -> move to the start of the root block or the current block. 
                case 'Home':
                    this.cursor.prepareMove().prependTo(this.cursor.parent);
                    break;

                // Ctrl-Home -> move to the start of the current block. 
                case 'Ctrl-Home':
                    this.cursor.prepareMove().prependTo(this);
                    break;

                // Shift-Home -> select to the start of the current block. 
                case 'Shift-Home':
                    while (this.cursor.prev) {
                        this.cursor.selectLeft();
                    }
                    break;

                // Ctrl-Shift-Home -> move to the start of the root block. 
                case 'Ctrl-Shift-Home':
                    while (this.cursor.prev || this.cursor.parent !== this) {
                        this.cursor.selectLeft();
                    }
                    break;

                case 'Left': this.cursor.moveLeft(); break;
                case 'Shift-Left': this.cursor.selectLeft(); break;
                case 'Ctrl-Left': break;
                case 'Meta-Left': break;

                case 'Right': this.cursor.moveRight(); break;
                case 'Shift-Right': this.cursor.selectRight(); break;
                case 'Ctrl-Right': break;
                case 'Meta-Right': break;

                case 'Up': this.cursor.moveUp(); break;
                case 'Down': this.cursor.moveDown(); break;

                case 'Shift-Up':
                    if (this.cursor.prev) {
                        while (this.cursor.prev) this.cursor.selectLeft();
                    } else {
                        this.cursor.selectLeft();
                    }

                case 'Shift-Down':
                    if (this.cursor.next) {
                        while (this.cursor.next) this.cursor.selectRight();
                    }
                    else {
                        this.cursor.selectRight();
                    }

                case 'Ctrl-Up': break;
                case 'Meta-Up': break;
                case 'Ctrl-Down': break;
                case 'Meta-Down': break;

                case 'Ctrl-Shift-Del':
                case 'Ctrl-Del':
                    while (this.cursor.next || this.cursor.selection) {
                        this.cursor.deleteForward();
                    }
                    this.triggerSpecialEvent('render');
                    break;

                case 'Shift-Del':
                case 'Del':
                    this.cursor.deleteForward();
                    this.triggerSpecialEvent('render');
                    break;

                case 'Meta-A':
                case 'Ctrl-A':
                    //so not stopPropagation'd at RootMathCommand
                    if (this !== this.cursor.root) return;

                    this.cursor.prepareMove().appendTo(this);
                    while (this.cursor.prev) this.cursor.selectLeft();
                    break;

                default:
                    return false;
            }
            e.preventDefault();
            return false;
        };
        _.onText = function (ch) {
            //Hack by Eli: don't exponentiate if there's nothing before the cursor
            if ((ch == '^' || ch == '_') && !this.cursor.prev) return;

            //Hack #2 by Eli: if you type '+' or '-' or '=' in an exponent, break out of it
            if ((ch == '+' || ch == '=' || ch == '-' || ch == '<' || ch == '>') && this.cursor.parent.parent.ctrlSeq === '^'
      && !this.cursor.next && this.cursor.prev
    ) {
                this.cursor.moveRight();
            }

            //Hack #3 by Eli: if you type "^" just after a superscript, behave as though you just pressed up
            //note: n
            if (ch === '^' && this.cursor.prev instanceof SupSub &&
            //note: need both of these, because if it's a superscript and subscript,
            //those could appear in either order
      (this.cursor.prev.ctrlSeq === '^' || this.cursor.prev.prev.ctrlSeq === '^')) {
                this.cursor.moveUp();
                return;
            }
            if (ch === '_' && this.cursor.prev instanceof SupSub &&
            //note: need both of these, because if it's a superscript and subscript,
            //those could appear in either order
      (this.cursor.prev.ctrlSeq === '_' || this.cursor.prev.prev.ctrlSeq === '_')) {
                this.cursor.moveDown();
                return;
            }



            this.cursor.write(ch);
            this.triggerSpecialEvent('render');
            return false;
        };

        //triggers a special event occured:
        //  1) pressed up and was at 'top' of equation
        //  2) pressed down and was at 'bottom' of equation
        //  3) pressed backspace and equation was empty
        //  4) the equation was rendered
        //  5) etc
        _.triggerSpecialEvent = function (eventName) {
            var jQ = this.jQ;
            setTimeout(function () { jQ.trigger(eventName); }, 1);
        };
    });

    var RootMathCommand = P(MathCommand, function (_, _super) {
        _.init = function (cursor) {
            _super.init.call(this, '$');
            this.cursor = cursor;
        };
        _.htmlTemplate = '<span class="mathquill-rendered-math">&0</span>';
        _.createBlocks = function () {
            this.firstChild =
    this.lastChild =
      RootMathBlock();

            this.blocks = [this.firstChild];

            this.firstChild.parent = this;

            var cursor = this.firstChild.cursor = this.cursor;
            this.firstChild.onText = function (ch) {
                if (ch !== '$' || cursor.parent !== this)
                    cursor.write(ch);
                else if (this.isEmpty()) {
                    cursor.insertAfter(this.parent).backspace()
          .insertNew(VanillaSymbol('\\$', '$')).show();
                }
                else if (!cursor.next)
                    cursor.insertAfter(this.parent);
                else if (!cursor.prev)
                    cursor.insertBefore(this.parent);
                else
                    cursor.write(ch);

                return false;
            };
        };
        _.latex = function () {
            return '$' + this.firstChild.latex() + '$';
        };
    });

    var RootTextBlock = P(MathBlock, function (_) {
        _.renderLatex = function (latex) {
            var self = this
            var cursor = self.cursor;
            self.jQ.children().slice(1).remove();
            self.firstChild = self.lastChild = 0;
            cursor.show().appendTo(self);

            var regex = Parser.regex;
            var string = Parser.string;
            var eof = Parser.eof;
            var all = Parser.all;

            // Parser RootMathCommand
            var mathMode = string('$').then(latexMathParser)
            // because TeX is insane, math mode doesn't necessarily
            // have to end.  So we allow for the case that math mode
            // continues to the end of the stream.
      .skip(string('$').or(eof))
      .map(function (block) {
          // HACK FIXME: this shouldn't have to have access to cursor
          var rootMathCommand = RootMathCommand(cursor);

          rootMathCommand.createBlocks();
          var rootMathBlock = rootMathCommand.firstChild;
          block.children().adopt(rootMathBlock, 0, 0);

          return rootMathCommand;
      })
    ;

            var escapedDollar = string('\\$').result('$');
            var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);
            var latexText = mathMode.or(textChar).many();
            var commands = latexText.skip(eof).or(all.result(false)).parse(latex);

            if (commands) {
                for (var i = 0; i < commands.length; i += 1) {
                    commands[i].adopt(self, self.lastChild, 0);
                }

                var html = self.join('html');
                MathElement.jQize(html).appendTo(self.jQ);

                this.finalizeInsert();
            }
        };
        _.onKey = RootMathBlock.prototype.onKey;
        _.onText = function (ch) {
            this.cursor.prepareEdit();
            if (ch === '$')
                this.cursor.insertNew(RootMathCommand(this.cursor));
            else
                this.cursor.insertNew(VanillaSymbol(ch));

            return false;
        };
    });
    /***************************
    * Commands and Operators.
    **************************/

    var CharCmds = {}, LatexCmds = {}; //single character commands, LaTeX commands

    var scale, // = function(jQ, x, y) { ... }
    //will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,
    //or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to
    //increasing the fontSize to match the vertical Y scaling factor.

    //ideas from http://github.com/louisremi/jquery.transform.js
    //see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx

  forceIERedraw = noop,
  div = document.createElement('div'),
  div_style = div.style,
  transformPropNames = {
      transform: 1,
      WebkitTransform: 1,
      MozTransform: 1,
      OTransform: 1,
      msTransform: 1
  },
  transformPropName;

    for (var prop in transformPropNames) {
        if (prop in div_style) {
            transformPropName = prop;
            break;
        }
    }

    if (transformPropName) {
        scale = function (jQ, x, y) {
            jQ.css(transformPropName, 'scale(' + x + ',' + y + ')');
        };
    }
    else if ('filter' in div_style) { //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms
        forceIERedraw = function (el) { el.className = el.className; };
        scale = function (jQ, x, y) { //NOTE: assumes y > x
            x /= (1 + (y - 1) / 2);
            jQ.css('fontSize', y + 'em');
            if (!jQ.hasClass('matrixed-container')) {
                jQ.addClass('matrixed-container')
      .wrapInner('<span class="matrixed"></span>');
            }
            var innerjQ = jQ.children()
    .css('filter', 'progid:DXImageTransform.Microsoft'
        + '.Matrix(M11=' + x + ",SizingMethod='auto expand')"
    );
            function calculateMarginRight() {
                jQ.css('marginRight', (innerjQ.width() - 1) * (x - 1) / x + 'px');
            }
            calculateMarginRight();
            var intervalId = setInterval(calculateMarginRight);
            $(window).load(function () {
                clearTimeout(intervalId);
                calculateMarginRight();
            });
        };
    }
    else {
        scale = function (jQ, x, y) {
            jQ.css('fontSize', y + 'em');
        };
    }

    var Style = P(MathCommand, function (_, _super) {
        _.init = function (ctrlSeq, tagName, attrs) {
            _super.init.call(this, ctrlSeq, '<' + tagName + ' ' + attrs + '>&0</' + tagName + '>');
        };
    });

    //fonts
    LatexCmds.mathrm = bind(Style, '\\mathrm', 'span', 'class="roman font"');
    LatexCmds.mathit = bind(Style, '\\mathit', 'i', 'class="font"');
    LatexCmds.mathbf = bind(Style, '\\mathbf', 'b', 'class="font"');
    LatexCmds.mathsf = bind(Style, '\\mathsf', 'span', 'class="sans-serif font"');
    LatexCmds.mathtt = bind(Style, '\\mathtt', 'span', 'class="monospace font"');
    //text-decoration
    LatexCmds.underline = bind(Style, '\\underline', 'span', 'class="non-leaf underline"');
    LatexCmds.overline = LatexCmds.bar = bind(Style, '\\overline', 'span', 'class="non-leaf overline"');

    var SupSub = P(MathCommand, function (_, _super) {
        _.init = function (ctrlSeq, tag, text) {
            _super.init.call(this, ctrlSeq, '<' + tag + ' class="non-leaf"><span class="non-leaf ' + tag + '">&0</span></' + tag + '>', [text]);
        };
        _.finalizeTree = function () {
            //TODO: use inheritance
            pray('SupSub is only _ and ^',
      this.ctrlSeq === '^' || this.ctrlSeq === '_'
    );

            if (this.prev instanceof BigSymbol && this.prev.ctrlSeq !== '\\int ') {
                var bigSym = this.prev, block = this.firstChild;
                if (this.ctrlSeq === '_') {
                    block.adopt(bigSym, 0, bigSym.firstChild);
                    $('<span class="from"></span>').append(block.jQ.removeClass('sub'))
        .appendTo(bigSym.jQ);
                    bigSym.down = block;
                    block.up = insertAfterUnlessAtBeginning;
                }
                else {
                    block.adopt(bigSym, bigSym.lastChild, 0);
                    $('<span class="to"></span>').append(block.jQ.removeClass('sup'))
        .prependTo(bigSym.jQ);
                    bigSym.up = block;
                    block.down = insertAfterUnlessAtBeginning;
                }
                this.disown();
                this.respace = noop; // don't let SupSub::respace reset the .up/.down ptrs
                return;
            }

            if (this.ctrlSeq === '_') {
                this.down = this.firstChild;
                this.firstChild.up = insertBeforeUnlessAtEnd;
            }
            else {
                this.up = this.firstChild;
                this.firstChild.down = insertBeforeUnlessAtEnd;
            }
        };
        function insertAfterUnlessAtBeginning(cursor) {
            // cursor.insertAfter(cmd), unless cursor at the beginning of block, and every
            // ancestor cmd is at the beginning of every ancestor block
            var cmd = this.parent, ancestorCmd = cursor;
            do {
                if (ancestorCmd.prev) {
                    cursor.insertAfter(cmd);
                    return false;
                }
                ancestorCmd = ancestorCmd.parent.parent;
            } while (ancestorCmd !== cmd);
            cursor.insertBefore(cmd);
            return false;
        }
        function insertBeforeUnlessAtEnd(cursor) {
            // cursor.insertBefore(cmd), unless cursor at the end of block, and every
            // ancestor cmd is at the end of every ancestor block
            var cmd = this.parent, ancestorCmd = cursor;
            do {
                if (ancestorCmd.next) {
                    cursor.insertBefore(cmd);
                    return false;
                }
                ancestorCmd = ancestorCmd.parent.parent;
            } while (ancestorCmd !== cmd);
            cursor.insertAfter(cmd);
            return false;
        }
        _.latex = function () {
            if (this.ctrlSeq === '_' && this.respaced) return '';

            var latex = '';

            if (this.ctrlSeq === '^' && this.next.respaced) {
                var block = this.next.firstChild.latex();
                if (block.length === 1) latex += '_' + block;
                else latex += '_{' + block + '}';
            }

            var block = this.firstChild.latex();
            if (block.length === 1) latex += this.ctrlSeq + block;
            else latex += this.ctrlSeq + '{' + (block || ' ') + '}';

            return latex;
        };
        _.redraw = function () {
            if (this.prev)
                this.prev.respace();
            //SupSub::respace recursively calls respace on all the following SupSubs
            //so if prev is a SupSub, no need to call respace on this or following nodes
            if (!(this.prev instanceof SupSub)) {
                this.respace();
                //and if next is a SupSub, then this.respace() will have already called
                //this.next.respace()
                if (this.next && !(this.next instanceof SupSub))
                    this.next.respace();
            }
        };
        _.respace = function () {
            if (
      this.prev.ctrlSeq === '\\int ' || (
        this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq
        && this.prev.prev && this.prev.prev.ctrlSeq === '\\int '
      )
    ) {
                if (!this['int']) {
                    this['int'] = true;
                    this.jQ.addClass('int');
                }
            }
            else {
                if (this['int']) {
                    this['int'] = false;
                    this.jQ.removeClass('int');
                }
            }

            this.respaced = this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq && !this.prev.respaced;
            if (this.respaced) {
                var fontSize = +this.jQ.css('fontSize').slice(0, -2),
        prevWidth = this.prev.jQ.outerWidth(),
        thisWidth = this.jQ.outerWidth();
                this.jQ.css({
                    left: (this['int'] && this.ctrlSeq === '_' ? -.25 : 0) - prevWidth / fontSize + 'em',
                    marginRight: .1 - min(thisWidth, prevWidth) / fontSize + 'em'
                    //1px extra so it doesn't wrap in retarded browsers (Firefox 2, I think)
                });
            }
            else if (this['int'] && this.ctrlSeq === '_') {
                this.jQ.css({
                    left: '-.25em',
                    marginRight: ''
                });
            }
            else {
                this.jQ.css({
                    left: '',
                    marginRight: ''
                });
            }

            if (this.respaced) {
                if (this.ctrlSeq === '^') this.down = this.firstChild.down = this.prev.firstChild;
                else this.up = this.firstChild.up = this.prev.firstChild;
            }
            else if (this.next.respaced) {
                if (this.ctrlSeq === '_') this.up = this.firstChild.up = this.next.firstChild;
                else this.down = this.firstChild.down = this.next.firstChild;
            }
            else {
                if (this.ctrlSeq === '_') {
                    delete this.up;
                    this.firstChild.up = insertBeforeUnlessAtEnd;
                }
                else {
                    delete this.down;
                    this.firstChild.down = insertBeforeUnlessAtEnd;
                }
            }

            if (this.next instanceof SupSub)
                this.next.respace();

            return this;
        };

        _.onKey = function (key, e) {
            if (this.getCursor().parent.parent !== this) return;

            switch (key) {
                case 'Tab':
                    if (this.next.respaced) {
                        this.getCursor().prepareMove().prependTo(this.next.firstChild);
                        e.preventDefault();
                        return false;
                    }
                    break;
                case 'Shift-Tab':
                    if (this.respaced) {
                        this.getCursor().prepareMove().appendTo(this.prev.firstChild);
                        e.preventDefault();
                        return false;
                    }
                    break;
                case 'Left':
                    if (!this.getCursor().prev && this.respaced) {
                        this.getCursor().prepareMove().insertBefore(this.prev);
                        return false;
                    }
                    break;
                case 'Right':
                    if (!this.getCursor().next && this.next.respaced) {
                        this.getCursor().prepareMove().insertAfter(this.next);
                        return false;
                    }
            }
        };
        _.getCursor = function () {
            var cursor;
            for (var ancestor = this.parent; !cursor; ancestor = ancestor.parent) {
                cursor = ancestor.cursor;
            }
            this.getCursor = function () { return cursor; };
            return this.getCursor();
        };
    });

    LatexCmds.subscript =
LatexCmds._ = bind(SupSub, '_', 'sub', '_');

    LatexCmds.superscript =
LatexCmds.supscript =
LatexCmds['^'] = bind(SupSub, '^', 'sup', '**');

    var Fraction =
LatexCmds.frac =
LatexCmds.dfrac =
LatexCmds.cfrac =
LatexCmds.fraction = P(MathCommand, function (_, _super) {
    _.ctrlSeq = '\\frac';
    _.htmlTemplate =
      '<span class="fraction non-leaf">'
    + '<span class="numerator">&0</span>'
    + '<span class="denominator">&1</span>'
    + '<span style="display:inline-block;width:0">&nbsp;</span>'
    + '</span>'
  ;
    _.textTemplate = ['(', '/', ')'];
    _.finalizeTree = function () {
        this.up = this.lastChild.up = this.firstChild;
        this.down = this.firstChild.down = this.lastChild;
    };
});

    var LiveFraction =
LatexCmds.over =
CharCmds['/'] = P(Fraction, function (_, _super) {
    _.createBefore = function (cursor) {
        if (!this.replacedFragment) {
            var prev = cursor.prev;
            if (prev instanceof TextBlock || prev instanceof Fraction) {
                prev = prev.prev;
            }
            else {
                while (prev &&
          !(
            prev instanceof BinaryOperator ||
            prev instanceof TextBlock ||
            prev instanceof BigSymbol ||
            prev instanceof Fraction ||
            prev.ctrlSeq === ',' ||
            prev.ctrlSeq === ':' ||
            prev.ctrlSeq === '\\space '
          ) //lookbehind for operator
        )
                    prev = prev.prev;

                if (prev instanceof BigSymbol && prev.next instanceof SupSub) {
                    prev = prev.next;
                    if (prev.next instanceof SupSub && prev.next.ctrlSeq != prev.ctrlSeq)
                        prev = prev.next;
                }
            }

            if (prev !== cursor.prev) {
                this.replaces(MathFragment(prev.next || cursor.parent.firstChild, cursor.prev));
                cursor.prev = prev;
            }
        }
        _super.createBefore.call(this, cursor);
    };
});

    var SquareRoot =
LatexCmds.sqrt =
LatexCmds['鈭�'] = P(MathCommand, function (_, _super) {
    _.ctrlSeq = '\\sqrt';
    _.htmlTemplate =
      '<span class="non-leaf">'
    + '<span class="scaled sqrt-prefix">&radic;</span>'
    + '<span class="non-leaf sqrt-stem">&0</span>'
    + '</span>'
  ;
    _.textTemplate = ['sqrt(', ')'];
    _.parser = function () {
        return latexMathParser.optBlock.then(function (optBlock) {
            return latexMathParser.block.map(function (block) {
                var nthroot = NthRoot();
                nthroot.blocks = [optBlock, block];
                optBlock.adopt(nthroot, 0, 0);
                block.adopt(nthroot, optBlock, 0);
                return nthroot;
            });
        }).or(_super.parser.call(this));
    };
    _.redraw = function () {
        var block = this.lastChild.jQ;
        scale(block.prev(), 1, block.innerHeight() / +block.css('fontSize').slice(0, -2) - .1);
    };
});


    var NthRoot =
LatexCmds.nthroot = P(SquareRoot, function (_, _super) {
    _.htmlTemplate =
      '<sup class="nthroot non-leaf">&0</sup>'
    + '<span class="scaled">'
    + '<span class="sqrt-prefix scaled">&radic;</span>'
    + '<span class="sqrt-stem non-leaf">&1</span>'
    + '</span>'
  ;
    _.textTemplate = ['sqrt[', '](', ')'];
    _.latex = function () {
        return '\\sqrt[' + this.firstChild.latex() + ']{' + this.lastChild.latex() + '}';
    };
    _.onKey = function (key, e) {
        if (this.getCursor().parent.parent !== this) return;

        switch (key) {
            case 'Right':
                if (this.getCursor().next) return;
            case 'Tab':
                if (this.getCursor().parent === this.firstChild) {
                    this.getCursor().prepareMove().prependTo(this.lastChild);
                    e.preventDefault();
                    return false;
                }
                break;
            case 'Left':
                if (this.getCursor().prev) return;
            case 'Shift-Tab':
                if (this.getCursor().parent === this.lastChild) {
                    this.getCursor().prepareMove().appendTo(this.firstChild);
                    e.preventDefault();
                    return false;
                }
        }
    };
    _.getCursor = SupSub.prototype.getCursor;
});

    // Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)
    var Bracket = P(MathCommand, function (_, _super) {
        _.init = function (open, close, ctrlSeq, end) {
            _super.init.call(this, '\\left' + ctrlSeq,
        '<span class="non-leaf">'
      + '<span class="scaled paren">' + open + '</span>'
      + '<span class="non-leaf">&0</span>'
      + '<span class="scaled paren">' + close + '</span>'
      + '</span>',
      [open, close]);
            this.end = '\\right' + end;
        };
        _.jQadd = function () {
            _super.jQadd.apply(this, arguments);
            var jQ = this.jQ;
            this.bracketjQs = jQ.children(':first').add(jQ.children(':last'));
        };
        //When typed, auto-expand paren to end of block
        _.finalizeTree = function () {
            if (this.firstChild.isEmpty() && this.next) {
                var nextAll = MathFragment(this.next, this.parent.lastChild).disown();
                nextAll.adopt(this.firstChild, 0, 0);
                nextAll.jQ.appendTo(this.firstChild.jQ);
            }
        };
        _.placeCursor = function (cursor) {
            cursor.prependTo(this.firstChild);
        };
        _.latex = function () {
            return this.ctrlSeq + this.firstChild.latex() + this.end;
        };
        _.redraw = function () {
            var blockjQ = this.firstChild.jQ;

            var height = blockjQ.outerHeight() / +blockjQ.css('fontSize').slice(0, -2);

            scale(this.bracketjQs, min(1 + .2 * (height - 1), 1.2), 1.05 * height);
        };
    });

    LatexCmds.left = P(MathCommand, function (_) {
        _.parser = function () {
            var regex = Parser.regex;
            var string = Parser.string;
            var regex = Parser.regex;
            var succeed = Parser.succeed;
            var block = latexMathParser.block;
            var optWhitespace = Parser.optWhitespace;

            return optWhitespace.then(regex(/^(?:[([|]|\\\{)/))
      .then(function (open) {
          if (open.charAt(0) === '\\') open = open.slice(1);

          var cmd = CharCmds[open]();

          return latexMathParser
          .map(function (block) {
              cmd.blocks = [block];
              block.adopt(cmd, 0, 0);
          })
          .then(string('\\right'))
          .skip(optWhitespace)
          .then(regex(/^(?:[\])|]|\\\})/))
          .then(function (close) {
              if (close.slice(-1) !== cmd.end.slice(-1)) {
                  return Parser.fail('open doesn\'t match close');
              }

              return succeed(cmd);
          })
        ;
      })
    ;
        };
    });

    LatexCmds.right = P(MathCommand, function (_) {
        _.parser = function () {
            return Parser.fail('unmatched \\right');
        };
    });

    LatexCmds.lbrace =
CharCmds['{'] = bind(Bracket, '{', '}', '\\{', '\\}');
    LatexCmds.langle =
LatexCmds.lang = bind(Bracket, '&lang;', '&rang;', '\\langle ', '\\rangle ');

    // Closing bracket matching opening bracket above
    var CloseBracket = P(Bracket, function (_, _super) {
        _.createBefore = function (cursor) {
            // if I'm replacing a selection fragment, just wrap in parens
            if (this.replacedFragment) return _super.createBefore.call(this, cursor);

            // elsewise, if my parent is a matching open-paren, then close it here,
            // i.e. move everything after me in the open-paren to after the parens
            var openParen = cursor.parent.parent;
            if (openParen.ctrlSeq === this.ctrlSeq) {
                if (cursor.next) {
                    var nextAll = MathFragment(cursor.next, openParen.firstChild.lastChild).disown();
                    nextAll.adopt(openParen.parent, openParen, openParen.next);
                    nextAll.jQ.insertAfter(openParen.jQ);
                    if (cursor.next.respace) cursor.next.respace();
                }
                cursor.insertAfter(openParen);
                openParen.bubble('redraw');
            }
            // or if not, make empty paren group and put cursor inside it
            // (I think this behavior is weird - Han)
            else {
                _super.createBefore.call(this, cursor);
                cursor.appendTo(this.firstChild); // FIXME HACK
            }
        };
        _.finalizeTree = noop;
        _.placeCursor = function (cursor) {
            this.firstChild.blur();
            cursor.insertAfter(this);
        };
    });

    LatexCmds.rbrace =
CharCmds['}'] = bind(CloseBracket, '{', '}', '\\{', '\\}');
    LatexCmds.rangle =
LatexCmds.rang = bind(CloseBracket, '&lang;', '&rang;', '\\langle ', '\\rangle ');

    var parenMixin = function (_, _super) {
        _.init = function (open, close) {
            _super.init.call(this, open, close, open, close);
        };
    };

    var Paren = P(Bracket, parenMixin);

    LatexCmds.lparen =
CharCmds['('] = bind(Paren, '(', ')');
    LatexCmds.lbrack =
LatexCmds.lbracket =
CharCmds['['] = bind(Paren, '[', ']');

    var CloseParen = P(CloseBracket, parenMixin);

    LatexCmds.rparen =
CharCmds[')'] = bind(CloseParen, '(', ')');
    LatexCmds.rbrack =
LatexCmds.rbracket =
CharCmds[']'] = bind(CloseParen, '[', ']');

    var Pipes =
LatexCmds.lpipe =
LatexCmds.rpipe =
CharCmds['|'] = P(Paren, function (_, _super) {
    _.init = function () {
        _super.init.call(this, '|', '|');
    }

    _.createBefore = function (cursor) {
        if (!cursor.next && cursor.parent.parent && cursor.parent.parent.end === this.end && !this.replacedFragment)
            cursor.insertAfter(cursor.parent.parent);
        else
            MathCommand.prototype.createBefore.call(this, cursor);
    };
    _.finalizeTree = noop;
});

    // DISABLED in DCG
    var TextBlock =
LatexCmds.text =
LatexCmds.textnormal =
LatexCmds.textrm =
LatexCmds.textup =
LatexCmds.textmd = P(MathCommand, function (_, _super) {
    _.ctrlSeq = '\\text';
    _.htmlTemplate = '<span class="text">&0</span>';
    _.replaces = function (replacedText) {
        if (replacedText instanceof MathFragment)
            this.replacedText = replacedText.remove().jQ.text();
        else if (typeof replacedText === 'string')
            this.replacedText = replacedText;
    };
    _.textTemplate = ['"', '"'];
    _.parser = function () {
        // TODO: correctly parse text mode
        var string = Parser.string;
        var regex = Parser.regex;
        var optWhitespace = Parser.optWhitespace;
        return optWhitespace
      .then(string('{')).then(regex(/^[^}]*/)).skip(string('}'))
      .map(function (text) {
          var cmd = TextBlock();
          cmd.createBlocks();
          var block = cmd.firstChild;
          for (var i = 0; i < text.length; i += 1) {
              var ch = VanillaSymbol(text.charAt(i));
              ch.adopt(block, block.lastChild, 0);
          }
          return cmd;
      })
    ;
    };
    _.createBlocks = function () {
        //FIXME: another possible Law of Demeter violation, but this seems much cleaner, like it was supposed to be done this way
        this.firstChild =
    this.lastChild =
      InnerTextBlock();

        this.blocks = [this.firstChild];

        this.firstChild.parent = this;
    };
    _.finalizeInsert = function () {
        //FIXME HACK blur removes the TextBlock
        this.firstChild.blur = function () { delete this.blur; return this; };
        _super.finalizeInsert.call(this);
    };
    _.createBefore = function (cursor) {
        _super.createBefore.call(this, this.cursor = cursor);

        if (this.replacedText)
            for (var i = 0; i < this.replacedText.length; i += 1)
                this.write(this.replacedText.charAt(i));
    };
    _.write = function (ch) {
        this.cursor.insertNew(VanillaSymbol(ch));
    };
    _.onKey = function (key, e) {
        //backspace and delete and ends of block don't unwrap
        if (!this.cursor.selection &&
      (
        (key === 'Backspace' && !this.cursor.prev) ||
        (key === 'Del' && !this.cursor.next)
      )
    ) {
            if (this.isEmpty())
                this.cursor.insertAfter(this);

            return false;
        }
    };
    _.onText = function (ch) {
        this.cursor.prepareEdit();
        if (ch !== '$')
            this.write(ch);
        else if (this.isEmpty())
            this.cursor.insertAfter(this).backspace().insertNew(VanillaSymbol('\\$', '$'));
        else if (!this.cursor.next)
            this.cursor.insertAfter(this);
        else if (!this.cursor.prev)
            this.cursor.insertBefore(this);
        else { //split apart
            var next = TextBlock(MathFragment(this.cursor.next, this.firstChild.lastChild));
            next.placeCursor = function (cursor) { //FIXME HACK: pretend no prev so they don't get merged
                this.prev = 0;
                delete this.placeCursor;
                this.placeCursor(cursor);
            };
            next.firstChild.focus = function () { return this; };
            this.cursor.insertAfter(this).insertNew(next);
            next.prev = this;
            this.cursor.insertBefore(next);
            delete next.firstChild.focus;
        }
        this.cursor.root.triggerSpecialEvent('render');
        return false;
    };
});

    var InnerTextBlock = P(MathBlock, function (_, _super) {
        _.blur = function () {
            this.jQ.removeClass('hasCursor');
            if (this.isEmpty()) {
                var textblock = this.parent, cursor = textblock.cursor;
                if (cursor.parent === this)
                    this.jQ.addClass('empty');
                else {
                    cursor.hide();
                    textblock.remove();
                    if (cursor.next === textblock)
                        cursor.next = textblock.next;
                    else if (cursor.prev === textblock)
                        cursor.prev = textblock.prev;

                    cursor.show().parent.bubble('redraw');
                }
            }
            return this;
        };
        _.focus = function () {
            _super.focus.call(this);

            var textblock = this.parent;
            if (textblock.next.ctrlSeq === textblock.ctrlSeq) { //TODO: seems like there should be a better way to move MathElements around
                var innerblock = this,
        cursor = textblock.cursor,
        next = textblock.next.firstChild;

                next.eachChild(function (child) {
                    child.parent = innerblock;
                    child.jQ.appendTo(innerblock.jQ);
                });

                if (this.lastChild)
                    this.lastChild.next = next.firstChild;
                else
                    this.firstChild = next.firstChild;

                next.firstChild.prev = this.lastChild;
                this.lastChild = next.lastChild;

                next.parent.remove();

                if (cursor.prev)
                    cursor.insertAfter(cursor.prev);
                else
                    cursor.prependTo(this);

                cursor.parent.bubble('redraw');
            }
            else if (textblock.prev.ctrlSeq === textblock.ctrlSeq) {
                var cursor = textblock.cursor;
                if (cursor.prev)
                    textblock.prev.firstChild.focus();
                else
                    cursor.appendTo(textblock.prev.firstChild);
            }
            return this;
        };
    });


    function makeTextBlock(latex, tagName, attrs) {
        return P(TextBlock, {
            ctrlSeq: latex,
            htmlTemplate: '<' + tagName + ' ' + attrs + '>&0</' + tagName + '>'
        });
    }

    LatexCmds.em = LatexCmds.italic = LatexCmds.italics =
LatexCmds.emph = LatexCmds.textit = LatexCmds.textsl =
  makeTextBlock('\\textit', 'i', 'class="text"');
    LatexCmds.strong = LatexCmds.bold = LatexCmds.textbf =
  makeTextBlock('\\textbf', 'b', 'class="text"');
    LatexCmds.sf = LatexCmds.textsf =
  makeTextBlock('\\textsf', 'span', 'class="sans-serif text"');
    LatexCmds.tt = LatexCmds.texttt =
  makeTextBlock('\\texttt', 'span', 'class="monospace text"');
    LatexCmds.textsc =
  makeTextBlock('\\textsc', 'span', 'style="font-variant:small-caps" class="text"');
    LatexCmds.uppercase =
  makeTextBlock('\\uppercase', 'span', 'style="text-transform:uppercase" class="text"');
    LatexCmds.lowercase =
  makeTextBlock('\\lowercase', 'span', 'style="text-transform:lowercase" class="text"');

    // input box to type a variety of LaTeX commands beginning with a backslash
    // DISABLED in DCG
    var LatexCommandInput =
P(MathCommand, function (_, _super) {
    _.ctrlSeq = '\\';
    _.replaces = function (replacedFragment) {
        this._replacedFragment = replacedFragment.disown();
        this.isEmpty = function () { return false; };
    };
    _.htmlTemplate = '<span class="latex-command-input non-leaf">\\<span>&0</span></span>';
    _.textTemplate = ['\\'];
    _.createBlocks = function () {
        _super.createBlocks.call(this);
        this.firstChild.focus = function () {
            this.parent.jQ.addClass('hasCursor');
            if (this.isEmpty())
                this.parent.jQ.removeClass('empty');

            return this;
        };
        this.firstChild.blur = function () {
            this.parent.jQ.removeClass('hasCursor');
            if (this.isEmpty())
                this.parent.jQ.addClass('empty');

            return this;
        };
    };
    _.createBefore = function (cursor) {
        _super.createBefore.call(this, cursor);
        this.cursor = cursor.appendTo(this.firstChild);
        if (this._replacedFragment) {
            var el = this.jQ[0];
            this.jQ =
        this._replacedFragment.jQ.addClass('blur').bind(
          'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?
          function (e) {
              $(e.target = el).trigger(e);
              return false;
          }
        ).insertBefore(this.jQ).add(this.jQ);
        }
    };
    _.latex = function () {
        return '\\' + this.firstChild.latex() + ' ';
    };
    _.onKey = function (key, e) {
        if (key === 'Tab' || key === 'Enter') {
            this.renderCommand();
            this.cursor.root.triggerSpecialEvent('render');
            e.preventDefault();
            return false;
        }
    };
    _.onText = function (ch) {
        if (ch.match(/[a-z]/i)) {
            this.cursor.prepareEdit();
            this.cursor.insertNew(VanillaSymbol(ch));
            return false;
        }
        this.renderCommand();
        if (ch === ' ' || (ch === '\\' && this.firstChild.isEmpty())) {
            this.cursor.root.triggerSpecialEvent('render');
            return false;
        }
    };
    _.renderCommand = function () {
        this.jQ = this.jQ.last();
        this.remove();
        if (this.next) {
            this.cursor.insertBefore(this.next);
        } else {
            this.cursor.appendTo(this.parent);
        }

        var latex = this.firstChild.latex(), cmd;
        if (!latex) latex = 'backslash';
        this.cursor.insertCmd(latex, this._replacedFragment);
    };
});

    var Binomial =
LatexCmds.binom =
LatexCmds.binomial = P(MathCommand, function (_, _super) {
    _.ctrlSeq = '\\binom';
    _.htmlTemplate =
      '<span class="paren scaled">(</span>'
    + '<span class="non-leaf">'
    + '<span class="array non-leaf">'
    + '<span>&0</span>'
    + '<span>&1</span>'
    + '</span>'
    + '</span>'
    + '<span class="paren scaled">)</span>'
  ;
    _.textTemplate = ['choose(', ',', ')'];
    _.redraw = function () {
        var blockjQ = this.jQ.eq(1);

        var height = blockjQ.outerHeight() / +blockjQ.css('fontSize').slice(0, -2);

        var parens = this.jQ.filter('.paren');
        scale(parens, min(1 + .2 * (height - 1), 1.2), 1.05 * height);
    };
});

    var Choose =
LatexCmds.choose = P(Binomial, function (_) {
    _.createBefore = LiveFraction.prototype.createBefore;
});

    var Vector =
LatexCmds.vector = P(MathCommand, function (_, _super) {
    _.ctrlSeq = '\\vector';
    _.htmlTemplate = '<span class="array"><span>&0</span></span>';
    _.latex = function () {
        return '\\begin{matrix}' + this.foldChildren([], function (latex, child) {
            latex.push(child.latex());
            return latex;
        }).join('\\\\') + '\\end{matrix}';
    };
    _.text = function () {
        return '[' + this.foldChildren([], function (text, child) {
            text.push(child.text());
            return text;
        }).join() + ']';
    }
    _.createBefore = function (cursor) {
        _super.createBefore.call(this, this.cursor = cursor);
    };
    _.onKey = function (key, e) {
        var currentBlock = this.cursor.parent;

        if (currentBlock.parent === this) {
            if (key === 'Enter') { //enter
                var newBlock = MathBlock();
                newBlock.parent = this;
                newBlock.jQ = $('<span></span>')
          .attr(mqBlockId, newBlock.id)
          .insertAfter(currentBlock.jQ);
                if (currentBlock.next)
                    currentBlock.next.prev = newBlock;
                else
                    this.lastChild = newBlock;

                newBlock.next = currentBlock.next;
                currentBlock.next = newBlock;
                newBlock.prev = currentBlock;
                this.bubble('redraw').cursor.appendTo(newBlock);

                e.preventDefault();
                return false;
            }
            else if (key === 'Tab' && !currentBlock.next) {
                if (currentBlock.isEmpty()) {
                    if (currentBlock.prev) {
                        this.cursor.insertAfter(this);
                        delete currentBlock.prev.next;
                        this.lastChild = currentBlock.prev;
                        currentBlock.jQ.remove();
                        this.bubble('redraw');

                        e.preventDefault();
                        return false;
                    }
                    else
                        return;
                }

                var newBlock = MathBlock();
                newBlock.parent = this;
                newBlock.jQ = $('<span></span>').attr(mqBlockId, newBlock.id).appendTo(this.jQ);
                this.lastChild = newBlock;
                currentBlock.next = newBlock;
                newBlock.prev = currentBlock;
                this.bubble('redraw').cursor.appendTo(newBlock);

                e.preventDefault();
                return false;
            }
            else if (e.which === 8) { //backspace
                if (currentBlock.isEmpty()) {
                    if (currentBlock.prev) {
                        this.cursor.appendTo(currentBlock.prev)
                        currentBlock.prev.next = currentBlock.next;
                    }
                    else {
                        this.cursor.insertBefore(this);
                        this.firstChild = currentBlock.next;
                    }

                    if (currentBlock.next)
                        currentBlock.next.prev = currentBlock.prev;
                    else
                        this.lastChild = currentBlock.prev;

                    currentBlock.jQ.remove();
                    if (this.isEmpty())
                        this.cursor.deleteForward();
                    else
                        this.bubble('redraw');

                    e.preventDefault();
                    return false;
                }
                else if (!this.cursor.prev) {
                    e.preventDefault();
                    return false;
                }
            }
        }
    };
});
    /**********************************
    * Symbols and Special Characters
    *********************************/

    var Variable = P(Symbol, function (_, _super) {
        _.init = function (ch, html) {
            _super.init.call(this, ch, '<var>' + (html || ch) + '</var>');
        }
        _.createBefore = function (cursor) {
            //want the longest possible autocommand, so assemble longest series of letters (Variables) first
            var ctrlSeq = this.ctrlSeq;
            for (var i = 0, prev = cursor.prev; i < MAX_AUTOCMD_LEN - 1 && prev && prev instanceof Variable; i += 1, prev = prev.prev)
                ctrlSeq = prev.ctrlSeq + ctrlSeq;
            //then test if there's an autocommand here, starting with the longest possible and slicing
            while (ctrlSeq.length) {
                if (AutoCmds.hasOwnProperty(ctrlSeq)) {
                    for (var i = 1; i < ctrlSeq.length; i += 1) cursor.backspace();
                    cursor.insertNew(LatexCmds[ctrlSeq](ctrlSeq));
                    return;
                }
                ctrlSeq = ctrlSeq.slice(1);
            }
            _super.createBefore.apply(this, arguments);
        };
        _.respace =
  _.finalizeTree = function () {
      //TODO: in better architecture, should be done in createBefore and backspace
      //respace is called too often, inefficient

      //want the longest possible autocommand, so assemble longest series of letters (Variables)
      var ctrlSeq = this.ctrlSeq;
      if (ctrlSeq.length > 1) return;
      for (var prev = this.prev; prev instanceof Variable && prev.ctrlSeq.length === 1; prev = prev.prev)
          ctrlSeq = prev.ctrlSeq + ctrlSeq;
      for (var next = this.next; next instanceof Variable && next.ctrlSeq.length === 1; next = next.next)
          ctrlSeq += next.ctrlSeq;

      //removeClass from all the things before figuring out what's an autocmd, if any
      MathFragment(prev.next || this.parent.firstChild, next.prev || this.parent.lastChild)
    .each(function (el) {
        el.jQ.removeClass('un-italicized last');
        delete el.isFirstLetter;
        delete el.isLastLetter;
    });

      //test if there's an autocommand here, going through substrings from longest to shortest
      outer: for (var i = 0, first = prev.next || this.parent.firstChild; i < ctrlSeq.length; i += 1, first = first.next) {
          for (var len = min(MAX_UNITALICIZED_LEN, ctrlSeq.length - i); len > 0; len -= 1) {
              if (UnItalicizedCmds.hasOwnProperty(ctrlSeq.slice(i, i + len))) {
                  first.isFirstLetter = true;
                  for (var j = 0, letter = first; j < len; j += 1, letter = letter.next) {
                      letter.jQ.addClass('un-italicized');
                      var last = letter;
                  }
                  last.isLastLetter = true;
                  if (!(last.next instanceof SupSub || last.next instanceof Bracket))
                      last.jQ.addClass('last');
                  i += len - 1;
                  first = last;
                  continue outer;
              }
          }
      }
  };
        _.latex = function () {
            return (
      this.isFirstLetter ? '\\' + this.ctrlSeq :
      this.isLastLetter ? this.ctrlSeq + ' ' :
      this.ctrlSeq
    );
        };
        _.text = function () {
            var text = this.ctrlSeq;
            if (this.prev && !(this.prev instanceof Variable)
        && !(this.prev instanceof BinaryOperator))
                text = '*' + text;
            if (this.next && !(this.next instanceof BinaryOperator)
        && !(this.next.ctrlSeq === '^'))
                text += '*';
            return text;
        };
    });

    var UnItalicized = P(Symbol, function (_, _super) {
        _.init = function (fn) {
            this.ctrlSeq = fn;
        };
        _.createBefore = function (cursor) {
            cursor.writeLatex(this.ctrlSeq).show();
        };
        _.parser = function () {
            var fn = this.ctrlSeq;
            var block = MathBlock();
            for (var i = 0; i < fn.length; i += 1) {
                Variable(fn.charAt(i)).adopt(block, block.lastChild, 0);
            }
            return Parser.succeed(block.children());
        };
    });

    //backslashless commands, words where adjacent letters (Variables)
    //that form them automatically are turned into commands
    var UnItalicizedCmds = {
        ln: 1,
        log: 1,
        min: 1,
        nCr: 1,
        nPr: 1,
        gcd: 1,
        lcm: 1,
        ceil: 1,
        exp: 1,
        abs: 1,
        max: 1,
        mod: 1,
        lcm: 1,
        gcd: 1,
        gcf: 1,
        hcf: 1,
        //  lim: 1,
        exp: 1,
        floor: 1,
        sign: 1,
        round: 1
    }, MAX_UNITALICIZED_LEN = 9, AutoCmds = {
        sqrt: 1,
        nthroot: 1,
        sum: 1,
        prod: 1,
        pi: 1,
        phi: 1,
        tau: 1,
        gamma: 1,
        theta: 1/*,
  int: 1*/
    }, MAX_AUTOCMD_LEN = 7;

    (function () {
        var trigs = { sin: 1, cos: 1, tan: 1, sec: 1, cosec: 1, csc: 1, cotan: 1, cot: 1, ctg: 1 };
        for (var trig in trigs) {
            UnItalicizedCmds[trig] =
    UnItalicizedCmds['arc' + trig] =
    UnItalicizedCmds[trig + 'h'] =
    UnItalicizedCmds['arc' + trig + 'h'] = 1;
        }

        for (var fn in UnItalicizedCmds)
            LatexCmds[fn] = UnItalicized;
    } ());

    var VanillaSymbol = P(Symbol, function (_, _super) {
        _.init = function (ch, html) {
            _super.init.call(this, ch, '<span>' + (html || ch) + '</span>');
        };
    });

    CharCmds[' '] = bind(VanillaSymbol, '\\space ', ' ');

    LatexCmds.prime = CharCmds["'"] = bind(VanillaSymbol, "'", '&prime;');

    // does not use Symbola font
    var NonSymbolaSymbol = P(Symbol, function (_, _super) {
        _.init = function (ch, html) {
            _super.init.call(this, ch, '<span class="nonSymbola">' + (html || ch) + '</span>');
        };
    });

    LatexCmds['@'] = NonSymbolaSymbol;
    LatexCmds['&'] = bind(NonSymbolaSymbol, '\\&', '&amp;');
    LatexCmds['%'] = bind(NonSymbolaSymbol, '\\%', '%');

    //the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html

    //lowercase Greek letter variables
    LatexCmds.alpha =
LatexCmds.beta =
LatexCmds.gamma =
LatexCmds.delta =
LatexCmds.zeta =
LatexCmds.eta =
LatexCmds.theta =
LatexCmds.iota =
LatexCmds.kappa =
LatexCmds.mu =
LatexCmds.nu =
LatexCmds.xi =
LatexCmds.rho =
LatexCmds.sigma =
LatexCmds.tau =
LatexCmds.chi =
LatexCmds.psi =
LatexCmds.omega = P(Variable, function (_, _super) {
    _.init = function (latex) {
        _super.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
    };
});

    //why can't anybody FUCKING agree on these
    LatexCmds.phi = //W3C or Unicode?
  bind(Variable, '\\phi ', '&#981;');

    LatexCmds.phiv = //Elsevier and 9573-13
LatexCmds.varphi = //AMS and LaTeX
  bind(Variable, '\\varphi ', '&phi;');

    LatexCmds.epsilon = //W3C or Unicode?
  bind(Variable, '\\epsilon ', '&#1013;');

    LatexCmds.epsiv = //Elsevier and 9573-13
LatexCmds.varepsilon = //AMS and LaTeX
  bind(Variable, '\\varepsilon ', '&epsilon;');

    LatexCmds.piv = //W3C/Unicode and Elsevier and 9573-13
LatexCmds.varpi = //AMS and LaTeX
  bind(Variable, '\\varpi ', '&piv;');

    LatexCmds.sigmaf = //W3C/Unicode
LatexCmds.sigmav = //Elsevier
LatexCmds.varsigma = //LaTeX
  bind(Variable, '\\varsigma ', '&sigmaf;');

    LatexCmds.thetav = //Elsevier and 9573-13
LatexCmds.vartheta = //AMS and LaTeX
LatexCmds.thetasym = //W3C/Unicode
  bind(Variable, '\\vartheta ', '&thetasym;');

    LatexCmds.upsilon = //AMS and LaTeX and W3C/Unicode
LatexCmds.upsi = //Elsevier and 9573-13
  bind(Variable, '\\upsilon ', '&upsilon;');

    //these aren't even mentioned in the HTML character entity references
    LatexCmds.gammad = //Elsevier
LatexCmds.Gammad = //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above)
LatexCmds.digamma = //LaTeX
  bind(Variable, '\\digamma ', '&#989;');

    LatexCmds.kappav = //Elsevier
LatexCmds.varkappa = //AMS and LaTeX
  bind(Variable, '\\varkappa ', '&#1008;');

    LatexCmds.rhov = //Elsevier and 9573-13
LatexCmds.varrho = //AMS and LaTeX
  bind(Variable, '\\varrho ', '&#1009;');

    //Greek constants, look best in un-italicised Times New Roman
    LatexCmds.pi = LatexCmds['蟺'] = bind(NonSymbolaSymbol, '\\pi ', '&pi;');
    LatexCmds.theta = LatexCmds['胃'] = bind(NonSymbolaSymbol, '\\theta ', '&theta;');
    LatexCmds.lambda = bind(NonSymbolaSymbol, '\\lambda ', '&lambda;');

    //uppercase greek letters

    LatexCmds.Upsilon = //LaTeX
LatexCmds.Upsi = //Elsevier and 9573-13
LatexCmds.upsih = //W3C/Unicode "upsilon with hook"
LatexCmds.Upsih = //'cos it makes sense to me
  bind(Symbol, '\\Upsilon ', '<var style="font-family: serif">&upsih;</var>'); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(

    //other symbols with the same LaTeX command and HTML character entity reference
    LatexCmds.Gamma =
LatexCmds.Delta =
LatexCmds.Theta =
LatexCmds.Lambda =
LatexCmds.Xi =
LatexCmds.Pi =
LatexCmds.Sigma =
LatexCmds.Phi =
LatexCmds.Psi =
LatexCmds.Omega =
LatexCmds.forall = P(VanillaSymbol, function (_, _super) {
    _.init = function (latex) {
        _super.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
    };
});

    // symbols that aren't a single MathCommand, but are instead a whole
    // Fragment. Creates the Fragment from a LaTeX string
    var LatexFragment = P(MathCommand, function (_) {
        _.init = function (latex) { this.latex = latex; };
        _.createBefore = function (cursor) { cursor.writeLatex(this.latex); };
        _.parser = function () {
            var frag = latexMathParser.parse(this.latex).children();
            return Parser.succeed(frag);
        };
    });

    // for what seems to me like [stupid reasons][1], Unicode provides
    // subscripted and superscripted versions of all ten Arabic numerals,
    // as well as [so-called "vulgar fractions"][2].
    // Nobody really cares about most of them, but some of them actually
    // predate Unicode, dating back to [ISO-8859-1][3], apparently also
    // known as "Latin-1", which among other things [Windows-1252][4]
    // largely coincides with, so Microsoft Word sometimes inserts them
    // and they get copy-pasted into MathQuill.
    //
    // (Irrelevant but funny story: Windows-1252 is actually a strict
    // superset of the "closely related but distinct"[3] "ISO 8859-1" --
    // see the lack of a dash after "ISO"? Completely different character
    // set, like elephants vs elephant seals, or "Zombies" vs "Zombie
    // Redneck Torture Family". What kind of idiot would get them confused.
    // People in fact got them confused so much, it was so common to
    // mislabel Windows-1252 text as ISO-8859-1, that most modern web
    // browsers and email clients treat the MIME charset of ISO-8859-1
    // as actually Windows-1252, behavior now standard in the HTML5 spec.)
    //
    // [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts
    // [2]: http://en.wikipedia.org/wiki/Number_Forms
    // [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1
    // [4]: http://en.wikipedia.org/wiki/Windows-1252
    LatexCmds['鹿'] = bind(LatexFragment, '^1');
    LatexCmds['虏'] = bind(LatexFragment, '^2');
    LatexCmds['鲁'] = bind(LatexFragment, '^3');
    LatexCmds['录'] = bind(LatexFragment, '\\frac14');
    LatexCmds['陆'] = bind(LatexFragment, '\\frac12');
    LatexCmds['戮'] = bind(LatexFragment, '\\frac34');

    var BinaryOperator = P(Symbol, function (_, _super) {
        _.init = function (ctrlSeq, html, text) {
            _super.init.call(this,
      ctrlSeq, '<span class="binary-operator">' + html + '</span>', text
    );
        };
        _.createBefore = function (cursor) {
            var ctrlSeq = cursor.prev.ctrlSeq + this.ctrlSeq;
            if (ctrlSeq === '<=')
                cursor.backspace().insertNew(BinaryOperator('\\le ', '&le;'));
            else if (ctrlSeq === '>=')
                cursor.backspace().insertNew(BinaryOperator('\\ge ', '&ge;'));
            else
                _super.createBefore.apply(this, arguments);
        };
    });

    var PlusMinus = P(BinaryOperator, function (_) {
        _.init = VanillaSymbol.prototype.init;

        _.respace = function () {
            if (!this.prev) {
                this.jQ[0].className = '';
            }
            else if (
      this.prev instanceof BinaryOperator &&
      this.next && !(this.next instanceof BinaryOperator)
    ) {
                this.jQ[0].className = 'unary-operator';
            }
            else {
                this.jQ[0].className = 'binary-operator';
            }
            return this;
        };
    });

    LatexCmds['+'] = bind(PlusMinus, '+', '+');
    //yes, these are different dashes, I think one is an en dash and the other is a hyphen
    LatexCmds['鈥�'] = LatexCmds['-'] = bind(PlusMinus, '-', '&minus;');
    LatexCmds['卤'] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus =
  bind(PlusMinus, '\\pm ', '&plusmn;');
    LatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus =
  bind(PlusMinus, '\\mp ', '&#8723;');

    CharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot =
  bind(BinaryOperator, '\\cdot ', '&middot;');
    //semantically should be &sdot;, but &middot; looks better

    LatexCmds['='] = bind(BinaryOperator, '=', '=');
    LatexCmds['<'] = bind(BinaryOperator, '<', '&lt;');
    LatexCmds['>'] = bind(BinaryOperator, '>', '&gt;');

    LatexCmds.notin =
LatexCmds.sim =
LatexCmds.cong =
LatexCmds.equiv =
LatexCmds.oplus =
LatexCmds.otimes = P(BinaryOperator, function (_, _super) {
    _.init = function (latex) {
        _super.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
    };
});

    LatexCmds.times = bind(BinaryOperator, '\\times ', '&times;', '[x]');

    LatexCmds['梅'] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides =
  bind(BinaryOperator, '\\div ', '&divide;', '[/]');

    LatexCmds['鈮�'] = LatexCmds.ne = LatexCmds.neq = bind(BinaryOperator, '\\ne ', '&ne;');

    LatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast =
  bind(BinaryOperator, '\\ast ', '&lowast;');
    //case 'there4 = // a special exception for this one, perhaps?
    LatexCmds.therefor = LatexCmds.therefore =
  bind(BinaryOperator, '\\therefore ', '&there4;');

    LatexCmds.cuz = // l33t
LatexCmds.because = bind(BinaryOperator, '\\because ', '&#8757;');

    LatexCmds.prop = LatexCmds.propto = bind(BinaryOperator, '\\propto ', '&prop;');

    LatexCmds['鈮�'] = LatexCmds.asymp = LatexCmds.approx = bind(BinaryOperator, '\\approx ', '&asymp;');

    LatexCmds.lt = bind(BinaryOperator, '<', '&lt;');

    LatexCmds.gt = bind(BinaryOperator, '>', '&gt;');

    LatexCmds['鈮�'] = LatexCmds.le = LatexCmds.leq = bind(BinaryOperator, '\\le ', '&le;');

    LatexCmds['鈮�'] = LatexCmds.ge = LatexCmds.geq = bind(BinaryOperator, '\\ge ', '&ge;');

    LatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator, '\\in ', '&isin;');

    LatexCmds.ni = LatexCmds.contains = bind(BinaryOperator, '\\ni ', '&ni;');

    LatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain =
  bind(BinaryOperator, '\\not\\ni ', '&#8716;');

    LatexCmds.sub = LatexCmds.subset = bind(BinaryOperator, '\\subset ', '&sub;');

    LatexCmds.sup = LatexCmds.supset = LatexCmds.superset =
  bind(BinaryOperator, '\\supset ', '&sup;');

    LatexCmds.nsub = LatexCmds.notsub =
LatexCmds.nsubset = LatexCmds.notsubset =
  bind(BinaryOperator, '\\not\\subset ', '&#8836;');

    LatexCmds.nsup = LatexCmds.notsup =
LatexCmds.nsupset = LatexCmds.notsupset =
LatexCmds.nsuperset = LatexCmds.notsuperset =
  bind(BinaryOperator, '\\not\\supset ', '&#8837;');

    LatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq =
  bind(BinaryOperator, '\\subseteq ', '&sube;');

    LatexCmds.supe = LatexCmds.supeq =
LatexCmds.supsete = LatexCmds.supseteq =
LatexCmds.supersete = LatexCmds.superseteq =
  bind(BinaryOperator, '\\supseteq ', '&supe;');

    LatexCmds.nsube = LatexCmds.nsubeq =
LatexCmds.notsube = LatexCmds.notsubeq =
LatexCmds.nsubsete = LatexCmds.nsubseteq =
LatexCmds.notsubsete = LatexCmds.notsubseteq =
  bind(BinaryOperator, '\\not\\subseteq ', '&#8840;');

    LatexCmds.nsupe = LatexCmds.nsupeq =
LatexCmds.notsupe = LatexCmds.notsupeq =
LatexCmds.nsupsete = LatexCmds.nsupseteq =
LatexCmds.notsupsete = LatexCmds.notsupseteq =
LatexCmds.nsupersete = LatexCmds.nsuperseteq =
LatexCmds.notsupersete = LatexCmds.notsuperseteq =
  bind(BinaryOperator, '\\not\\supseteq ', '&#8841;');


    //sum, product, coproduct, integral
    var BigSymbol = P(Symbol, function (_, _super) {
        _.init = function (ch, html) {
            _super.init.call(this, ch, '<span class="large-operator non-leaf"><big>' + html + '</big></span>');
            //FIXME HACK
            if (ch !== '\\int ')
                this.placeCursor = function (cursor) {
                    cursor.writeLatex('^{}_{n=}').appendTo(this.firstChild).show();
                };
        };
        _.isEmpty = MathCommand.prototype.isEmpty;
        _.latex = function () {
            var fromLatex = this.firstChild ? '_' + simplify(this.firstChild.latex()) : '',
      toLatex = this.lastChild ? '^' + simplify(this.lastChild.latex()) : '';
            return this.ctrlSeq + fromLatex + toLatex;

            function simplify(latex) {
                return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';
            }
        };
    });

    LatexCmds['鈭�'] = LatexCmds.sum = LatexCmds.summation = bind(BigSymbol, '\\sum ', '&sum;');
    LatexCmds['鈭�'] = LatexCmds.prod = LatexCmds.product = bind(BigSymbol, '\\prod ', '&prod;');
    LatexCmds.coprod = LatexCmds.coproduct = bind(BigSymbol, '\\coprod ', '&#8720;');
    LatexCmds['鈭�'] = LatexCmds['int'] = LatexCmds.integral = P(BigSymbol, function (_) {
        _.init = function () {
            Symbol.prototype.init.call(this, '\\int ', '<big>&int;</big>');
        };
    });


    /*

    //the canonical sets of numbers
    LatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals =
    bind(VanillaSymbol,'\\mathbb{N}','&#8469;');

    LatexCmds.P =
    LatexCmds.primes = LatexCmds.Primes =
    LatexCmds.projective = LatexCmds.Projective =
    LatexCmds.probability = LatexCmds.Probability =
    bind(VanillaSymbol,'\\mathbb{P}','&#8473;');

    LatexCmds.Z = LatexCmds.integers = LatexCmds.Integers =
    bind(VanillaSymbol,'\\mathbb{Z}','&#8484;');

    LatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals =
    bind(VanillaSymbol,'\\mathbb{Q}','&#8474;');

    LatexCmds.R = LatexCmds.reals = LatexCmds.Reals =
    bind(VanillaSymbol,'\\mathbb{R}','&#8477;');

    LatexCmds.C =
    LatexCmds.complex = LatexCmds.Complex =
    LatexCmds.complexes = LatexCmds.Complexes =
    LatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane =
    bind(VanillaSymbol,'\\mathbb{C}','&#8450;');

    LatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions =
    bind(VanillaSymbol,'\\mathbb{H}','&#8461;');

    //spacing
    LatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol,'\\quad ','    ');
    LatexCmds.qquad = bind(VanillaSymbol,'\\qquad ','        ');
    spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow
    case ',':
    return VanillaSymbol('\\, ',' ');
    case ':':
    return VanillaSymbol('\\: ','  ');
    case ';':
    return VanillaSymbol('\\; ','   ');
    case '!':
    return Symbol('\\! ','<span style="margin-right:-.2em"></span>');

    //binary operators
    LatexCmds.diamond = bind(VanillaSymbol, '\\diamond ', '&#9671;');
    LatexCmds.bigtriangleup = bind(VanillaSymbol, '\\bigtriangleup ', '&#9651;');
    LatexCmds.ominus = bind(VanillaSymbol, '\\ominus ', '&#8854;');
    LatexCmds.uplus = bind(VanillaSymbol, '\\uplus ', '&#8846;');
    LatexCmds.bigtriangledown = bind(VanillaSymbol, '\\bigtriangledown ', '&#9661;');
    LatexCmds.sqcap = bind(VanillaSymbol, '\\sqcap ', '&#8851;');
    LatexCmds.triangleleft = bind(VanillaSymbol, '\\triangleleft ', '&#8882;');
    LatexCmds.sqcup = bind(VanillaSymbol, '\\sqcup ', '&#8852;');
    LatexCmds.triangleright = bind(VanillaSymbol, '\\triangleright ', '&#8883;');
    LatexCmds.odot = bind(VanillaSymbol, '\\odot ', '&#8857;');
    LatexCmds.bigcirc = bind(VanillaSymbol, '\\bigcirc ', '&#9711;');
    LatexCmds.dagger = bind(VanillaSymbol, '\\dagger ', '&#0134;');
    LatexCmds.ddagger = bind(VanillaSymbol, '\\ddagger ', '&#135;');
    LatexCmds.wr = bind(VanillaSymbol, '\\wr ', '&#8768;');
    LatexCmds.amalg = bind(VanillaSymbol, '\\amalg ', '&#8720;');

    //relationship symbols
    LatexCmds.models = bind(VanillaSymbol, '\\models ', '&#8872;');
    LatexCmds.prec = bind(VanillaSymbol, '\\prec ', '&#8826;');
    LatexCmds.succ = bind(VanillaSymbol, '\\succ ', '&#8827;');
    LatexCmds.preceq = bind(VanillaSymbol, '\\preceq ', '&#8828;');
    LatexCmds.succeq = bind(VanillaSymbol, '\\succeq ', '&#8829;');
    LatexCmds.simeq = bind(VanillaSymbol, '\\simeq ', '&#8771;');
    LatexCmds.mid = bind(VanillaSymbol, '\\mid ', '&#8739;');
    LatexCmds.ll = bind(VanillaSymbol, '\\ll ', '&#8810;');
    LatexCmds.gg = bind(VanillaSymbol, '\\gg ', '&#8811;');
    LatexCmds.parallel = bind(VanillaSymbol, '\\parallel ', '&#8741;');
    LatexCmds.bowtie = bind(VanillaSymbol, '\\bowtie ', '&#8904;');
    LatexCmds.sqsubset = bind(VanillaSymbol, '\\sqsubset ', '&#8847;');
    LatexCmds.sqsupset = bind(VanillaSymbol, '\\sqsupset ', '&#8848;');
    LatexCmds.smile = bind(VanillaSymbol, '\\smile ', '&#8995;');
    LatexCmds.sqsubseteq = bind(VanillaSymbol, '\\sqsubseteq ', '&#8849;');
    LatexCmds.sqsupseteq = bind(VanillaSymbol, '\\sqsupseteq ', '&#8850;');
    LatexCmds.doteq = bind(VanillaSymbol, '\\doteq ', '&#8784;');
    LatexCmds.frown = bind(VanillaSymbol, '\\frown ', '&#8994;');
    LatexCmds.vdash = bind(VanillaSymbol, '\\vdash ', '&#8870;');
    LatexCmds.dashv = bind(VanillaSymbol, '\\dashv ', '&#8867;');

    //arrows
    LatexCmds.longleftarrow = bind(VanillaSymbol, '\\longleftarrow ', '&#8592;');
    LatexCmds.longrightarrow = bind(VanillaSymbol, '\\longrightarrow ', '&#8594;');
    LatexCmds.Longleftarrow = bind(VanillaSymbol, '\\Longleftarrow ', '&#8656;');
    LatexCmds.Longrightarrow = bind(VanillaSymbol, '\\Longrightarrow ', '&#8658;');
    LatexCmds.longleftrightarrow = bind(VanillaSymbol, '\\longleftrightarrow ', '&#8596;');
    LatexCmds.updownarrow = bind(VanillaSymbol, '\\updownarrow ', '&#8597;');
    LatexCmds.Longleftrightarrow = bind(VanillaSymbol, '\\Longleftrightarrow ', '&#8660;');
    LatexCmds.Updownarrow = bind(VanillaSymbol, '\\Updownarrow ', '&#8661;');
    LatexCmds.mapsto = bind(VanillaSymbol, '\\mapsto ', '&#8614;');
    LatexCmds.nearrow = bind(VanillaSymbol, '\\nearrow ', '&#8599;');
    LatexCmds.hookleftarrow = bind(VanillaSymbol, '\\hookleftarrow ', '&#8617;');
    LatexCmds.hookrightarrow = bind(VanillaSymbol, '\\hookrightarrow ', '&#8618;');
    LatexCmds.searrow = bind(VanillaSymbol, '\\searrow ', '&#8600;');
    LatexCmds.leftharpoonup = bind(VanillaSymbol, '\\leftharpoonup ', '&#8636;');
    LatexCmds.rightharpoonup = bind(VanillaSymbol, '\\rightharpoonup ', '&#8640;');
    LatexCmds.swarrow = bind(VanillaSymbol, '\\swarrow ', '&#8601;');
    LatexCmds.leftharpoondown = bind(VanillaSymbol, '\\leftharpoondown ', '&#8637;');
    LatexCmds.rightharpoondown = bind(VanillaSymbol, '\\rightharpoondown ', '&#8641;');
    LatexCmds.nwarrow = bind(VanillaSymbol, '\\nwarrow ', '&#8598;');

    //Misc
    */
    LatexCmds.space = bind(VanillaSymbol, '\\space ', '&nbsp;');
    /*
    LatexCmds.ldots = bind(VanillaSymbol, '\\ldots ', '&#8230;');
    LatexCmds.cdots = bind(VanillaSymbol, '\\cdots ', '&#8943;');
    LatexCmds.vdots = bind(VanillaSymbol, '\\vdots ', '&#8942;');
    LatexCmds.ddots = bind(VanillaSymbol, '\\ddots ', '&#8944;');
    LatexCmds.surd = bind(VanillaSymbol, '\\surd ', '&#8730;');
    LatexCmds.triangle = bind(VanillaSymbol, '\\triangle ', '&#9653;');
    LatexCmds.ell = bind(VanillaSymbol, '\\ell ', '&#8467;');
    LatexCmds.top = bind(VanillaSymbol, '\\top ', '&#8868;');
    LatexCmds.flat = bind(VanillaSymbol, '\\flat ', '&#9837;');
    LatexCmds.natural = bind(VanillaSymbol, '\\natural ', '&#9838;');
    LatexCmds.sharp = bind(VanillaSymbol, '\\sharp ', '&#9839;');
    LatexCmds.wp = bind(VanillaSymbol, '\\wp ', '&#8472;');
    LatexCmds.bot = bind(VanillaSymbol, '\\bot ', '&#8869;');
    LatexCmds.clubsuit = bind(VanillaSymbol, '\\clubsuit ', '&#9827;');
    LatexCmds.diamondsuit = bind(VanillaSymbol, '\\diamondsuit ', '&#9826;');
    LatexCmds.heartsuit = bind(VanillaSymbol, '\\heartsuit ', '&#9825;');
    LatexCmds.spadesuit = bind(VanillaSymbol, '\\spadesuit ', '&#9824;');

    //variable-sized
    LatexCmds.oint = bind(VanillaSymbol, '\\oint ', '&#8750;');
    LatexCmds.bigcap = bind(VanillaSymbol, '\\bigcap ', '&#8745;');
    LatexCmds.bigcup = bind(VanillaSymbol, '\\bigcup ', '&#8746;');
    LatexCmds.bigsqcup = bind(VanillaSymbol, '\\bigsqcup ', '&#8852;');
    LatexCmds.bigvee = bind(VanillaSymbol, '\\bigvee ', '&#8744;');
    LatexCmds.bigwedge = bind(VanillaSymbol, '\\bigwedge ', '&#8743;');
    LatexCmds.bigodot = bind(VanillaSymbol, '\\bigodot ', '&#8857;');
    LatexCmds.bigotimes = bind(VanillaSymbol, '\\bigotimes ', '&#8855;');
    LatexCmds.bigoplus = bind(VanillaSymbol, '\\bigoplus ', '&#8853;');
    LatexCmds.biguplus = bind(VanillaSymbol, '\\biguplus ', '&#8846;');

    //delimiters
    LatexCmds.lfloor = bind(VanillaSymbol, '\\lfloor ', '&#8970;');
    LatexCmds.rfloor = bind(VanillaSymbol, '\\rfloor ', '&#8971;');
    LatexCmds.lceil = bind(VanillaSymbol, '\\lceil ', '&#8968;');
    LatexCmds.rceil = bind(VanillaSymbol, '\\rceil ', '&#8969;');
    LatexCmds.slash = bind(VanillaSymbol, '\\slash ', '&#47;');
    LatexCmds.opencurlybrace = bind(VanillaSymbol, '\\opencurlybrace ', '&#123;');
    LatexCmds.closecurlybrace = bind(VanillaSymbol, '\\closecurlybrace ', '&#125;');

    //various symbols

    LatexCmds.caret = bind(VanillaSymbol,'\\caret ','^');
    LatexCmds.underscore = bind(VanillaSymbol,'\\underscore ','_');
    LatexCmds.backslash = bind(VanillaSymbol,'\\backslash ','\\');
    LatexCmds.vert = bind(VanillaSymbol,'|');
    LatexCmds.perp = LatexCmds.perpendicular = bind(VanillaSymbol,'\\perp ','&perp;');
    LatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol,'\\nabla ','&nabla;');
    LatexCmds.hbar = bind(VanillaSymbol,'\\hbar ','&#8463;');

    LatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom =
    bind(VanillaSymbol,'\\text\\AA ','&#8491;');

    LatexCmds.ring = LatexCmds.circ = LatexCmds.circle =
    bind(VanillaSymbol,'\\circ ','&#8728;');

    LatexCmds.bull = LatexCmds.bullet = bind(VanillaSymbol,'\\bullet ','&bull;');

    LatexCmds.setminus = LatexCmds.smallsetminus =
    bind(VanillaSymbol,'\\setminus ','&#8726;');

    LatexCmds.not = //bind(Symbol,'\\not ','<span class="not">/</span>');
    LatexCmds['卢'] = LatexCmds.neg = bind(VanillaSymbol,'\\neg ','&not;');

    LatexCmds['鈥�'] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip =
    LatexCmds.ellipsis = LatexCmds.hellipsis =
    bind(VanillaSymbol,'\\dots ','&hellip;');

    LatexCmds.converges =
    LatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow =
    bind(VanillaSymbol,'\\downarrow ','&darr;');

    LatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow =
    bind(VanillaSymbol,'\\Downarrow ','&dArr;');

    LatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow =
    bind(VanillaSymbol,'\\uparrow ','&uarr;');

    LatexCmds.uArr = LatexCmds.Uparrow = bind(VanillaSymbol,'\\Uparrow ','&uArr;');

    LatexCmds.to = bind(BinaryOperator,'\\to ','&rarr;');

    LatexCmds.rarr = LatexCmds.rightarrow = bind(VanillaSymbol,'\\rightarrow ','&rarr;');

    LatexCmds.implies = bind(BinaryOperator,'\\Rightarrow ','&rArr;');

    LatexCmds.rArr = LatexCmds.Rightarrow = bind(VanillaSymbol,'\\Rightarrow ','&rArr;');

    LatexCmds.gets = bind(BinaryOperator,'\\gets ','&larr;');

    LatexCmds.larr = LatexCmds.leftarrow = bind(VanillaSymbol,'\\leftarrow ','&larr;');

    LatexCmds.impliedby = bind(BinaryOperator,'\\Leftarrow ','&lArr;');

    LatexCmds.lArr = LatexCmds.Leftarrow = bind(VanillaSymbol,'\\Leftarrow ','&lArr;');

    LatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow =
    bind(VanillaSymbol,'\\leftrightarrow ','&harr;');

    LatexCmds.iff = bind(BinaryOperator,'\\Leftrightarrow ','&hArr;');

    LatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow =
    bind(VanillaSymbol,'\\Leftrightarrow ','&hArr;');

    LatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(VanillaSymbol,'\\Re ','&real;');

    LatexCmds.Im = LatexCmds.imag =
    LatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary =
    bind(VanillaSymbol,'\\Im ','&image;');

    LatexCmds.part = LatexCmds.partial = bind(VanillaSymbol,'\\partial ','&part;');

    LatexCmds.inf = LatexCmds.infin = LatexCmds.infty = LatexCmds.infinity =
    bind(VanillaSymbol,'\\infty ','&infin;');

    LatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym =
    bind(VanillaSymbol,'\\aleph ','&alefsym;');

    LatexCmds.xist = //LOL
    LatexCmds.xists = LatexCmds.exist = LatexCmds.exists =
    bind(VanillaSymbol,'\\exists ','&exist;');
    */
    LatexCmds.and = LatexCmds.land = LatexCmds.wedge =
  bind(VanillaSymbol, '\\wedge ', '&and;');

    LatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(VanillaSymbol, '\\vee ', '&or;');
    /*
    LatexCmds.o = LatexCmds.O =
    LatexCmds.empty = LatexCmds.emptyset =
    LatexCmds.oslash = LatexCmds.Oslash =
    LatexCmds.nothing = LatexCmds.varnothing =
    bind(BinaryOperator,'\\varnothing ','&empty;');

    LatexCmds.cup = LatexCmds.union = bind(BinaryOperator,'\\cup ','&cup;');

    LatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection =
    bind(BinaryOperator,'\\cap ','&cap;');

    LatexCmds.deg = LatexCmds.degree = bind(VanillaSymbol,'^\\circ ','&deg;');

    LatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol,'\\angle ','&ang;');
    */
    // Parser MathCommand
    var latexMathParser = (function () {
        function commandToBlock(cmd) {
            var block = MathBlock();
            cmd.adopt(block, 0, 0);
            return block;
        }
        function joinBlocks(blocks) {
            var firstBlock = blocks[0] || MathBlock();

            for (var i = 1; i < blocks.length; i += 1) {
                blocks[i].children().adopt(firstBlock, firstBlock.lastChild, 0);
            }

            return firstBlock;
        }

        var string = Parser.string;
        var regex = Parser.regex;
        var letter = Parser.letter;
        var any = Parser.any;
        var optWhitespace = Parser.optWhitespace;
        var succeed = Parser.succeed;
        var fail = Parser.fail;

        // Parsers yielding MathCommands
        var variable = letter.map(Variable);
        var symbol = regex(/^[^${}\\_^]/).map(VanillaSymbol);

        var controlSequence =
    regex(/^[^\\]/)
    .or(string('\\').then(
      regex(/^[a-z]+/i)
      .or(regex(/^\s+/).result(' '))
      .or(any)
    )).then(function (ctrlSeq) {
        var cmdKlass = LatexCmds[ctrlSeq];

        if (cmdKlass) {
            return cmdKlass(ctrlSeq).parser();
        }
        else {
            return fail('unknown command: \\' + ctrlSeq);
        }
    })
  ;

        var command =
    controlSequence
    .or(variable)
    .or(symbol)
  ;

        // Parsers yielding MathBlocks
        var mathGroup = string('{').then(function () { return mathSequence; }).skip(string('}'));
        var mathBlock = optWhitespace.then(mathGroup.or(command.map(commandToBlock)));
        var mathSequence = mathBlock.many().map(joinBlocks).skip(optWhitespace);

        var optMathBlock =
    string('[').then(
      mathBlock.then(function (block) {
          return block.join('latex') !== ']' ? succeed(block) : fail();
      })
      .many().map(joinBlocks).skip(optWhitespace)
    ).skip(string(']'))
  ;

        var latexMath = mathSequence;

        latexMath.block = mathBlock;
        latexMath.optBlock = optMathBlock;
        return latexMath;
    })();
    /********************************************
    * Cursor and Selection "singleton" classes
    *******************************************/

    /* The main thing that manipulates the Math DOM. Makes sure to manipulate the
    HTML DOM to match. */

    /* Sort of singletons, since there should only be one per editable math
    textbox, but any one HTML document can contain many such textboxes, so any one
    JS environment could actually contain many instances. */

    //A fake cursor in the fake textbox that the math is rendered in.
    var Cursor = P(function (_) {
        _.init = function (root) {
            this.parent = this.root = root;
            var jQ = this.jQ = this._jQ = $('<span class="cursor">&zwj;</span>');

            //closured for setInterval
            this.blink = function () { jQ.toggleClass('blink'); }

            this.upDownCache = {};
        };

        _.prev = 0;
        _.next = 0;
        _.parent = 0;
        _.show = function () {
            this.jQ = this._jQ.removeClass('blink');
            if ('intervalId' in this) //already was shown, just restart interval
                clearInterval(this.intervalId);
            else { //was hidden and detached, insert this.jQ back into HTML DOM
                if (this.next) {
                    if (this.selection && this.selection.first.prev === this.prev)
                        this.jQ.insertBefore(this.selection.jQ);
                    else
                        this.jQ.insertBefore(this.next.jQ.first());
                }
                else
                    this.jQ.appendTo(this.parent.jQ);
                this.parent.focus();
            }
            this.intervalId = setInterval(this.blink, 500);
            return this;
        };
        _.hide = function () {
            if ('intervalId' in this)
                clearInterval(this.intervalId);
            delete this.intervalId;
            this.jQ.detach();
            this.jQ = $();
            return this;
        };
        _.insertAt = function (parent, prev, next) {
            var old_parent = this.parent;

            this.parent = parent;
            this.prev = prev;
            this.next = next;

            old_parent.blur(); //blur may need to know cursor's destination
        };
        _.insertBefore = function (el) {
            this.insertAt(el.parent, el.prev, el)
            this.parent.jQ.addClass('hasCursor');
            this.jQ.insertBefore(el.jQ.first());
            return this;
        };
        _.insertAfter = function (el) {
            this.insertAt(el.parent, el, el.next);
            this.parent.jQ.addClass('hasCursor');
            this.jQ.insertAfter(el.jQ.last());
            return this;
        };
        _.prependTo = function (el) {
            this.insertAt(el, 0, el.firstChild);
            if (el.textarea) //never insert before textarea
                this.jQ.insertAfter(el.textarea);
            else
                this.jQ.prependTo(el.jQ);
            el.focus();
            return this;
        };
        _.appendTo = function (el) {
            this.insertAt(el, el.lastChild, 0);
            this.jQ.appendTo(el.jQ);
            el.focus();
            return this;
        };
        _.hopLeft = function () {
            this.jQ.insertBefore(this.prev.jQ.first());
            this.next = this.prev;
            this.prev = this.prev.prev;
            return this;
        };
        _.hopRight = function () {
            this.jQ.insertAfter(this.next.jQ.last());
            this.prev = this.next;
            this.next = this.next.next;
            return this;
        };
        _.moveLeftWithin = function (block) {
            if (this.prev) {
                // FIXME HACK: when moving right to left, want to go into NthRoot's body,
                // which is its lastChild.
                if (this.prev instanceof NthRoot) this.appendTo(this.prev.lastChild);
                else if (this.prev.up instanceof MathBlock) this.appendTo(this.prev.up);
                else if (this.prev.firstChild) this.appendTo(this.prev.firstChild)
                else this.hopLeft();
            }
            else {
                // unless we're at the beginning of the containing block, escape left
                if (this.parent !== block) this.insertBefore(this.parent.parent);
                else if (block.moveOutOf) block.moveOutOf('left', this);
            }
        };
        _.moveRightWithin = function (block) {
            if (this.next) {
                if (this.next.up instanceof MathBlock) this.prependTo(this.next.up);
                else if (this.next.firstChild) this.prependTo(this.next.firstChild)
                else this.hopRight();
            }
            else {
                // unless we're at the beginning of the containing block, escape left
                if (this.parent !== block) this.insertAfter(this.parent.parent);
                else if (block.moveOutOf) block.moveOutOf('right', this);
            }
        };
        _.moveLeft = function () {
            clearUpDownCache(this);

            if (this.selection)
                this.insertBefore(this.selection.first).clearSelection();
            else {
                this.moveLeftWithin(this.root);
            }
            this.root.triggerSpecialEvent('cursorMoved');
            return this.show();
        };
        _.moveRight = function () {
            clearUpDownCache(this);

            if (this.selection)
                this.insertAfter(this.selection.last).clearSelection();
            else {
                this.moveRightWithin(this.root);
            }
            this.root.triggerSpecialEvent('cursorMoved');
            return this.show();
        };

        /**
        * moveUp and moveDown have almost identical algorithms:
        * - first check next and prev, if so prepend/appendTo them
        * - else check the parent's 'up'/'down' property - if it's a function,
        *   call it with the cursor as the sole argument and use the return value.
        *
        *   Given undefined, will bubble up to the next ancestor block.
        *   Given false, will stop bubbling.
        *   Given a MathBlock,
        *     + moveUp will appendTo it
        *     + moveDown will prependTo it
        *
        */
        _.moveUp = function () { return moveUpDown(this, 'up'); };
        _.moveDown = function () { return moveUpDown(this, 'down'); };
        function moveUpDown(self, dir) {
            if (self.next[dir]) self.prependTo(self.next[dir]);
            else if (self.prev[dir]) self.appendTo(self.prev[dir]);
            else {
                var ancestorBlock = self.parent;
                do {
                    var prop = ancestorBlock[dir];
                    if (prop) {
                        if (typeof prop === 'function') prop = ancestorBlock[dir](self);
                        if (prop === false || prop instanceof MathBlock) {
                            self.upDownCache[ancestorBlock.id] = { parent: self.parent, prev: self.prev, next: self.next };

                            if (prop instanceof MathBlock) {
                                var cached = self.upDownCache[prop.id];

                                if (cached) {
                                    if (cached.next) {
                                        self.insertBefore(cached.next);
                                    } else {
                                        self.appendTo(cached.parent);
                                    }
                                } else {
                                    var pageX = offset(self).left;
                                    self.appendTo(prop);
                                    self.seekHoriz(pageX, prop);
                                }
                            }
                            break;
                        }
                    }
                    ancestorBlock = ancestorBlock.parent.parent;
                } while (ancestorBlock);
            }

            return self.clearSelection().show();
        }

        _.seek = function (target, pageX, pageY) {
            clearUpDownCache(this);
            var cmd, block, cursor = this.clearSelection().show();

            block = MathElement[target.attr(mqBlockId)];
            if (block && target.hasClass('empty')) {
                cursor.prependTo(block);
                return cursor;
            }

            cmd = MathElement[target.attr(mqCmdId)];
            if (cmd instanceof Symbol) { //insert at whichever side is closer
                if (target.outerWidth() > 2 * (pageX - target.offset().left))
                    cursor.insertBefore(cmd);
                else
                    cursor.insertAfter(cmd);

                return cursor;
            }
            if (!cmd && !block) { //if no MathQuill data, try parent, if still no, just start from the root
                target = target.parent();
                cmd = MathElement[target.attr(mqCmdId)];
                if (!cmd) {
                    block = MathElement[target.attr(mqBlockId)];
                    if (!block) block = cursor.root;
                }
            }

            if (cmd)
                cursor.insertAfter(cmd);
            else
                cursor.appendTo(block);

            return cursor.seekHoriz(pageX, cursor.root);
        };
        _.seekHoriz = function (pageX, block) {
            //move cursor to position closest to click
            var cursor = this;
            var dist = offset(cursor).left - pageX;
            var prevDist;

            while (dist > 0 && (cursor.prev || cursor.parent !== block)) {
                //FIXME HACK
                //with x_1^2, when the cursor is in the exponent,
                //moveLeftWithinBlock will move it in-between the subscript
                //and the exponent, which is fine, but the next call to
                //moveLeftWithinBlock will see that when moving horizontally
                //into the subscript, the cursor should go to the "top" block
                //which is in fact the exponent...ad nauseum.
                //Gosh, if only moving horizontally into a node was delegated
                //to its .moveToward() method or something.
                if (!cursor.prev && cursor.parent.parent.respaced)
                    cursor.appendTo(cursor.parent.parent.prev.firstChild);
                else
                    cursor.moveLeftWithin(block);
                prevDist = dist;
                dist = offset(cursor).left - pageX;
            }

            if (-dist > prevDist) cursor.moveRightWithin(block);

            return cursor;
        };
        function offset(self) {
            //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()
            //returns all 0's on inline elements with negative margin-right (like
            //the cursor) at the end of their parent, so temporarily remove the
            //negative margin-right when calling jQuery::offset()
            //Opera bug DSK-360043
            //http://bugs.jquery.com/ticket/11523
            //https://github.com/jquery/jquery/pull/717
            var offset = self.jQ.removeClass('cursor').offset();
            self.jQ.addClass('cursor');
            return offset;
        }
        _.writeLatex = function (latex) {
            var self = this;
            clearUpDownCache(self);
            self.show().deleteSelection();

            var all = Parser.all;
            var eof = Parser.eof;

            var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);

            if (block) {
                block.children().adopt(self.parent, self.prev, self.next);
                MathElement.jQize(block.join('html')).insertBefore(self.jQ);
                self.prev = block.lastChild;
                block.finalizeInsert();
                self.parent.bubble('redraw');
            }

            return this;
        };
        _.write = function (ch) {
            clearUpDownCache(this);
            return this.show().insertCh(ch);
        };
        _.insertCh = function (ch) {
            var cmd;
            if (ch.match(/^[a-z]$/i))
                cmd = Variable(ch);
            else if (cmd = CharCmds[ch] || LatexCmds[ch])
                cmd = cmd(ch);
            else
                cmd = VanillaSymbol(ch);

            if (this.selection) {
                this.prev = this.selection.first.prev;
                this.next = this.selection.last.next;
                cmd.replaces(this.selection);
                delete this.selection;
            }

            return this.insertNew(cmd);
        };
        _.insertNew = function (cmd) {
            cmd.createBefore(this);
            return this;
        };
        _.insertCmd = function (latexCmd, replacedFragment) {
            var cmd = LatexCmds[latexCmd];
            if (cmd) {
                cmd = cmd(latexCmd);
                if (replacedFragment) cmd.replaces(replacedFragment);
                this.insertNew(cmd);
            }
            else {
                cmd = TextBlock();
                cmd.replaces(latexCmd);
                cmd.firstChild.focus = function () { delete this.focus; return this; };
                this.insertNew(cmd).insertAfter(cmd);
                if (replacedFragment)
                    replacedFragment.remove();
            }
            return this;
        };
        _.unwrapGramp = function () {
            var gramp = this.parent.parent;
            var greatgramp = gramp.parent;
            var next = gramp.next;
            var cursor = this;

            var prev = gramp.prev;
            gramp.disown().eachChild(function (uncle) {
                if (uncle.isEmpty()) return;

                uncle.children()
        .adopt(greatgramp, prev, next)
        .each(function (cousin) {
            cousin.jQ.insertBefore(gramp.jQ.first());
        })
      ;

                prev = uncle.lastChild;
            });

            if (!this.next) { //then find something to be next to insertBefore
                if (this.prev)
                    this.next = this.prev.next;
                else {
                    while (!this.next) {
                        this.parent = this.parent.next;
                        if (this.parent)
                            this.next = this.parent.firstChild;
                        else {
                            this.next = gramp.next;
                            this.parent = greatgramp;
                            break;
                        }
                    }
                }
            }
            if (this.next)
                this.insertBefore(this.next);
            else
                this.appendTo(greatgramp);

            gramp.jQ.remove();

            if (gramp.prev)
                gramp.prev.respace();
            if (gramp.next)
                gramp.next.respace();
        };
        _.backspace = function () {
            clearUpDownCache(this);
            this.show();

            if (this.deleteSelection()); // pass
            else if (this.prev) {
                if (this.prev.isEmpty()) {
                    if (this.prev.ctrlSeq === '\\le ') var ins = LatexCmds['<']('<');
                    else if (this.prev.ctrlSeq === '\\ge ') var ins = LatexCmds['>']('>');
                    this.prev = this.prev.remove().prev;
                    if (ins) this.insertNew(ins);
                }
                else if (this.prev instanceof Bracket)
                    return this.appendTo(this.prev.firstChild).deleteForward();
                else
                    this.selectLeft();
            }
            else if (this.parent !== this.root) {
                if (this.parent.parent.isEmpty())
                    return this.insertAfter(this.parent.parent).backspace();
                else if (this.next instanceof Bracket)
                    return this.prependTo(this.next.firstChild).backspace();
                else
                    this.unwrapGramp();
            }
            else this.root.triggerSpecialEvent('backspacePressed');

            if (this.prev)
                this.prev.respace();
            if (this.next)
                this.next.respace();
            this.parent.bubble('redraw');

            return this;
        };
        _.deleteForward = function () {
            clearUpDownCache(this);
            this.show();

            if (this.deleteSelection()); // pass
            else if (this.next) {
                if (this.next.isEmpty())
                    this.next = this.next.remove().next;
                else
                    this.selectRight();
            }
            else if (this.parent !== this.root) {
                if (this.parent.parent.isEmpty())
                    return this.insertBefore(this.parent.parent).deleteForward();
                else
                    this.unwrapGramp();
            }
            else this.root.triggerSpecialEvent('delPressed');

            if (this.prev)
                this.prev.respace();
            if (this.next)
                this.next.respace();
            this.parent.bubble('redraw');

            return this;
        };
        _.selectFrom = function (anticursor) {
            //find ancestors of each with common parent
            var oneA = this, otherA = anticursor; //one ancestor, the other ancestor
            loopThroughAncestors: while (true) {
                for (var oneI = this; oneI !== oneA.parent.parent; oneI = oneI.parent.parent) //one intermediate, the other intermediate
                    if (oneI.parent === otherA.parent) {
                        left = oneI;
                        right = otherA;
                        break loopThroughAncestors;
                    }

                for (var otherI = anticursor; otherI !== otherA.parent.parent; otherI = otherI.parent.parent)
                    if (oneA.parent === otherI.parent) {
                        left = oneA;
                        right = otherI;
                        break loopThroughAncestors;
                    }

                if (oneA.parent.parent)
                    oneA = oneA.parent.parent;
                if (otherA.parent.parent)
                    otherA = otherA.parent.parent;
            }
            //figure out which is left/prev and which is right/next
            var left, right, leftRight;
            if (left.next !== right) {
                for (var next = left; next; next = next.next) {
                    if (next === right.prev) {
                        leftRight = true;
                        break;
                    }
                }
                if (!leftRight) {
                    leftRight = right;
                    right = left;
                    left = leftRight;
                }
            }
            this.hide().selection = Selection(left.prev.next || left.parent.firstChild, right.next.prev || right.parent.lastChild);
            this.insertAfter(right.next.prev || right.parent.lastChild);
            this.root.selectionChanged();
        };
        _.selectLeft = function () {
            clearUpDownCache(this);
            if (this.selection) {
                if (this.selection.first === this.next) { //if cursor is at left edge of selection;
                    if (this.prev) //then extend left if possible
                        this.hopLeft().selection.extendLeft();
                    else if (this.parent !== this.root) //else level up if possible
                        this.insertBefore(this.parent.parent).selection.levelUp();
                }
                else { //else cursor is at right edge of selection, retract left if possible
                    this.hopLeft();
                    if (this.selection.first === this.selection.last) {
                        this.clearSelection().show(); //clear selection if retracting to nothing
                        return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
                    }
                    this.selection.retractLeft();
                }
            }
            else {
                if (this.prev)
                    this.hopLeft();
                else //end of a block
                    if (this.parent !== this.root)
                        this.insertBefore(this.parent.parent);
                    else
                        return;

                this.hide().selection = Selection(this.next);
            }
            this.root.selectionChanged();
        };
        _.selectRight = function () {
            clearUpDownCache(this);
            if (this.selection) {
                if (this.selection.last === this.prev) { //if cursor is at right edge of selection;
                    if (this.next) //then extend right if possible
                        this.hopRight().selection.extendRight();
                    else if (this.parent !== this.root) //else level up if possible
                        this.insertAfter(this.parent.parent).selection.levelUp();
                }
                else { //else cursor is at left edge of selection, retract right if possible
                    this.hopRight();
                    if (this.selection.first === this.selection.last) {
                        this.clearSelection().show(); //clear selection if retracting to nothing
                        return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
                    }
                    this.selection.retractRight();
                }
            }
            else {
                if (this.next)
                    this.hopRight();
                else //end of a block
                    if (this.parent !== this.root)
                        this.insertAfter(this.parent.parent);
                    else
                        return;

                this.hide().selection = Selection(this.prev);
            }
            this.root.selectionChanged();
        };

        function clearUpDownCache(self) {
            self.upDownCache = {};
        }

        _.prepareMove = function () {
            clearUpDownCache(this);
            return this.show().clearSelection();
        };

        _.prepareEdit = function () {
            clearUpDownCache(this);
            return this.show().deleteSelection();
        }

        _.clearSelection = function () {
            if (this.selection) {
                this.selection.clear();
                delete this.selection;
                this.root.selectionChanged();
            }
            return this;
        };
        _.deleteSelection = function () {
            if (!this.selection) return false;

            this.prev = this.selection.first.prev;
            this.next = this.selection.last.next;
            this.selection.remove();
            this.root.selectionChanged();
            return delete this.selection;
        };
    });

    var Selection = P(MathFragment, function (_, _super) {
        _.init = function () {
            var frag = this;
            _super.init.apply(frag, arguments);

            frag.jQwrap(frag.jQ);
        };
        _.jQwrap = function (children) {
            this.jQ = children.wrapAll('<span class="selection"></span>').parent();
            //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it
        };
        _.adopt = function () {
            this.jQ.replaceWith(this.jQ = this.jQ.children());
            return _super.adopt.apply(this, arguments);
        };
        _.clear = function () {
            this.jQ.replaceWith(this.jQ.children());
            return this;
        };
        _.levelUp = function () {
            var seln = this,
      gramp = seln.first = seln.last = seln.last.parent.parent;
            seln.clear().jQwrap(gramp.jQ);
            return seln;
        };
        _.extendLeft = function () {
            this.first = this.first.prev;
            this.first.jQ.prependTo(this.jQ);
        };
        _.extendRight = function () {
            this.last = this.last.next;
            this.last.jQ.appendTo(this.jQ);
        };
        _.retractRight = function () {
            this.first.jQ.insertBefore(this.jQ);
            this.first = this.first.next;
        };
        _.retractLeft = function () {
            this.last.jQ.insertAfter(this.jQ);
            this.last = this.last.prev;
        };
    });
    /*********************************************************
    * The actual jQuery plugin and document ready handlers.
    ********************************************************/

    //The publicy exposed method of jQuery.prototype, available (and meant to be
    //called) on jQuery-wrapped HTML DOM elements.
    $.fn.mathquill = function (cmd, latex) {
        switch (cmd) {
            case 'focus':
            case 'blur':
                return this.each(function () {
                    var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
                    if (block && block.textarea)
                        block.textarea.children().trigger(cmd);
                });
            case 'onKey':
            case 'onText':
                return this.each(function () {
                    var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;

                    if (cursor) {
                        cursor.parent.bubble(cmd, latex, { preventDefault: noop });
                        if (block.blurred) cursor.hide().parent.blur();
                    }
                });
            case 'redraw':
                return this.each(function () {
                    var blockId = $(this).attr(mqBlockId),
        rootBlock = blockId && MathElement[blockId];
                    if (rootBlock) {
                        (function postOrderRedraw(el) {
                            el.eachChild(postOrderRedraw);
                            if (el.redraw) el.redraw();
                        } (rootBlock));
                    }
                });
            case 'revert':
                return this.each(function () {
                    var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId];
                    if (block && block.revert)
                        block.revert();
                });
            case 'latex':
                if (arguments.length > 1) {
                    return this.each(function () {
                        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId];
                        if (block) {

                            //fixes bug with highlighting everything and then setting state with latex
                            //https://github.com/desmosinc/knox/issues/1115
                            cursor = block && block.cursor;
                            if (cursor) cursor.clearSelection();

                            block.renderLatex(latex);

                            if (block.blurred) block.cursor.hide().parent.blur();
                            block.triggerSpecialEvent('render');
                        }
                    });
                }

                var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
                return block && block.latex();
            case 'text':
                var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
                return block && block.text();
            case 'html':
                return this.html().replace(/ ?hasCursor|hasCursor /, '')
      .replace(/ class=(""|(?= |>))/g, '')
      .replace(/<span class="?cursor( blink)?"?>.?<\/span>/i, '')
      .replace(/<span class="?textarea"?><textarea><\/textarea><\/span>/i, '');
            case 'write':
                if (arguments.length > 1)
                    return this.each(function () {
                        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId],
          cursor = block && block.cursor;

                        if (cursor) {
                            cursor.writeLatex(latex)
                            if (block.blurred) cursor.hide().parent.blur();
                        }
                    });
            case 'cmd':
                if (arguments.length > 1)
                    return this.each(function () {
                        var blockId = $(this).attr(mqBlockId),
          block = blockId && MathElement[blockId],
          cursor = block && block.cursor;

                        if (cursor) {
                            cursor.show();
                            if (/^\\[a-z]+$/i.test(latex)) {
                                var selection = cursor.selection;
                                if (selection) {
                                    cursor.prev = selection.first.prev;
                                    cursor.next = selection.last.next;
                                    delete cursor.selection;
                                }
                                cursor.insertCmd(latex.slice(1), selection);
                            }
                            else
                                cursor.insertCh(latex);
                            if (block.blurred) cursor.hide().parent.blur();
                        }
                    });
            case 'moveStart':
                var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
                if (block && block.cursor)
                    block.cursor.prependTo(block);
                break;
            case 'moveEnd':
                var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId];
                if (block && block.cursor)
                    block.cursor.appendTo(block);
                break;
            case 'selection':
                var blockId = $(this).attr(mqBlockId),
      block = blockId && MathElement[blockId],
      cursor = block && block.cursor;
                if (!cursor) return;
                return cursor.selection ? '$' + cursor.selection.latex() + '$' : '';
            case 'clearSelection':
                return this.each(function () {
                    var blockId = $(this).attr(mqBlockId),
        block = blockId && MathElement[blockId],
        cursor = block && block.cursor;
                    if (cursor) {
                        cursor.clearSelection();
                        if (block.blurred) cursor.hide().parent.blur();
                    }
                });
            default:
                var textbox = cmd === 'textbox',
      editable = textbox || cmd === 'editable',
      RootBlock = textbox ? RootTextBlock : RootMathBlock;
                return this.each(function () {
                    createRoot($(this), RootBlock(), textbox, editable);
                });
        }
    };

    //on document ready, mathquill-ify all `<tag class="mathquill-*">latex</tag>`
    //elements according to their CSS class.
    $(function () {
        $('.mathquill-editable:not(.mathquill-rendered-math)').mathquill('editable');
        $('.mathquill-textbox:not(.mathquill-rendered-math)').mathquill('textbox');
        $('.mathquill-embedded-latex').mathquill();
    });


} ());

define("mathquill", function () { });

define('main/keypad', ['require', 'desmos', 'lib/browser', 'main/resize', 'templates/keypad', 'main/cookie', 'mathquill'], function (require) {
    var Desmos = require('desmos');
    var Browser = require('lib/browser');
    var Resize = require('main/resize');
    require('templates/keypad');
    require('main/cookie');
    require('mathquill');


    var keypadView = {
        isOpen: false,

        //user forced minimize by clicking the button
        userMinimized: false,

        generateKeys: function () {
            var trig = 'sin cos tan csc sec cot';
            var oneArgFuncs = 'ceil floor round abs ln log exp';
            var twoArgFuncs = 'min max lcm gcd mod';
            var nk = 'nCr nPr';
            var tabs = 'trig stats calc';

            _.each(tabs.split(' '), function (t) {
                this.keys[t + 'Tab'] = { display: { html: t }, action: { tab: t} };
            }, this);

            _.each(oneArgFuncs.split(' '), function (f) {
                this.keys[f] = { display: { html: f }, action: { func: f} };
            }, this);

            _.each(twoArgFuncs.split(' '), function (f) {
                this.keys[f] = { display: { html: f }, action: { func: f, args: 2} };
            }, this);

            _.each(nk.split(' '), function (f) {
                this.keys[f] = { display: { html: f }, action: { func: f, args: 2} };
            }, this);

            _.each(trig.split(' '), function (fn) {
                _.each([fn, 'arc' + fn, fn + 'h'], function (f) {
                    this.keys[f] = { display: { html: f }, action: { func: f} };
                }, this);
            }, this);

            var i;

            for (i = 0; i < 26; i++) { // a-f
                var ch = String.fromCharCode(97 + i);
                this.keys[ch] = { display: { html: ch }, action: { text: ch} };
            }

            for (i = 0; i < 10; i++) { // 0-9
                var num = String.fromCharCode(48 + i);
                this.keys[num] = { display: { html: num }, action: { text: num} };
            }

            _.each(this.keys, function (item, id) {
                this.genButton(id);
            }, this);
        },

        keys: {
            unknown: { display: { html: '?' },
                action: { text: '?'}
            },
            pi: { display: { html: '&pi;', tooltip: "<b>Pi (3.14159...)</b> you can also type <u>p</u><u>i</u>" },
                action: { text: 'pi'}
            },
            leftparen: { display: { html: '(' },
                action: { text: '('}
            },
            rightparen: { display: { html: ')' },
                action: { text: ')'}
            },
            sqrt: { display: { html: '&radic;', tooltip: '<b>Square Root</b> you can also type <u>s</u><u>q</u><u>r</u><u>t</u>' },
                action: { text: 'sqrt'}
            },
            cuberoot: { display: { html: '<sup>3</sup>&radic;', tooltip: '<b>Square Root</b> you can also type <u>s</u><u>q</u><u>r</u><u>t</u>', noMQ: true },
                action: { custom: 'cuberoot'}
            },
            lt: { display: { html: '&lt;' },
                action: { text: '<'}
            },
            gt: { display: { html: '&gt;' },
                action: { text: '>'}
            },
            le: { display: { html: '&le;' },
                action: { text: '<='}
            },
            ge: { display: { html: '&ge;' },
                action: { text: '>='}
            },
            exponent: { display: { html: 'a^b', tooltip: '<b>Exponent</b> You can also type <u>^</u>' },
                action: { text: '^'}
            },
            subscript: { display: { html: 'a_b', tooltip: '<b>Subscript</b> You can also type <u>_</u>' },
                action: { text: '_'}
            },
            fact: { display: { html: 'x!' },
                action: { text: '!'}
            },
            theta: { display: { html: '&theta;', tooltip: "<b>Theta, for polar graphing</b> you can also type <u>t</u><u>h</u><u>e</u><u>t</u><u>a</u>" },
                action: { text: 'theta'}
            },
            leftbrace: { display: { html: '{', noMQ: true },
                action: { text: '{'}
            },
            rightbrace: { display: { html: '}', noMQ: true },
                action: { text: '}'}
            },
            colon: { display: { html: ':' },
                action: { text: ':'}
            },
            comma: { display: { html: ',' },
                action: { text: ','}
            },

            times: { display: { html: '&times;' },
                action: { text: '*'}
            },
            plus: { display: { html: '+' },
                action: { text: '+'}
            },
            divide: { display: { html: '&divide;' },
                action: { text: '/'}
            },
            minus: { display: { html: '&ndash;' },
                action: { text: '-'}
            },
            equals: { display: { html: '=' },
                action: { text: '='}
            },
            decimal: { display: { html: '.' },
                action: { text: '.'}
            },

            backspace: { display: { aClass: 'always-enabled', html: '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAA5CAMAAACF4xz5AAAC5VBMVEUTERMTExUODQ4PDg8VFRMRERESEhERERIPDw8ODhERERMODg4RERIRERINDQ4NDQ0PDxERERQODg+fn6mpqbLS0tcxMTdhYWtra2vW1tc9PUTo6Ovn5+lra3Dn6Ofd3d3n5+fl5eeMjJLZ2d4xMTEXFxbp6eoxMTTr6+/o6Oq+usDy8vErKy3Z2eAdHR3m5ufS0tLo6Oni4uL19fcdHSDe3uKpqa1ra3bq6usVFRf09PbT09nj4+jQ0Na6usAcHCElJSUnJyfw8PBwcHtMTFo3NzoWFhUpKS0TExbd3d6ysr6MjIyxsbq+vsj09PTAwMIXFxotLTRhYWHl5eatrbbFxcifn7GSkpfNzdPl5eW+vsXQ0NIUFBOtrbL5+PoVFRX4+PqkpKng4OKkn6m2trbAwMi6urqtrbF2dnZhYWXZ2d1RUVvNzdCCgocWFha2trrAwMDAwMWXl5fw8O97e4LCwsvIyMjIyMtcXFwVFRZlZWVRUVbFxcvi4uP39/cgICLm5uYXFxfv7/IpKSvv7+/p6ekpKSkaGhsUFBafn5/Z2dr4+Pj09PWbm6SpqbHFxc3e3t4gICA0NDefn6RWVlvo6OgTExMWFheysrK+vsDT09PCwsjq6ur29vcbGxvj4+P19fZMTFC+vsIiIiKkpK3IyM2Hh4zCwsUTExRwcHaysrZFRUWMjJcaGhocHBybm5/v7/AUFBT39/jv7/Hg4OCXl5+Xl5vz8/Pw8PHy8vPx8fERERH4+Pnx8fLx8fOSkp8VFRaSkptISEgAAAANDQ4MDA0ODg4ODg4ODg4LCwsNDQ8NDQ4LCwsNDQ0ODg4LCwsLCws3NzQsLCw0NDQ9PToCAgNKSkqMjJukpK0FBQQCAgI3NzonJyoZGRkeHiAHBwYDAwQkJCQ6OjoJCQg6Oj0EBAUGBgcHBwgFBQY9PT0ODg8DAwMODg4JCQoICAkPDw8FBQULCwsEBAQGBgYHBwcICAgJCQmeKy57AAAAxHRSTlP4//39//j6+vv9+P35+v39+/j9WlAozpmPJMISEo8SHBIUbiDO8RDODhJACNYg6RQoEhgE6RxQjxDzBiYWKkDp4NsKia7H89j2HEhuSDwGOvHTmRRMNFpoLBQ8KvZMAvMCVhpaRDpATIOZIKosePFEOjpiCn44MjKd85WqNBgC5BTxCtgKENjs81ogAgZeUDQc5MxapRL28Ug8JjgQBOwWBK484lYycjj2iUi4buzpXgrzAgoaYmIGCggI/wIICGj/aLMAcnz+fQAABORJREFUeNq1mGdQ3EYUx+1JmCHczA3pvffeey9O77333nu1sR1347jFPcEGQ4BQDeHOmIDhsnPM6IM/pCeOjTH4TjIaLTv73upzuGM0rLQ6iWOS/4c76Wnvp7fv7b6n0yQSohIyfj0tHQeCS6dNPbChIdHdnUhkPpzvEcVi3ZmD7ux5PB6LZQ8aDjq4XQWr2OZDeiYPDw0NDY/K+faTM6Kn8dAjw8DlR6dNs5/nJ3N7avpRweC779OYAWnMT8AYP6I1CLyoAvoNFLIoFeHSYfvw4QHg8uUAaWrnL4uy4cPKcoIX3WRxFPZEwDYkf96aC1xSwQwYGSNL+N5HCGVamPzlhxzgsook8/hrCcMQPlyD6ZbbRHHbr13+4JJLgYPwzM/e3Wcj9TJE3w4LqOU2Dg1s8QV3rtBAiS8vmrawRVDqQlAsXHj+vJTndji0d7MfuLVa46C748CM9RsIaZ9igJC4wOZeRsjsWcDGBb5RAHhmTLFohDtCbtRwzKxbBXMy1k1NSOX7+YNbGw74O+2JQ5rPayNZdV3Pdeo4Zq6fM2rtmMshFByjjFF3ntFqucC5fMN1GoySwZo5w7F2VGoYAk4UM6+/lO1cNzZgcxMTIhMdXnDKmLVjR4pK4D3KqnhKSzHd9oBh8gIiMU5FEBRg+jGScWkfCwS/MAQg1E1ArXukQV0nZ0pN5DjJ1Nai6VIoer3gd4oYoM/u16Hgq86xYWeeZJpNMyTud02oS35g7153rajTDCb8yopAM/21BJpdOfNY6XSJxUG4wa4tvXa146+iQQDrkVwNtqYQmFSJlBh/U8g42jkkwLSqiK/eLDQlf1TwJ5/J/qoCgLgft0ZDKQ5qKB59mzE3V/U5KmfQmWdtv/Q7FXz1rYyH9AuR5ulLvNwlVsqQuMqquPJaBmCHSACLJspc3DMmGQxFbvBVlzMTw5uZgN/ti2XuafuYsr8q+Bp06mygqG5qZ8vg04tN2V81xldUF4IIJwOcc547fW2zEMSgHZC8Nb0WhsYYIyuJRx2raTCYPBFxsqBorK6fSxR1ncV3iVwxzurlVSIwGmit2kB8tOkiDWkQmLyLQTtPmAUPEF9tWcZ1EQQmdS0sp8+AjW0S7PgTyyWfb7FBBIHJK7tygQVEHpO4GzX7BOl0670ghAv8m+dJ6MUI90UjWyb7O3W+aUarOqW1sRzQ7XGHG0yaNRt9/BXJpXK/sFIpg+NiOYPPWBgIJnWoxlmwnTXSkLv2NxgiY1G5p3y7mwkJPPCl0v7jBYAq+CHJ32S2Puhg0gfzAZNmn3JlJzc6l99Ljs6JCiNtPedYX691h2Kg3QHL5Aj37lLkkcSFJKOPikynrqNhRhc/m/3X+FItRzsUTN5CW9mkPJ3IrjPKpCkDw4cz1seVLr3H/4k+rnMvOcW1WGnn2vmcobwKeXFVKbl9vxRHD1jyWNb3GqK3L5n2X39qLm4mg1y/407LdJ6mQ8GkmsOgh8wgqYGnalMBoCVBSrcSCsXnKBNKlx7Nm2pVy+Y/OcHkNWVzi7STIcWaD5i8SpUMKlx/q4DhP6TqpmiFsIU9EQnYd0GrBFbjnOJiQmB+823B7yveSAKiyFeIcH/YG5YPGQDmK45PPh8GJh9/2vijlpe29VS+/wFRwKrWxb+or/9p3Kr/fM1KQhzwf6z/Hfwvv0uHU3Wig3wAAAAASUVORK5CYII=" />' },
                action: { key: 'Backspace'}
            },
            enter: { display: { aClass: 'always-enabled', html: 'ent<span>er</span>' },
                action: { key: 'Enter'}
            },
            toggleLetters: { display: { aClass: 'always-enabled toggle-btn', html: 'A B C', colspan: 2 },
                action: { changeLayout: "letters"}
            },
            toggleNumbers: { display: { aClass: 'always-enabled toggle-btn', html: '1<span> </span>2<span> </span>3', colspan: 1 },
                action: { changeLayout: 'mainNumbers'}
            },

            popupFunctions: { display: { aClass: 'always-enabled toggle-btn', html: 'functions', colspan: 2 },
                action: { popup: "functions"}
            },

            blank: { display: {},
                action: {}
            },

            halfBlank: { display: { colspan: 0.5 },
                action: {}
            },

            left: { display: { aClass: 'always-enabled', html: '&larr;' },
                action: { key: "Left"}
            },
            up: { display: { aClass: 'always-enabled', html: '&uarr;' },
                action: { key: "Up"}
            },
            right: { display: { aClass: 'always-enabled', html: '&rarr;' },
                action: { key: "Right"}
            },
            down: { display: { aClass: 'always-enabled', html: '&darr;' },
                action: { key: "Down"}
            },

            toggleAltLeft: { display: { aClass: 'always-enabled toggle-btn', html: 'more', colspan: 2 },
                action: { changeLayout: "altNumbers"}
            },
            toggleMainLeft: { display: { aClass: 'always-enabled toggle-btn active', html: 'more', colspan: 2 },
                action: { changeLayout: "mainNumbers"}
            },
            loga: { display: { html: 'log_a' },
                action: { custom: 'loga'}
            },
            ddx: { display: { html: 'd/dx' },
                action: { custom: 'd/dx'}
            },
            sum: { display: { html: '\\sum' },
                action: { text: 'sum'}
            },
            prod: { display: { html: '\\prod' },
                action: { text: 'prod'}
            }
        },


        genButton: function (buttonId) {
            var key = this.keys[buttonId];
            var display = key.display;
            var action = key.action;

            if (!('cellClass' in display))
                display.cellClass = '';

            if (!('aClass' in display))
                display.aClass = '';

            if (display.colspan) {

                if (display.cellClass)
                    display.cellClass += ' ';

                switch (display.colspan) {
                    case 0.5:
                        display.cellClass += 'halfwide';
                        break;
                    case 1.5:
                        display.cellClass += 'oneandhalfwide';
                        break;
                    case 2:
                        display.cellClass += 'twowide';
                        break;
                }
            }

            if (display.html) {
                display.aClass = (display.aClass ? display.aClass + ' key' : 'key');

                if (display.actionOn == "tapstart") {
                    display.aClass += " tapstartable";
                } else {
                    display.aClass += " tappable";
                }
            }

            if (
      !(action.tab || action.key || action.popup || action.changeLayout) &&
      !display.noMQ && display.html
    ) {
                display.mathquill = true;

                // ask mathquill for an html version of itself
                // note: this will break for things like parentheses with contents,
                // which need to be inserted into the dom to know their correct size.
                // but works for uncomplicated mathquill

                display.html = $(
         "<span>" +
         display.html +
         "</span>"
       ).mathquill().mathquill('html');
                display.aClass += ' mathquill-rendered-math';
            }

            $.extend(display, { id: buttonId });
        },

        hideKeypad: function () {
            setTimeout(function () {
                if (Browser.IS_IE8 || Browser.IS_IE9) {
                    $('#show-keypad').show();     // IE<10 doesn't support transitions, so we shouldn't fade the button in
                } else {
                    $('#show-keypad').fadeIn();
                }
            }, 250);

            // return early if we're already closed
            if (!this.isOpen)
                return;

            var $keys = $('#keys-container');

            //transform it far enough that even the tab isn't visible
            $keys.css('transform', 'translate3d(0, 255  px, 0)');

            //don't want it below the screen (this fixes bug #1267)
            setTimeout(function () {
                $keys.hide();
            }, 250);
            this.hidePopups();
            this.isOpen = false;
            Resize.trigger();
        },

        showKeypad: function () {
            if (this.isOpen)
                return;

            this.setLayout("mainNumbers");
            var $keys = $('#keys-container');
            $('#show-keypad').hide();
            $keys.show();
            setTimeout(function () {
                $keys.css('transform', 'translate3d(0, 0, 0)');
            }, 0);
            this.isOpen = true;

            setTimeout(function () {
                Resize.trigger();
            }, 400);
        },

        setIsBlurred: function (isBlurred) {
            if (this.userMinimized)
                return;

            if (isBlurred && this.isOpen) {
                this.hideKeypad();
            } else if (!isBlurred && !this.isOpen) {
                this.showKeypad();
            }
        },

        setKeysDisabled: function (isDisabled) {
            $('#keys').toggleClass('keys-disabled', isDisabled);
        },

        getButton: function (buttonId) {
            if (!this.keys[buttonId])
                buttonId = "unknown";
            return this.keys[buttonId].display;
        },

        buttonArray: function (buttonsString) {
            buttons = [];
            _.each(buttonsString.split(' '), function (button, index) {
                buttons[index] = this.getButton(button);
            }, this);

            return buttons;
        },

        setupKeypad: function () {
            this.buttons = {
                mainNumbersLeft: [
        { keys: this.buttonArray('x y exponent') },
        { keys: this.buttonArray('leftparen rightparen comma') },
        { keys: this.buttonArray('lt gt sqrt') },
        { keys: this.buttonArray('toggleAltLeft subscript') }
      ],

                altNumbersLeft: [
        { keys: this.buttonArray('r theta pi') },
        { keys: this.buttonArray('leftbrace rightbrace colon') },
        { keys: this.buttonArray('le ge cuberoot') },
        { keys: this.buttonArray('toggleMainLeft e') }
      ],

                numbersMiddle: [
        { keys: this.buttonArray('7 8 9 divide') },
        { keys: this.buttonArray('4 5 6 times') },
        { keys: this.buttonArray('1 2 3 minus') },
        { keys: this.buttonArray('0 decimal equals plus') }
      ],

                numbersRight: [
        { keys: this.buttonArray('popupFunctions backspace') },
        { keys: this.buttonArray('toggleLetters enter') },
        { keys: this.buttonArray('blank up blank') },
        { keys: this.buttonArray('left down right') }
      ],

                letters: [
        { keys: this.buttonArray('q w e r t y u i o p backspace') },
        { keys: this.buttonArray('halfBlank a s d f g h j k l halfBlank toggleNumbers') },
        { keys: this.buttonArray('blank z x c v b n m comma blank enter') },
        { keys: this.buttonArray('halfBlank equals leftparen rightparen leftbrace rightbrace colon theta pi subscript') }
      ]

            };

            this.popups = {
                functionsPopup: {
                    trig: {
                        tab: this.getButton('trigTab'),
                        funcs: this.buttonArray('sin arcsin sinh cos arccos cosh tan arctan tanh csc arccsc csch sec arcsec sech cot arccot coth')

                    },

                    stats: {
                        tab: this.getButton('statsTab'),
                        funcs: this.buttonArray('ceil floor round abs min max lcm gcd mod nCr nPr fact')
                    },

                    calc: {
                        tab: this.getButton('calcTab'),
                        funcs: this.buttonArray('exp ln log loga ddx sum prod fact')
                    }

                }
            };
        },

        init: function () {

            if (getCookie("keypadMinimized") === "true") {
                this.userMinimized = true;
                //in this case, we're not going to open up the keypad, so we should manually show the "show-keypad" button.
                keypadView.hideKeypad();
            }

            this.generateKeys();
            this.setupKeypad();
            this.setLayout('mainNumbers');

            var self = this;
            $('#keys-container').html(Desmos.Templates.keypad({ buttons: this.buttons, popups: this.popups }));
            $('#keys-container').on('tap', '.tappable', function (evt) {
                var button = $(evt.target).closest('.tappable');
                self.buttonClicked(button);
            });

            $('#keys-container').on('tapstart', '.tapstartable', function (evt) {
                var button = $(evt.target).closest('.tapstartable');
                self.buttonClicked(button);
            });



            //initialize hide & show
            $('#minimize-keypad').on("tap", function () {
                self.userMinimized = true;

                setCookie("keypadMinimized", "true");

                self.hideKeypad();
            });
            //on show: drop focus into the first equation item
            $('#show-keypad').on("tap", function () {
                self.userMinimized = false;
                setCookie("keypadMinimized", "false");

                self.showKeypad();

                if (!Desmos.expressions.itemFocused ||
          (
            !Desmos.expressions.getSelected().isExpression &&
            !Desmos.expressions.getSelected().isTable
          )
      ) {
                    //we're not currently focused in an expression that can take keyboard input
                    var index = 0;
                    while (Desmos.expressions.getItemByIndex(index) && !Desmos.expressions.getItemByIndex(index).isExpression) {
                        index++;
                    }

                    var exprItem = Desmos.expressions.getItemByIndex(index);
                    var exprId = exprItem ? exprItem.id : null;
                    var exprView = Desmos.expressions.getItemView(exprId);
                    if (exprView) {
                        exprView.addFocus();
                    } else {
                        //create a new blank expression and give it focus
                        //note: did this because I didn't want to duplicate code, but this seems like
                        //a flaky solution. Seems like "add expression at bottom of list with focus" should
                        //just be a method that gets called her and from "new expression"
                        $('#new-expression').trigger("tap");
                    }

                }
            });

        },

        height: function () {
            return this.isOpen ? $('#keys-container').height() : 0;
        },

        setLayout: function (newLayout) {
            $('#keys-container').removeClass('letters').removeClass('altNumbers').removeClass('mainNumbers').addClass(newLayout);
        },

        setTab: function (newTab) {
            var tabs = 'trig stats calc';
            _.each(tabs.split(' '), function (tab) {
                $('#' + tab + 'Tab').removeClass('selected');
                $('#funcs-' + tab).hide();
            });
            $('#' + newTab + 'Tab').addClass('selected');
            $('#funcs-' + newTab).show();
        },

        hidePopups: function () {
            $('#popupFunctions').removeClass("active");
            $('#functions-popover').hide();
        },

        setPopup: function (newPopup) {
            if (newPopup === 'functions') {
                if ($(window).height() < 525) {
                    $('#functions-popover').removeClass("top").addClass("left");
                } else {
                    $('#functions-popover').removeClass("left").addClass("top");
                }
                $('#popupFunctions').toggleClass("active");
                $('#functions-popover').toggle();
            }
        },

        insMQText: function (str) {
            var editor = Desmos.expressions.getActiveMathquill();
            for (var i = 0; i < str.length; i++) {
                editor.mathquill("onText", str.charAt(i));
            }
        },

        buttonClicked: function (button) {
            var keyID = $(button).attr('id'),
        buttonAction = this.keys[keyID].action;

            if (buttonAction.changeLayout) {
                this.hidePopups();
                this.setLayout(buttonAction.changeLayout);
                return;
            }
            if (buttonAction.tab) {
                this.setTab(buttonAction.tab);
                return;
            }
            if (buttonAction.popup) {
                this.setPopup(buttonAction.popup);
                return;
            }

            //hide popup when any button is pressed (Except a popup or tab button)
            this.hidePopups();

            var editor = Desmos.expressions.getActiveMathquill();
            if (!editor.length) {

                // makes it so that the keypad works for the non-editable table cells.
                var selected = Desmos.expressions.getSelected();
                if (selected && selected.isTable) {
                    if (selected.selectedCell) {
                        var view = Desmos.expressions.getItemView(selected.id);
                        view.doKeyAction(buttonAction.key);
                    }
                }

                return;
            }

            try {
                if (buttonAction.key) {
                    editor.mathquill("onKey", buttonAction.key);
                } else if (buttonAction.text) {
                    this.insMQText(buttonAction.text);
                } else if (buttonAction.func) {
                    var suffix = '\\left( \\right)';
                    if (buttonAction.args === 2) {
                        suffix = '\\left({},{}\\right)';
                    }
                    editor.mathquill('write', buttonAction.func + suffix);
                    editor.mathquill('onKey', 'Left');
                    if (buttonAction.args === 2) {
                        editor.mathquill('onKey', 'Left');
                    }

                } else if (buttonAction.custom) {
                    switch (buttonAction.custom) {
                        case 'loga':
                            editor.mathquill('write', 'log_{}\\left( \\right)');
                            editor.mathquill('onKey', 'Left');
                            editor.mathquill('onKey', 'Left');
                            editor.mathquill('onKey', 'Left');
                            break;
                        case 'cuberoot':
                            editor.mathquill('write', '\\sqrt[3]{}');
                            editor.mathquill('onKey', 'Left');
                            break;
                        case 'd/dx':
                            editor.mathquill('write', '\\frac{d}{dx}');
                            break;
                    }
                }

                // after everything is said and done, tell mathquill it rendered. This
                // will update the value stored for the expressions latex. And that
                // will cause this change to go into undo/redo.
                editor.trigger('render');
            } catch (e) {
                console.log(e);
            }
        }
    };
    $(function () {
        keypadView.init();
    });

    return keypadView;
});

define('lib/keydown_which', ['require'], function (require) {

    // based on http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
    var table = {
        8: 'Backspace',
        9: 'Tab',
        13: 'Enter',
        27: 'Esc',
        37: 'Left',
        38: 'Up',
        39: 'Right',
        40: 'Down',
        46: 'Del'
    };

    return {
        which: function (which) {
            return table[which];
        }
    };

});
; (function ($) {

    $.fn.extend({

        scrollVisible: function (elms, topOffset, bottomOffset) {

            if (elms && elms.length) {

                topOffset = topOffset || 0;
                bottomOffset = bottomOffset || 0;

                var view_top = this.offset().top + topOffset;
                var view_height = this.height() + bottomOffset - topOffset;

                //set the first top and bottom
                var elms_top = $(elms[0]).offset().top;
                var elms_bottom = $(elms).height() + elms_top;

                //loop through all other elements to find combined top/bottom
                elms.each(function () {
                    var elm = $(this);
                    var top = elm.offset().top;
                    var bottom = elm.height() + top;

                    if (top < elms_top) elms_top = top;
                    if (bottom > elms_bottom) elms_bottom = bottom;
                });

                var value = -this.scrollTop();

                //adjust for the offset of "this"
                elms_top -= view_top + value;
                elms_bottom -= view_top + value;

                var min = -elms_top;
                var max = view_height - elms_bottom;

                if (value > max && value < min) {
                    //do nothing
                } else if (elms_bottom - elms_top > view_height) {
                    // do nothing
                    // the content is larger than the viewport and we'll just get in the
                    // way of the browser. The browser will put the correct part of the
                    // content in view based on which part of the content has focus.
                } else if (value > max) {
                    this.scrollTop(-max);
                } else if (value < min) {
                    this.scrollTop(-min);
                }
            }

            return this;
        }
    });

})(jQuery);






define("lib/jquery.scrollvisible", function () { });

//Utilities for tracking feature usage.
//Not just using straight event tracking because we want to do things like:
// * Record only the discovery of a feature
// * Record only a sub-sample of feature uses
define('lib/track_feature', ['require', 'analytics/kissmetrics'], function (require) {
    require('analytics/kissmetrics');

    var discovered = {};

    var discover = function (name) {
        if (discovered.hasOwnProperty(name)) return;
        discovered[name] = true;
        _kmq.push(['record', 'Discovered ' + name]);
    };

    var use = function (name) {
        sample_usage(name, 1);
    };

    var sample_usage = function (name, n) {
        //n should be n integer >= 1
        //Feature usage will be reported 1/n of the time, with a property which records the current n
        //In analytics, summing over this property should give a good estimate of total uses
        //Setting n = 1 will report every instance
        discover(name); //Always report if it's the first usage in a session
        if (Math.random() > 1 / n) return;
        var params = {};
        params['E(' + name + ')'] = n;
        _kmq.push(['record', 'Used ' + name, params]);
    };

    return {
        discover: discover,
        use: use,
        sample_usage: sample_usage
    };
});

// desmos/public/assets/grapher/compiled_underscore_templates/new_expression.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/new_expression', ["desmos"], function (Desmos) {
    Desmos.Templates["new_expression"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class="expressionitem new-expression opened">\n  <div class=\'new-math-div do-not-blur action-newmath\'>\n    <div class=\'new-expression-fade\'></div>\n  </div>\n\n\n  <div class=\'more-options-slideout-container\'>\n    <div class=\'more-options-slideout do-not-blur isHidden\'>\n\n      <div class=\'new-item do-not-blur action-newtext\'>\n        <img src=\'/assets/grapher/img/expr-icons/new-text.png\'>\n        <br>\n        text\n      </div>\n\n      <div class=\'new-item do-not-blur action-newtable\' id=\'new-table\'>\n        <img src=\'/assets/grapher/img/expr-icons/new-table.png\'>\n        <br>\n        table\n      </div>\n\n      <div class=\'new-item do-not-blur action-newmath\'>\n        <img src=\'/assets/grapher/img/expr-icons/new-expression.png\'>\n        <br>\n        expression\n      </div>\n    </div>\n  </div>\n\n\n  <div class=\'more-options btn do-not-blur action-moreoptions\'>\n    <i class=\'icon-chevron-right\'></i>\n    <i class=\'icon-chevron-left\'></i>\n  </div>\n\n  <span\n     class="tab"\n  >\n     <span class=\'num variable-index\'>2</span>\n     <div class=\'tab-interior\'></div>\n  </span>\n\n</div>\n';
        }
        return __p;
    };
});
define('expressions/abstractitem', ['require', 'pjs', 'lib/underscore_model'], function (require) {
    var nextId = 1;
    var P = require('pjs');
    var UnderscoreModel = require('lib/underscore_model');

    var AbstractItemModel = P(UnderscoreModel, function (model, _super) {

        nextItemId = 1;

        model.init = function (state) {
            _super.init.call(this);

            // TODO - these belong on view, not the model
            this.index = -1;
            this.selected = false;

            for (var property in state) {
                if (state.hasOwnProperty(property)) {
                    this[property] = state[property];
                }
            }

            if (!this.hasOwnProperty('id')) {
                this.id = nextItemId++;
            } else if (this.id >= nextItemId) {
                nextItemId = this.id + 1;
            }
        };
    });

    return AbstractItemModel;
});

define('expressions/domain', ['require', 'lib/underscore_model', 'pjs'], function (require) {
    var UnderscoreModel = require('lib/underscore_model');
    var P = require('pjs');

    var DomainModel = P(UnderscoreModel, function (model, _super) {
        model.init = function (min, max) {
            _super.init.call(this);
            this.min = min;
            this.max = max;
        };

        model.isValid = function () {
            return isFinite(this.min) && isFinite(this.max) && (this.max > this.min);
        };

        model.serialize = function () {
            return { min: this.min, max: this.max };
        };
    });

    DomainModel.deserialize = function (obj) {
        if (!obj) return DomainModel();
        else return DomainModel(obj.min, obj.max);
    };

    return DomainModel;
});

define('expressions/slider', ['require', 'pjs', 'lib/underscore_model'], function (require) {
    var P = require('pjs');
    var UnderscoreModel = require('lib/underscore_model');

    var SliderModel = P(UnderscoreModel, function (model, _super) {
        model.init = function (value, min, max, step) {
            _super.init.call(this);
            this.min = min;
            this.max = max;
            this.step = step;
            this.value = value;
        };

        model.serialize = function () {
            return { min: this.min, max: this.max, step: this.step, value: this.value };
        };
    });

    SliderModel.deserialize = function (obj) {
        if (!obj) return SliderModel();
        else return SliderModel(obj.value, obj.min, obj.max, obj.step);
    };

    return SliderModel;
});

define('expressions/colors', ['require'], function (require) {
    var colors = ['#C0504D', '#8064A2', '#F79646', '#000000', '#4F81BD', '#9BBB59'];

    var generate_i = 0;
    function generateNewColor() {
        generate_i++;
        if (generate_i >= colors.length) {
            generate_i = 0;
        }

        return colors[generate_i];
    }

    return {
        colors: colors,
        generateNewColor: generateNewColor
    };
});
define('expressions/expression', ['require', 'desmos', 'pjs', 'lib/underscore_model', 'math/evaluationstate', 'undoredo', './abstractitem', './domain', './slider', './colors'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreModel = require('lib/underscore_model');
    var EvaluationState = require('math/evaluationstate');
    var UndoRedo = require('undoredo');
    var AbstractItemModel = require('./abstractitem');
    var DomainModel = require('./domain');
    var SliderModel = require('./slider');
    var Colors = require('./colors');

    var computeNewLatex = function (latex, v) {
        var p = /([^=><]+[=><]* *)([^ ]+)( *)/;

        latex = latex.split("\\space").join(" ");
        latex = latex.split("\\le").join("<=").split("\\ge").join(">=");
        latex = latex.replace(p, "$1" + v + "$3");
        latex = latex.split(" ").join("\\space").split("<=").join("\\le");
        latex = latex.split(">=").join("\\ge");

        return latex;
    };


    var ExpressionObject = P(AbstractItemModel, function (model, _super) {

        model.isExpression = true;

        model.init = function (state) {
            _super.init.call(this, state);

            this.loading = true;
            // a default blank formula while we calculate the real one
            this.formula = EvaluationState({ status: SILENT });

            // TODO - this is very temporary. Eventually we'll want to save the
            // slider info in here, but there are some old states that have obsolete
            // values stored in there. We've repurposed the .slider variable on this
            // class to be a SliderModel. Because the .slider value is being set
            // on instantiation, we aren't overwriting it with a SliderModel. Then,
            // when the .slider property is expected to do things that a SliderModel
            // can, it throws an error. When we migrate old graph states to use this
            // property, we need to remove the next line.
            delete this.slider;

            // fill in a color if not specified
            if (!this.color) {
                this.color = Colors.generateNewColor();
            }

            // convert old style of color definition to simpler new version
            else if (typeof this.color === 'object') {
                this.color = this.color.value;
            }

            if (this.userRequestedGraphing === undefined) {
                this.userRequestedGraphing = 'default';
            }

            if (this.latex === undefined) this.latex = '';

            // convert raw domain object to a DomainModel Object
            var raw_domain = this.domain ? this.domain : { min: 0, max: 10 };
            this.domain = DomainModel.deserialize(raw_domain);
            this.domain.observe('min max', function (property) {
                this.onExpressionDidChange();

                // handle undo/redo
                var id = this.id;
                var oldValue = this.domain.getOldProperty(property);
                var newValue = this.domain.getProperty(property);

                UndoRedo.addTransaction({
                    type: UndoRedo.RESPONSE_TO_CHANGE,
                    undo: function () { Desmos.expressions.getItemById(id).domain.setProperty(property, oldValue); },
                    redo: function () { Desmos.expressions.getItemById(id).domain.setProperty(property, newValue); }
                });
            } .bind(this));

            this.computeShouldGraph();

            this.observe('formula', this.onFormulaUpdate.bind(this));
            this.observe('latex color userRequestedGraphing', this.onStateDidChange.bind(this));
            this.observe('color', this.onColorDidChange.bind(this));
            this.observe('latex shouldGraph color', this.onExpressionDidChange.bind(this));
            this.observe('userRequestedGraphing', this.computeShouldGraph.bind(this));

            // TODO - I think we should call this.onExpressionDidChange here and
            // not in the expression list. The expression is responsible for
            // requestParse() on any change after it's created. It should be
            // responsible for the requestParse() immediately after it's created.
            // The only problem there is that it's not too certain when it's destroyed
            // and it'll still be up to the expression list to requestUnparse() it.
            // That would be solved if the expression had a 'inTheList' property that
            // we tripped when it was deleted. An alternative to this would be
            // for the expression itself to never call .requestParse() but for the
            // expression list to simply observe changes to the expression. I think
            // I like that better.
        };

        model.computeShouldGraph = function () {
            var shouldGraph = (
        this.userRequestedGraphing === 'default' ||
        this.userRequestedGraphing === 'always'
      );
            this.setProperty('shouldGraph', shouldGraph);
        };

        // Record change for undo-redo
        model.onStateDidChange = function (prop) {
            var id = this.id;
            var oldValue = this.getOldProperty(prop);
            var newValue = this.getProperty(prop);

            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () {
                    Desmos.expressions.getItemById(id).setProperty(prop, oldValue);
                },
                redo: function () {
                    Desmos.expressions.getItemById(id).setProperty(prop, newValue);
                }
            });
        };

        model.onColorDidChange = function () {
            if (this.isGraphed) {
                this.requestGraph();
            }
        };

        model.onExpressionDidChange = function () {
            if (this.domain.isValid()) {
                this.requestParse();
            }
        };

        model.getParsableObject = function () {
            //Work-around for bug in Mathquill / expression list
            // where on deletion of an expression via back-space key, Mathquill fires both an UpwardDelete
            // and a Render event.  UpwardDelete causes the expressionList to delete, and Render causes
            // expression list to fire another add request for the already deleted expression, which comes
            // in with latex === undefined.
            if (this.latex === undefined) {
                return undefined;
            }

            return {
                type: 'statement',
                id: this.id,
                latex: this.latex,
                domain: this.domain.serialize(),
                shouldGraph: this.shouldGraph,
                color: this.color
            };
        };

        model.requestParse = function () {
            Desmos.expressions.triggerAddExp(this.getParsableObject());
        };

        model.requestUnparse = function () {
            Desmos.expressions.triggerRemoveExp(this.id);
        };

        model.getState = function () {
            var state = {
                id: this.id,
                latex: this.latex,
                domain: this.domain.serialize(),
                userRequestedGraphing: this.userRequestedGraphing,
                color: this.color
            };

            // TODO - change this to state.slider = this.slider.serialize() but can't
            // do that until we convert all previously saved graphs to have a slider
            // object rather than three global properties. We either need to do that
            // or we need to make the setState() function backwards compatible.
            if (this.slider) {
                state.sliderMin = this.slider.min;
                state.sliderMax = this.slider.max;
                state.sliderInterval = this.slider.step;
            }

            return state;
        };

        model.onFormulaUpdate = function () {
            var formula = this.formula;

            this.setProperty('error', formula.error);
            this.setProperty('isGraphable', formula.is_graphable);
            this.setProperty('dependent', formula.assignment);
            this.setProperty('isTableable', formula.is_tableable);

            // delay instantiation of a slider for this expression until we need one.
            // once created, the slider object won't be destroyed. The view for the
            // slider will though. The slider sticks around to save information about
            // limits. They'd get reset each time if we didn't keep the slider.
            if (formula.is_slidable && !this.slider) {
                this.createSliderModel();
            }
        };

        model.createSliderModel = function () {

            this.slider = SliderModel.deserialize({
                min: this.sliderMin !== undefined ? this.sliderMin : -10,
                max: this.sliderMax !== undefined ? this.sliderMax : 10,
                step: this.sliderInterval,
                value: this.formula.simple_constant
            });

            var id = this.id;

            this.slider.observe('step', function () {
                var oldStep = this.slider.getOldProperty('step');
                var newStep = this.slider.getProperty('step');

                UndoRedo.addTransaction({
                    type: UndoRedo.RESPONSE_TO_CHANGE,
                    undo: function () {
                        Desmos.expressions.getItemById(id).slider.setProperty('step', oldStep);
                    },
                    redo: function () {
                        Desmos.expressions.getItemById(id).slider.setProperty('step', newStep);
                    }
                });
            } .bind(this));

            this.slider.observe('min', function () {
                var oldMin = this.slider.getOldProperty('min');
                var newMin = this.slider.getProperty('min');
                var oldValue = this.slider.getProperty('value');
                var oldLatex = newMin > oldValue ? this.latex : null;
                var newLatex = newMin > oldValue ? computeNewLatex(oldLatex, newMin) : null;

                UndoRedo.addTransaction({
                    type: UndoRedo.CAUSE_OF_CHANGE,
                    undo: function () {
                        var expression = Desmos.expressions.getItemById(id);
                        expression.slider.setProperty('min', oldMin);
                        if (oldLatex) {
                            expression.setProperty('latex', oldLatex);
                        }
                    },
                    redo: function () {
                        var expression = Desmos.expressions.getItemById(id);
                        expression.slider.setProperty('min', newMin);
                        if (newLatex) {
                            expression.setProperty('latex', newLatex);
                        }
                    }
                });
            } .bind(this));

            this.slider.observe('max', function () {
                var oldMax = this.slider.getOldProperty('max');
                var newMax = this.slider.getProperty('max');
                var oldValue = this.slider.getProperty('value');
                var oldLatex = newMax < oldValue ? this.latex : null;
                var newLatex = newMax < oldValue ? computeNewLatex(oldLatex, newMax) : null;

                UndoRedo.addTransaction({
                    type: UndoRedo.CAUSE_OF_CHANGE,
                    undo: function () {
                        var expression = Desmos.expressions.getItemById(id);
                        expression.slider.setProperty('max', oldMax);
                        if (oldLatex) {
                            expression.setProperty('latex', oldLatex);
                        }
                    },
                    redo: function () {
                        var expression = Desmos.expressions.getItemById(id);
                        expression.slider.setProperty('max', newMax);
                        if (newLatex) {
                            expression.setProperty('latex', newLatex);
                        }
                    }
                });
            } .bind(this));

            this.slider.observe('value', function () {
                var newValue = this.slider.getProperty('value');

                // check if the new value is too big for the slider limits. If so,
                // we adjust the slider limits to enclose the value.
                var oldLimitValue = null;
                var narrowLimit = "";
                if (newValue < this.slider.min) {
                    narrowLimit = "min";
                    oldLimitValue = this.slider.min;
                } else if (newValue > this.slider.max) {
                    narrowLimit = "max";
                    oldLimitValue = this.slider.max;
                }

                if (narrowLimit) {
                    UndoRedo.addTransaction({
                        type: UndoRedo.BATCHED_CHANGE,
                        undo: function () {
                            var expression = Desmos.expressions.getItemById(id);
                            expression.slider.setProperty(narrowLimit, oldLimitValue);
                        },
                        redo: function () {
                            var expression = Desmos.expressions.getItemById(id);
                            expression.slider.setProperty(narrowLimit, newValue);
                        }
                    });
                }

                // only update latex if change from slider view. if the value
                // changed from the user typing latex, then the latex will already be
                // updated and this will return early. If it's from the slider view,
                // the latex will not have updated, so let's update it now. We're
                // compressing multiple slider thumb moves into a single undo event.
                var oldLatex = this.latex;
                var newLatex = computeNewLatex(oldLatex, newValue);
                if (oldLatex === newLatex) return;

                UndoRedo.addTransaction({
                    type: UndoRedo.CAUSE_OF_CHANGE,
                    compressWith: "<commit_slider_value>",
                    undo: function () {
                        var expression = Desmos.expressions.getItemById(id);
                        expression.setProperty('latex', oldLatex);
                    },
                    redo: function () {
                        var expression = Desmos.expressions.getItemById(id);
                        expression.setProperty('latex', newLatex);
                    }
                });
            } .bind(this));
        };

        model.isEmpty = function () {
            var latex = this.latex;
            return !latex || latex.split(" ").join("") === "";
        };
    });

    return ExpressionObject;
});

/* big.js v1.0.1 https://github.com/MikeMcl/big.js/LICENCE */
; (function (global) {


    /*
    big.js v1.0.1
    A small, fast Javascript library for arbitrary-precision arithmetic with decimal numbers. 
    https://github.com/MikeMcl/big.js/
    Copyright (c) 2012 Michael Mclaughlin <M8ch88l@gmail.com>
    MIT Expat Licence
    */

    /****************************** EDITABLE DEFAULTS **********************************/


    // The default values below must be integers within the stated ranges (inclusive).

    /*
    * The maximum number of decimal places of the results of methods involving
    * division, i.e. 'div' and 'sqrt', and 'pow' with negative exponents.
    */
    Big['DP'] = 20;                                  // 0 to MAX_DP

    /*
    * The rounding mode used when rounding to the above decimal places.
    *
    * 0 Round towards zero (i.e. truncate, no rounding).               (ROUND_DOWN     )
    * 1 Round to nearest neighbour. If equidistant, round up.          (ROUND_HALF_UP  )
    * 2 Round to nearest neighbour. If equidistant, to even neighbour. (ROUND_HALF_EVEN)
    */
    Big['RM'] = 1;                                   // 0, 1 or 2

    // The maximum value of 'Big.DP'.
    var MAX_DP = 1E6,                                // 0 to 1e+6

    // The maximum magnitude of the exponent argument to the 'pow' method.
        MAX_POWER = 1E6,                             // 1 to 1e+6

    /*
    * The exponent value at and beneath which 'toString' returns exponential notation.
    * Javascript's Number type: -7
    * -1e+6 is the minimum recommended exponent value of a 'Big'.
    */
        TO_EXP_NEG = -7,                             // 0 to -1e+6

    /*
    * The exponent value at and above which 'toString' returns exponential notation.
    * Javascript's Number type: 21
    * 1e+6 is the maximum recommended exponent value of a 'Big', though there is no
    * enforcing or checking of a limit.
    */
        TO_EXP_POS = 21,                             // 0 to 1e+6


    /***********************************************************************************/

        P = Big.prototype,
        isValid = /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?$/i,
        ONE = new Big(1);


    // CONSTRUCTOR


    /*
    * The exported function.
    * Create and return a new instance of a 'Big' object.
    *
    * n {number|string|Big} A numeric value.
    */
    function Big(n) {
        var i, j, nL,
            x = this;

        // Enable constructor usage without new.
        if (!(x instanceof Big)) {
            return new Big(n)
        }

        // Duplicate.
        if (n instanceof Big) {
            x['s'] = n['s'];
            x['e'] = n['e'];
            x['c'] = n['c'].slice();
            return
        }

        // Minus zero?
        if (n === 0 && 1 / n < 0) {
            n = '-0'
            // Ensure 'n' is string and check validity.
        } else if (!isValid.test(n += '')) {
            throw NaN
        }

        // Determine sign.
        x['s'] = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

        // Decimal point?
        if ((i = n.indexOf('.')) > -1) {
            n = n.replace('.', '')
        }

        // Exponential form?
        if ((j = n.search(/e/i)) > 0) {

            // Determine exponent.
            if (i < 0) {
                i = j
            }
            i += +n.slice(j + 1);
            n = n.substring(0, j)

        } else if (i < 0) {

            // Integer.
            i = n.length
        }

        // Determine leading zeros.
        for (j = 0; n.charAt(j) == '0'; j++) {
        }

        if (j == (nL = n.length)) {

            // Zero.
            x['c'] = [x['e'] = 0]
        } else {

            // Determine trailing zeros.
            for (; n.charAt(--nL) == '0'; ) {
            }

            x['e'] = i - j - 1;
            x['c'] = [];

            // Convert string to array of digits (without leading and trailing zeros).
            for (i = 0; j <= nL; x['c'][i++] = +n.charAt(j++)) {
            }
        }
    }


    // PRIVATE FUNCTIONS


    /*
    * Round 'Big' 'x' to a maximum of 'dp' decimal places using rounding mode
    * 'rm'. (Called by 'div', 'sqrt' and 'round'.)
    *
    * x {Big} The 'Big' to round.
    * dp {number} Integer, 0 to MAX_DP inclusive.
    * rm {number} 0, 1 or 2 ( ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
    * [more] {boolean} Whether the result of division was truncated.
    */
    function rnd(x, dp, rm, more) {
        var xc = x['c'],
            i = x['e'] + dp + 1;

        if (rm !== 0 && rm !== 1 && rm !== 2) {
            throw '!Big.RM!'
        }

        // 'xc[i]' is the digit after the digit that may be rounded up.
        rm = rm && (xc[i] > 5 || xc[i] == 5 &&
          (rm == 1 || more || i < 0 || xc[i + 1] != null || xc[i - 1] & 1));

        if (i < 1 || !xc[0]) {
            x['c'] = rm
            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              ? (x['e'] = -dp, [1])
            // Zero.
              : [x['e'] = 0];
        } else {

            // Remove any digits after the required decimal places.
            xc.length = i--;

            // Round up?
            if (rm) {

                // Rounding up may mean the previous digit has to be rounded up and so on.
                for (; ++xc[i] > 9; ) {
                    xc[i] = 0;

                    if (!i--) {
                        ++x['e'];
                        xc.unshift(1)
                    }
                }
            }

            // Remove trailing zeros.
            for (i = xc.length; !xc[--i]; xc.pop()) {
            }
        }

        return x
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
    * Return
    * 1 if the value of this 'Big' is greater than the value of 'Big' 'y',
    * -1 if the value of this 'Big' is less than the value of 'Big' 'y', or
    * 0 if they have the same value,
    */
    P['cmp'] = function (y) {
        var xNeg,
            x = this,
            xc = x['c'],
            yc = (y = new Big(y))['c'],
            i = x['s'],
            j = y['s'],
            k = x['e'],
            l = y['e'];

        // Either zero?
        if (!xc[0] || !yc[0]) {
            return !xc[0] ? !yc[0] ? 0 : -j : i
        }

        // Signs differ?
        if (i != j) {
            return i
        }
        xNeg = i < 0;

        // Compare exponents.
        if (k != l) {
            return k > l ^ xNeg ? 1 : -1
        }

        // Compare digit by digit.
        for (i = -1,
              j = (k = xc.length) < (l = yc.length) ? k : l;
              ++i < j; ) {

            if (xc[i] != yc[i]) {
                return xc[i] > yc[i] ^ xNeg ? 1 : -1
            }
        }

        // Compare lengths.
        return k == l ? 0 : k > l ^ xNeg ? 1 : -1
    };


    /*
    * Return a new 'Big' whose value is the value of this 'Big' divided by the
    * value of 'Big' 'y', rounded, if necessary, to a maximum of 'Big.DP'
    * decimal places using rounding mode 'Big.RM'.
    */
    P['div'] = function (y) {
        var x = this,
            dvd = x['c'],
            dvs = (y = new Big(y))['c'],
            s = x['s'] == y['s'] ? 1 : -1,
            dp = Big['DP'];

        if (dp !== ~ ~dp || dp < 0 || dp > MAX_DP) {
            throw '!Big.DP!'
        }

        // Either 0?
        if (!dvd[0] || !dvs[0]) {

            // Both 0?
            if (dvd[0] == dvs[0]) {
                throw NaN
            }

            // 'dvs' is 0?
            if (!dvs[0]) {
                // Throw +-Infinity.
                throw s / 0
            }

            // 'dvd' is 0. Return +-0.
            return new Big(s * 0)
        }


        var dvsL, dvsT, next, cmp, remI,
            dvsZ = dvs.slice(),
            dvdI = dvsL = dvs.length,
            dvdL = dvd.length,
            rem = dvd.slice(0, dvsL),
            remL = rem.length,
            quo = new Big(ONE),
            qc = quo['c'] = [],
            qi = 0,
            digits = dp + (quo['e'] = x['e'] - y['e']) + 1;

        quo['s'] = s;
        s = digits < 0 ? 0 : digits;

        // Create version of divisor with leading zero.
        dvsZ.unshift(0);

        // Add zeros to make remainder as long as divisor.
        for (; remL++ < dvsL; rem.push(0)) {
        }

        do {

            // 'next' is how many times the divisor goes into the current remainder.
            for (next = 0; next < 10; next++) {

                // Compare divisor and remainder.
                if (dvsL != (remL = rem.length)) {
                    cmp = dvsL > remL ? 1 : -1
                } else {
                    for (remI = -1, cmp = 0; ++remI < dvsL; ) {

                        if (dvs[remI] != rem[remI]) {
                            cmp = dvs[remI] > rem[remI] ? 1 : -1;
                            break
                        }
                    }
                }

                // Subtract divisor from remainder (if divisor < remainder).
                if (cmp < 0) {

                    // Remainder cannot be more than one digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for (dvsT = remL == dvsL ? dvs : dvsZ; remL; ) {

                        if (rem[--remL] < dvsT[remL]) {

                            for (remI = remL;
                                  remI && !rem[--remI];
                                  rem[remI] = 9) {
                            }
                            --rem[remI];
                            rem[remL] += 10
                        }
                        rem[remL] -= dvsT[remL]
                    }
                    for (; !rem[0]; rem.shift()) {
                    }
                } else {
                    break
                }
            }

            // Add the 'next' digit to the result array.
            qc[qi++] = cmp ? next : ++next;

            // Update the remainder.
            rem[0] && cmp
              ? (rem[remL] = dvd[dvdI] || 0)
              : (rem = [dvd[dvdI]])

        } while ((dvdI++ < dvdL || rem[0] != null) && s--);

        // Leading zero? Do not remove if result is simply zero (qi == 1).
        if (!qc[0] && qi != 1) {

            // There can't be more than one zero.
            qc.shift();
            quo['e']--;
        }

        // Round?
        if (qi > digits) {
            rnd(quo, dp, Big['RM'], rem[0] != null)
        }

        return quo
    }


    /*
    * Return a new 'Big' whose value is the value of this 'Big' minus the value
    * of 'Big' 'y'.
    */
    P['minus'] = function (y) {
        var d, i, j, xLTy,
            x = this,
            a = x['s'],
            b = (y = new Big(y))['s'];

        // Signs differ?
        if (a != b) {
            return y['s'] = -b, x['plus'](y)
        }

        var xc = x['c'],
            xe = x['e'],
            yc = y['c'],
            ye = y['e'];

        // Either zero?
        if (!xc[0] || !yc[0]) {

            // 'y' is non-zero?
            return yc[0]
              ? (y['s'] = -b, y)
            // 'x' is non-zero?
              : new Big(xc[0]
                ? x
            // Both are zero.
                : 0)
        }

        // Determine which is the bigger number.
        // Prepend zeros to equalise exponents.
        if (xc = xc.slice(), a = xe - ye) {
            d = (xLTy = a < 0) ? (a = -a, xc) : (ye = xe, yc);

            for (d.reverse(), b = a; b--; d.push(0)) {
            }
            d.reverse()
        } else {

            // Exponents equal. Check digit by digit.
            j = ((xLTy = xc.length < yc.length) ? xc : yc).length;

            for (a = b = 0; b < j; b++) {

                if (xc[b] != yc[b]) {
                    xLTy = xc[b] < yc[b];
                    break
                }
            }
        }

        // 'x' < 'y'? Point 'xc' to the array of the bigger number.
        if (xLTy) {
            d = xc, xc = yc, yc = d;
            y['s'] = -y['s']
        }

        /*
        * Append zeros to 'xc' if shorter. No need to add zeros to 'yc' if shorter
        * as subtraction only needs to start at 'yc.length'.
        */
        if ((b = -((j = xc.length) - yc.length)) > 0) {

            for (; b--; xc[j++] = 0) {
            }
        }

        // Subtract 'yc' from 'xc'.
        for (b = yc.length; b > a; ) {

            if (xc[--b] < yc[b]) {

                for (i = b; i && !xc[--i]; xc[i] = 9) {
                }
                --xc[i];
                xc[b] += 10
            }
            xc[b] -= yc[b]
        }

        // Remove trailing zeros.
        for (; xc[--j] == 0; xc.pop()) {
        }

        // Remove leading zeros and adbust exponent accordingly.
        for (; xc[0] == 0; xc.shift(), --ye) {
        }

        if (!xc[0]) {

            // Result must be zero.
            xc = [ye = 0]
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
    * Return a new 'Big' whose value is the value of this 'Big' modulo the
    * value of 'Big' 'y'.
    */
    P['mod'] = function (y) {
        y = new Big(y);
        var c,
            x = this,
            i = x['s'],
            j = y['s'];

        if (!y['c'][0]) {
            throw NaN
        }

        x['s'] = y['s'] = 1;
        c = y['cmp'](x) == 1;
        x['s'] = i, y['s'] = j;

        return c
          ? new Big(x)
          : (i = Big['DP'], j = Big['RM'],
            Big['DP'] = Big['RM'] = 0,
              x = x['div'](y),
                Big['DP'] = i, Big['RM'] = j,
                  this['minus'](x['times'](y)))
    };


    /*
    * Return a new 'Big' whose value is the value of this 'Big' plus the value
    * of 'Big' 'y'.
    */
    P['plus'] = function (y) {
        var d,
            x = this,
            a = x['s'],
            b = (y = new Big(y))['s'];

        // Signs differ?
        if (a != b) {
            return y['s'] = -b, x['minus'](y)
        }

        var xe = x['e'],
            xc = x['c'],
            ye = y['e'],
            yc = y['c'];

        // Either zero?
        if (!xc[0] || !yc[0]) {

            // 'y' is non-zero?
            return yc[0]
              ? y
              : new Big(xc[0]

            // 'x' is non-zero?
                ? x

            // Both are zero. Return zero.
                : a * 0)
        }

        // Prepend zeros to equalise exponents.
        // Note: Faster to use reverse then do unshifts.
        if (xc = xc.slice(), a = xe - ye) {
            d = a > 0 ? (ye = xe, yc) : (a = -a, xc);

            for (d.reverse(); a--; d.push(0)) {
            }
            d.reverse()
        }

        // Point 'xc' to the longer array.
        if (xc.length - yc.length < 0) {
            d = yc, yc = xc, xc = d
        }

        /*
        * Only start adding at 'yc.length - 1' as the
        * further digits of 'xc' can be left as they are.
        */
        for (a = yc.length, b = 0; a;
             b = (xc[--a] = xc[a] + yc[a] + b) / 10 ^ 0, xc[a] %= 10) {
        }

        // No need to check for zero, as +x + +y != 0 && -x + -y != 0

        if (b) {
            xc.unshift(b);
            ++ye
        }

        // Remove trailing zeros.
        for (a = xc.length; xc[--a] == 0; xc.pop()) {
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
    * Return a 'Big' whose value is the value of this 'Big' raised to the power
    * 'e'. If 'e' is negative, round, if necessary, to a maximum of 'Big.DP'
    * decimal places using rounding mode 'Big.RM'.
    *
    * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.
    */
    P['pow'] = function (e) {
        var isNeg = e < 0,
            x = new Big(this),
            y = ONE;

        if (e !== ~ ~e || e < -MAX_POWER || e > MAX_POWER) {
            throw '!pow!'
        }

        for (e = isNeg ? -e : e; ; ) {

            if (e & 1) {
                y = y['times'](x)
            }
            e >>= 1;

            if (!e) {
                break
            }
            x = x['times'](x)
        }

        return isNeg ? ONE['div'](y) : y
    };


    /*
    * Return a new 'Big' whose value is the value of this 'Big' rounded, if
    * necessary, to a maximum of 'dp' decimal places using rounding mode 'rm'.
    * If 'dp' is not specified, round to 0 decimal places.
    * If 'rm' is not specified, use 'Big.RM'.
    *
    * [dp] {number} Integer, 0 to MAX_DP inclusive.
    * [rm] 0, 1 or 2 ( i.e. ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
    */
    P['round'] = function (dp, rm) {
        var x = new Big(this);

        if (dp == null) {
            dp = 0
        } else if (dp !== ~ ~dp || dp < 0 || dp > MAX_DP) {
            throw '!round!'
        }
        rnd(x, dp, rm == null ? Big['RM'] : rm);

        return x
    };


    /*
    * Return a new 'Big' whose value is the square root of the value of this
    * 'Big', rounded, if necessary, to a maximum of 'Big.DP' decimal places
    * using rounding mode 'Big.RM'.
    */
    P['sqrt'] = function () {
        var estimate, r, approx,
            x = this,
            xc = x['c'],
            i = x['s'],
            e = x['e'],
            half = new Big('0.5');

        // Zero?
        if (!xc[0]) {
            return new Big(x)
        }

        // Negative?
        if (i < 0) {
            throw NaN
        }

        // Estimate.
        i = Math.sqrt(x.toString());

        // Math.sqrt underflow/overflow?
        // Pass 'x' to Math.sqrt as integer, then adjust the exponent of the result.
        if (i == 0 || i == 1 / 0) {
            estimate = xc.join('');

            if (!(estimate.length + e & 1)) {
                estimate += '0'
            }

            r = new Big(Math.sqrt(estimate).toString());
            r['e'] = (((e + 1) / 2) | 0) - (e < 0 || e & 1)
        } else {
            r = new Big(i.toString())
        }

        i = r['e'] + (Big['DP'] += 4);

        // Newton-Raphson loop.
        do {
            approx = r;
            r = half['times'](approx['plus'](x['div'](approx)))
        } while (approx['c'].slice(0, i).join('') !==
                       r['c'].slice(0, i).join(''));

        rnd(r, Big['DP'] -= 4, Big['RM']);

        return r
    };


    /*
    * Return a new 'Big' whose value is the value of this 'Big' times the value
    * of 'Big' 'y'.
    */
    P['times'] = function (y) {
        var c,
            x = this,
            xc = x['c'],
            yc = (y = new Big(y))['c'],
            a = xc.length,
            b = yc.length,
            i = x['e'],
            j = y['e'];

        y['s'] = x['s'] == y['s'] ? 1 : -1;

        // Either 0?
        if (!xc[0] || !yc[0]) {

            return new Big(y['s'] * 0)
        }

        y['e'] = i + j;

        if (a < b) {
            c = xc, xc = yc, yc = c, j = a, a = b, b = j
        }

        for (j = a + b, c = []; j--; c.push(0)) {
        }

        // Multiply!
        for (i = b - 1; i > -1; i--) {

            for (b = 0, j = a + i;
                  j > i;
                  b = c[j] + yc[i] * xc[j - i - 1] + b,
                  c[j--] = b % 10 | 0,
                  b = b / 10 | 0) {
            }

            if (b) {
                c[j] = (c[j] + b) % 10
            }
        }

        b && ++y['e'];

        // Remove any leading zero.
        !c[0] && c.shift();

        // Remove trailing zeros.
        for (j = c.length; !c[--j]; c.pop()) {
        }

        return y['c'] = c, y
    };


    /*
    * Return a string representing the value of this 'Big'.
    * Return exponential notation if this 'Big' has a positive exponent equal
    * to or greater than 'TO_EXP_POS', or a negative exponent equal to or less
    * than 'TO_EXP_NEG'.
    */
    P['toString'] = P['valueOf'] = function () {
        var x = this,
            e = x['e'],
            str = x['c'].join(''),
            strL = str.length;

        // Exponential notation?
        if (e <= TO_EXP_NEG || e >= TO_EXP_POS) {
            str = str.charAt(0) + (strL > 1 ? '.' + str.slice(1) : '') +
              (e < 0 ? 'e' : 'e+') + e

            // Negative exponent?
        } else if (e < 0) {

            // Prepend zeros.
            for (; ++e; str = '0' + str) {
            }
            str = '0.' + str

            // Positive exponent?
        } else if (e > 0) {

            if (++e > strL) {

                // Append zeros.
                for (e -= strL; e--; str += '0') {
                }
            } else if (e < strL) {
                str = str.slice(0, e) + '.' + str.slice(e)
            }

            // Exponent zero.
        } else if (strL > 1) {
            str = str.charAt(0) + '.' + str.slice(1)
        }

        // Avoid '-0'
        return x['s'] < 0 && x['c'][0] ? '-' + str : str
    };


    /*
    ***************************************************************************
    *
    * If 'toExponential', 'toFixed', 'toPrecision' and 'format' are not
    * required they can safely be commented-out or deleted. No redundant code
    * will be left. 'format' is used only by 'toExponential', 'toFixed' and
    * 'toPrecision'.
    *
    ***************************************************************************
    */


    /*
    * PRIVATE FUNCTION
    *
    * Return a string representing the value of 'Big' 'x' in normal or
    * exponential notation to a fixed number of decimal places or significant
    * digits 'dp'.
    * (Called by toString, toExponential, toFixed and toPrecision.)
    *
    * x {Big} The 'Big' to format.
    * dp {number} Integer, 0 to MAX_DP inclusive.
    * toE {number} undefined (toFixed), 1 (toExponential) or 2 (toPrecision).
    */
    function format(x, dp, toE) {
        // The index (in normal notation) of the digit that may be rounded up.
        var i = dp - (x = new Big(x))['e'],
            c = x['c'];

        // Round?
        if (c.length > ++dp) {
            rnd(x, i, Big['RM'])
        }

        // Recalculate 'i' if toFixed as 'x.e' may have changed if value rounded up.
        i = !c[0] ? i + 1 : toE ? dp : (c = x['c'], x['e'] + i + 1);

        // Append zeros?
        for (; c.length < i; c.push(0)) {
        }
        i = x['e'];

        /*
        * 'toPrecision' returns exponential notation if the number of
        * significant digits specified is less than the number of digits
        * necessary to represent the integer part of the value in normal
        * notation.
        */
        return toE == 1 || toE == 2 && (dp <= i || i <= TO_EXP_NEG)

        // Exponential notation.
            ? (x['s'] < 0 && c[0] ? '-' : '') + (c.length > 1
              ? (c.splice(1, 0, '.'), c.join(''))
              : c[0]) + (i < 0 ? 'e' : 'e+') + i

        // Normal notation.
            : x.toString()
    }


    /*
    * Return a string representing the value of this 'Big' in exponential
    * notation to 'dp' fixed decimal places and rounded, if necessary, using
    * 'Big.RM'.
    *
    * [dp] {number} Integer, 0 to MAX_DP inclusive.
    */
    P['toExponential'] = function (dp) {

        if (dp == null) {
            dp = this['c'].length - 1
        } else if (dp !== ~ ~dp || dp < 0 || dp > MAX_DP) {
            throw '!toExp!'
        }

        return format(this, dp, 1)
    };


    /*
    * Return a string representing the value of this 'Big' in normal notation
    * to 'dp' fixed decimal places and rounded, if necessary, using 'Big.RM'.
    *
    * [dp] {number} Integer, 0 to MAX_DP inclusive.
    */
    P['toFixed'] = function (dp) {
        var str,
            x = this,
            neg = TO_EXP_NEG,
            pos = TO_EXP_POS;

        TO_EXP_NEG = -(TO_EXP_POS = 1 / 0);

        if (dp == null) {
            str = x.toString()
        } else if (dp === ~ ~dp && dp >= 0 && dp <= MAX_DP) {
            str = format(x, x['e'] + dp);

            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if (x['s'] < 0 && x['c'][0] && str.indexOf('-') < 0) {
                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
                str = '-' + str
            }
        }
        TO_EXP_NEG = neg, TO_EXP_POS = pos;

        if (!str) {
            throw '!toFix!'
        }

        return str
    };


    /*
    * Return a string representing the value of this 'Big' to 'sd' significant
    * digits and rounded, if necessary, using 'Big.RM'. If 'sd' is less than
    * the number of digits necessary to represent the integer part of the value
    * in normal notation, then use exponential notation.
    *
    * sd {number} Integer, 1 to MAX_DP inclusive.
    */
    P['toPrecision'] = function (sd) {

        if (sd == null) {
            return this.toString()
        } else if (sd !== ~ ~sd || sd < 1 || sd > MAX_DP) {
            throw '!toPre!'
        }

        return format(this, sd - 1, 2)
    };


    // EXPORT


    // Node and other CommonJS-like environments that support module.exports.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Big

        //AMD.
    } else if (typeof define == 'function' && define.amd) {
        define('vendor/big', [], function () {
            return Big
        })

        //Browser.
    } else {
        global['Big'] = Big
    }

})(this);

define('big', ['require', 'vendor/big'], function (require) {
    var Big = require('vendor/big');
    Big.prototype.equals = function (x) { return this.cmp(x) === 0; };
    return Big;
});

define('expressions/table', ['require', 'desmos', 'pjs', 'lib/underscore_model', 'lib/underscore_view', 'lib/track_feature', 'big', './abstractitem', './colors', 'undoredo'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreModel = require('lib/underscore_model');
    var UnderscoreView = require('lib/underscore_view');
    var Feature = require('lib/track_feature');
    var Big = require('big');
    var AbstractItemModel = require('./abstractitem');
    var Colors = require('./colors');
    var UndoRedo = require('undoredo');

    var Cell = P(UnderscoreModel, function (cellModel, _super) {

        cellModel.init = function (column, state) {
            _super.init.call(this);

            this.column = column;

            if (state) {
                this.value = state.value;
                this.error = state.error;
            }
        };

        cellModel.isEmpty = function () {
            return this.value.split(' ').join("") === '';
        };
    });


    var Column = P(AbstractItemModel, function (colModel, _super) {

        colModel.init = function (table, index, state) {

            // default values
            this.latex = '';
            this.showLine = false;
            this.showPoints = true;
            this.values = [];
            this.error = '';

            _super.init.call(this, state);

            if (!this.color) {
                this.color = Colors.generateNewColor();
            }

            // any column other than the first should generate the correct number
            // of blank cells if none are passed in.
            if (index !== 0 && this.values.length === 0) {
                this.values = []; // don't want to modify array passed in through 'state'
                var len = table.columns[0].cells.length;
                for (var i = 0; i < len; i++) {
                    this.values.push('');
                }
            }

            // map cells from raw values to objects
            var self = this;
            this.cells = this.values.map(function (value) {
                return Cell(self, { value: String(value) });
            });
            delete this.values;

            this.table = table;
            this.index = index;

            // first column can't be graphed
            if (index === 0) {
                this.showPoints = false;
                this.showLine = false;
            }

            // observers
            this.isGraphable = !this.error;
            this.observe('error', function () {
                this.setProperty('isGraphable', !this.error);
            } .bind(this));

            this.observe('selected', this.onSelectedDidChange.bind(this)); // TODO - probably not have selected property on the model
            this.observe('color showLine showPoints latex', this.onStateChange.bind(this));
        };

        colModel.onStateChange = function (property) {
            this.table.requestParse();

            var id = this.table.id;
            var index = this.index;
            function getColumn() {
                return Desmos.expressions.getItemById(id).columns[index];
            }

            var oldValue = this.getOldProperty(property);
            var newValue = this.getProperty(property);
            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () { getColumn().setProperty(property, oldValue); },
                redo: function () { getColumn().setProperty(property, newValue); }
            });
        };

        colModel.isEmpty = function () {
            return this.latex.split(" ").join(" ") === "";
        };

        colModel.getValues = function () {
            var vals = [];
            var len = this.cells.length;
            for (var i = 0; i < len; i++) {
                var val = this.cells[i].value;
                if (val === null || val === undefined) {
                    vals.push('');
                } else {
                    vals.push(String(val));
                }
            }

            return vals;
        };

        colModel.triggerRowChange = function () { };

        colModel.insertCell = function (index, value) {
            var cell = Cell(this, { value: value });
            this.cells.splice(index, 0, cell);
        };

        colModel.removeCell = function (index) {
            this.cells.splice(index, 1);
        };

        // it's possible to select the headers during trace, so we need
        // to make sure we focus the header too
        colModel.onSelectedDidChange = function () {
            // TODO - need a way to check if focused. Maybe check if mathquill
            // hasClass('hasCursor')
            if (this.selected && !this.focused) {
                var view = Desmos.expressions.getItemView(this.table.id);
                if (!view) return;

                view.selectCell(0, this.index);
            }
        };

        function formatValuesForDisplay(values) {
            var vals = [];

            for (var i = 0; i < values.length; i++) {
                var value = values[i];
                var val_str = '';
                if (_.isNumber(value)) {
                    val_str = String(Number(Number(value).toFixed(4)));
                    val_str = val_str.replace("NaN", "Undefined");
                }

                vals.push(val_str);
            }

            return vals;
        }

        colModel.setComputedValues = function (c_data) {

            //Track discovering dependent columns
            if (!c_data.error && c_data.dependent) Feature.discover('dependent table columns');

            // TODO - get the worker to pass back a blank array. It'll be important
            // for when we check that the size of the output matches the size of the
            // table. If there is a size mismatch, we must throw the computations
            // away because they are stale.

            // the worker thread doesn't pass back a list of values in this case.
            // we need to build list of null values
            if (c_data.values.length === 0 && c_data.error) {
                for (var i = 0; i < this.cells.length - 1; i++) {
                    c_data.values[i] = null;
                }
            }


            this.setProperty('error', c_data.error);
            this.setProperty('discrete', c_data.discrete);
            this.setProperty('disabled', c_data.dependent);
            this.setErrors(c_data.values);

            if (c_data.dependent) {

                // if we haven't saved the independent values, save them now before
                // they get overwritten with the values sent back from the evaluator.
                if (!this.independentValues) {
                    this.independentValues = this.getValues();
                }

                this.setValues(formatValuesForDisplay(c_data.values));
            } else if (this.independentValues) {

                // set the indepentedValues back.
                this.setValues(this.independentValues);

                // clear out the cached independent values.
                this.independentValues = null;
            }
        };

        colModel.setValues = function (values) {
            for (var i = 0; i < values.length; i++) {
                this.cells[i].setProperty('value', String(values[i]));
            }
        };

        colModel.setErrors = function (values) {
            // if the computed value is a string, then it's an error
            for (var i = 0; i < values.length; i++) {
                if (typeof values[i] === "string") {
                    this.cells[i].setProperty('error', values[i]);
                } else {
                    this.cells[i].setProperty('error', '');
                }
            }
        };

        colModel.serialize = function () {
            return {
                values: this.getValues(),
                showPoints: this.showPoints,
                showLine: this.showLine,
                id: this.id,
                color: this.color,
                latex: this.latex
            };
        };

    });

    var TableObject = P(AbstractItemModel, function (model, _super) {

        model.isTable = true;

        model.init = function (state) {
            var i, r, c;
            _super.init.call(this, state);

            this.selectedCell = null;

            // TODO - get rid of this when we upgrade states in DB
            // what we used to call 'headings' is now 'columns'
            if (this.headings) {
                this.columns = this.headings;
                delete this.headings;
            }

            // TODO - get rid of this when we upgrade states in DB
            // what used to be 'rows' is now transposed and part of each column
            if (this.rows) {
                for (c = 0; c < this.columns.length; c++) {
                    var column = this.columns[c];
                    column.values = [];

                    for (r = 0; r < this.rows.length; r++) {
                        column.values.push(this.rows[r][c]);
                    }
                }

                delete this.rows;
            }

            // map raw columns to Column objects
            var self = this;
            if (!this.columns) this.columns = [];
            this.columns = this.columns.map(function (col_state, index) {
                return Column(self, index, col_state);
            });

            // add a column to the right
            this.columns.push(Column(this, this.columns.length, { disabled: true }));

            // add a bottom row of empty values
            var lastRow = this.columns[0].cells.length;
            _.each(this.columns, function (column) {
                column.insertCell(lastRow, '');
            });

            // observers
            this.observe('selected', this.onSelectedChange.bind(this));
        };

        model.onSelectedChange = function () {
            if (!this.selected) {
                this.setProperty('selectedCell', null);
            }
        };

        model.insertColumn = function (index, column) {

            var id = this.id;
            UndoRedo.addTransaction({
                type: UndoRedo.CAUSE_OF_CHANGE,

                undo: function () {
                    var table = Desmos.expressions.getItemById(id);
                    table.__removeColumn(index);
                },

                redo: function () {
                    var table = Desmos.expressions.getItemById(id);
                    table.__insertColumn(index, column);

                    // need to update reference to heading so that
                    // next time we press redo, we pass in the complete
                    // heading info. This makes sure the next redo uses
                    // the same color and id as the original column that
                    // was later deleted and then restored.
                    column = table.columns[index].serialize();
                }
            });

        };

        model.removeColumn = function (index) {

            var id = this.id;
            var column = this.columns[index].serialize();

            UndoRedo.addTransaction({
                type: UndoRedo.CAUSE_OF_CHANGE,

                undo: function () {
                    var table = Desmos.expressions.getItemById(id);
                    table.__insertColumn(index, column);
                },

                redo: function () {
                    var table = Desmos.expressions.getItemById(id);
                    table.__removeColumn(index);
                }
            });
        };

        // this does the raw column insert. Called from the wrapper function that
        // makes it also work with undo redo.
        model.triggerColumnAdded = function (index) { };
        model.__insertColumn = function (index, columnData) {
            if (!columnData) {
                columnData = {};
            }

            // add column
            var column = Column(this, index, columnData);
            this.columns.splice(index, 0, column);

            // let every column after the insertion point know its new index
            for (var i = index + 1; i < this.columns.length; i++) {
                this.columns[i].setProperty('index', i);
            }

            this.triggerColumnAdded(index);

            this.requestParse();
        };

        // this does the raw column remove. Called from the wrapper function that
        // makes it also work with undo redo.
        model.triggerColumnRemoved = function (index) { };
        model.__removeColumn = function (index) {

            // remove column
            this.requestUnparseColumn(index);
            this.columns.splice(index, 1);

            // let every column after the deletion point know its new index
            for (var i = index; i < this.columns.length; i++) {
                this.columns[i].setProperty('index', i);
            }

            this.triggerColumnRemoved(index);

            this.requestParse();
        };

        // Could try to recognize fractions and multiples of pi (or anything
        // really).
        model.getAutofillValues = function (index) {
            var i;
            var numberOfColumns = this.columns.length;
            var rowValues = [];
            for (i = 0; i < numberOfColumns; i++) {
                rowValues.push('');
            }

            var firstColumn = this.columns[0].getValues();

            // Use big.js https://github.com/desmosinc/big.js to compute exact
            // differences and sums so that autofilling decimals works.
            // big.js will throw errors if improper input is used.
            //
            // this line just ensures that there is a constant offset between
            // each value in the first column starting from the beginning up
            // right before where we want to auto fill.
            var valDiff;
            try {
                if (index > 1) {
                    valDiff = Big(firstColumn[1]).minus(firstColumn[0]);
                }

                for (i = 2; i < index && valDiff !== undefined; i++) {
                    var nextDiff = Big(firstColumn[i]).minus(firstColumn[i - 1]);
                    if (!valDiff.equals(nextDiff)) {
                        valDiff = undefined;
                    }
                }
            } catch (e) {
                valDiff = undefined;
            }

            // add valDiff to the previous row to figure out what the autocomplete
            // value should be
            if (valDiff !== undefined) {
                rowValues[0] = valDiff.plus(firstColumn[index - 1]).toString();
            }

            return rowValues;
        };

        model.setComputedValues = function (columns_data) {
            for (var i = 0; i < columns_data.length; i++) {
                this.columns[i].setComputedValues(columns_data[i]);
            }
        };

        model.triggerRowAdded = function (index) { };
        model.insertRow = function (index, values) {

            for (var i = 0; i < this.columns.length; i++) {
                this.columns[i].insertCell(index, values[i]);
            }

            this.triggerRowAdded(index);

            var id = this.id;
            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () {
                    Desmos.expressions.getItemById(id).removeRow(index);
                },
                redo: function () {
                    Desmos.expressions.getItemById(id).insertRow(index, values);
                }
            });

            // TODO - only parse this row
            this.requestParse();
        };

        model.triggerRowRemoved = function (index) { };
        model.removeRow = function (index) {
            var values = [];
            for (var i = 0; i < this.columns.length; i++) {
                values.push(this.columns[i].cells[index].value);
                this.columns[i].removeCell(index);
            }

            this.triggerRowRemoved(index);

            var id = this.id;
            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () {
                    Desmos.expressions.getItemById(id).insertRow(index, values);
                },
                redo: function () {
                    Desmos.expressions.getItemById(id).removeRow(index);
                }
            });

            // TODO - don't need it now, but sameday may need to unparse the row
        };

        model.getParsableObject = function () {

            var columns = this.columns.map(function (column) {

                // serialize column to pure JSON
                column = column.serialize();

                // pop off blank bottom row
                column.values.pop();

                return column;
            });

            // popoff blank right column
            columns.pop();

            return {
                type: 'table',
                id: this.id,
                columns: columns
            };
        };

        model.requestParse = function () {
            Desmos.expressions.triggerAddExp(this.getParsableObject());
        };

        model.requestUnparse = function () {
            var ids = [this.id];
            for (var i = 0; i < this.columns.length; i++) {
                ids.push(this.columns[i].id);
            }

            Desmos.expressions.triggerRemoveExps(ids);
        };

        model.requestUnparseColumn = function (index) {
            Desmos.expressions.triggerRemoveExp(this.columns[index].id);
        };

        model.getState = function () {

            // serialize each column
            var columns = this.columns.map(function (column) {
                var data = column.serialize();

                // pop off blank bottom row
                data.values.pop();

                // TODO - do we want to do this? Might be better for loadup if
                // we save the previous values along with wether or not the column
                // was disabled. If the evaluator ever changes, we can convert
                // old graph states or just let the new system overwrite the values like
                // it does now. The two big complaints I have is that computed columns
                // show up with an 'empty' underline temporarily and the table icon
                // flickers if the column is actually continuous rather than discrete.
                // if column is disabled, all values blanked
                // TODO - convert old graph states to have '' instead of null.
                if (column.disabled) {
                    data.values = data.values.map(function () { return '' });
                }

                return data;
            });

            // pop off blank right column
            columns.pop();

            return {
                id: this.id,
                columns: columns
            };
        };

        model.isEmpty = function () {
            return false;
        };
    });

    return TableObject;
});

define('expressions/text', ['require', 'desmos', 'pjs', './abstractitem', 'undoredo'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var AbstractItemModel = require('./abstractitem');
    var UndoRedo = require('undoredo');

    var TextObject = P(AbstractItemModel, function (model, _super) {

        model.isText = true;

        model.init = function (state) {
            _super.init.call(this, state);

            if (!this.text) this.text = '';
            this.observe('text', this.onStateDidChange.bind(this));
        };

        model.isEmpty = function () {
            return this.text.split(" ").join("") === "";
        };

        model.getState = function () {
            return {
                id: this.id,
                text: this.text
            };
        };

        // Record change for undo-redo
        model.onStateDidChange = function (prop) {
            var oldValue = this.getOldProperty(prop);
            var newValue = this.getProperty(prop);
            var id = this.id;

            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () {
                    Desmos.expressions.getItemById(id).setProperty(prop, oldValue);
                },
                redo: function () {
                    Desmos.expressions.getItemById(id).setProperty(prop, newValue);
                }
            });
        };
    });

    return TextObject;
});

define('expressions/new_expression', ['require', 'desmos', 'pjs', 'lib/underscore_view', 'lib/track_feature', 'templates/new_expression', './expression', './table', './text'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var Feature = require('lib/track_feature');
    require('templates/new_expression');
    var ExpressionObject = require('./expression');
    var TableObject = require('./table');
    var TextObject = require('./text');

    var NewExpressionView = P(UnderscoreView, function (view, _super) {

        view.templateName = "new_expression";

        view.init = function (listView) {
            _super.init.call(this);
            this.observe('index', this.updateIndex.bind(this));
            this.listView = listView;
        };

        view.showMoreOptions = function () {
            if (!this.$('.more-options-slideout').hasClass("isHidden")) {
                this.hideMoreOptions();
                return;
            }

            //.float-to-top puts the slideout container on top of the div that makes a new expression on any tap
            this.$('.more-options-slideout-container').removeClass("float-to-top");

            this.$('.more-options-slideout').removeClass("isHidden");
            this.$('.new-expression').addClass("opened");
        };

        view.hideMoreOptions = function () {
            this.$('.more-options-slideout').addClass("isHidden");
            this.$('.new-expression').removeClass("opened");
            this.$('.more-options-slideout-container').removeClass("float-to-top");
        };

        view.forceHideMoreOptions = function () {
            this.$('.more-options-slideout-container').hide();
            var self = this;
            setTimeout(function () {
                self.$('.more-options-slideout-container').show();
            }, 200);
            this.hideMoreOptions();
        };

        view.didInsertElement = function () {
            this.forceHideMoreOptions();

            // update the index now and observe any changes
            this.updateIndex();

            this.$('.action-newmath').on('tap', this.newMath.bind(this));
            this.$('.action-newtext').on('tap', this.newText.bind(this));
            this.$('.action-newtable').on('tap', this.newTable.bind(this));
            this.$('.action-moreoptions').on('tap', this.toggleMoreOptions.bind(this));
        };

        view.updateIndex = function () {
            this.$('.variable-index').text(this.index);
        };

        view.toggleMoreOptions = function () {
            if (!this.$('.more-options').hasClass("active")) {
                this.showMoreOptions();
            } else {
                this.hideMoreOptions();
            }
        };

        view.newMath = function () {
            var constructor = ExpressionObject;
            var properties = { selected: true, latex: '' };
            var obj = constructor(properties);
            this.listView.model.insertItemAt(this.listView.model.getItemCount(), obj);
            this.listView.getSelectedView().addFocus();

            //Hacking our "hovered" library -- we don't unhover until a mousemove
            //but we don't want the "hovered" class to remain on new-expression after it's been clicked and moved down
            this.$(".new-expression").removeClass("hovered");
        };

        view.newText = function () {
            var properties = { selected: true, text: '' };
            var obj = TextObject(properties);
            this.listView.model.insertItemAt(this.listView.model.getItemCount(), obj);
            this.listView.getSelectedView().addFocus();
        };

        view.newTable = function () {
            var properties = { selected: true, latex: '' };
            properties.columns = [
        {
            latex: "x",
            values: [1]
        },
        {
            latex: "y",
            values: ['']
        }
      ];

            // create a new expression and populate it
            var obj = TableObject(properties);
            this.listView.model.insertItemAt(this.listView.model.getItemCount(), obj);
            this.listView.getSelectedView().addFocus('cell', 1, 1);

            Feature.use('create table');
        };
    });

    return NewExpressionView;
});

/*
* Renders expression items visible in the viewport by setting their "renderShell" property to false.
* On desktop, also renders off-screen expression in the background if all viewport expressions are shown.
*
* NOTE: ideally this shouldn't poll, but listen to events on the expression list to know when items have
*       been added/deleted, or the viewport has changed.
*/
define('expressions/renderviewport', ['require', 'main/timermodules', 'desmos', 'lib/browser'], function (require) {
    var TimerModules = require('main/timermodules');
    var Desmos = require('desmos');
    var Browser = require('lib/browser');

    TimerModules.add('expressions.renderviewport', (function (expressions) {
        var $exppanel = null;
        var expPanelTop = null;

        var lastScrollStableTime = 0;
        var lastScrollHeight = 0;
        var lastScrollTop = 0;

        function getUnrenderedViewportItems() {
            // Cache #exppanel
            if (!$exppanel) {
                $exppanel = $('#exppanel');
                if (!$exppanel.length) {
                    $exppanel = null;
                    return [];
                }
                expPanelTop = $exppanel.offset().top;
            }

            var unrenderedViewportItems = [];

            // Wait for scroll bar to settle down for 300ms
            var scrollTop = $exppanel.scrollTop(),
        scrollHeight = $exppanel.height();
            if (scrollTop == lastScrollTop && scrollHeight == lastScrollHeight) {
                var time = new Date().getTime();
                if (lastScrollStableTime === 0) {
                    lastScrollStableTime = time;
                } else if (time - lastScrollStableTime > 300) {
                    var first = Desmos.expressions.expressionAtPoint(5, expPanelTop),
            last = Desmos.expressions.expressionAbovePoint(5, expPanelTop + scrollHeight);
                    if (first && last) {
                        Desmos.expressions.getItemsByIndexRange(first.index, last.index).forEach(function (item) {
                            if (item.renderShell) {
                                unrenderedViewportItems.push(item);
                            }
                        });
                    }
                }
            } else {
                lastScrollTop = scrollTop;
                lastScrollHeight = scrollHeight;
                lastScrollStableTime = 0;
            }

            return unrenderedViewportItems;
        }

        function renderItems(unrenderedViewportItems) {
            var i;

            if (unrenderedViewportItems.length) {
                // If viewport items need to be rendered, then render them all (with a 10ms pause in-between to help them display in view order)
                i = 0;
                unrenderedViewportItems.forEach(function (item) {
                    (function (item) {
                        setTimeout(function () {
                            item.setProperty('renderShell', false);
                        }, i * 10);
                    })(item, i++);
                });
            } else {
                // Otherwise, if not mobile, just render first unrendered item (as long as we're not slowly redrawing.)
                //
                // We can't do this on mobile as iPad 3 doesn't correctly update any expressions rendered off-screen (it renders white boxes instead.)
                if (!Browser.IS_MOBILE && !grapher.redraw_slowly_timeout) {
                    var len = Desmos.expressions.model.getItemCount();
                    for (i = 0; i < len; ++i) {
                        var item = Desmos.expressions.model.getItemAt(i);
                        if (item.renderShell) {
                            item.setProperty('renderShell', false);
                            break;
                        }
                    }
                }
            }
        }

        return function () {
            renderItems(getUnrenderedViewportItems());
        };
    }));
});

//if an equation is selected, show the keypad. If not, don't.
define('expressions/togglekeypad', ['require', 'main/timermodules', 'desmos', 'main/keypad'], function (require) {
    var TimerModues = require('main/timermodules');
    var Desmos = require('desmos');
    var keypadView = require('main/keypad');


    TimerModules.add('expressions.togglekeypad', (function (expressions) {

        function updateKeypadDisabled() {
            var needKeypad = expressions.needFakeKeypad;
            var mathquillFocused = expressions.mathquillFocused;
            keypadView.setKeysDisabled(needKeypad && !mathquillFocused);
        }

        expressions.observe('needFakeKeypad', function () {
            keypadView.setIsBlurred(!expressions.needFakeKeypad);
            updateKeypadDisabled();
        });

        expressions.observe('mathquillFocused', updateKeypadDisabled);

    }));
});

define('expressions/list_view', ['require', 'desmos', 'pjs', 'vendor/jquery.tipsy', 'lib/underscore_view', 'undoredo', 'main/resize', 'main/keypad', 'lib/keydown_which', 'lib/jquery.scrollvisible', './new_expression', './renderviewport', './togglekeypad', './expression'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    require('vendor/jquery.tipsy');
    var UnderscoreView = require('lib/underscore_view');

    var UndoRedo = require('undoredo');
    var Resize = require('main/resize');
    var keypadView = require('main/keypad');
    var Keydown = require('lib/keydown_which');

    require('lib/jquery.scrollvisible');
    var NewExpressionView = require('./new_expression');
    require('./renderviewport');
    require('./togglekeypad');
    var ExpressionObject = require('./expression');

    var ExpressionListView = P(UnderscoreView, function (view, _super) {
        view.__itemViews = {};

        view.init = function (model) {
            _super.init.call(this);
            this.model = model;
            this.model.triggerItemAdded = this.onItemAdded.bind(this);
            this.model.triggerItemRemoved = this.onItemRemoved.bind(this);
            this.model.triggerItemMoved = this.onItemMoved.bind(this);
            this.model.triggerSetState = this.onSetState.bind(this);

            // an optimization so that we don't compare entire items when changing
            // selectedItem property.
            this.setPropertyComparator('selectedItem', function (a, b) {
                return a === b;
            });

            this.observe('itemFocused', this.renderItemFocused.bind(this));

            //Scroll to ensure selected expression is always visible, on selection change, on resize, and on keypress
            var ensureVisible = this.ensureVisible.bind(this);

            this.observe('selectedItem', ensureVisible);
            $(document).on('keypress', '#exppanel', ensureVisible);
        };

        view.onItemAdded = function (index, item) {

            //update index for newExpressionView
            if (this.newExpressionView) {
                this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);
            }

            // if we've started adding items to dom, add this item. Otherwise,
            // the view will be created when the ExpressionListView is inserted
            // into the dom
            if (this.$items) {
                var view = this.createItemView(item);
                if (view) {
                    if (index === 0) {
                        view.prependTo(this.$items); // beginning
                    } else if (index === this.model.getItemCount() - 1) {
                        view.appendTo(this.$items); //end
                    } else { //somewhere in the middle
                        view.insertAfter(this.$items.children(':nth-child(' + index + ')'));
                    }
                }

                // observe selected
                item.observe('selected.listview', this.observeItemSelected.bind(this));
                if (item.selected) {
                    this.observeItemSelected('selected', item);
                }

                var len = this.model.getItemCount();
                for (var i = index; i < len; i++) {
                    this.model.getItemAt(i).setProperty('index', i);
                }
            }
        };

        view.onItemRemoved = function (index, item) {
            var item_id = String(item.id);

            if (this.selectedItem === item) {
                this.setProperty('selectedItem', null);
            }

            item.unobserve('.listview');

            // update index on newExpressionView
            if (this.newExpressionView) {
                this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);
            }

            // remove item view from dom
            var view = this.__itemViews[item_id];
            if (view) {
                view.remove();
                delete this.__itemViews[item_id];

                var len = this.model.getItemCount();
                for (var i = index; i < len; i++) {
                    this.model.getItemAt(i).setProperty('index', i);
                }
            }
        };

        view.onItemMoved = function (from, to) {
            // update index of each affected item
            var min_affected = Math.min(from, to);
            var max_affected = Math.max(from, to);
            for (var i = min_affected; i <= max_affected; i++) {
                this.model.getItemAt(i).setProperty('index', i);
            }

            // move view to correct spot
            var view = this.getItemView(this.model.getItemAt(to).id);
            if (view) {
                var $items = this.$items;
                // put at beginning
                if (to === 0) {
                    $items.prepend(view.$());
                }

                // put at end
                else if (to === this.model.getItemCount() - 1) {
                    $items.append(view.$());
                }

                // put somewhere in middle
                else {

                    // must add 1 to index if to > from. This is because the from spot will
                    // get plucked out and inserted after the to spot. Means we need to
                    // search one deeper into sibling list to find the correct node to
                    // insert after.
                    var child_index = to + (to > from ? 1 : 0);
                    view.$().insertAfter($items.children(':nth-child(' + child_index + ')'));
                }
            }
        };

        view.onSetState = function (list) {
            // destroy item views
            for (var id in this.__itemViews) {
                if (this.__itemViews.hasOwnProperty(id)) {
                    this.__itemViews[id].remove(); //TODO - could do a destruct() and remove all at once from dom for optimization.
                }
            }

            this.__itemViews = {};
            this.selectedItem = null;

            // update index on newExpressionView
            if (this.newExpressionView) {
                this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);
            }

            // make all the views at once and insert one large structure
            this.createAllItemViews();
        };

        view.renderItemFocused = function () {
            this.$('#exppanel').toggleClass('item-focused', this.itemFocused);
        };

        // MUST OVERRIDE
        view.instantiateItemView = function (item) { };

        view.createItemView = function (item) {
            var view = this.instantiateItemView(item);
            var item_id = String(item.id);

            if (view) {
                this.__itemViews[item_id] = view;

                // add some triggers to the view
                var self = this;
                view.triggerDelete = function () { self.onDelete(view) };
                view.triggerEnterPressed = function () { self.onEnterPressed(view) };
                view.triggerUpPressed = function () { self.onUpPressed(view) };
                view.triggerDownPressed = function () { self.onDownPressed(view) };
                view.triggerBackspacePressed = function () { self.onBackspacePressed(view) };
                view.triggerDelPressed = function () { self.onDelPressed(view) };
            }

            return view;
        };
        view.createAllItemViews = function () {

            // only do this if we've been added to the dom
            if (!this.$items) return;

            var len = this.model.getItemCount();
            for (var i = 0; i < len; i++) {
                var item = this.model.getItemAt(i);
                var view = this.createItemView(item);
                if (view) {
                    view.appendTo(this.$items);
                    //TODO - generate only the html

                    item.setProperty('index', i);

                    // observe selected
                    item.observe('selected.listview', this.observeItemSelected.bind(this));
                    if (item.selected) {
                        this.observeItemSelected('selected', item);
                    }
                }
            }

            //TODO - insert large structure at once

            //TODO - assign the nodes for each view based on the structure

            //Focus if something is selected
            var selected = this.getSelectedView();
            if (selected) { selected.addFocus(); }
        };

        // holds a copy of the each item's view for later reference

        view.getItemView = function (id) {
            return this.__itemViews[String(id)];
        };

        view.onDelete = function (view) {
            var self = this;
            UndoRedo.oneTransaction(function () {
                self.model.removeItemAt(view.model.index);
                if (self.model.getItemCount() === 0) {
                    var new_exp = ExpressionObject();
                    self.model.insertItemAt(0, new_exp);
                }
            });
        };

        view.onUpPressed = function (view) {
            // nothing above
            if (view.model.index === 0) return;

            this.selectPrevExpression(view.model);
            this.getSelectedView().addFocus('end');
        };

        view.onDownPressed = function (view) {
            this.selectNextExpression(view.model);
            this.getSelectedView().addFocus('start');
        };

        view.onBackspacePressed = function (view) {
            this.upwardDeleteExpression(view.model);
            this.getSelectedView().addFocus('end');
        };

        view.onDelPressed = function (view) {
            this.downwardDeleteExpression(view.model);
            this.getSelectedView().addFocus('start');
        };

        view.onEnterPressed = function (view) {
            var obj = ExpressionObject({ selected: true });
            this.model.insertItemAt(view.model.index + 1, obj);
            this.getSelectedView().addFocus();
        };

        view.expressionsVisible = true;
        view.hideExpressions = function () {
            this.setProperty('expressionsVisible', false);
            //remove the tab and transform the whole thing off the screen
            $('#hide-expressions-tab').hide();
            var $self = this.$();
            $(document.activeElement).blur();
            $('body').addClass('fullscreen');
            Resize.trigger();

            var expressionListWidth = 356;  // see grapher/_common.styl
            $self.css('transform', 'translate(-' + (expressionListWidth + 1) + 'px, 0)');

            //wait until it's back in position and add back in the 'open this' tab
            setTimeout(function () {
                $('#show-expressions-tab').fadeIn('fast');
            }, 300);
        };
        view.showExpressions = function () {
            this.setProperty('expressionsVisible', true);
            $(document.activeElement).blur();
            $('#show-expressions-tab').hide();

            this.$().css('transform', 'translate(0, 0)');
            setTimeout(function () {
                $('body').removeClass('fullscreen');
                if ($('#grapher').position().left > 0) {
                    Resize.trigger();
                }
                $('#hide-expressions-tab').fadeIn('fast');
            }, 300);
        };

        view.toggleEditListMode = function () {
            if (this.$('.edit-list-btn').toggleClass('btn-primary').hasClass('btn-primary')) {

                $(document.activeElement).blur();

                this.$().addClass('edit-list-mode');
                this.$('.edit-list-btn').text('done');
                var self = this;
                $(document).on('tapstart', function (evt) {
                    if ($(evt.target).closest('#exppanel').length === 0 && $(evt.target).closest('.options-menu').length === 0 && $(evt.target).closest('.edit-list-btn').length === 0)
                        self.exitEditListMode();
                });

            } else {
                this.exitEditListMode();
            }
        };
        view.exitEditListMode = function () {
            this.$().removeClass('edit-list-mode');
            this.$('.edit-list-btn').removeClass('btn-primary').html('edit');
        };

        /*
        * EVENTS
        */
        view.onFocusIn = function (evt) {

            //it's possible to add focus to an expression even when the expressions are hidden.
            // Most prominently: if you click a curve to select it and then type
            // If that happens, we want to show the expression that's being edited, so pop back out the expressions list
            if (!this.expressionsVisible) {
                this.showExpressions();
            }

            var target = $(evt.target);
            var inMathquill = target.closest('.mathquill-rendered-math').length !== 0;
            var inEditableMathquill = target.closest('.mathquill-editable').length !== 0;
            var inText = target.closest('.expressiontext').length !== 0;

            if (!inMathquill && !inEditableMathquill && !inText) {
                this.setProperty('itemFocused', false);
                $('#grapher').removeClass('item-focused');
            } else {
                // in case we're in list mode, get out of it!
                this.exitEditListMode();
                this.setProperty('itemFocused', true);
                $('#grapher').addClass('item-focused');
            }

            this.setProperty('mathquillFocused', inEditableMathquill);

            clearTimeout(this.fakeKeypadTimeout);
            if (!inMathquill && !inEditableMathquill) {
                this.setProperty('needFakeKeypad', false);
            } else {
                this.setProperty('needFakeKeypad', true);
            }
        };

        view.onFocusOut = function () {
            clearTimeout(this.fakeKeypadTimeout);

            // wait two run loops to actually fire this. It can take up to two
            // runloops for the focus event to fire and for ember to fully
            // render.
            this.fakeKeypadTimeout = setTimeout(function () {
                this.fakeKeypadTimeout = setTimeout(function () {

                    // Mathquill does something weird where it triggers a focusout on
                    // render, but nothing actually happens to focus. To combat that, and
                    // anything else similar, we check if we still have a focused
                    // expression. If so, just ignore this event.
                    var selected = this.getSelectedView();
                    if (selected && selected.isFocused()) return;

                    this.setProperty('itemFocused', false);
                    $('#grapher').removeClass('item-focused');
                    this.setProperty('needFakeKeypad', false);
                    this.setProperty('mathquillFocused', false);
                } .bind(this), 0);
            } .bind(this), 0);
        };

        view.didInsertElement = function () {
            var self = this;
            _super.didInsertElement.call(this);

            this.$items = this.$('.template-expressioneach');

            Resize.register(function () {
                var exppanel = self.$();
                var header_height = exppanel.offset().top;
                var expressions_height = (
          $(window).height() -
          header_height -
          keypadView.height()
        );

                exppanel.css('height', expressions_height + 'px');
                self.ensureVisible();
            });

            Resize.trigger();

            $('#loading_div').fadeOut();
            $('#grapher').show();

            //add tooltips for the icons within the expression
            this.$().tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 0,
                live: true,
                delegate: '.tooltip',
                gravity: 'n'
            });

            //
            //listen for scroll && add class when scrolled
            //
            this.$('#exppanel').scroll(function (evt) {
                $('#expression-top-bar').toggleClass('expressions-scrolled', ($(evt.target).scrollTop() > 0));
            })
            //
            // for iPad & nexus, listen for taps in the empty area underneath an expression and defocus
            // because that doesn't happen automatically
            //
      .on('tapstart', function (evt) {
          if ($(evt.target).attr('id') === 'exppanel') {
              self.setSelected(null);
          }
      });
            //the below should happen automatically, but doesn't on iPad / android
            //this lets you defocus the currently focused expression by clicking the 'Expressions' header
            $('#expression-top-bar').on('tapstart', function (evt) {
                if ($(evt.target).attr('id') === 'expression-top-bar') {
                    self.setSelected(null);
                }
            });

            this.$().on('focusout', this.onFocusOut.bind(this));
            this.$().on('focusin', this.onFocusIn.bind(this));
            this.$('.action-toggleeditlistmode').on('tap', this.toggleEditListMode.bind(this));
            this.$('.action-hideexpressions').on('tap', this.hideExpressions.bind(this));
            this.$('.action-showexpressions').on('tap', this.showExpressions.bind(this));
            $('body').on('keydown', this.handleKeyDown.bind(this));


            this.renderItemFocused();

            this.newExpressionView = NewExpressionView(this);
            this.newExpressionView.replace(this.$('.template-newexpression'));
            this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);

            this.createAllItemViews();
        };

        // Find the view for the selected expression and scroll that expression
        // into view. If the expression doesn't have a view yet, we'll let the
        // view call this once it's inserted into the dom.
        view.ensureVisible = function () {
            var selectedItem = this.selectedItem;
            if (!selectedItem) return;

            var selectedView = this.getItemView(selectedItem.id);

            if (selectedView) {
                this.$('#exppanel').scrollVisible(selectedView.$(), 0, -150);
            }
        };

        view.handleKeyDown = function (evt) {
            // make sure nothing has focus
            if (document.activeElement && document.activeElement !== document.body) {
                return;
            }

            // make sure event didn't happen from within expression list
            if ($(evt.target).closest('#exppanel').length) {
                return;
            }

            var selected = this.getSelectedView();
            if (selected && selected.isFocused()) {
                selected.processMissedKeyEvent(evt);
                return;
            }

            switch (Keydown.which(evt.which)) {
                case 'Up':
                    evt.preventDefault();
                    this.selectPrevExpression(selected.model);
                    break;

                case 'Down':
                    evt.preventDefault();
                    this.selectNextExpression(selected.model, true);
                    break;
                case 'Esc':
                    evt.preventDefault();
                    this.setSelected(null);
                    break;

                case 'Right':
                case 'Tab':
                    evt.preventDefault();
                    if (selected) {
                        if (selected.model.isTable) {
                            selected.addFocus('cell', 0, 0);
                        } else {
                            selected.addFocus('start');
                        }
                    }
                    break;

                case 'Left':
                    evt.preventDefault();
                    if (selected) {
                        if (selected.model.isTable) {
                            selected.addFocus('cell', 0, selected.model.columns.length - 1);
                        } else {
                            selected.addFocus('end');
                        }
                    }
                    break;

                case 'Backspace':
                    evt.preventDefault();
                    this.upwardDeleteExpression(selected.model);
                    break;

                case 'Del':
                    evt.preventDefault();
                    this.downwardDeleteExpression(selected.model);
                    break;

                case 'Enter':
                    evt.preventDefault();
                    if (selected) {
                        var obj = ExpressionObject({ selected: true });
                        this.model.insertItemAt(selected.model.index + 1, obj);
                        this.getItemView(obj.id).addFocus('end');
                    }
                    break;

                // TODO - probably rule out other keys from activating focus. For 
                //        instance, pressing only the shift key probably shouldn't 
                //        put focus in the textbox. 
                // anything else 
                default:
                    if (selected) {
                        if (selected.model.isTable) {
                            // do nothing since we don't know where to type
                        } else {
                            selected.addFocus('end');
                        }
                    }
            }
        };

        /*
        * PUBLIC METHODS
        */

        view.getWidth = function () {
            return this.$().children('#exppanel').outerWidth();
        };

        view.observeItemSelected = function (property, item) {
            var selected = item.selected;
            if (!selected && this.selectedItem === item) {
                this.setProperty('selectedItem', null);
            } else if (selected && !this.selectedItem) {
                this.setProperty('selectedItem', item);
            } else if (selected && this.selectedItem !== item) {
                this.selectedItem.setProperty('selected', false);
                this.setProperty('selectedItem', item);
            }
        };

        view.getSelected = function () {
            return this.selectedItem;
        };

        view.getSelectedView = function () {
            var selected = this.getSelected();
            if (selected) {
                var view = this.getItemView(selected.id);
                return view;
            }

            return null;
        };

        view.setSelected = function (i) {
            var nextSelected = i;

            if (typeof i === 'number') nextSelected = this.model.getItemAt(i);
            if (nextSelected) {
                nextSelected.setProperty('selected', true);
            } else {
                var selected = this.getSelected();
                if (selected) selected.setProperty('selected', false);
            }
        };

        view.upwardDeleteExpression = function (expression) {
            var index = expression.index;
            var prev = this.model.getItemAt(index - 1);
            var self = this;

            if (prev) {
                this.setSelected(prev);
                this.model.removeItemAt(index);
            }

            // first, but not only expression
            else if (this.model.getItemCount() > 1) {
                this.setSelected(1);
                this.model.removeItemAt(index);
            }

            // only expression
            else {
                UndoRedo.oneTransaction(function () {
                    self.model.removeItemAt(0);
                    self.model.insertItemAt(0, ExpressionObject());
                    self.setSelected(0);
                });
            }
        };

        view.downwardDeleteExpression = function (expression) {
            var index = expression.index;
            var next = this.model.getItemAt(index + 1);
            var self = this;

            if (next) {
                this.setSelected(next);
                this.model.removeItemAt(index);
            }

            // last, but not only expression
            else if (this.model.getItemCount() > 1) {
                this.setSelected(index - 1);
                this.model.removeItemAt(index);
            }

            // only expression
            else {
                UndoRedo.oneTransaction(function () {
                    self.model.removeItemAt(0);
                    self.model.insertItemAt(0, ExpressionObject());
                    self.setSelected(0);
                });
            }
        };

        view.selectPrevExpression = function (expression) {
            if (!expression) return;

            index = expression.index;
            prev = this.model.getItemAt(index - 1);

            if (prev) {
                prev.setProperty('selected', true);

                // check if this was an empty last expression
                // if so, remove it
                if (index + 1 === this.model.getItemCount() && expression.isEmpty()) {
                    this.model.removeItemAt(index);
                }
            }
        };

        view.selectNextExpression = function (expression, dontCreateNew) {
            if (!expression) return;

            index = expression.index;
            next = this.model.getItemAt(index + 1);

            if (next) {
                next.setProperty('selected', true);
            } else if (!dontCreateNew) {
                obj = ExpressionObject({ selected: true });
                this.model.insertItemAt(index + 1, obj);
            }
        };

        // TODO - weird indirection. might even get rid of call completely
        view.getItemByIndex = function (i) {
            return this.model.getItemAt(i);
        };

        view.getItemsByIndexRange = function (min, max) {
            min = Math.max(0, min);
            max = Math.min(this.model.getItemCount() - 1, max);

            var arr = [];
            for (var i = min; i <= max; i++) {
                arr.push(this.model.getItemAt(i));
            }
            return arr;
        };

        // TODO - should put this on the model itself. fine for now
        view.getItemById = function (id) {
            return this.model.__itemIds[id];
        };

        // TODO - figure out if this should be separate from getItemById
        // and if so, figure out a more efficient way to do this. Probably
        // should have each item add/remove it's children from this list. Or
        // we could know the parent's id jump straight to the parent. A way to
        // do that would be for the child's id to be prefixed by the parent's id.
        view.getChildItemById = function (id) {
            var len = this.model.getItemCount();
            for (var i = 0; i < len; i++) {
                var item = this.model.getItemAt(i);

                // tables are the only ones that can have children
                if (item.isTable) {
                    var columns = item.columns;
                    for (var j = 0; j < columns.length; j++) {
                        if (String(columns[j].id) === String(id)) {
                            return columns[j];
                        }
                    }
                }
            }

            return null;
        };

        view.updateItemById = function (id, properties) {
            this.getItemById(id).setProperties(properties);
        };

        view.addItem = function (obj) {
            var lastObject = this.model.getItemAt(this.model.getItemCount() - 1);
            // Replace empty expressions
            if (
        lastObject &&
        !(lastObject.text || lastObject.columns || lastObject.headings) && //TODO - remove headings after DB updated
        lastObject.latex === ''
      ) {
                this.model.removeItemAt(this.model.getItemCount() - 1); //pop off last
            }

            this.model.insertItemAt(this.model.getItemCount(), obj); //push to end
        };

        /*
        * Does a binary search to find the .expressionitem that is at the point
        */
        view.expressionAtPoint = function (x, y) { //TODO - always return view and move out of expression list.
            var lo = 0;
            var hi = this.model.getItemCount() - 1;

            while (lo <= hi) {
                var mid = lo + Math.floor((hi - lo) / 2);
                var exp = this.model.getItemAt(mid);
                var view = this.getItemView(exp.id);
                var rect = view && view.getBounds();

                if (!rect || rect.top > y) {
                    hi = mid - 1;
                } else if (rect.bottom < y) {
                    lo = mid + 1;
                } else {
                    return exp;
                }
            }

            return null;
        };

        /*
        * Finds the first expression at or above the point
        */
        view.expressionAbovePoint = function (x, y, getDom) { //TODO - always return view and move out of here...
            var lo = 0;
            var hi = this.model.getItemCount() - 1;
            var found = null;

            while (lo <= hi) {
                var mid = lo + Math.floor((hi - lo) / 2);
                var exp = this.model.getItemAt(mid);
                var view = this.getItemView(exp.id);
                var rect = view && view.getBounds();

                if (!rect || rect.top > y) {
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                    found = exp;
                }
            }

            if (found) return (getDom) ? this.getItemView(found.id).$() : found;

            return (getDom) ? $() : null;
        };

        view.getActiveMathquill = function () {
            return $(document.activeElement).closest('.mathquill-editable');
        };

        view.onChange = function (changes) {
            var id;

            for (id in changes) {
                if (!changes.hasOwnProperty(id)) continue;

                var expression = this.getItemById(id);
                if (expression) {

                    if (expression.constructor === ExpressionObject) {
                        var formula = changes[id];
                        if (!formula) continue;

                        var view = this.getItemView(expression.id);
                        if (expression.loading === false && view && view.doAnimate === undefined) {
                            view.setProperty('doAnimate', true);
                        }

                        expression.setProperty('loading', false);
                        expression.setProperty('formula', formula);
                    } else if (expression.isTable) {
                        var table_data = changes[id];
                        expression.setComputedValues(table_data);
                    }
                }
            }
        };

        // noop default callbacks
        view.triggerRemoveExpr = function () { };
        view.triggerAddExp = function () { };
    });

    return ExpressionListView;
});

define('expressions/list', ['require', 'desmos', 'pjs', 'lib/underscore_model', './expression', './text', './table', 'undoredo'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreModel = require('lib/underscore_model');
    var ExpressionObject = require('./expression');
    var TextObject = require('./text');
    var TableObject = require('./table');
    var UndoRedo = require('undoredo');
    var ExpressionListModel = P(UnderscoreModel, function (model, _super) {

        model.init = function () {
            _super.init.call(this);

            this.__items = [];
            this.__itemIds = {};
        };

        model.getItemAt = function (index) {
            return this.__items[index];
        };

        model.triggerItemAdded = function () { };
        model.insertItemAt = function (index, item, insideSetState) {

            var item_id = String(item.id);
            if (this.__itemIds.hasOwnProperty(item_id)) {
                throw Error('Item with id \'' + item_id + '\' is already in list');
            }

            // add item to list
            this.__itemIds[item_id] = item;
            this.__items.splice(index, 0, item);

            // if we're doing a setState, then we don't want the  rest of this
            // function to execute. The setState will handle the undo/redo. The
            // setState will also deal with the added item on its own, so we'd
            // duplicate setup code if we called .triggerItemAdded(). It'll also
            // parse the new item, so we don't need to do that here.
            if (insideSetState) return;

            // allow view to tap into this
            this.triggerItemAdded(index, item);

            // request that expressions get evaluated
            if (typeof item.requestParse === 'function') item.requestParse();

            // add to undo/redo
            var self = this;
            var constructor = item.constructor;
            var state = item.getState();
            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () {
                    self.removeItemAt(index);
                },
                redo: function () {
                    self.insertItemAt(index, constructor(state));
                }
            });
        };

        model.triggerItemRemoved = function (index, item) { };
        model.removeItemAt = function (index) {
            var item = this.__items.splice(index, 1)[0];
            var item_id = String(item.id);
            delete this.__itemIds[item_id];

            // request that expressions get unevaluated
            if (typeof item.requestUnparse === 'function') item.requestUnparse();

            // allow a view to tap into this
            this.triggerItemRemoved(index, item);

            var self = this;
            var constructor = item.constructor;
            var state = item.getState();
            UndoRedo.addTransaction({
                type: UndoRedo.RESPONSE_TO_CHANGE,
                undo: function () {
                    self.insertItemAt(index, constructor(state));
                },
                redo: function () {
                    self.removeItemAt(index);
                }
            });
        };

        model.triggerItemMoved = function (from, to) { };
        model.moveItemTo = function (a, b) {
            var self = this;

            var manipulator = function (from, to) {
                if (from === to) return;

                var len = self.getItemCount();
                var item = self.__items[from];

                // check that the numbers are within range
                if (from < 0 || to < 0 || from >= len || to >= len) return;

                // remove from items
                self.__items.splice(from, 1);

                // insert back in correct spot
                self.__items.splice(to, 0, item);

                // allow a view to tap into this
                self.triggerItemMoved(from, to);
            };

            // add to undo/redo
            UndoRedo.addTransaction({
                type: UndoRedo.CAUSE_OF_CHANGE,
                undo: function () {
                    manipulator(b, a);
                },
                redo: function () {
                    manipulator(a, b);
                }
            });
        };

        model.getItemCount = function () {
            return this.__items.length;
        };

        model.isEmpty = function () {
            var len = this.getItemCount();
            if (len === 0) return true;
            if (len > 1) return false;

            // TODO - maybe this should be this.getItemAt(0).isEmpty(). Only
            // problem I see there is that tables aren't ever considered empty. Not
            // sure if we consider expression list empty if it only contains an
            // empty text.
            return this.getItemAt(0).latex === '';
        };

        model.getState = function () {
            var list_state = [];
            var len = this.getItemCount();

            for (var i = 0; i < len; i++) {
                list_state.push(this.getItemAt(i).getState());
            }

            return { list: list_state };
        };

        model.triggerCompleteState = function () { };
        model.triggerSetState = function (list) { };
        model.setState = function (state) {

            var i;
            var list_content = [];
            var eval_state = [];

            for (i = 0; i < state.list.length; i++) {
                var expState = state.list[i];
                var obj;

                // Start rendering UI as shell until we know if it's on screen
                expState.renderShell = true;

                obj = this.fromState(expState);

                if (!obj) {
                    continue;
                }

                if (obj.getParsableObject) eval_state.push(obj.getParsableObject());
                list_content.push(obj);
            }

            // clear list and add all items
            this.__items = [];
            this.__itemIds = {};
            for (i = 0; i < list_content.length; i++) {
                this.insertItemAt(i, list_content[i], true);
            }

            // allow the view to tap into this
            this.triggerSetState(list_content);

            // allow the evaluator to tap into this
            this.triggerCompleteState(eval_state);
        };

        // Factory method for making a single expression object of the appropriate
        // type from a serialized state.
        model.fromState = function (itemState) {
            if (itemState.text !== undefined) {
                return TextObject(itemState);
            }
            if (itemState.columns !== undefined || itemState.headings !== undefined) { // TODO - remove headings after DB updated
                return TableObject(itemState);
            }

            // Expression object
            var valid_graph_modes = ['default', 'always', 'never'];

            if (valid_graph_modes.indexOf(itemState.userRequestedGraphing) === -1) {
                if (itemState.hasOwnProperty('graphed')) {
                    itemState.userRequestedGraphing = !!itemState.graphed ?
            'always' :
            'never'
          ;
                } else {
                    itemState.userRequestedGraphing = 'default';
                }
            }

            return ExpressionObject(itemState);
        };
    });


    return ExpressionListModel;
});

//handles drag/drop of expressions
define('expressions/dragdrop', ['require', 'jquery'], function (require) {
    require('jquery');

    var expressions = null; // filled in when .init() is called
    var draggedExpression = null;
    var draggedView = null;
    var grabPoint = null;
    var dragPoint = null;
    var $line = $('<div id="expressionDropLine"></div>');

    var grabIndex = null;
    var dropIndex = null;
    var redragTimeout = null;

    function isDragging() {
        return !!draggedExpression;
    }

    function startDrag(x, y) {
        draggedExpression = expressions.getSelected();
        draggedView = expressions.getItemView(draggedExpression.id);
        grabPoint = { x: x, y: y };
        dragPoint = { x: x, y: y, accumDistance: 0 };

        grabIndex = draggedExpression.index;
        dropIndex = null;

        // add line to expression list
        $line.appendTo($('#exppanel .expressionlist'));

        // simulate first mouse move to get line in correct position
        continueDrag(x, y);
    }

    function cancelDrag() {
        clearTimeout(redragTimeout);
        if (!isDragging()) return;

        // remove line from expression list
        $line.remove();

        draggedExpression = null;
        draggedView = null;
        grabPoint = null;
        dragPoint = null;

        grabIndex = null;
        dropIndex = null;
    }

    function finishDrag() {

        if (_.isFinite(dropIndex)) {

            if (dropIndex < grabIndex) {
                expressions.model.moveItemTo(grabIndex, dropIndex);
                expressions.setSelected(dropIndex);

                //notice that we should drop at one index before
                //since the item will first get removed (thus it drop
                //position is less 1)
            } else if (grabIndex < dropIndex) {
                expressions.model.moveItemTo(grabIndex, dropIndex - 1);
                expressions.setSelected(dropIndex - 1);
            } else {
                expressions.setSelected(grabIndex);
            }
        }

        cancelDrag();
    }


    // TODO - could clean this up some more
    function continueDrag(x, y) {
        clearTimeout(redragTimeout);
        if (!isDragging()) return;
        var exppanel = $('#exppanel');

        //gets the top and bottom of the exppanel
        var left = 0;
        var top = exppanel.offset().top;
        var bottom = exppanel.innerHeight() + top;
        var scrollSpeed = 0;
        var dom = null; //the element closest to our mouse
        var dropTop = true; //drop to the top of the dom
        var dropPosition;
        var domData = null;

        //checks if the mouse is above or below the exppanel
        if (y < top) {
            scrollSpeed = (y - top);
        }
        else if (y > bottom) {
            scrollSpeed = (y - bottom);
        }

        //adjust the scrollSpeed based on how tall the expressions
        //list is
        scrollSpeed = expressions.model.getItemCount() * scrollSpeed / 30;

        //if we have a scroll_speed, scroll the exppanel that much
        var origScrollSpeed = scrollSpeed;
        var scrollTop = exppanel.scrollTop();

        if (scrollSpeed) {
            exppanel.scrollTop(scrollTop + scrollSpeed);

            //check if it actually scrolled
            if (exppanel.scrollTop() == scrollTop)
                scrollSpeed = 0;
        }

        //now figure out where our mouse is closest to

        //get the first .expressionitem in the viewport
        if (scrollSpeed < 0) {
            dom = expressions.expressionAbovePoint(left + 5, top, true);
            dropTop = false;

            //get the last .expressionitem in the viewport
        } else if (scrollSpeed > 0) {
            dom = expressions.expressionAbovePoint(left + 5, bottom, true);

            //above exppanel and maxed out scroll
        } else if (origScrollSpeed < 0) {
            dom = expressions.getItemView(expressions.getItemByIndex(0).id).$();

            //below exppanel and maxed out scroll
        } else if (origScrollSpeed > 0) {
            dom = expressions.getItemView(expressions.getItemByIndex(expressions.model.getItemCount() - 1).id).$();
            dropTop = false;

            //check under the mouse for an .expressionitem
        } else {
            dom = expressions.expressionAbovePoint(left + 5, y, true);

            if (dom.length) {
                domData = {
                    top: dom.offset().top,
                    height: dom.innerHeight()
                };

                //figure out which side we're closer to (top or bottom)
                if (Math.abs(y - domData.top) > Math.abs(y - (domData.top + domData.height))) {
                    dropTop = false;
                }
            }
        }

        if (!dom.length) {
            dropIndex = null;

        } else {
            //show it
            dropIndex = parseInt(dom.attr('index'), 10);
            dropPosition = dom.position().top + scrollTop;
            if (!dropTop) {
                dropPosition += 1 + (domData ? domData.height : dom.innerHeight());
                dropIndex++;
            }

        }

        // make sure the mouse moves a bit before showing the line
        dragPoint.accumDistance += Math.abs(dragPoint.y - y);
        dragPoint.x = x;
        dragPoint.y = y;

        if (dropIndex !== null && dragPoint.accumDistance > 5) {
            $line.css('top', dropPosition + "px");
        } else {
            $line.css('top', "-50px");
        }

        // call this again on a timeout so that we can get repeated scrolling
        // effects if the user docks the mouse above or below the list.
        redragTimeout = setTimeout(function () {
            continueDrag(x, y);
        }, 50);
    }

    // TODO - any kind of user interaction (undo, typing, etc) should call
    // .cancel() to prevent us from getting in a weird state where we're dragging
    // an expression that doesn't exist.

    return {
        grab: startDrag,
        drop: finishDrag,
        drag: continueDrag,
        cancel: cancelDrag,
        isDragging: isDragging,

        init: function (expr_list) {
            expressions = expr_list;
        }
    };
});

define('expressions/abstractitem_view', ['require', 'desmos', 'pjs', 'lib/underscore_view', './dragdrop', './expression', 'undoredo'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var DragDrop = require('./dragdrop');
    var ExpressionObject = require('./expression');
    var UndoRedo = require('undoredo');

    var AbstractItemView = P(UnderscoreView, function (view, _super) {
        view.init = function (model) {
            _super.init.call(this);

            this.model = model;

            // do this now instead of letting renderSelected do this. If we wait
            // for renderSelected to do it, we'll end up calling rerender within a
            // already started render loop. That'll cause events to get bound twice
            // and other weird stuff will happen.
            if (this.model.selected) {
                this.model.renderShell = false;
            }

            this.model.observe('index.itemview', this.renderIndex.bind(this));
            this.model.observe('selected.itemview', this.renderSelected.bind(this));
            this.model.observe('renderShell.itemview', this.rerender.bind(this));
        };

        view.destruct = function () {
            this.model.unobserve('.itemview');
        };

        view.getTemplateParams = function () {
            return {
                renderShell: this.model.renderShell
            };
        };

        view.renderIndex = function () {
            var index = this.model.index;
            this.$().attr('index', index);
            this.$('.variable-index').text(index + 1);
        };

        view.renderSelected = function () {
            if (this.model.selected) {
                if (this.model.renderShell) {
                    this.model.setProperty('renderShell', false);
                }
            }

            this.$().toggleClass('selected', this.model.selected);
        };

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);

            var self = this;
            this.$().on('tap tapstart', function (evt) {
                // when using mouse, fire on 'tapStart' and when on touch we
                // fire on the 'tap' event.
                if (evt.type === 'tap' && evt.device === 'mouse') return;
                if (evt.type === 'tapstart' && evt.device === 'touch') return;

                self.onMouseSelect(evt);
            });

            this.$('.action-drag').on('tapstart', this.onDragStart.bind(this));
            this.$('.action-delete').on('tap', this.onDelete.bind(this));

            this.$().attr('expr-id', this.model.id);
            this.renderIndex();
            this.renderSelected();
        };

        view.triggerDelete = function () { };
        view.triggerEnterPressed = function () { };
        view.triggerUpPressed = function () { };
        view.triggerDownPressed = function () { };
        view.triggerBackspacePressed = function () { };
        view.triggerDelPressed = function () { };

        view.onDelete = function () {
            this.triggerDelete();
        };

        view.convertTo = function (cls, state) {

            var obj = cls(state);
            var index = this.model.index;

            UndoRedo.oneTransaction(function () {
                Desmos.expressions.model.removeItemAt(index);
                Desmos.expressions.model.insertItemAt(index, obj);
            });

            return obj;
        };

        view.getBounds = function () {
            var dom = this.$();
            var offset = dom.offset();
            if (!offset) return null;

            var top = offset.top;
            var height = dom.height();

            return {
                top: top,
                bottom: top + height
            };
        };

        view.onDragStart = function (evt) {

            // must be first touch and must not be dragging already. Ideally, these
            // conditions mean the same thing, but I could imagine a case where
            // an event gets lost and we stay in a dragging state. We'd like that
            // dragging state to resolve itself on the next tapend before we start
            // dragging another expression.
            if (evt.touches.length !== 1 || DragDrop.isDragging()) return;

            // put expression in selected, but unfocused state
            this.model.setProperty('selected', true);

            // remove focus, then mark it as being dragged
            $(document.activeElement).blur();

            // prevents scroll on Ipad and text selection on others
            evt.preventDefault();

            // save the touch identifier so that multitouch doesn't mess us up. Also
            // create a function that allows us to lookup the touch we care about.
            var touch_identifier = evt.touches[0].identifier;
            function getTouch(evt) {
                for (var i = 0; i < evt.touches.length; i++) {
                    var touch = evt.touches[i];
                    if (touch.identifier === touch_identifier) {
                        return touch;
                    }
                }
            }

            // listen for mouse movements and tell DragDrop about them.
            $(document).on('tapmove.dragdrop', function (evt) {
                // touch must still be around
                var touch = getTouch(evt);
                if (!touch) return;

                DragDrop.drag(touch.x, touch.y);
            });

            // listen for mouse ups and tell DragDrop about them.
            $(document).on('tapend.dragdrop', function (evt) {
                // touch must not be around
                var touch = getTouch(evt);
                if (touch) return;

                $(document).off('.dragdrop');
                DragDrop.drop(x, y);
            });

            // start dragging
            DragDrop.grab(evt.touches[0].x, evt.touches[0].y);
        };

        view.hideContextMenu = function () {
            // TODO - temporary until we have a better popup menu manager
            if (window.opened_options_menu) {
                window.opened_options_menu.hideOptions();
            }
        };

        view.processMissedKeyEvent = function (evt) { };
        view.addFocus = function (where) { };
        view.isFocused = function () { return false };
    });



    return AbstractItemView;
});
define('expressions/colorthumbnail', ['require', 'graphing/dasheddrawer'], function (require) {
    var DashedDrawer = require('graphing/dasheddrawer');

    function ColorThumbnail(width, height) {
        this.width = width;
        this.height = height;

        this.color = "#000000";
        this.thickness = 2;
        this.graphics = [{ type: 'straightline', opacity: ColorThumbnail.ON}];
    }

    ColorThumbnail.ON = 1;
    ColorThumbnail.FADED = 0.35;
    ColorThumbnail.OFF = 0;

    ColorThumbnail.prototype.instantiate = function (canvas) {
        this.node = $(canvas);
        this.node.attr('width', this.width);
        this.node.attr('height', this.height);

        this.ctx = canvas.getContext('2d');
        this.redraw();
    };

    ColorThumbnail.prototype.point = function (x, y) {
        var ctx = this.ctx;
        ctx.moveTo(x - 0.1, y - 0.1);
        ctx.lineTo(x - 0.1, y + 0.1);
        ctx.lineTo(x + 0.1, y + 0.1);
        ctx.lineTo(x + 0.1, y - 0.1);
        ctx.closePath();
    };


    ColorThumbnail.prototype.draw_straightline = function (details) {
        var ctx = this.ctx;
        ctx.lineWidth = this.thickness;
        ctx.globalAlpha = 0.7 * details.opacity;

        if (details.dotted) {
            // Total segment length should never be THAT huge for a thumbnail.
            var buf = new DashedDrawer(ctx, this.width + this.height);
            buf.start(0, this.height);
            buf.next(this.width, 0);
            buf.close();
        } else {
            ctx.beginPath();
            ctx.moveTo(0, this.height);
            ctx.lineTo(this.width, 0);
            ctx.stroke();
        }

        if (details.fill) {
            ctx.globalAlpha = 0.4 * details.opacity;
            ctx.beginPath();
            ctx.moveTo(0, this.height);
            ctx.lineTo(this.width, 0);
            ctx.lineTo(this.width, this.height);
            ctx.closePath();
            ctx.fill();
        }
    };

    ColorThumbnail.prototype.draw_shadebetween = function (details) {
        var buf, ctx = this.ctx;
        ctx.lineWidth = this.thickness;
        ctx.globalAlpha = 0.7 * details.opacity;

        // y values
        var top = [0.7 * this.height, -0.3 * this.height];
        var bottom = [1.3 * this.height, 0.3 * this.height];

        if (details.dottedTop) {
            // Total segment length should never be THAT huge for a thumbnail.
            buf = new DashedDrawer(ctx, this.width + this.height);
            buf.start(0, top[0]);
            buf.next(this.width, top[1]);
            buf.close();
        } else {
            ctx.beginPath();
            ctx.moveTo(0, top[0]);
            ctx.lineTo(this.width, top[1]);
            ctx.stroke();
        }

        if (details.dottedBottom) {
            // Total segment length should never be THAT huge for a thumbnail.
            buf = new DashedDrawer(ctx, this.width + this.height);
            buf.start(0, bottom[0]);
            buf.next(this.width, bottom[1]);
            buf.close();
        } else {
            ctx.beginPath();
            ctx.moveTo(0, bottom[0]);
            ctx.lineTo(this.width, bottom[1]);
            ctx.stroke();
        }

        ctx.globalAlpha = 0.4 * details.opacity;
        ctx.beginPath();
        ctx.moveTo(0, top[0]);
        ctx.lineTo(this.width, top[1]);
        ctx.lineTo(this.width, bottom[1]);
        ctx.lineTo(0, bottom[0]);
        ctx.closePath();
        ctx.fill();
    };

    ColorThumbnail.prototype.draw_bentline = function (details) {
        var ctx = this.ctx;
        ctx.lineWidth = this.thickness;
        ctx.globalAlpha = 0.9 * details.opacity;

        ctx.beginPath();
        ctx.moveTo(this.width * 6 / 50, this.height * 45 / 50);
        ctx.lineTo(this.width * 15 / 50, this.height * 15 / 50);
        ctx.lineTo(this.width * 32 / 50, this.height * 30 / 50);
        ctx.lineTo(this.width * 45 / 50, this.height * 6 / 50);
        ctx.stroke();
    };

    ColorThumbnail.prototype.draw_pointplot = function (details) {
        var ctx = this.ctx;
        ctx.lineWidth = this.thickness * 3.5;
        ctx.globalAlpha = 0.9 * details.opacity;

        ctx.beginPath();
        this.point(this.width * 0.5, this.height * 0.5);
        ctx.stroke();
    };

    ColorThumbnail.prototype.draw_scatterplot = function (details) {
        var ctx = this.ctx;
        ctx.lineWidth = this.thickness * 3;
        ctx.globalAlpha = 0.9 * details.opacity;

        ctx.beginPath();
        this.point(this.width * 10 / 50, this.height * 38 / 50);
        this.point(this.width * 15 / 50, this.height * 17 / 50);
        this.point(this.width * 32 / 50, this.height * 30 / 50);
        this.point(this.width * 41 / 50, this.height * 11 / 50);
        ctx.stroke();
    };

    ColorThumbnail.prototype.draw_largedot = function (details) {
        var ctx = this.ctx;
        ctx.lineWidth = this.thickness * 4.5;
        ctx.globalAlpha = 0.9 * details.opacity;

        ctx.beginPath();
        this.point(this.width * 0.5, this.height * 0.5);
        ctx.stroke();
    };

    ColorThumbnail.prototype.redraw = function () {
        if (!this.node) return;

        var ctx = this.ctx;
        ctx.clearRect(0, 0, this.width, this.height);
        ctx.strokeStyle = this.color;
        ctx.fillStyle = this.color;
        ctx.lineJoin = "round";

        // cycle through all the graphic details and draw them in order.
        for (var i = 0; i < this.graphics.length; i++) {
            var details = this.graphics[i];
            this['draw_' + details.type](details);
        }
    };

    return ColorThumbnail;
});

define('expressions/abstract_icon', ['require', 'lib/underscore_view', 'pjs', 'expressions/colorthumbnail'], function (require) {
    var UnderscoreView = require('lib/underscore_view');
    var P = require('pjs');
    var ColorThumbnail = require('expressions/colorthumbnail');

    var icon_count = 0;

    var AbstractIconView = P(UnderscoreView, function (view, _super) {

        view.init = function (model) {
            this.model = model;

            _super.init.call(this);
            this.colorThumb = new ColorThumbnail(18, 18);
            this.optionsmenu_guid = (++icon_count);

            this.model.observe('error.iconview', this.renderErrorTooltip.bind(this));
            this.observe('error errorStable', this.computeErrorShown.bind(this));
            this.observe('errorShown', this.renderErrorShown.bind(this));
        };

        view.destruct = function () {
            this.model.unobserve('.iconview');
        };

        view.computeErrorShown = function () {
            this.setProperty('errorShown', this.error && this.errorStable);
        };

        view.renderErrorTooltip = function () {
            var error = this.model.error;
            this.$('.variable-errortooltip').attr('tooltip', error);
        };

        view.renderErrorShown = function () {
            this.$().toggleClass('error', !!this.errorShown);
            this.$('.variable-errortooltip').toggleClass('tipsy-sticky', !!this.errorShown);
        };

        view.didInsertElement = function () {
            this.colorThumb.instantiate(this.$('canvas')[0]);
            this.renderErrorShown();
            this.renderErrorTooltip();
        };

        // defined in subclass
        // view.createOptionsMenuView()

        view.toggleOptions = function () {
            if (this.error) {
                this.hideOptions();
                return;
            }
            if (this.optionsShown) {
                this.hideOptions();
                return;
            }

            this.optionsShown = true;

            // Add options menu to body. workaround bug with "-webkit-scrolling-overflow: touch" and child "position: relative" elements not respecting z-index
            // see: "-webkit-overflow-scrolling: touch is messing up z-index stacking" [http://code.google.com/p/chromium/issues/detail?id=128325]
            var placeholder = this.$('.template-optionsmenu');
            var offset = placeholder.offset();

            this.optionsMenu = this.createOptionsMenuView(); //defined in subclass
            this.optionsMenu.$().css({
                position: 'absolute',
                top: offset.top + 'px',
                left: offset.left + 'px'
            });

            // TODO - temporary until we have a better popup menu manager
            window.opened_options_menu = this;

            var id = this.optionsmenu_guid;

            // ipad sends out a scroll event when you tapstart on the button that
            // opens the context menu. We want that first scroll event to be
            // ignored, so we add the listener after a slight timeout to give the
            // first scroll event time to pass through.
            setTimeout(function () {
                //make sure options menu hasn't closed before the timeout fires
                if (this.optionsShown) {
                    $('#exppanel').on("scroll.options-menu" + id, function (evt) {
                        this.hideOptions();
                    } .bind(this));
                }
            } .bind(this), 0);

            $(document).on("keydown.options-menu" + id, function (e) {
                if (e.which === 27) { // 'Esc'
                    this.hideOptions();
                }
            } .bind(this));

            $(document).on("tapstart.options-menu-" + id, function (e) {

                // close this unless:
                // * we click on the icon again (will handle that separately)
                // * we click insde the context-menu (that's been moved to the body)

                // we click inside the context menu
                if ($(e.target).closest(".options-menu").length) return;

                // we click within this view again
                if ($(e.target).closest(this.$()).length) return;

                this.hideOptions();

            } .bind(this));
        };

        view.hideOptions = function () {
            var id = this.optionsmenu_guid;
            $(document).off("tapstart.options-menu-" + id);
            $(document).off("keydown.options-menu" + id);
            $('#exppanel').off("scroll.options-menu" + id);
            this.optionsShown = false;

            if (this.optionsMenu) {
                this.optionsMenu.remove();
                this.optionsMenu = null;
            }

            // TODO - temporary until we have a better popup menu manager
            if (window.opened_options_menu === this) {
                window.opened_options_menu = null;
            }
        },

    view.onDisplayChange = function () {
        var error = this.model.error ? true : false;
        if (this.model.isEmpty()) error = false;

        //next sequence of code will only add the errorStable property
        //if the error value hasn't changed within the last 500ms
        if (error !== this.error) {
            this.setProperty('errorStable', false);
            this.__errorTime = new Date().getTime();
            setTimeout(this.onDisplayChange.bind(this), 100);
        } else if (this.__errorTime + 500 < new Date().getTime()) {
            this.setProperty('errorStable', true);
        } else if (!this.errorStable) {
            setTimeout(this.onDisplayChange.bind(this), 100);
        }

        this.setProperty('error', error);
    };

    });

    return AbstractIconView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/expression_icon.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/expression_icon', ["desmos"], function (Desmos) {
    Desmos.Templates["expression_icon"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<span class="graph-icon" handleevent="true">\n\n  <div class="outline" >\n    <div class="thumb action-togglegraphshown variable-errortooltip">\n      <span class="graphic">\n        <canvas></canvas>\n      </span>\n    </div>\n  </div>\n\n  <div class="outline color-picker-btn tooltip"  tooltip=\'change color\'>\n    <div class="thumb action-toggleoptions">\n      <span class="graphic">\n        <canvas class="variable-colorcss"></canvas>\n      </span>\n    </div>\n  </div>\n\n  <div class="template-optionsmenu"></div>\n  \n</span>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/expression_options_menu.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/expression_options_menu', ["desmos"], function (Desmos) {
    Desmos.Templates["expression_options_menu"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class=\'options-menu exp-options-menu\'>\n  <table>\n    <tr>\n      <td colspan="2">\n        <div class="template-colorsview"></div>\n      </td>\n    </tr>\n  </table>\n</div>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/expression_colors.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/expression_colors', ["desmos"], function (Desmos) {
    Desmos.Templates["expression_colors"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class="color-menu do-not-blur">\n  <table>\n    <tr>\n      ';
            _.each(colors, function (color) {
                ; __p += '\n        <td>\n          <span class="color-option"\n                color="' +
(color) +
'"\n                style="background: ' +
(color) +
'"\n                handleevent="true">\n          </span>\n        </td>\n      ';
            })
; __p += '\n    </tr>\n  </table>\n</div>';
        }
        return __p;
    };
});
define('expressions/expression_colors', ['require', 'pjs', 'lib/underscore_view', './colors', 'templates/expression_colors'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var Colors = require('./colors');

    require('templates/expression_colors');

    var ExpressionColorsView = P(UnderscoreView, function (view, _super) {
        view.templateName = "expression_colors",

    view.init = function (expression) {
        _super.init.call(this);

        this.expression = expression;
        this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
    };

        view.destruct = function () {
            this.expression.unobserve('.colorview');
        };

        view.renderSelectedColor = function () {
            var color = this.expression.color;
            this.$('.color-option').removeClass('selected');
            this.$('.color-option[color="' + color + '"]').addClass('selected');
        };

        view.didInsertElement = function () {
            this.$().on('tap tapstart', '.color-option', this.onSelectColor.bind(this));
            this.renderSelectedColor();
        };

        view.getTemplateParams = function () {
            return {
                colors: Colors.colors
            };
        };

        view.onSelectColor = function (evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            var color = $(evt.target).attr('color');
            this.expression.setProperty('color', color);
        };

    });

    return ExpressionColorsView;
});

define('expressions/expression_options_view', ['require', 'pjs', 'lib/underscore_view', 'templates/expression_options_menu', './expression_colors'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    require('templates/expression_options_menu');
    var ExpressionColorsView = require('./expression_colors');

    var ExpressionOptionsMenuView = P(UnderscoreView, function (view, _super) {
        view.templateName = "expression_options_menu";

        view.init = function (expression) {
            this.expression = expression;
        };

        view.destruct = function () {
            if (this.colorsView) {
                this.colorsView.remove();
                this.colorsView = null;
            }
        };

        view.didInsertElement = function () {
            // this view has a nested template. We instantiate the color picker
            // and replace a placeholder element within the html.
            this.colorsView = ExpressionColorsView(this.expression);
            this.colorsView.replace(this.$('.template-colorsview'));
        };

    });

    return ExpressionOptionsMenuView;
});

define('expressions/expression_icon', ['require', 'pjs', 'expressions/abstract_icon', 'lib/underscore_view', 'expressions/colorthumbnail', 'math/comparators', 'templates/expression_icon', './expression_options_view'], function (require) {
    var P = require('pjs');
    var AbstractIconView = require('expressions/abstract_icon');
    var UnderscoreView = require('lib/underscore_view');
    var ColorThumbnail = require('expressions/colorthumbnail');
    var Comparators = require('math/comparators');
    require('templates/expression_icon');
    var ExpressionOptionsMenuView = require('./expression_options_view');

    var ExpressionIconView = P(AbstractIconView, function (view, _super) {
        view.templateName = 'expression_icon';

        view.init = function (model) {
            _super.init.call(this, model);
            this.expression = model;

            this.expression.observe('color.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('formula.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('isGraphable.iconview', this.renderUngraphable.bind(this));
            this.expression.observe('loading.iconview', this.renderLoading.bind(this));
            this.expression.observe('color.iconview', this.renderColorCSS.bind(this));
        };

        view.destruct = function () {
            _super.destruct.call(this);

            this.expression.unobserve('.iconview');
        };

        view.renderUngraphable = function () {
            this.$().toggleClass('ungraphable', !this.expression.isGraphable);
        };

        view.renderLoading = function () {
            this.$().toggleClass('loading', this.expression.loading);
        };

        view.renderColorCSS = function () {
            this.$('.variable-colorcss').css('background', this.expression.color);
        };

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);

            this.$('.action-togglegraphshown').on('tap', this.toggleGraphShown.bind(this));
            this.$('.action-toggleoptions').on('tap', this.toggleOptions.bind(this));
            this.renderLoading();
            this.renderUngraphable();
            this.renderColorCSS();
            this.onDisplayChange();
        };

        // TODO - consider userRequestedGraphing being part of the expression's
        // view not it's model. Not sure on that because whether the expression
        // is graphed might be model worthy.
        view.isGraphShown = function () {
            return this.expression.userRequestedGraphing !== "never";
        };
        view.toggleGraphShown = function () {
            if (this.errorShown) return;

            if (this.isGraphShown()) {
                this.expression.setProperty("userRequestedGraphing", "never");
            } else {
                this.expression.setProperty("userRequestedGraphing", "always");
            }
        };

        view.createOptionsMenuView = function () {
            var optionsView = ExpressionOptionsMenuView(this.expression);
            optionsView.appendTo('body');

            return optionsView;
        };

        view.onDisplayChange = function () {
            _super.onDisplayChange.call(this);

            var formula = this.expression.formula;
            var shouldGraph = this.expression.shouldGraph;

            if (this.error) {
                //change nothing
            } else if (!formula.is_graphable) {
                this.colorThumb.graphics = [];
            } else if (formula.is_point_list) {
                this.colorThumb.graphics = [{
                    type: 'pointplot',
                    opacity: shouldGraph ? ColorThumbnail.ON : ColorThumbnail.FADED
                }];
            } else if (formula.is_shade_between) {
                var operators = formula.shade_between_operators;
                var op_i = Comparators.table[operators[0]].direction === -1 ? 1 : 0;

                this.colorThumb.graphics = [{
                    type: 'shadebetween',
                    opacity: shouldGraph ? ColorThumbnail.ON : ColorThumbnail.FADED,
                    dottedTop: Comparators.table[operators[op_i]].inclusive === false,
                    dottedBottom: Comparators.table[operators[1 - op_i]].inclusive === false
                }];
            } else {
                var operator = formula.operator;
                this.colorThumb.graphics = [{
                    type: 'straightline',
                    opacity: shouldGraph ? ColorThumbnail.ON : ColorThumbnail.FADED,
                    fill: Comparators.table[operator].direction !== 0,
                    dotted: Comparators.table[operator].inclusive === false
                }];
            }

            this.colorThumb.color = this.expression.color;
            this.colorThumb.redraw();
        };

    });

    return ExpressionIconView;
});

define('expressions/expression_view', ['require', 'desmos', 'pjs', 'lib/underscore_view', './expression', 'lib/keydown_which', 'undoredo', 'mathquill', 'expressions/abstractitem_view', 'expressions/expression_icon'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');

    var ExpressionObject = require('./expression');
    var Keydown = require('lib/keydown_which');
    var UndoRedo = require('undoredo');
    require('mathquill');

    var AbstractItemView = require('expressions/abstractitem_view');
    var ExpressionIconView = require('expressions/expression_icon');

    var ExpressionView = P(AbstractItemView, function (view, _super) {

        view.init = function (model) {
            _super.init.call(this, model);
            this.expression = model;

            this.model.observe('formula.exprview', this.onFormulaChange.bind(this));
            this.model.observe('selected.exprview', this.onSelectedChange.bind(this));
            this.model.observe('latex.exprview', this.onLatexChange.bind(this));
            this.model.observe('dependent.exprview', this.renderDependent.bind(this));

            this.observe('shouldExpand', this.observeShouldExpand.bind(this));
            this.observe('doAnimate', this.renderDoAnimate.bind(this));
            this.observe('expanded', this.renderExpanded.bind(this));
        };

        view.destruct = function () {
            _super.destruct.call(this);

            this.model.unobserve('.exprview');

            if (this.iconView) {
                this.iconView.remove();
                this.iconView = null;
            }

            if (this.sliderView) {
                this.sliderView.remove();
                this.sliderView = null;
            }

            if (this.promptSliderView) {
                this.promptSliderView.remove();
                this.promptSliderView = null;
            }

            if (this.domainView) {
                this.domainView.remove();
                this.domainView = null;
            }

            if (this.evaluationView) {
                this.evaluationView.remove();
                this.evaluationView = null;
            }
        };

        view.renderExpanded = function () {
            this.$().toggleClass('expanded', !!this.expanded);
        };

        view.renderDoAnimate = function () {
            this.$().toggleClass('do-animate', !!this.doAnimate);
        };

        view.onLatexChange = function () {
            this.hideContextMenu.bind(this);
            if (!this.mathquill) return;

            var latex = this.model.latex;

            if (latex !== undefined && this.mathquill.mathquill('latex') !== latex)
                this.mathquill.mathquill('latex', latex);
        };

        // OVERRIDE TO CREATE APPROPRIATE CHILD VIEW. IF NOT OVERRIDEN, THE
        // VIEW WILL SIMPLY NOT BE CREATED AT RUNTIME.
        view.createSliderView = function () { };
        view.createPromptSliderView = function () { };
        view.createDomainView = function () { };
        view.createEvaluationView = function () { };

        view.onFormulaChange = function () {

            // Skip this while we are rendering shell. Without this catch, we'd
            // create the child views while rendring the shells and throw them
            // away when we render fully.
            if (this.model.renderShell) return;

            var formula = this.model.formula;

            var showSlider = formula.is_slidable;
            if (this.sliderView && !showSlider) {
                this.sliderView.remove();
                this.sliderView = null;
            } else if (!this.sliderView && showSlider) {
                this.sliderView = this.createSliderView();
                if (this.sliderView) {
                    this.sliderView.appendTo(this.$('.template-bottom'));
                    this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
                }
            }

            var promptCreateSlider = formula.variables.length > 0;
            if (this.promptSliderView && !promptCreateSlider) {
                this.promptSliderView.remove();
                this.promptSliderView = null;
            } else if (!this.promptSliderView && promptCreateSlider) {
                this.promptSliderView = this.createPromptSliderView();
                if (this.promptSliderView) {
                    this.promptSliderView.appendTo(this.$('.template-bottom'));
                }
            }

            var showDomain = formula.is_parametric;
            if (this.domainView && !showDomain) {
                this.domainView.remove();
                this.domainView = null;
            } else if (!this.domainView && showDomain) {
                this.domainView = this.createDomainView();
                if (this.domainView) {
                    this.domainView.appendTo(this.$('.template-bottom'));
                }
            }

            var showEvaluation = formula.is_evaluable;
            if (this.evaluationView && !showEvaluation) {
                this.evaluationView.remove();
                this.evaluationView = null;
            } else if (!this.evaluationView && showEvaluation) {
                this.evaluationView = this.createEvaluationView();
                if (this.evaluationView) {
                    this.evaluationView.appendTo(this.$('.template-bottom'));
                    this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
                }
            }

            if (this.sliderView && !this.sliderView.dragging) {
                this.model.slider.setProperty('value', formula.simple_constant);
            }

            if (this.promptSliderView) {
                this.promptSliderView.setProperty('variables', formula.variables);
            }

            if (this.evaluationView) {
                this.evaluationView.setProperty('evaluations', formula.zero_values);
            }

            var shouldExpand = !!(this.evaluationView ||
                            this.promptSliderView ||
                            this.sliderView ||
                            this.domainView);

            this.setProperty('shouldExpand', shouldExpand);
        };

        view.renderDependent = function () {
            if (this.sliderView) {
                this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
            }
            if (this.evaluationView) {
                this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
            }
        };

        // NOTE: this will get called once with model.renderShell = true and once
        // with model.renderShell = false. The first time, the template will
        // shortcircuit and render the bare minimum. The second time the entire
        // dom will get destroyed and rebuilt. We don't want to add any nested
        // views when model.renderShell = false because the views' dom elements will
        // get wiped out as soon as we render with model.renderShell = false. And,
        // the whole point of renderShell=true is that we want as little as
        // possible to happen at startup as possible.
        view.didInsertElement = function () {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            this.mathquill = this.$('.template-mathquill').mathquill('editable');
            this.mathquill.on('render upPressed downPressed enterPressed backspacePressed delPressed keydown focusin focus', this.onMathquillEvent.bind(this));
            this.mathquill.mathquill('latex', this.model.latex || "");

            this.iconView = ExpressionIconView(this.model);
            this.iconView.replace(this.$('.template-expricon'));

            this.$('.action-duplicate').on('tap', this.onDuplicateWithoutFocus.bind(this));

            this.renderDoAnimate();
            this.renderExpanded();
            this.onFormulaChange();
        };


        view.onSelectedChange = function () {
            if (!this.model.selected && this.mathquill) {
                // take focus out of mathquill
                this.mathquill.mathquill('clearSelection').mathquill('blur');
            }
        };

        view.onMathquillEvent = function (evt) {
            var index, prev, next, obj;

            switch (evt.type) {
                case "render":
                    this.model.setProperty('latex', this.mathquill.mathquill('latex'));
                    return;

                case "focus":
                case "focusin":
                    this.model.setProperty('selected', true);
                    return;

                case "upPressed":
                    this.triggerUpPressed();
                    return;

                case "downPressed":
                    this.triggerDownPressed();
                    return;

                case "enterPressed":
                    this.triggerEnterPressed();
                    return;

                case "backspacePressed":
                    if (!this.model.isEmpty()) return;
                    this.triggerBackspacePressed();
                    return;

                case "delPressed":
                    if (!this.model.isEmpty()) return;
                    this.triggerDelPressed();
                    return;

                case "keydown":
                    if (Keydown.which(evt.which) === 'Esc') $(document.activeElement).blur();
                    return;
            }
        };

        view.createSliders = function (vars) {
            // build the list of states
            // this is important, because the first time, it will generate
            // an id for us automatically. If we undo then redo, we need to
            // reusue the generated ids.
            // set slider min/max so that they don't
            // get set automatically and messup undo/redo
            var var_states = [];
            for (var i = 0; i < vars.length; i++) {
                var_states.push({
                    latex: vars[i] + '=1',
                    sliderMin: -10, // TODO - combine this lines into:
                    sliderMax: 10,   // slider: {min: -10, max: 10}
                    userRequestedGraphing: "never" //don't show a circle when we create an r= slider
                });
            }

            var index = this.model.index;
            var next_index = index + 1;

            UndoRedo.addTransaction({
                type: UndoRedo.CAUSE_OF_CHANGE,

                undo: function () {
                    for (var i = 0; i < vars.length; i++) {
                        Desmos.expressions.model.removeItemAt(next_index);
                    }
                },

                redo: function () {
                    for (var i = var_states.length - 1; i >= 0; i--) {
                        var obj = ExpressionObject(var_states[i]);
                        var_states[i].id = obj.id; // store the generated id for next time
                        Desmos.expressions.model.insertItemAt(next_index, obj);
                    }
                }
            });
            this.tempDisableAnimate();
        };

        view.onDuplicate = function () {
            var obj = this.onDuplicateWithoutFocus();
            var view = Desmos.expressions.getItemView(obj.id);
            view.addFocus();
        };

        view.onDuplicateWithoutFocus = function () {
            var index = this.model.index;
            var state = this.model.getState();
            state.selected = true;
            delete state.id;

            var obj = ExpressionObject(state);
            Desmos.expressions.model.insertItemAt(index + 1, obj);
            return obj;
        };

        view.onMouseSelect = function (evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            this.model.setProperty('selected', true);
            var targetInMathquill = $(evt.target).closest('.mathquill-editable').length;

            // stop the mathquill from losing focus immediately. Only do this when
            // using mouse. When on ipad, this stops you from being able to put
            // cursor. And when on ipad, focus doesn't get lost anyways.
            if (evt.device === 'mouse') {
                evt.preventDefault();
            }

            /*
            * This will simualte a mousedown on the mathquill itself so that
            * you can start a mouse selection from outside of mathquill. But,
            * this doesn't make much sense for ipad because we don't do selection on
            * mousedown for ipad, we do it on click. That's because we want scroll
            * to work. We also don't want to pass the event into mathquill if it
            * originally started in mathquill.
            */
            if (evt.device === 'mouse' && !targetInMathquill) {

                // the event we're looking at is of type 'tapstart' and that means
                // nothing to mathquill. We need to turn this back into a 'mousedown'
                // so that it can handle it normally.
                var fakeEvent = $.event.fix(evt.originalEvent);

                // pass into mathquill so it can act like it happened within mathquill
                this.$('.mathquill-editable').triggerHandler(fakeEvent);
            }

            // on ipad, we need to manually add focus here
            else if (!targetInMathquill) {
                this.addFocus('end');
            }
        };

        view.getDependentLabel = function () {
            var dependent = this.model.dependent;
            if (!dependent) return '';

            // ask mathquill for an html version of itself
            // note: this will break for things like parentheses, which need to be
            // inserted into the dom to know their correct size we should probably
            // be passing around mathquill objects instead of strings, but this
            // works for uncomplicated mathquill
            dependent = $(
        "<span>" +
        dependent +
        "</span>"
      ).mathquill('editable').mathquill('html');

            // surround it in the right class so that it can pull in mathquill
            // stylings
            dependent = (
        "<span class='mathquill-rendered-math'>" +
        dependent +
        "</span>"
      );

            return dependent;
        };


        //the following three function determine the animation
        //and delay of the bottom area under expressions
        //that house sliders, evaluations, etc

        //temporarily disable animation on this expression
        //called after adding a slider from a button, for example
        view.tempDisableAnimate = function () {
            var self = this;
            self.setProperty('doAnimate', false);
            clearTimeout(self.restoreAnimationTimeout);
            self.restoreAnimationTimeout = setTimeout(function () {
                self.setProperty('doAnimate', true);
            }, 500);
        };

        view.observeShouldExpand = function () {
            var self = this;
            clearTimeout(self.animateTimeout);
            if (this.doAnimate) {
                self.animateTimeout = setTimeout(function () {
                    self.setProperty('expanded', self.shouldExpand);
                }, 500);
            } else {
                //immediately expand/collapse when animation is disabled (initial load)
                self.setProperty('expanded', self.shouldExpand);
            }
        };

        view.isFocused = function () {
            return $(document.activeElement).closest(this.mathquill).length !== 0;
        };

        view.addFocus = function (where) {
            if (!this.mathquill) return;

            this.mathquill.mathquill('focus');

            if (where === 'start') {
                this.mathquill.mathquill('moveStart');
            } else if (where === 'end') {
                this.mathquill.mathquill('moveEnd');
            }
        };
    });

    return ExpressionView;
});
// desmos/public/assets/grapher/compiled_underscore_templates/evaluation_view.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/evaluation_view', ["desmos"], function (Desmos) {
    Desmos.Templates["evaluation_view"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<table class="evaluation do-blur" handleEvent="true">\n  <tr>\n    <th class="action-selectevaluation">\n      <span class="template-dependentlabelhtml"></span>\n      <span class="equals">=</span>\n    </th>\n    <td class="text-selectable template-evaluationshtml"></td>\n  </tr>\n</table>';
        }
        return __p;
    };
});
define('expressions/evaluation', ['require', 'pjs', 'lib/underscore_view', 'templates/evaluation_view'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    require('templates/evaluation_view');

    var EvaluationView = P(UnderscoreView, function (view, _super) {
        view.templateName = "evaluation_view";

        view.init = function (domain) {
            _super.init.call(this);
            this.evaluations = [];

            this.observe('dependentLabel', this.renderDependent.bind(this));
            this.observe('evaluations', this.renderEvaluations.bind(this));
        };

        view.renderDependent = function () {
            this.$('.template-dependentlabelhtml').html(this.dependentLabel);
        };

        view.renderEvaluations = function () {
            var vals = this.evaluations;
            var vals_str = [];

            for (var i = 0; i < vals.length; i++) {
                var f_val = vals[i];
                if (f_val.val === false) {
                    f_val.val = 'false';
                } else if (isNaN(f_val.val)) {
                    f_val.val = 'undefined';
                } else if (f_val.val === true) {
                    f_val.val = 'true';
                } else if (Math.abs(f_val.val) < 1e-15) {
                    f_val.val = 0;
                } else if (vals.length === 1) {
                    f_val.val = Number(f_val.val.toPrecision(8));
                } else {
                    f_val.val = Number(f_val.val.toPrecision(6));
                }

                vals_str.push(f_val.val);
            }

            if (vals_str.length === 0) return "";
            var output = vals_str.join('<span class="or">or</span>');

            this.$('.template-evaluationshtml').html(output);
        };

        view.didInsertElement = function () {
            this.renderDependent();
            this.renderEvaluations();

            this.$('.action-selectevaluation').on('tap', this.onSelectEvaluation.bind(this));
        };


        view.onSelectEvaluation = function () {
            var numberElement = this.$('td')[0];
            var range = document.createRange();
            range.selectNodeContents(numberElement);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
        };

    });
    return EvaluationView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/domain_view.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/domain_view', ["desmos"], function (Desmos) {
    Desmos.Templates["domain_view"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class="domain do-blur" handleEvent="true">\n  \n  <div class="edit-domain variable-invalid">\n    <table>\n      <tr>\n        <td>\n          <input type="number" limit="min" />\n        </td>\n        <td>鈮�</td>\n        <td>t</td>\n        <td>鈮�</td>\n        <td>\n          <input type="number" limit="max" />\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n  <div class="display-domain">\n    <span class="variable-min"></span> 鈮� t 鈮� <span class="variable-max"></span>    \n  </div>\n\n</div>';
        }
        return __p;
    };
});
define('expressions/domain_view', ['require', 'lib/underscore_view', 'pjs', 'templates/domain_view'], function (require) {
    var UnderscoreView = require('lib/underscore_view');
    var P = require('pjs');
    require('templates/domain_view');

    var DomainView = P(UnderscoreView, function (view, _super) {
        view.templateName = "domain_view";

        view.init = function (domain) {
            _super.init.call(this);

            this.domain = domain;

            this.domain.observe('min.domainview max.domainview', function (property) {
                if (property === 'min') {
                    this.renderMin();
                } else if (property === 'max') {
                    this.renderMax();
                }

                var valid = this.domain.isValid();
                this.setProperty('invalid', !valid);
            } .bind(this));

            this.setProperty('editing', false);
            this.setProperty('invalid', !this.domain.isValid());
            this.observe('invalid', this.renderInvalid.bind(this));
            this.observe('editing', this.renderEditing.bind(this));
            this.storeLastValidDomain();
        };

        view.destruct = function () {
            this.domain.unobserve('.domainview');
        };

        view.storeLastValidDomain = function () {
            if (this.domain.isValid()) {
                this.lastValidDomain = this.domain.serialize();
            }
        };

        view.renderInvalid = function () {
            this.$('.variable-invalid').toggleClass('invalid', this.invalid);
        };

        view.renderEditing = function () {
            var editing = this.getProperty('editing');
            this.$().toggleClass('editing-domain', editing);
        };

        view.renderMin = function () {
            var min = this.domain.min;
            this.$('input[limit=min]').val(min);
            this.$('.variable-min').text(min);
        };

        view.renderMax = function () {
            var max = this.domain.max;
            this.$('input[limit=max]').val(max);
            this.$('.variable-max').text(max);
        };

        view.didInsertElement = function () {
            this.$().on('tap tapstart', '.display-domain', this.startEditing.bind(this));
            this.$('input').on('focusin', this.focusIn.bind(this))
                   .on('focusout', this.focusOut.bind(this))
                   .on('keydown keyup keypress', this.handleUserInput.bind(this));

            this.renderInvalid();
            this.renderEditing();
            this.renderMin();
            this.renderMax();
        };

        view.startEditing = function (evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            evt.preventDefault();

            this.setProperty('editing', true);
            var self = this;
            setTimeout(function () {
                self.$('input').first().focus().select();
            }, 0);
        };

        view.stopEditing = function () {
            if (!this.domain.isValid() && this.lastValidDomain) {
                this.domain.setProperty('min', this.lastValidDomain.min);
                this.domain.setProperty('max', this.lastValidDomain.max);
            }

            this.setProperty('editing', false);
        };

        // blur input when enter pressed
        view.handleUserInput = function (evt) {
            if (evt.which == 13) {
                $(document.activeElement).blur();
            } else {
                var limit = $(evt.target).attr('limit'); //'min' or 'max'
                var value = parseFloat($(evt.target).val());

                // tell the domain about the change
                this.domain.setProperty(limit, value);
                this.storeLastValidDomain();
            }
        };

        // FocusIn and FocusOut work together here to switch the domain edit inputs
        // back to a text label after the domain edit boxes lose focus. Need to use
        // a timeout because when the cursor moves from one input to another,
        // focusOut fires before focusIn.
        view.focusIn = function (evt) {
            clearTimeout(this.stopEditingTimeout);
        };

        view.focusOut = function (evt) {
            var self = this;

            this.stopEditingTimeout = setTimeout(function () {
                clearTimeout(self.stopEditingTimeout);
                self.stopEditing();
            }, 1);
        };
    });

    return DomainView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/slider_view.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/slider_view', ["desmos"], function (Desmos) {
    Desmos.Templates["slider_view"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<span class="slider-container">\n\n  <div class="do-blur slider" handleEvent="true">\n    <div class="minLabel template-minlabelhtml">\n    </div>\n    <div class="maxLabel">\n      <span class="template-maxlabelhtml"></span>\n      <span class=\'label-pencil tooltip\' tooltip="edit slider limits"></span>\n    </div>\n    <div class="track action-startdragging">\n      <div class="ticks template-tickmarkhtml"></div>\n      <div class="graphic"></div>\n    </div>\n    <div class="zeroMarker action-startdragging">\n      <div class="graphic"></div>\n    </div>\n    <div class="thumb action-startdragging">\n      <div class="graphic"></div>\n    </div>\n  </div>\n  \n  <div class="slider_menu do-blur" handleEvent="true">\n    <table>\n      <tr>\n        <td>\n          <input class="slider_min" limit="min" type="number">\n    ';
            /*
            Need to be careful with unescaped html insertion. This html is generated
            from user input by mathquill, so we're relying on mathquill to escape
            html as necessary.
            */
            ; __p += '\n        </td>\n        <td>\n          鈮n        </td>\n        <td class="template-dependentlabelhtml"></td>\n        <td>鈮�</td>\n        <td>\n          <input class="slider_max" limit="max" type="number">\n        </td>\n        <td class=\'step\'>step:</td>\n        <td> \n          <input class="slider_interval" limit="step" type="number">\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n</span>';
        }
        return __p;
    };
});
define('expressions/slider_view', ['require', 'pjs', 'lib/underscore_view', 'templates/slider_view'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    require('templates/slider_view');

    var label2html = function (num) {
        var onum = num;
        var str = String(num).split("-").join("");

        if (str.length > 4 || str.indexOf("e") != -1) {
            // size of input
            var digits = Math.floor(Math.log(Math.abs(num)) / Math.LN10);

            // move the decimial over to the unit's place
            num = num / Math.pow(10, digits);

            // round to 1 sig figs
            num = Math.round(num);

            if (Math.abs(num) >= 10) {
                digits++;
                if (num < 0) {
                    num = -1;
                } else {
                    num = 1;
                }
            }

            if (digits >= -3 && digits <= 3) {
                str = String(onum);
                if (str.indexOf("0.") === 0) {
                    str = str.substr(1);
                } else if (str.indexOf("-0.") === 0) {
                    str = "-" + str.substr(2);
                }

                return str.substr(0, 5);
            }

            return num + "x10<span class='sup'>" + digits + "</span> ";
        } else {
            return String(num);
        }
    };

    // static variable that holds left hand side of sliders. Moved this to static
    // to temporarily fix slider duplication. Eventually, we'll want to refactor
    // sliders to be able to change widths on the fly.
    var cachedDimensions;

    var SliderView = P(UnderscoreView, function (view, _super) {
        view.templateName = "slider_view";

        view.init = function (slider) {
            _super.init.call(this);
            this.slider = slider;

            // we hold a local copy of the slider's value. this allows us to
            // throttle how quickly we set the value back to the slider.
            this.value = this.slider.value;

            // if the slider's value changes, we immediately overwrite our local
            // copy of the variable with the new official value.
            this.slider.observe('value', function () {
                this.setProperty('value', this.slider.value);
            } .bind(this));

            // Watch changes to the properties while we edit the slider.
            this.slider.observe('min.sliderview max.sliderview', this.renderThumbPosition.bind(this));
            this.observe('value', this.renderThumbPosition.bind(this));

            this.slider.observe('min.sliderview max.sliderview', this.renderZeroMarker.bind(this));
            this.slider.observe('min.sliderview max.sliderview step.sliderview', this.renderTickMarks.bind(this));
            this.slider.observe('min.sliderview', this.renderMin.bind(this));
            this.slider.observe('max.sliderview', this.renderMax.bind(this));
            this.slider.observe('step.sliderview', this.renderStep.bind(this));

            this.observe('dependentLabel', this.renderDependent.bind(this));
            this.observe('editing', this.renderEditing.bind(this));
            this.observe('invalid', this.renderInvalid.bind(this));
            this.observe('dragging', this.renderDragging.bind(this));
        };

        view.destruct = function () {
            this.slider.unobserve('.sliderview');
        };

        view.renderDependent = function () {
            this.$('.template-dependentlabelhtml').html(this.dependentLabel);
        };

        view.renderDragging = function () {
            this.$('.thumb').toggleClass('down', this.dragging);
        };

        view.renderStep = function () {
            this.$('input[limit=step]').val(this.slider.step);
        };

        view.renderMin = function () {
            this.$('.template-minlabelhtml').html(label2html(this.slider.min));
            this.$('input[limit=min]').val(this.slider.min);
        };

        view.renderMax = function () {
            this.$('.template-maxlabelhtml').html(label2html(this.slider.max));
            this.$('input[limit=max]').val(this.slider.max);
        };

        view.renderEditing = function () {
            this.$('.slider').toggle(!this.editing);
            this.$('.slider_menu').toggle(this.editing);
        };

        view.renderInvalid = function () {
            this.$('.slider_menu').toggleClass('invalid', this.invalid);
        };

        view.renderThumbPosition = function () {
            var left;
            var min = this.slider.min;
            var max = this.slider.max;
            var val = this.value;

            if (val <= min) {
                left = this.dimensions.trackLeft;
            } else if (val >= max) {
                left = this.dimensions.trackRight;
            } else {
                var t = (val - min) / (max - min);
                left = this.dimensions.trackLeft * (1 - t) + this.dimensions.trackRight * t;
            }

            this.$('.thumb').css('left', left + "px");
        };

        view.renderZeroMarker = function () {
            var t = (0 - this.slider.min) / (this.slider.max - this.slider.min);
            var css = {};

            if (t >= 0 && t <= 1) {
                var left = this.dimensions.trackLeft * (1 - t) + this.dimensions.trackRight * t;
                css.display = "block";
                css.left = left + 'px';
            } else {
                css.display = "none";
            }

            this.$('.zeroMarker').css(css);
        };

        view.renderTickMarks = function () {
            var step = this.slider.step;
            var min = this.slider.min;
            var max = this.slider.max;

            var percent = 100 * step / (max - min);
            if (percent < 3) percent = 0; // don't draw too many ticks

            var html = "";
            if (percent > 0 && percent < 100) {
                for (var i = percent; i < 100; i += percent) {
                    html += '<div class="tick" style="left:' + i + '%"></div>';
                }
            }

            this.$('.template-tickmarkhtml').html(html);
        };

        view.didInsertElement = function () {

            // setup event handlers
            this.$().on('tapstart tap', '.minLabel', this.onEditMin.bind(this));
            this.$().on('tapstart tap', '.maxLabel', this.onEditMax.bind(this));
            this.$('.action-startdragging').on('tapstart', this.onStartDragging.bind(this));
            this.$().on('focusout', this.focusOut.bind(this));
            this.$().on('focusin', this.focusIn.bind(this));
            this.$().on('keydown', this.keyDown.bind(this));
            this.$('input[limit]').on('keypress keydown keyup', this.checkInvalid.bind(this));

            // should only have to be set once because once created, the slider
            // shouldn't be changing width or left position. If we ever change that,
            // then this'll have to be updated.
            if (cachedDimensions === undefined) {
                var sliderLeft = this.$('.slider').position().left;
                var track = this.$('.track');
                var trackLeft = track.position().left;
                var trackRight = trackLeft + track.width();

                cachedDimensions = {
                    trackLeft: trackLeft,
                    trackRight: trackRight,
                    sliderLeft: sliderLeft
                };
            }

            this.dimensions = cachedDimensions;

            this.renderTickMarks();
            this.renderThumbPosition();
            this.renderZeroMarker();
            this.renderDependent();
            this.renderMin();
            this.renderMax();
            this.renderStep();

            this.checkInvalid();
        };

        view.onStartDragging = function (evt) {

            // only start dragging if this is the first touch
            if (evt.touches.length !== 1) return;

            // prevents the currently selected expression from losing focus
            // when the slider handle is pressed. Allows you to drag the slider
            // of an unselected expression while keeping the currently selected
            // expression focused.
            evt.preventDefault();
            evt.handle();

            var self = this;

            // figures out where the slider is located on the screen. Only
            // need to do this on mouse down because the slider shouldn't
            // be changing position during the dragging.
            var left = this.dimensions.trackLeft + this.dimensions.sliderLeft;
            var right = this.dimensions.trackRight + this.dimensions.sliderLeft;
            var width = right - left;

            // store these values since they shouldn't be changing during the sliding
            var step = this.slider.step;
            var min = this.slider.min;
            var max = this.slider.max;
            var pixel_units = (max - min) / width;

            var getTouchByIdentifier = function (evt, identifier) {
                var touches = evt.touches;
                var touch = null;

                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].identifier === identifier) {
                        touch = touches[i];
                    }
                }

                return touch;
            };

            self.setProperty('dragging', true);

            // this bunch of code exposes a function that throttles how quickly
            // the self.commitSliderValue() function is called. This code could
            // be a lot simpler, but then it wouldn't be as complete. This code
            // ensures that the slider value isn't commited more often than 50ms
            // in general unless it's the very last commit. The very last commit
            // happens on mouseUp. It allows mouseMoves to be immediately responded
            // to if 50ms has elapsed since the last mouseMove and it ensures that
            // the last mouseMove in a rapid sequence isn't lost.
            var commitSliderTimeout;
            var commitSliderDirty = false;
            var commitSliderThrottleDelay = 50; //TODO - possibly make this adaptive
            var commitSliderThrottled = function (isFinalCommit) {

                // if it isn't too soon, then commit
                if (!commitSliderTimeout) {
                    self.commitSliderValue();
                    commitSliderDirty = false;

                    // mark that we are in the throttle period. Any calls to
                    // commitSliderThrottled won't commit the value until this
                    // timeout fires.
                    commitSliderTimeout = setTimeout(function () {
                        commitSliderTimeout = null;
                        if (commitSliderDirty) {
                            self.commitSliderValue();
                            commitSliderDirty = false;
                        }
                    }, commitSliderThrottleDelay);

                    // it's too soon to commit
                } else {

                    // last one, so do it anyways
                    if (isFinalCommit) {
                        clearTimeout(commitSliderTimeout);
                        commitSliderTimeout = null;
                        self.commitSliderValue();
                        commitSliderDirty = false;

                        // can't update yet, so just mark as dirty. when the timeout
                        // fires, it'll commit the value.
                    } else {
                        commitSliderDirty = true;
                    }
                }
            };

            var touchIdentifier = evt.changedTouches[0].identifier;
            var onMouseMove = function (evt) {

                // lookup the touch that started this
                var touch = getTouchByIdentifier(evt, touchIdentifier);
                if (!touch) return;

                // figures out the percent 0%-100% of the thumbs position
                var t = Math.min(1, Math.max(0, (touch.pageX - left) / width));

                var val = min * (1 - t) + max * t;
                if (val <= min) val = min;
                else if (val >= max) val = max;
                else {

                    // round to a pretty number
                    val = Rounding.bestRound(val, pixel_units);

                    // snap to the step interval
                    if (step > 0 || step < 0) {
                        val = Math.round((val - min) / step) * step + min;
                    }

                    // round to realistic number
                    val = Number(val.toPrecision(9));
                    if (val < min) val = min;
                    else if (val > max) val = max;
                }

                self.setProperty('value', val);

                // We commit the slider's value manually here instead of using an
                // observer on 'value' because we need precise control of when the
                // value is committed. When the user types in mathquill, that causes
                // a change in the sliders value. We don't want that change to get
                // routed back into commitSliderValue(). If it did, the user would never
                // be able to type decimals. When they typed "a=1.", the
                // commitSliderValue() function would turn that into "a=1" again.
                commitSliderThrottled();
            };

            var onMouseUp = function (evt) {

                // checks if the touch that started the slider is still around. If so,
                // don't do anything here. A different touch must have lifted.
                var touch = getTouchByIdentifier(evt, touchIdentifier);
                if (touch) return;

                $(document).off('tapmove', onMouseMove);
                $(document).off('tapend tapcancel', onMouseUp);

                self.setProperty('dragging', false);
                commitSliderThrottled(true);
            };

            $(document).on('tapmove', onMouseMove);
            $(document).on('tapend tapcancel', onMouseUp);

            // move the slider immediately on mouse down
            onMouseMove(evt);
        };

        view.commitSliderValue = function () {
            this.slider.setProperty('value', this.value);
        };

        view.onEditMin = function (evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            this.setProperty('editing', true);

            evt.preventDefault();

            this.$('.slider_min').focus().select();
        };

        view.onEditMax = function (evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            this.setProperty('editing', true);

            evt.preventDefault();

            this.$('.slider_max').focus().select();
        };

        view.checkInvalid = function () {
            var min = parseFloat(this.$('input[limit=min]').attr('value'));
            var max = parseFloat(this.$('input[limit=max]').attr('value'));
            var step = this.$('input[limit=step]').attr('value');
            step = step === '' ? 0 : parseFloat(step);

            var invalid = (!isFinite(min) || !isFinite(max) || min >= max || step < 0);
            this.setProperty('invalid', invalid);
        };

        // blur input when enter pressed
        view.keyDown = function (evt) {
            if (evt.which == 13) {
                $(document.activeElement).blur();
            } else {
                this.checkInvalid();
            }
        },

        // went straight into a focus, so don't save
    view.focusIn = function (evt) {
        clearTimeout(this.saveAfterBlurTimeout);
        this.checkInvalid();
    },

        // if we don't focus into one of the other boxes really soon,
        // we'll just act like the save button was pressed. This is
        // a sideeffect of focusin being fired AFTER focusout. Temporarily,
        // nothing is focused and we can't tell if focus is about to be
        // placed or not.
    view.focusOut = function (evt) {
        var self = this;
        this.save(evt.target);

        this.saveAfterBlurTimeout = setTimeout(function () {
            clearTimeout(self.saveAfterBlurTimeout);
            self.onClose();
        }, 1);

        this.checkInvalid();
    },

    view.save = function (node) {

        if (node) {
            var target = $(node);
            var value = parseFloat(target.attr('value'));

            if (target.hasClass('slider_min')) {

                // set the new min
                if (value < this.slider.max) {
                    this.slider.setProperty('min', value);

                    // reset the value since it's invalid
                } else {
                    target.attr('value', this.slider.min);
                }

            } else if (target.hasClass('slider_max')) {

                // set the new min
                if (value > this.slider.min) {
                    this.slider.setProperty('max', value);

                    // reset the value since it's invalid
                } else {
                    target.attr('value', this.slider.max);
                }

            } else if (target.hasClass('slider_interval')) {

                // set the new step interval
                if (value >= 0) {
                    this.slider.setProperty('step', value);

                    // invalid step intervals get set to blank
                } else {
                    target.attr('value', '');
                    this.slider.setProperty('step', ''); //TODO - dont set a string here. use undefined
                }

            }
        }
    };

        view.onClose = function () {
            this.setProperty('editing', false);
        };

    });

    return SliderView;
});
// desmos/public/assets/grapher/compiled_underscore_templates/prompt_sliders.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/prompt_sliders', ["desmos"], function (Desmos) {
    Desmos.Templates["prompt_sliders"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class="create_sliders action-createslider" handleEvent="true">\n  <span class="msg">add slider:</span>\n  <span class="btns">\n    ';
            _.each(variables, function (variable) {
                ; __p += '\n      <div class="slider_btn_container" var_name="' +
(variable.name) +
'" >\n        <div class="btn btn-primary btn-small">' +
(variable.label) +
'</div>\n      </div>\n    ';
            })
; __p += '\n              \n    ';
            if (variables.length > 1) {
                ; __p += '\n      <div class="slider_btn_container all">\n        <div class="btn btn-small btn-success all">all!</div>\n      </div>\n    ';
            }
            ; __p += '\n  </span>\n</div>';
        }
        return __p;
    };
});
define('expressions/promptslider_view', ['require', 'pjs', 'lib/underscore_view', 'templates/prompt_sliders'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    require('templates/prompt_sliders');

    var PromptSliderView = P(UnderscoreView, function (view, _super) {

        view.templateName = "prompt_sliders";

        view.init = function (expressionView) {
            _super.init.call(this);

            this.variables = [];
            this.expressionView = expressionView;
            this.observe('variables', this.rerender.bind(this));
        };

        view.didInsertElement = function () {
            this.$('.action-createslider').on('tap', this.onCreateSlider.bind(this));
        };

        view.getTemplateParams = function () {
            var vars = this.variables;
            var formattedVariables = [];
            for (var i = 0; i < 4 && i < vars.length; i++) {
                var v = vars[i];
                var vName, vHtml = v.split('{').join('').split('}').join('').split('_');

                if (vHtml.length > 1) {
                    vName = vHtml[0] + "_{" + vHtml[1] + "}";
                    vHtml = vHtml[0] + "<sub>" + vHtml[1] + "</sub>";
                } else {
                    vName = vHtml[0];
                    vHtml = vHtml[0];
                }

                formattedVariables.push({ name: vName, label: vHtml });
            }

            return { variables: formattedVariables };
        };

        view.onCreateSlider = function (evt) {
            var dom = $(evt.target).closest('.slider_btn_container');
            if (!dom.length) return;

            var vars;
            if (dom.hasClass('all')) {
                vars = this.variables.slice();
            } else {
                vars = [dom.attr('var_name')];
            }

            if (!vars.length) return;

            this.expressionView.createSliders(vars);
        };

    });

    return PromptSliderView;
});
// desmos/public/assets/grapher/compiled_underscore_templates/expression_desktop.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/expression_desktop', ["desmos"], function (Desmos) {
    Desmos.Templates["expression_desktop"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '';
            if (renderShell) {
                ; __p += '\n\n<div class="do-not-blur expressionitem shell">\n  <div class=\'shell\'></div>\n</div>\n\n';
            } else {
                ; __p += '\n\n<div class="do-not-blur expressionitem">\n  <div class=\'fade-container\'>\n\n    <div class="fadeout-left"></div>\n  \n    <span class="main">\n      <span class="template-expricon"></span>\n      <div class="scroll-container">\n        <span class="template-mathquill"></span>\n      </div>\n    </span>\n\n    <span class="fadeout">          \n    </span>\n  \n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n  \n    <div class="template-bottom"></div>\n  </div>\n\n  <span class="tab action-drag" handleEvent="true">\n    <span class=\'num variable-index\'></span>\n    <div class=\'tab-interior\'></div>\n  </span>\n\n  <span class=\'exp-actions\'>\n    <i class="icon-remove tooltip action-delete" tooltip="remove" handleEvent="true"></i>\n    <i class="icon-copy tooltip action-duplicate" tooltip="duplicate" handleEvent="true"></i>\n    <img src="/assets/grapher/img/expr-icons/small-table.png" class="tooltip table-icon action-createtable template-createtable" tooltip="convert to table" handleEvent="true"></i>\n  </span>\n  \n</div>\n\n';
            }
            ; __p += '\n';
        }
        return __p;
    };
});
define('expressions/expression_view_desktop', ['require', 'desmos', 'pjs', './text', './table', 'lib/track_feature', 'undoredo', './expression_view', 'expressions/evaluation', 'expressions/domain_view', 'expressions/slider_view', 'expressions/promptslider_view', 'templates/expression_desktop'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var TextObject = require('./text');
    var TableObject = require('./table');
    var Feature = require('lib/track_feature');
    var UndoRedo = require('undoredo');
    var ExpressionView = require('./expression_view');

    var EvaluationView = require('expressions/evaluation');
    var DomainView = require('expressions/domain_view');
    var SliderView = require('expressions/slider_view');
    var PromptSliderView = require('expressions/promptslider_view');

    require('templates/expression_desktop');

    var ExpressionViewDesktop = P(ExpressionView, function (view, _super) {

        view.templateName = 'expression_desktop';

        view.createSliderView = function () {
            return SliderView(this.model.slider);
        };
        view.createDomainView = function () {
            return DomainView(this.model.domain);
        };
        view.createPromptSliderView = function () {
            return PromptSliderView(this);
        };
        view.createEvaluationView = function () {
            return EvaluationView(this);
        };

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            this.$('.action-createtable').on('tap', this.onCreateTable.bind(this));
        };

        // OVERRIDE - but eventually, we should listen for ' or " press within the
        // expression list view and handle the conversion there.
        view.onLatexChange = function () {
            this.hideContextMenu();
            if (!this.mathquill) return;

            var latex = this.model.latex;
            if (latex === '"' || latex === "'") {
                var text = this.convertTo(TextObject, { selected: true });
                Desmos.expressions.getSelectedView().addFocus();
                return;
            }

            if (latex !== undefined && this.mathquill.mathquill('latex') !== latex)
                this.mathquill.mathquill('latex', latex);
        };

        view.onCreateTable = function () {
            var i;
            var latex = this.model.latex;
            var formula = this.model.formula;

            Feature.use("convert to table");

            if (!this.model.isTableable) return;

            var table_info = formula.table_info;
            var index = this.model.index;
            var state = { selected: true };

            var shouldShowLine = true;
            if (formula.is_point_list || this.model.userRequestedGraphing === "never")
                shouldShowLine = false;

            state.columns = [{
                latex: table_info.independent_variable,
                values: [-2, -1, 0, 1, 2]
            }, {
                latex: table_info.dependent_column,
                color: this.model.color,
                showLine: shouldShowLine,
                values: ['', '', '', '', '']
            }];

            /* TODO - copy the values from table_info. But, we want the values to
            * be in column form, not row form now.

            //Initialize from table_info.values if provided
            if(table_info.values){
            for(i = 0; i < table_info.values.length; i++){
            state.rows.push(table_info.values[i]);
            }
            }
            else{
            for (i=-2; i<=2; i++) {
            state.rows.push([i,'']);
            }
            }*/

            UndoRedo.oneTransaction(function () {
                if (!table_info.by_reference) {
                    Desmos.expressions.model.removeItemAt(index);
                    index--;
                }

                var obj = TableObject(state);
                Desmos.expressions.model.insertItemAt(index + 1, obj);
            });
        };
    });

    return ExpressionViewDesktop;
});

// desmos/public/assets/grapher/compiled_underscore_templates/text.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/text', ["desmos"], function (Desmos) {
    Desmos.Templates["text"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '';
            if (renderShell) {
                ; __p += '\n\n<div class="do-not-blur expressionitem expressiontext shell">\n  <div class=\'shell\'></div>\n</div>\n\n';
            } else {
                ; __p += '\n\n<div class="do-not-blur expressiontext expressionitem">\n  <div class=\'fade-container\'>\n\n    <span class="main">\n      <textarea class="do-blur" placeholder="enter some text..."></textarea>\n    </span>\n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="tab action-drag" handleEvent="true">\n    <span class=\'num variable-index\'></span>\n    <div class=\'tab-interior\'></div>\n  </span>\n\n  <span class=\'exp-actions\'>\n    <i class="icon-remove tooltip action-delete" tooltip="remove" handleEvent="true"></i>\n  </span>\n\n</div>\n\n';
            }
            ; __p += '';
        }
        return __p;
    };
});
define('expressions/text_view', ['require', 'desmos', 'pjs', './expression', './abstractitem_view', 'lib/keydown_which', 'templates/text'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var ExpressionObject = require('./expression');
    var AbstractItemView = require('./abstractitem_view');
    var Keydown = require('lib/keydown_which');
    require('templates/text');

    var TextView = P(AbstractItemView, function (view, _super) {

        view.templateName = 'text';

        view.init = function (model) {
            _super.init.call(this, model);

            this.model.observe('selected.textview', this.onSelectedChange.bind(this));
            this.model.observe('text.textview', this.renderText.bind(this));
        };

        view.destruct = function () {
            this.model.unobserve('.textview');
        };

        view.renderText = function () {
            var textarea = this.$('textarea')[0];
            if (!textarea) return;

            textarea.value = this.model.text;
            this.fitText();
            setTimeout(this.fitText.bind(this), 1); //TODO - do we still need this?
        };

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);

            if (this.renderShell) return;

            var $textarea = this.$('textarea');

            $textarea.focusin(function () {
                this.model.setProperty('selected', true);
            } .bind(this));

            $textarea.bind('keydown keypress keyup change cut paste', this.onTextareaEvent.bind(this));

            this.renderText();
        };

        view.onTextareaEvent = function (evt) {
            var ta = this.$('textarea')[0];
            var ta_is_active = ta && ta === document.activeElement;
            var ta_len = ta_is_active ? ta.value.length : 0;
            var key = ta_is_active && evt.type === 'keydown' ? Keydown.which(evt.which) : '';

            // pressing enter inside textarea creates a new expression underneath
            if (key === 'Enter') {

                evt.preventDefault();
                this.triggerEnterPressed();
                return;

                // pressing escape removes focus
            } else if (key === 'Esc') {
                $(document.activeElement).blur();
                return;

                // pressing up while at start of textarea selects expression above
            } else if (key === 'Up') {

                if (ta.selectionStart === 0 && ta.selectionEnd === 0) {
                    evt.preventDefault();
                    this.triggerUpPressed();
                }
                return;

                // pressing down while at end of textarea selects expression below
            } else if (key === 'Down') {

                if (ta.selectionStart === ta_len && ta.selectionEnd === ta_len) {
                    evt.preventDefault();
                    this.triggerDownPressed();
                }
                return;

                // pressing backspace when completely empty should delete textarea
            } else if (key === 'Backspace') {

                if (ta_len === 0) {
                    evt.preventDefault();
                    this.triggerBackspacePressed();
                }
                return;

                // pressing delete when completely empty should delete textarea
            } else if (key === 'Del') {

                if (ta_len === 0) {
                    evt.preventDefault();
                    this.triggerDelPressed();
                }
                return;

            }

            // if we made it down here, then we should update the stored text value
            this.model.setProperty('text', ta.value);
        };

        view.onSelectedChange = function () {
            if (!this.model.selected) {
                var textarea = this.$('textarea')[0];
                if (textarea) textarea.blur();
            }
        };

        view.onMouseSelect = function (evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            this.model.setProperty('selected', true);
        };

        view.fitText = function () {
            var $textarea = this.$('textarea');
            var textarea = $textarea[0];
            if (!textarea) return;

            var rows = 0;
            do {
                rows++;
                $textarea.attr('rows', rows);
            } while (textarea.clientHeight < textarea.scrollHeight);
        };

        view.isFocused = function () {
            return $(document.activeElement).closest(this.$()).length !== 0;
        };

        view.addFocus = function (where) {
            var textarea = this.$('textarea')[0];
            if (!textarea) return;

            textarea.focus();
            if (where === 'end') {
                textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
            } else if (where === 'start') {
                textarea.selectionStart = textarea.selectionEnd = 0;
            }
        };

    });

    return TextView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/table_icon.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_icon', ["desmos"], function (Desmos) {
    Desmos.Templates["table_icon"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<span class="graph-icon do-not-blur" handleevent="true">\n      \n  <div class="outline">\n    <div class="thumb action-toggleoptions variable-errortooltip">\n      <span class="graphic">\n        <canvas></canvas>\n      </span>\n    </div>\n  </div>\n  \n  <div class="template-optionsmenu"></div>\n  \n</span>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_options_menu.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_options_menu', ["desmos"], function (Desmos) {
    Desmos.Templates["table_options_menu"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class=\'options-menu\'>\n  <table>\n    <tr>\n      <td colspan="2">\n        <div class="template-colorsview"></div>\n      </td>\n    </tr>\n    <tr>\n      <td class="option-link do-not-blur" width=\'50%\'>\n        <label>\n          <input type="checkbox" class="checkbox-showline" />\n          <span class="variable-showlinemessage"></span>\n        </label>\n      </td>\n      <td class="option-link do-not-blur action-insertcolumnleft" width=\'50%\'>\n        <div>\n          <i class=\'icon-chevron-left\'></i><i class=\'icon-plus\'></i>\n          insert left\n        </div>\n      </td>\n    </tr>  \n    <tr>\n      <td class="option-link do-not-blur variable-showpoints">\n        <label>\n          <input type="checkbox" class="checkbox-showpoints" />\n          show points\n        </label>\n      </td>\n      <td class="option-link do-not-blur action-insertcolumnright">\n        <div>\n          <i class=\'icon-plus\'></i><i class=\'icon-chevron-right\'></i>\n          insert right\n        </div>\n      </td>\n    </tr>\n    <tr class="template-removecolumn">\n      <td colspan="2" class="option-link do-not-blur action-removecolumn">\n        <div>\n          <i class=\'icon-trash\' style="font-size:130%"></i>\n          remove column\n        </div>\n      </td>\n    </tr>\n  </table>\n</div>';
        }
        return __p;
    };
});
define('expressions/table_options_view', ['require', './abstract_icon', 'desmos', 'pjs', 'lib/underscore_view', 'expressions/colorthumbnail', 'templates/table_icon', 'templates/table_options_menu', './expression_colors'], function (require) {
    var AbstractIconView = require('./abstract_icon');
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var ColorThumbnail = require('expressions/colorthumbnail');
    require('templates/table_icon');
    require('templates/table_options_menu');
    var ExpressionColorsView = require('./expression_colors');


    var TableOptionsMenuView = P(UnderscoreView, function (view, _super) {
        view.templateName = "table_options_menu";

        view.init = function (parentView, expression) {
            _super.init.call(this);
            this.expression = expression;
            this.parentView = parentView;

            this.expression.observe('isGraphable.optionsmenu', this.renderShowPoints.bind(this));
            this.expression.observe('showPoitns.optionsmenu', this.renderShowPoints.bind(this));
            this.expression.observe('isGraphable.optionsmenu', this.renderShowLine.bind(this));
            this.expression.observe('discrete.optionsmenu', this.renderShowLineMessage.bind(this));
        };

        view.destruct = function () {
            this.expression.unobserve('.optionsmenu');
            this.expression.table.unobserve('.optionsmenu');
        };

        view.renderRemoveColumn = function () {
            var disabled = this.expression.table.columns.length < 3;
            this.$('.template-removecolumn').toggle(!disabled);
        };

        view.renderShowPoints = function () {
            var disabled = !this.expression.isGraphable;
            var checkbox = this.$('.checkbox-showpoints');
            var checked = this.expression.showPoints;

            this.$('.variable-showpoints').toggleClass('disabled', disabled);

            if (disabled) {
                checkbox.attr('disabled', 'true');
            } else {
                checkbox.removeAttr('disabled');
            }

            if (checked) {
                checkbox.attr('checked', 'checked');
            } else {
                checkbox.removeAttr('checked');
            }
        };

        view.renderShowLine = function () {
            var disabled = !this.expression.isGraphable;
            var checkbox = this.$('.checkbox-showline');
            var checked = this.expression.showLine;

            this.$('.variable-showpoints').toggleClass('disabled', disabled);

            if (disabled) {
                checkbox.attr('disabled', 'true');
            } else {
                checkbox.removeAttr('disabled');
            }

            if (checked) {
                checkbox.attr('checked', 'checked');
            } else {
                checkbox.removeAttr('checked');
            }
        };

        view.renderShowLineMessage = function () {
            var message = this.expression.discrete ? 'connect' : 'show curve';
            this.$('.variable-showlinemessage').text(message);
        };

        view.didInsertElement = function () {
            // this view has a nested template. We instantiate the color picker
            // and replace a placeholder element within the html.
            var colorsView = ExpressionColorsView(this.expression);
            colorsView.replace(this.$('.template-colorsview'));

            this.renderRemoveColumn();
            this.renderShowPoints();
            this.renderShowLine();
            this.renderShowLineMessage();

            var self = this;
            this.$('.checkbox-showpoints').on('change', function () {
                var checked = !!$(this).attr('checked');
                self.expression.setProperty('showPoints', checked);
            });

            this.$('.checkbox-showline').on('change', function () {
                var checked = !!$(this).attr('checked');
                self.expression.setProperty('showLine', checked);
            });

            this.$('.action-insertcolumnleft').on('tap', this.insertColumnLeft.bind(this));
            this.$('.action-insertcolumnright').on('tap', this.insertColumnRight.bind(this));
            this.$('.action-removecolumn').on('tap', this.removeColumn.bind(this));
        };

        view.removeColumn = function (evt) {
            if ($(evt.target).closest('.disabled').length) return;
            this.parentView.hideOptions();

            var table = this.expression.table;
            var index = this.expression.index;
            var cell = table.selectedCell;
            table.removeColumn(index);

            // selection was after the deleted column, so decrease selected column.
            if (cell && cell.column > index) {
                table.setProperty('selectedCell', { row: cell.row, column: cell.column - 1 });
            }

            // deleted column was selected, so we need to try to select another one.
            else if (cell && cell.column === index) {

                // we just deleted the last column, so we have to select the one
                // to the left of where we just deleted
                if (table.columns.length <= index) {
                    Desmos.expressions.getItemView(table.id).selectCell(cell.row, cell.column - 1);
                }

                // we can put focus back in the column that just slid into the
                // deleteded one's place.
                else {
                    Desmos.expressions.getItemView(table.id).selectCell(cell.row, cell.column);
                }
            }

            // don't need to do anything because the deleted column was after the
            // selected column. Or, there was no selected column.
            else {
            }
        };

        view.insertColumnLeft = function (evt) {
            if ($(evt.target).closest('.disabled').length) return;
            this.parentView.hideOptions();

            var index = this.expression.index;
            var table = this.expression.table;
            table.insertColumn(index, { latex: '' });
            Desmos.expressions.getItemView(table.id).selectCell(0, index);
        };

        view.insertColumnRight = function (evt) {
            if ($(evt.target).closest('.disabled').length) return;
            this.parentView.hideOptions();

            var index = this.expression.index + 1;
            var table = this.expression.table;
            table.insertColumn(index, { latex: '' });
            Desmos.expressions.getItemView(table.id).selectCell(0, index);
        };
    });

    return TableOptionsMenuView;
});

define('expressions/table_icon', ['require', './abstract_icon', 'pjs', 'lib/underscore_view', 'expressions/colorthumbnail', 'templates/table_icon', 'templates/table_options_menu', './table_options_view'], function (require) {
    var AbstractIconView = require('./abstract_icon');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var ColorThumbnail = require('expressions/colorthumbnail');
    require('templates/table_icon');
    require('templates/table_options_menu');
    var TableOptionsMenuView = require('./table_options_view');

    var TableIconView = P(AbstractIconView, function (view, _super) {
        view.templateName = 'table_icon';

        view.init = function (model) {
            _super.init.call(this, model);
            this.expression = model;

            this.expression.observe('color.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('error.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('discrete.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('showPoints.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('showLine.iconview', this.onDisplayChange.bind(this));
        };

        view.destruct = function () {
            _super.destruct.call(this);

            this.expression.unobserve('.iconview');
        };

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);

            this.$('.action-toggleoptions').on('tapstart', this.toggleOptions.bind(this));

            this.onDisplayChange();
        };

        view.createOptionsMenuView = function () {
            var optionsView = TableOptionsMenuView(this, this.expression);
            optionsView.appendTo('body');

            return optionsView;
        };

        view.onDisplayChange = function () {
            _super.onDisplayChange.call(this);

            var showPoints = this.expression.showPoints;
            var showLine = this.expression.showLine;
            var isDiscrete = this.expression.discrete;

            if (this.error) {
                //change nothing
            } else {
                this.colorThumb.graphics = [];
                this.colorThumb.graphics.push({
                    type: isDiscrete ? 'bentline' : 'straightline',
                    opacity: showLine ? ColorThumbnail.ON : ColorThumbnail.FADED
                });
                this.colorThumb.graphics.push({
                    type: isDiscrete ? 'scatterplot' : 'largedot',
                    opacity: showPoints ? ColorThumbnail.ON : ColorThumbnail.FADED
                });
            }

            this.colorThumb.color = this.expression.color;
            this.colorThumb.redraw();

        };
    });

    return TableIconView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/table.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table', ["desmos"], function (Desmos) {
    Desmos.Templates["table"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '';
            if (renderShell) {
                ; __p += '\n\n<div class="expressionitem expressiontable shell">\n  <div class=\'shell\'></div>\n</div>\n\n';
            } else {
                ; __p += '\n\n<div class="expressionitem expressiontable">\n    \n  <div class=\'fade-container\'>\n    \n    <span class="main">\n      \n      ';

                // store these varaibles for use in the template logic
                var rightColumn = columns.length - 1;
                var bottomRow = columns[0].cells.length - 1;

                ; __p += '\n\n      <table class="tabledata">\n           \n        <tr class="header">\n          ';
                _.each(columns, function (junk, c) {

                    if (c === rightColumn) {
                        print(Desmos.Templates['table_cell_headerright']())
                    } else {
                        print(Desmos.Templates['table_cell_header']())
                    }

                })

; __p += '\n        </tr>\n        \n        ';
                _.each(columns[0].cells, function (junk, r) {
                    ; __p += '\n        <tr>\n          ';

                    _.each(columns, function (junk, c) {

                        if (c === rightColumn) {

                            if (r === bottomRow) {
                                print(Desmos.Templates['table_cell_bottomright']())
                            } else {
                                print(Desmos.Templates['table_cell_bodyright']())
                            }

                        } else {

                            if (r === bottomRow) {
                                print(Desmos.Templates['table_cell_bottom']())
                            } else {
                                print(Desmos.Templates['table_cell_body']())
                            }

                        }
                    })

; __p += '\n        </tr>\n        ';
                })
; __p += '\n          \n      </table>\n    </span>\n    \n    ';
                //covers up the right hand side of an overflowing table 
                ; __p += '\n    <span class="fadeout"></span>\n    <i class="icon-remove top-level-delete action-delete" handleEvent="true"></i>\n  </div>\n  \n  <span class="tab action-drag" handleEvent="true">\n    <span class=\'num variable-index\'></span>\n    <div class=\'tab-interior\'></div>\n  </span>\n\n  <span class=\'exp-actions\'>\n    <i class="icon-remove tooltip action-delete" tooltip="remove" handleEvent="true"></i>\n  </span>  \n</div>\n\n';
            }
            ; __p += '\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_cell_body.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_cell_body', ["desmos"], function (Desmos) {
    Desmos.Templates["table_cell_body"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<td class="non-editable empty">\n  <div class=\'interior-container\'>\n  \n    <span class="error-indicator do-not-blur tipsy-sticky"\n          handleevent="true"\n          style="display:none"\n    >\n    </span>\n                  \n    <span class=\'mathquill-rendered-math\'></span>\n  </div>\n</td>\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_cell_bodyright.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_cell_bodyright', ["desmos"], function (Desmos) {
    Desmos.Templates["table_cell_bodyright"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<td class="empty non-editable">\n  <span class=\'mathquill-rendered-math\'></span>\n  <div class="faded-h"></div>\n</td>\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_cell_header.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_cell_header', ["desmos"], function (Desmos) {
    Desmos.Templates["table_cell_header"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<td class="editable">\n  <div class=\'interior-container\'>\n    <span class="template-icon"></span>\n    <span class="mathquill-rendered-math"></span>\n  </div>\n</td>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_cell_headerright.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_cell_headerright', ["desmos"], function (Desmos) {
    Desmos.Templates["table_cell_headerright"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<td class="editable">\n  <span class="mathquill-rendered-math"></span>\n  <div class="faded-h"></div>\n</td>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_cell_bottom.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_cell_bottom', ["desmos"], function (Desmos) {
    Desmos.Templates["table_cell_bottom"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<td class="empty non-editable">\n  <span class=\'mathquill-rendered-math\'></span> \n  <div class="faded-v"></div>\n</td>\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/table_cell_bottomright.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/table_cell_bottomright', ["desmos"], function (Desmos) {
    Desmos.Templates["table_cell_bottomright"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<td class="empty non-editable">\n  <span class=\'mathquill-rendered-math\'></span>\n  <div class="faded-v"></div>\n  <div class="faded-h"></div>\n</td>';
        }
        return __p;
    };
});
define('expressions/table_view', ['require', 'desmos', 'pjs', 'lib/underscore_view', 'undoredo', 'mathquill', 'lib/keydown_which', './abstractitem_view', './table_icon', 'templates/table', 'templates/table_cell_body', 'templates/table_cell_bodyright', 'templates/table_cell_header', 'templates/table_cell_headerright', 'templates/table_cell_bottom', 'templates/table_cell_bottomright'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var UndoRedo = require('undoredo');
    require('mathquill');
    var Keydown = require('lib/keydown_which');

    var AbstractItemView = require('./abstractitem_view');
    var TableIconView = require('./table_icon');
    require('templates/table');
    require('templates/table_cell_body');
    require('templates/table_cell_bodyright');
    require('templates/table_cell_header');
    require('templates/table_cell_headerright');
    require('templates/table_cell_bottom');
    require('templates/table_cell_bottomright');

    var TableView = P(AbstractItemView, function (view, _super) {

        view.templateName = 'table';

        /* TODO - missing na observer to make this happen
        * Should work for both headings and cells
   
        onLatexChange: function () {
        this.hideContextMenu();
        }.observes('expression.headings.@each.latex'), */

        view.init = function (model) {
            _super.init.call(this, model);

            this.model.triggerRowRemoved = this.onRowRemoved.bind(this);
            this.model.triggerRowAdded = this.onRowAdded.bind(this);
            this.model.triggerColumnAdded = this.onColumnAdded.bind(this);
            this.model.triggerColumnRemoved = this.onColumnRemoved.bind(this);

            this.model.observe('selectedCell.tableview', this.onSelectedCellChange.bind(this));
        };

        view.destruct = function () {
            this.model.unobserve('.tableview');

            //TODO - should delete this.model.triggerRowRemoved
            //TODO - should delete this.model.triggerRowAdded
            //TODO - should delete this.model.triggerColumnRemoved
            //TODO - should delete this.model.triggerColumnAdded
        };

        view.getTemplateParams = function () {
            return {
                columns: this.model.columns,
                renderShell: this.model.renderShell
            };
        };

        view.onRowRemoved = function (index) {
            if (!this.columnViews) return;

            // index starts at 0 for row under headers. columnViews starts at 0
            // including header. Make the adjustment here.
            var r = index + 1;

            for (var c = 0; c < this.columnViews.length; c++) {
                var cellView = this.columnViews[c].splice(r, 1)[0];
                cellView.remove();
            }

            // remove the tr that housed the cells
            this.$('tr:nth-of-type(' + (r + 1) + ')').remove();

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onRowAdded = function (index) {
            if (!this.columnViews) return;

            // index starts at 0 for row under headers. columnViews starts at 0
            // including header. Make the adjustment here.
            var r = index + 1;
            var cell;
            var cellView;
            var columns = this.model.columns;
            var columnCount = this.columnViews.length;

            // add a tr to put our cells into
            var tds = '';
            for (var i = 0; i < columnCount; i++) tds += "<td></td>";
            var $tr = $('<tr>' + tds + '</tr>');

            this.$('tr:nth-of-type(' + r + ')').after($tr);


            for (var c = 0; c < columnCount; c++) {
                cell = columns[c].cells[index];

                if (c + 1 < columnCount) {
                    cellView = CellView(cell, this);
                } else {
                    cellView = RightCellView(cell, this);
                }

                // replace placeholder td with full view.
                cellView.replace($tr.find('td:nth-of-type(' + (c + 1) + ')'));

                this.columnViews[c].splice(r, 0, cellView);
            }

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onColumnRemoved = function (index) {
            if (!this.columnViews) return;

            var column = this.columnViews.splice(index, 1)[0];
            for (var i = 0; i < column.length; i++) {
                column[i].remove();
            }

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onColumnAdded = function (index) {
            if (!this.columnViews) return;

            var prev_views = this.columnViews[index - 1];
            var column = this.model.columns[index];
            var cells = column.cells;
            var i, views = [];

            // create header
            views.push(HeaderView(column, this));

            // create each cell for each row
            for (i = 0; i < cells.length - 1; i++) {
                views.push(CellView(cells[i], this));
            }

            // add bottom cell
            views.push(BottomCellView(cells[i], this));

            this.columnViews.splice(index, 0, views);

            // add each view into the dom by placing it after the cell to the left
            // of it.
            views.forEach(function (view, i) {
                view.insertAfter(prev_views[i].$());
            });

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            var self = this;
            this.$().on('focusin', function () {
                setTimeout(self.onFocusChange.bind(self), 0);
            });
            this.$().on('keydown', this.onMathQuillKeydownEvent.bind(this));
            this.$().on('upPressed downPressed leftPressed rightPressed enterPressed backspacePressed delPressed', this.onMathQuillSpecialEvent.bind(this));

            this.columnViews = [];

            // all the cells are placed in the dom, but they aren't setup yet.
            // optimization: could walk through the table more efficiently to access
            // the cell's dom element rather than doing a this.findCell(r,c) every
            // time. Could walk left to right, top to bottom.
            var columns = this.model.columns;
            var columnCount = columns.length;
            var rowCount = columns[0].cells.length;
            var r, c, cell, cellView;

            // setup header cells
            for (c = 0; c < columnCount; c++) {
                cell = columns[c];

                if (c + 1 < columnCount) {
                    cellView = HeaderView(cell, this);
                } else {
                    cellView = RightHeaderView(cell, this);
                }

                cellView.setDomNode(this.findCell(0, c));
                this.columnViews[c] = [cellView];
            }

            // setup body cells
            var rightColumn = columnCount - 1;
            var bottomRow = rowCount;

            for (r = 1; r <= rowCount; r++) {
                for (c = 0; c < columnCount; c++) {
                    cell = columns[c].cells[r - 1];

                    if (r === bottomRow) {
                        cellView = BottomCellView(cell, this);
                    } else if (c === rightColumn) {
                        cellView = RightCellView(cell, this);
                    } else {
                        cellView = CellView(cell, this);
                    }

                    cellView.setDomNode(this.findCell(r, c));

                    this.columnViews[c].push(cellView);
                }
            }

            this.onSelectedCellChange();
        };

        view.onSelectedCellChange = function () {
            if (!this.columnViews) return;

            // could optimize by remembering what cell last had selected class
            this.$('table .selected').removeClass('selected');

            var cell = this.model.selectedCell;

            // TODO - set selectedCell = null at time the cell is deleted rather than
            // catch it here. This is a bit hacky.
            // make sure cell isn't out of range
            if (cell) {
                if (cell.column >= this.columnViews.length || cell.row >= this.columnViews[0].length) {
                    this.model.selectedCell = null; //silently overwrite the property. won't fire observers
                    return;
                }
            }

            if (cell) {
                var cellView = this.columnViews[cell.column][cell.row];
                cellView.$().addClass('selected');

                this.model.setProperty('selected', true);
            }

            // if the cell with focus isn't selected, then remove focus
            var caret = this.getCaretPosition();
            if (caret && !_.isEqual(caret, cell)) {
                if (document.activeElement) {
                    document.activeElement.blur();
                }
            }

            // need to do this manually if the cell that's focused is not editable.
            // these handlers are what hide/show keypad.
            if (cell) {
                var input = this.findCellInput(cell.row, cell.column)[0];
                Desmos.expressions.onFocusIn({ target: input });
            } else {
                Desmos.expressions.onFocusOut();
            }

            var no_faded_h = cell && cell.column + 1 === this.model.columns.length;
            var no_faded_v = cell && cell.row === this.model.columns[0].cells.length;
            this.$().toggleClass('no-faded-h', no_faded_h);
            this.$().toggleClass('no-faded-v', no_faded_v);

            this.hideContextMenu();
        };


        view.onMouseSelect = function (evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            var target = $(evt.target);
            var table = target.closest('table')[0];

            // if we're clicking on the table itself, we don't know which cell
            // we meant to click. We'll just act like we clicked the outer padding.
            // that's not terrible, because for us to reach this point, we must
            // have clicked in seemingly blank space anyways.
            if (table && evt.target === table) {
                table = null;
            }

            if (!table) {
                if (document.activeElement) {
                    document.activeElement.blur();
                }

                this.model.setProperty('selectedCell', null);
                this.model.setProperty('selected', true);
                return;
            }

            var editable = target.closest('.mathquill-editable')[0];
            if (editable) return; //clicked within editable mathquill

            evt.preventDefault();
            editable = target.find('.mathquill-editable');

            if (editable.length) {
                editable.mathquill('focus');

                /*
                * This will simualte a mousedown on the mathquill itself so that
                * you can start a mouse selection from outside of mathquill. But,
                * this doesn't make much sense for ipad because we don't do selection on
                * mousedown for ipad, we do it on click. That's because we want scroll
                * to work. We also don't want to pass the event into mathquill if it
                * originally started in mathquill.
                */
                if (evt.device === "mouse") {

                    // the event we're looking at is of type 'tapstart' and that means
                    // nothing to mathquill. We need to turn this back into a 'mousedown'
                    // so that it can handle it normally.
                    var fakeEvent = $.event.fix(evt.originalEvent);

                    // pass into mathquill so it can act like it happened within mathquill
                    editable.triggerHandler(fakeEvent);
                }
                return;
            }

            //select the uneditable cell
            var cell = this.getNodesCellPosition(target);
            this.selectCell(cell.row, cell.column);
        };

        view.getNodesCellPosition = function (node) {
            var c = node.closest('td').prevAll('td').length;
            var r = node.closest('tr').prevAll('tr').length;
            return { row: r, column: c };
        };

        view.getCaretPosition = function () {
            if (this.$().find(document.activeElement).length) {
                return this.getNodesCellPosition($(document.activeElement));
            } else {
                return null;
            }
        };

        view.findCell = function (r, c) {
            return this.$('tr:nth-child(' + (r + 1) + ') td:nth-child(' + (c + 1) + ')');
        };

        view.findCellInput = function (r, c) {
            return this.findCell(r, c).find('.mathquill-rendered-math');
        };

        view.selectCell = function (r, c, selectEnd) {
            if (r < 0 || c < 0) return;

            var mathquill = this.findCellInput(r, c);
            if (!mathquill.length) return;

            var newSelectedCell = { row: r, column: c };
            this.model.setProperty('selectedCell', newSelectedCell);

            if (mathquill.hasClass('mathquill-editable')) {
                mathquill.mathquill('focus');
                if (selectEnd) {
                    mathquill.mathquill('moveEnd');
                } else {
                    mathquill.triggerHandler('select_all');
                }
            } else {
                $(document.activeElement).blur();
            }
        };

        view.unfocus = function () {
            var active = document.activeElement;
            if (this.$().find(active).length) {
                active.blur();
            }
        };

        view.processMissedKeyEvent = function (evt) {
            this.doKeyAction(Keydown.which(evt.which), evt);
        };

        view.onMathQuillKeydownEvent = function (evt) {
            var key = Keydown.which(evt.which);
            if (key === 'Tab' || key === 'Esc') {
                this.doKeyAction(key, evt);
            }
        };

        view.onMathQuillSpecialEvent = function (evt) {
            var evt_type = evt.type;
            var key = evt_type.slice(0, -('Pressed'.length));
            key = key.charAt(0).toUpperCase() + key.slice(1);
            this.doKeyAction(key, evt);
        };

        view.doKeyAction = function (key, evt) {

            // it's possible this came from a fake key event (keypad for example)
            // just create a dumby event so that evt.preventDefault() is callable.
            if (!evt) evt = $.Event();

            var selectedCell = this.model.selectedCell;
            var r_orig = selectedCell ? selectedCell.row : -1;
            var c_orig = selectedCell ? selectedCell.column : -1;

            var columns = this.model.columns;
            var totalRows = columns[0].cells.length;
            var totalCols = columns.length;

            var _createColumn = function (c) {
                this.model.insertColumn(c, { latex: '' });
                this.selectCell(0, c);
            } .bind(this);

            var _move = function (r, c) {

                // try to wrap it around up one row and to the very right.
                if (r === -1) {
                    this.triggerUpPressed();
                } else if (r > totalRows) {
                    this.triggerDownPressed();
                } else {

                    // wrap around the left side. goes up a row and to the far right.
                    if (c === -1) {
                        c = totalCols - 1;
                        r--;

                        // wrap around the right side. goes down a row and to the far left.
                    } else if (c === totalCols) {
                        r++;
                        c = 0;
                    }

                    this.selectCell(r, c);
                    evt.preventDefault();
                }
            } .bind(this);

            var _deleteRow = function (r) {

                // don't delete the last row
                if (totalRows <= 1) return;

                // remove the old row
                this.model.removeRow(r_orig - 1);

                this.selectCell(r, c_orig);
                evt.preventDefault();
            } .bind(this);

            var _deleteColumn = function (c) {
                // don't delete the first col, and don't delete one of last two cols
                if (c_orig === 0 || totalCols <= 2) return;

                // remove the old row
                this.model.removeColumn(c_orig);

                this.selectCell(r_orig, c);
                evt.preventDefault();
            } .bind(this);

            switch (key) {

                case 'Left': _move(r_orig, c_orig - 1); break;
                case 'Right': _move(r_orig, c_orig + 1); break;
                case 'Up': _move(r_orig - 1, c_orig); break;
                case 'Down': _move(r_orig + 1, c_orig); break;

                case 'Enter':
                    if (r_orig < totalRows) {
                        this.model.insertRow(r_orig, this.model.getAutofillValues(r_orig));
                        this.selectCell(r_orig + 1, c_orig);

                        // enter in bottom row creates a new row, but puts focus back in empty row
                    } else {
                        this.model.insertRow(r_orig - 1, this.model.getAutofillValues(r_orig - 1));
                        this.selectCell(r_orig, c_orig);
                    }
                    break;

                case 'Esc':
                    $(document.activeElement).blur();
                    this.model.setProperty('selectedCell', null);
                    break;

                case 'Tab':

                    // if focus isn't within the table, then prevent tab default.
                    if ($(document.activeElement).closest(this.$()).length === 0) {
                        evt.preventDefault();
                        return;
                    }
                    break;

                case 'Backspace':
                    if (r_orig === 0) {
                        if (c_orig === 0) { //backspace in empty top-left cell removes whole table
                            this.triggerBackspacePressed();
                            Desmos.SubheaderView.flashUndo();
                        }

                        else if (c_orig < totalCols - 1) {
                            _deleteColumn(c_orig - 1);

                            // backspace from right most column simply moves left
                        } else {
                            _move(0, c_orig - 1);
                        }
                    } else if (c_orig !== 0) {
                        _move(r_orig, c_orig - 1);
                    } else if (r_orig === totalRows) {
                        // backspace in bottom row simply moves up a row.
                        _move(r_orig - 1, c_orig);
                    } else {
                        _deleteRow(r_orig - 1);
                    }
                    break;

                case 'Del':
                    if (r_orig === 0) {
                        if (c_orig === 0) {
                            this.triggerDelPressed();
                            Desmos.SubheaderView.flashUndo();
                        }

                        // only delete column if its not on the far right
                        else if (c_orig < totalCols - 1) {
                            _deleteColumn(c_orig);
                        }

                    } else if (r_orig >= totalRows) {
                        // can't delete last row
                    } else {
                        _deleteRow(r_orig);
                    }
                    break;
            }
        };

        view.onFocusChange = function () {
            if (!this.model) return;
            this.model.setProperty('selectedCell', this.getCaretPosition());
        };


        view.isFocused = function () {
            return !!this.model.selectedCell;
        };

        view.addFocus = function (where, r, c) {
            if (where === 'cell') {
                this.selectCell(r, c);
            }

            else if (where !== 'end') {
                this.selectCell(0, 0);
            }

            else {
                this.selectCell(this.model.columns[0].cells.length, 0);
            }
        };
    });

    var RightHeaderView = P(UnderscoreView, function (headerView, _super) {
        headerView.templateName = 'table_cell_headerright';

        headerView.init = function (model, tableView) {
            _super.init.call(this);

            this.model = model;
            this.tableView = tableView;
        };

        headerView.didInsertElement = function () {
            _super.didInsertElement.call(this);

            this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');

            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function () {
                self.$mathquill.mathquill('clearSelection');
            });

            this.$().on('render', '.mathquill-rendered-math', function () {
                var latex = $(this).mathquill('latex');
                if (!latex) return;

                // set latex back to blank
                $(this).mathquill('latex', '');

                var index = self.model.index;
                self.model.table.insertColumn(index, { latex: latex });

                // select the new cell and put focus at end
                self.tableView.selectCell(0, index, true);
            });
        };

    });

    var HeaderView = P(UnderscoreView, function (headerView, _super) {
        headerView.templateName = 'table_cell_header';

        headerView.init = function (model, tableView) {
            _super.init.call(this);
            this.__renderedLatex = '';

            this.model = model;
            this.model.observe('index.headerview', this.updateIndex.bind(this)); // TODO - get rid of a need to put index in html
            this.model.observe('latex.headerview', this.onLatexChange.bind(this));
        };

        headerView.destruct = function () {
            this.model.unobserve('.headerview');
        };

        headerView.updateIndex = function () {
            this.$().attr('index', this.model.index);
        };

        headerView.onLatexChange = function () {
            if (!this.$mathquill) return;
            if (this.__renderedLatex === this.model.latex) return;
            this.__renderedLatex = this.model.latex;

            this.$mathquill.mathquill('latex', this.model.latex);
        };

        headerView.didInsertElement = function () {
            this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');
            // TODO - move these mathquill handlers up to the table view instead of
            // assigning them on each table cell individually
            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function () {
                self.$mathquill.mathquill('clearSelection');
            });

            this.$().on('render', '.mathquill-rendered-math', function () {
                var oldLatex = self.model.latex;
                var newLatex = $(this).mathquill('latex');
                if (oldLatex === newLatex) return;

                self.__renderedLatex = newLatex;
                self.model.setProperty('latex', newLatex);
            });

            this.iconView = TableIconView(this.model);
            this.iconView.replace(this.$('.template-icon'));

            this.onLatexChange();
            this.updateIndex();
        };

    });

    var BaseCellView = P(UnderscoreView, function (cellView, _super) {

        cellView.init = function (model, tableView) {
            _super.init.call(this);

            this.model = model;
            this.tableView = tableView;

            this.__renderedDisabled = true;
            this.__renderedValue = '';
            this.__renderedError = '';
        };

        cellView.lookupCellPosition = function () {
            var cells = this.model.column.cells;
            var cell = this.model;

            return {
                row: _.indexOf(cells, cell) + 1, //because there is a header above it
                column: this.model.column.index
            };
        };

        cellView.onValueChange = function () {
            var value = this.model.value;
            this.$().toggleClass('empty', !value);

            if (!this.$mathquill || this.__renderedValue === value) return;
            this.__renderedValue = value;

            // disabled mathquill can only have simple numerical values. Just
            // set the text. Ideally .mathquill('latex', ...) would work for
            // non-editable mathquill, but it doesn't. So we can hack this
            // together by simply setting the inner contents directly.
            if (this.__renderedDisabled) {
                this.$mathquill.text(value);
            }

            else {
                this.$mathquill.mathquill('latex', value);
            }
        };

        cellView.onDisabledChange = function () {
            var disabled = !!this.model.column.disabled;
            if (!this.$mathquill || this.__renderedDisabled === disabled) return;
            this.__renderedDisabled = disabled;

            this.$().toggleClass('non-editable', disabled);

            // revert mathquill to not editable
            if (disabled) {
                // Ideally we'd use .mathquill('revert') but that doesn't do what
                // you'd expect. It completely gets rid of mathquill. It doesn't turn
                // an editable mathquill back to non-editable. So, we destroy the
                // mathquill and replace it with an non-editable one.
                var $newMathquill = $('<span class="mathquill-rendered-math">' + this.model.value + '</span>');
                this.$mathquill.replaceWith($newMathquill);
                this.$mathquill = $newMathquill;
            }

            // make mathquill editable
            else {

                // TODO - The empty underline is the wrong size if we make
                // mathquill editable in the same code loop as when the td
                // is added to the dom. Not sure how to fix that.
                this.$mathquill.mathquill('editable');
            }
        };

        cellView.onErrorChange = function () {
            var error = this.model.error ? this.model.error : '';

            if (!this.$error || this.__renderedError === error) return;
            this.__renderedError = error;

            this.$error.attr('tooltip', error);
            this.$error.css('display', error ? '' : 'none');
        };
    });

    var RightCellView = P(BaseCellView, function (cellView, _super) {
        cellView.templateName = 'table_cell_bodyright';
    });

    var BottomCellView = P(BaseCellView, function (cellView, _super) {
        cellView.templateName = 'table_cell_bottom';

        cellView.init = function (model, tableView) {
            _super.init.call(this, model, tableView);

            this.model.column.observe('disabled.cellview', this.onDisabledChange.bind(this));
        };

        cellView.destruct = function () {
            this.model.column.unobserve('.cellview');
        };

        cellView.didInsertElement = function () {
            this.$mathquill = this.$('.mathquill-rendered-math');

            this.onDisabledChange();

            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function () {
                self.$mathquill.mathquill('clearSelection');
            });

            this.$().on('render', '.mathquill-rendered-math', function () {
                var latex = $(this).mathquill('latex');
                if (latex === '') return;

                // add a row
                $(this).mathquill('latex', '');
                var position = self.lookupCellPosition();

                var table = self.model.column.table;

                var rowValues = [];
                for (var i = 0; i < table.columns.length; i++) {
                    rowValues[i] = '';
                }

                rowValues[position.column] = latex;
                table.insertRow(position.row - 1, rowValues);
                self.tableView.selectCell(position.row, position.column, true);
            });
        };
    });

    var CellView = P(BaseCellView, function (cellView, _super) {
        cellView.templateName = 'table_cell_body';
        cellView.init = function (model, tableView) {
            _super.init.call(this, model, tableView);

            this.model.observe('value.cellview', this.onValueChange.bind(this));
            this.model.observe('error.cellview', this.onErrorChange.bind(this));
            this.model.column.observe('disabled.cellview', this.onDisabledChange.bind(this));
        };

        cellView.destruct = function () {
            this.model.unobserve('.cellview');
            this.model.column.unobserve('.cellview');
        };

        cellView.didInsertElement = function () {
            this.$error = this.$('.error-indicator');
            this.$mathquill = this.$('.mathquill-rendered-math');

            this.onDisabledChange();
            this.onValueChange();
            this.onErrorChange();

            // TODO - move these mathquill handlers up to the table view instead of
            // assigning them on each table cell individually
            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function () {
                self.$mathquill.mathquill('clearSelection');
            });

            this.$().on('render', '.mathquill-rendered-math', function () {
                var oldValue = self.model.value;
                var newValue = $(this).mathquill('latex');
                if (oldValue === newValue) return;
                self.__renderedValue = newValue;

                var id = self.model.column.table.id;
                var position = self.lookupCellPosition();
                function getCell() {
                    var table = Desmos.expressions.getItemById(id);
                    var column = table.columns[position.column];
                    return column.cells[position.row - 1];
                }

                UndoRedo.addTransaction({
                    type: UndoRedo.CAUSE_OF_CHANGE,
                    undo: function () {
                        var cell = getCell();
                        cell.setProperty('value', oldValue);
                        cell.column.table.requestParse();
                    },
                    redo: function () {
                        var cell = getCell();
                        cell.setProperty('value', newValue);
                        cell.column.table.requestParse();
                    }
                });

            });
        };
    });

    return TableView;
});
// desmos/public/assets/grapher/compiled_underscore_templates/list_desktop.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/list_desktop', ["desmos"], function (Desmos) {
    Desmos.Templates["list_desktop"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="exppanel-ember">\n  <div id="expression-top-bar">\n    <a class=\'edit-list-btn btn do-not-blur action-toggleeditlistmode\'>edit<a>\n      Expressions\n    <a class=\'hide-exp-btn do-not-blur action-hideexpressions\'>hide</a>  \n  </div>\n  \n  <div id="exppanel">\n  \n    <div class="expressionlist">\n      <span class="template-expressioneach"></span>\n      <div class="template-newexpression"></div>\n    </div>\n  </div>\n  \n  <div id=\'show-expressions-tab\'>\n    <button class=\'btn btn-primary action-showexpressions\'><i class=\'icon-caret-right\'></i></button>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
define('expressions/list_view_desktop', ['require', 'pjs', './list_view', './list', './expression_view_desktop', './text_view', './table_view', 'templates/list_desktop', 'lib/underscore_view'], function (require) {
    var P = require('pjs');
    var ListView = require('./list_view');
    var ExpressionList = require('./list');

    var ExpressionViewDesktop = require('./expression_view_desktop');
    var TextView = require('./text_view');
    var TableView = require('./table_view');

    require('templates/list_desktop');
    var UnderscoreView = require('lib/underscore_view');

    var ListViewDesktop = P(ListView, function (view, _super) {
        view.templateName = 'list_desktop';

        view.instantiateItemView = function (item) {
            if (item.isExpression) {
                return ExpressionViewDesktop(item);
            } else if (item.isText) {
                return TextView(item);
            } else if (item.isTable) {
                return TableView(item);
            }
        };
    });

    return ListViewDesktop(ExpressionList());
});

/*
* The ipad has some quirky scrolling behavior. This module fixes them.
* NOTE: this module is only for vertical scrolling. Horizontal page scroll
*       can be turned off by an html setting. If we want, we can enable
*       this module to monitor horizontal scrolling as well.
*
* On the ipad you can scroll an entire page by:
*     a) Sliding your finger on a non scrollable object.
*     b) Sliding your finger on a scrollable object in a direction
*        that the scrollable object is already maxed out.
*
* You can preventDefault() the 'touchMove' event and that will prevent
*  the ipad from scrolling the entire page. The only problem is that this
*  also prevents any scrollable area from scrolling.
*
* The solution is to monitor the 'touchStart' event to predict what will
*  happen when the user moves their finger. It predicts both movements up
*  and down. If it predicts that the entire page will be scrolled, it
*  makes that movement as invalid. If it predicts that a scrollable area
*  will be scrolled, it makes the movement as valid.
*
* On 'touchMove', this module looks up the prediction for the direction the
*  user moved. If the movement was valid, it lets the movement continue on
*  and scroll the scrollable area. If the movement was invalid, it does a
*  preventDefault() on the 'touchMove' event to prevent the entire page from
*  scrolling.
*
* Also important to know is that once you grab a scrollable area and start
*  scrolling, you're safe. The page won't scroll even if you max the
*  scrollable area out and keep dragging in that direction.
*
* The prediction routine runs up the ancestors of the evt.target and finds
* the first that:
*
*  1) has overflow and overflow-y properties that allow scrolling
*                 AND
*    2) has scrollTop != 0 (can be scrolled downward)
*                          AND/OR
*    3) has scrollTop that can be incremented (can be scrolled upward)
*/
; (function ($) {

    //some constants
    var NONE = 0;
    var UP = 1;
    var DOWN = 2;

    //holds the state
    var validMoveDirections = NONE;
    var startTouches = null;

    //decides which directions an element can be scrolled
    $(document).bind('touchstart', function (evt) {

        var dom = $(evt.target);
        validMoveDirections = NONE;

        while (validMoveDirections === NONE && dom.length) {

            //mobile safari throws error if you try to do normal
            //.css() on the top most element
            if (dom[0].tagName === undefined) {
                break;
            }

            var overflow = dom.css('overflow');
            var overflow_y = dom.css('overflow-y');

            //check if overflow allows it to be scrolled
            if (overflow !== "hidden" && overflow !== "visible" &&
          overflow_y !== "hidden" && overflow_y !== "hidden") {

                //can be scrolled downward if it isn't scrolled to the very top
                var scrollTop = dom.scrollTop();
                if (scrollTop !== 0) {
                    validMoveDirections = DOWN;
                }

                //can be scrolled upward if we try to scroll it upward and
                //it succeeds
                dom.scrollTop(scrollTop + 1);
                if (dom.scrollTop() !== scrollTop) {

                    //mark up as a valid scroll
                    validMoveDirections = UP | validMoveDirections;

                    //move it back to where it was
                    dom.scrollTop(scrollTop);
                }
            }

            dom = dom.parent();
        }

        //if any scroll is valid, lets save the original touchStart event
        //so that we can compare it with the touchMove event later to decide
        //which direction the user scrolled.
        if (validMoveDirections !== NONE) {
            startTouches = [];

            //We must clone the original touchStart event instead of simply
            //saving a reference to it. For some reason, the original touchStart
            //event updates it's pageY, screenY, etc properties as you scroll.
            //That means that touchStart.screenY will always equal the
            //touchMove.screenY event when you compare them.
            var origTouches = evt.originalEvent.touches;
            for (var i = 0; i < origTouches.length; i++) {
                var clonedTouch = {};
                for (var j in origTouches[i]) {
                    if (origTouches[i].hasOwnProperty(j)) {
                        clonedTouch[j] = origTouches[i][j];
                    }
                }
                startTouches.push(clonedTouch);
            }
        }
    });

    //decides if the the movement is in a valid direction.
    $(document).bind('touchmove', function (evt) {

        //makes sure this is the first touchmove after touchstart
        if (startTouches) {

            //get positions of the touch and move events
            var startTouch = startTouches[0];
            var moveTouch = evt.originalEvent.touches[0];

            //find the direction we moved our finger
            //var deltaX = moveTouch.screenX - startTouch.screenX;
            var deltaY = moveTouch.screenY - startTouch.screenY;

            //check if any of the movements weren't allowed
            //and if not, say that NO move is allowed. Will
            //get caught later at bottom of the function.
            if (deltaY > 0 && !(validMoveDirections & DOWN)) {
                validMoveDirections = NONE;
            } else if (deltaY < 0 && !(validMoveDirections & UP)) {
                validMoveDirections = NONE;
            }

            //first touchmove has been processed
            if (deltaY) {
                startTouches = null;
            }
        }

        //don't scroll the entire screen
        if (validMoveDirections === NONE) {
            evt.preventDefault();
        }
    });

    //resets the state
    $(document).bind('touchend', function () {
        validMoveDirections = NONE;
        startTouches = null;
    });

})(jQuery);
define("lib/ipad.scrollfix", function () { });

define('main/parse_json_errors', ['require'], function (require) {

    var parseJSONErrors = function (jqXHR) {
        try {
            return $.parseJSON(jqXHR.responseText).errors;
        } catch (err) {
            return [{ message: 'Internal Server Error.'}];
        }
    };
    return parseJSONErrors;
});
// Shim HTML5 placeholder element.
//
// https://github.com/parndt/jquery-html5-placeholder-shim

(function ($) {
    // @todo Document this.
    $.extend($, { placeholder: {
        browser_supported: function () {
            return this._supported !== undefined ?
          this._supported :
          (this._supported = !!('placeholder' in $('<input type="text">')[0]));
        },
        shim: function (opts) {
            var config = {
                color: '#888',
                cls: 'placeholder',
                selector: 'input[placeholder], textarea[placeholder]'
            };
            $.extend(config, opts);
            if (!this.browser_supported()) {
                $(config.selector)._placeholder_shim(config);
            }
        }
    }
    });

    $.extend($.fn, {
        _placeholder_shim: function (config) {
            function calcPositionCss(target) {
                var op = $(target).offsetParent().offset();
                var ot = $(target).offset();

                return {
                    top: ot.top - op.top,
                    left: ot.left - op.left,
                    width: $(target).width()
                };
            }
            return this.each(function () {
                var $this = $(this);

                if ($this.data('placeholder')) {
                    var $ol = $this.data('placeholder');
                    $ol.css(calcPositionCss($this));
                    return true;
                }

                var possible_line_height = {};
                if (!$this.is('textarea') && $this.css('height') != 'auto') {
                    possible_line_height = { lineHeight: $this.css('height'), whiteSpace: 'nowrap' };
                }

                var ol = $('<label />')
          .text($this.attr('placeholder'))
          .addClass(config.cls)
          .css($.extend({
              position: 'absolute',
              display: 'inline',
              float: 'none',
              overflow: 'hidden',
              textAlign: 'left',
              color: config.color,
              cursor: 'text',
              paddingTop: $this.css('padding-top'),
              paddingLeft: $this.css('padding-left'),
              paddingRight: $this.css('padding-right'),
              paddingBottom: $this.css('padding-bottom'),
              fontSize: $this.css('font-size'),
              fontFamily: $this.css('font-family'),
              fontStyle: $this.css('font-style'),
              fontWeight: $this.css('font-weight'),
              textTransform: $this.css('text-transform'),
              backgroundColor: 'transparent',
              zIndex: 99
          }, possible_line_height))
          .css(calcPositionCss(this))
          .attr('for', this.id)
          .data('target', $this)
          .click(function () {
              $(this).data('target').focus();
          })
          .insertBefore(this);
                $this
          .data('placeholder', ol)
          .focus(function () {
              ol.hide();
          }).blur(function () {
              ol[$this.val().length ? 'hide' : 'show']();
          }).triggerHandler('blur');
                $(window)
          .resize(function () {
              var $target = ol.data('target');
              ol.css(calcPositionCss($target));
          });
            });
        }
    });
})(jQuery);

jQuery(document).add(window).bind('ready load', function () {
    if (jQuery.placeholder) {
        jQuery.placeholder.shim();
    }
});
define("vendor/jquery.html5-placeholder-shim", function () { });

// desmos/public/assets/grapher/compiled_underscore_templates/tutorial_video.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/tutorial_video', ["desmos"], function (Desmos) {
    Desmos.Templates["tutorial_video"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="tutorial-video" class="modal_section">\n  <div class=\'tutorial_video_container\'>\n    \n  </div>\n</div>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/unsupported_browser.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/unsupported_browser', ["desmos"], function (Desmos) {
    Desmos.Templates["unsupported_browser"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="unsupported-browser" class="modal_section">\n  <div style=\'color:black; font-size:150%;\'>Unsupported Browser</div>\n  <div style=\'padding:20px 0px; color:#666\'>\n      We currently support:\n      <ul class="browsers">\n          <li><a target="_blank" href="https://www.google.com/chrome">Chrome</a></li>\n          <li><a target="_blank" href="http://www.mozilla.org/en-US/firefox/new/">Firefox (4+)</a></li>\n          <li><a target="_blank" href="http://www.apple.com/safari/download/">Safari (4+)</a></li>\n          <li><a target="_blank" href="http://windows.microsoft.com/en-US/internet-explorer/downloads/ie">Internet Explorer (9+)</a></li>\n          <li><a target="_blank" href="http://www.opera.com/">Opera (10+)</a></li>\n          <li>Safari on Mac or iPad</li>\n      </ul>\n          We\'ll be adding support for more browsers (and devices) as soon as possible!\n          \n          <div style="text-align: center; margin-top: 25px; margin-bottom:-16px">\n              <a class=\'btn action-hide do-not-blur\'>Ok, I\'ve been warned. Let me try it anyway! &rarr;</a>\n          </div>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/login_dialog.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/login_dialog', ["desmos"], function (Desmos) {
    Desmos.Templates["login_dialog"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="login-dialog" class="modal_section">\n  <h1>\n    Sign In\n  </h1>\n  \n  <div class=\'bg-line\'>\n    <span>Sign in with Google</span>\n  </div>\n    <div class=\'google-login-btn\'>\n      <span class=\'btn btn-large action-googlelogin\'><img src=\'/assets/grapher/img/google_32.png\' width=\'24px\' height=\'24px\' /> Sign in with your Google account</span>\n    </div>\n    \n  <div class=\'bg-line\'>\n    <span>Sign in with Desmos</span>\n  </div>\n  \n  ';
            _.each(errors, function (error) {
                ; __p += '\n  <div class="errors">\n      <span>' +
(error.message) +
'</span>\n  </div>\n  ';
            })
; __p += '\n  \n  <form class="desmos-login action-submit">\n    <div class="form_content_interior">\n      <label for="email">\n        <span>Email:</span>\n        <input type="email"\n          name="email"\n          class="input"\n          autofocus="autofocus"\n          required="required"\n          id="top_email"\n        />\n      </label>\n  \n      <label>\n        <span>Password:</span>\n        <input type="password"\n          name="password"\n          class="input"\n          required="required"\n          id="top_password"\n        />\n      </label>\n  \n      <span style="float:right; margin-right:30px;">\n        <a href="#" class="action-recoverpassword">Forgot your password?</a>\n        <div style=\'height:10px\'></div>\n        <a href="#" class="action-createaccount">Don\'t have an account?</a>\n      </span>\n  \n      <div style="padding:5px 0px; margin-bottom:8px">\n        ';
            if (spinning) {
                ; __p += '\n          <div class="progress_indicator progress"></div>\n        ';
            } else {
                ; __p += '\n          <button type="submit" class="btn btn-success">Sign Me In!</button> \n        ';
            }
            ; __p += '\n      </div>\n  \n    </div>\n  </form>\n</div>\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/create_account_dialog.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/create_account_dialog', ["desmos"], function (Desmos) {
    Desmos.Templates["create_account_dialog"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="create-account-dialog" class="modal_section">\n  <h1>\n    Create an account\n  </h1>\n  \n  <div class=\'bg-line\'>\n    <span>Link to Google</span>\n  </div>\n    <div class=\'google-login-btn\'>\n      <span class=\'btn btn-large action-googlelogin\'><img src=\'/assets/grapher/img/google_32.png\' width=\'24px\' height=\'24px\' /> Link to a Google account</span>\n    </div>\n    \n  <div class=\'bg-line\'>\n    <span>or use your email address</span>\n  </div>\n  \n  ';
            _.each(errors, function (error) {
                ; __p += '\n  <div class="errors">\n      <span>' +
(error.message) +
'</span>\n  </div>\n  ';
            })
; __p += '\n  \n  <form class="action-submit">\n    <label>\n      <span>Name:</span>\n      <input type="text"\n        name="name"\n        class="input"\n        required="required"\n        autofocus="autofocus"\n      />\n    </label>\n  \n    <div class="description">\n      This is the name we\'ll use if we feature one of your graphs\n    </div>\n  \n    <label>\n      <span>Email:</span>\n      <input type="email"\n        name="email"\n        class="input"\n        required="required"\n      />\n    </label>\n  \n    <div class="description">\n      We&rsquo;ll never share or sell your email address!\n    </div>\n  \n    <label>\n      <span>Password:</span>\n      <input type="password"\n        class="input"\n        name="password"\n        required="required"\n      />\n    </label>\n  \n    <br />\n    <br />\n  \n    <span style="float:right; margin-right:30px; margin-top:10px">\n      <a href="#" class="action-login">Already have an account?</a>\n    </span>\n  \n  \n    ';
            if (spinning) {
                ; __p += '\n      <div class="progress_indicator progress"></div>\n    ';
            } else {
                ; __p += '\n      <button type="submit" class="btn btn-success">Create Account!</button>\n    ';
            }
            ; __p += '\n      \n  \n  </form>\n  <div class=\'notice\'>\n    <b>Note:</b> by clicking "Create Account," you acknowledge that you\'ve read and accept our <a href=\'/terms\' target=\'_blank\'>Terms of Use</a>\n  </div>\n';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/edit_account_dialog.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/edit_account_dialog', ["desmos"], function (Desmos) {
    Desmos.Templates["edit_account_dialog"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="edit-account-dialog" class="modal_section">\n  \n  ';
            _.each(errors, function (error) {
                ; __p += '\n  <div class="errors">\n      <span>' +
(error.message) +
'</span>\n  </div>\n  ';
            })
; __p += '\n  \n  <form class="action-submit">\n    ';
            if (user) {
                ; __p += '\n      <h3>Edit Your Account</h3>\n      <label>\n        <span>Your Name:</span>\n        <input type="text"\n          name="name"\n          class="input"\n          id="edit_name"\n          autofocus="autofocus"\n          required="required"\n          value="' +
(user.name) +
'"\n        />\n      </label>\n      <div class="description">Note: this name may be displayed next to any publicly shared graphs</div>\n  \n      ';
                if (!user.isEdmodoUser) {
                    ; __p += '\n        <h3>Update password</h3>\n        <div id="update-password-fields">\n          <label>\n            <span>Current&nbsp;Password:</span>\n            <input type="password"\n              name="old_pass"\n              class="input"\n            />\n          </label>\n  \n          <label>\n            <span>New&nbsp;Password:</span>\n            <input type="password"\n              name="new_pass"\n              class="input"\n            />\n          </label>\n  \n          <label>\n            <span>Repeat&nbsp;Password:</span>\n            <input type="password"\n              name="repeat_new_pass"\n              class="input"\n            />\n          </label>\n        </div>\n      ';
                }
                ; __p += '\n      <br />\n      \n      ';
                if (spinning) {
                    ; __p += '\n        <div class="progress_indicator progress"></div>\n      ';
                } else {
                    ; __p += '\n        <button type="submit" class=\'btn btn-success\' id=\'save_graph_btn\'>Update Account</button>\n      ';
                }
                ; __p += '\n    ';
            }
            ; __p += '\n  </form>\n</div>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/save_dialog.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/save_dialog', ["desmos"], function (Desmos) {
    Desmos.Templates["save_dialog"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="save-dialog" class="modal_section">\n  <form class="action-submit">\n    <h1>\n      Save This Graph!\n    </h1>\n\n    <label>\n      <div class=\'graph-title-title\'>Title: &nbsp; </div>\n      <input class="title-input"\n             name="title"\n             placeholder="[Untitled Graph]"\n             value="' +
(title) +
'"\n      >\n    </label>\n    <br>\n    <button type="submit" class="btn btn-success" id="save_graph_btn">Save Graph!</button>\n    ';
            if (user.isDriveUser) {
                ; __p += '\n    <label class=\'send-to-drive\'>\n      <input type="checkbox" name="push_to_drive" />\n      Send a copy to Google Drive\n    </label>\n    ';
            }
            ; __p += '\n    <br><br>\n  </form>\n</div>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/recover_password_dialog.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/recover_password_dialog', ["desmos"], function (Desmos) {
    Desmos.Templates["recover_password_dialog"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="recover-password-dialog" class="modal_section">\n  <h1>Recover your password</h1>\n  \n  ';
            _.each(errors, function (error) {
                ; __p += '\n  <div class="errors">\n      <span>' +
(error.message) +
'</span>\n  </div>\n  ';
            })
; __p += '\n  \n  ';
            if (sentMessage) {
                ; __p += '\n    <p>Message sent. Please check your email for a password recovery link. (didn\'t work? <a href=\'#\' class="action-tryagain">try again</a>)</p>\n  ';
            } else {
                ; __p += '\n  \n    <form class="action-submit">\n      <p>Please enter your email address. We will send a password recovery link to you.</p>\n  \n      <label>\n        <span>Email:</span>\n        <input type="email"\n        name="email"\n        class="input"\n        id="recover_email"\n        required="required"\n        autofocus="autofocus"\n        />\n      </label>\n      \n      <br />\n      \n      ';
                if (spinning) {
                    ; __p += '\n        <div class="progress_indicator progress"></div>\n      ';
                } else {
                    ; __p += '\n        <button type="submit" class="btn btn-success">Recover</button>\n      ';
                }
                ; __p += '\n      \n    </form>\n    <br />\n  ';
            }
            ; __p += '\n  <p>Remembered your password? <a href="#" class="action-login">Sign In!</a></p>\n</div>';
        }
        return __p;
    };
});
define('main/user_modals', ['require', 'exports', 'module', 'pjs', 'lib/underscore_view', 'main/account_backend', 'main/user_controller', 'main/graphs_controller', 'main/parse_json_errors', 'vendor/jquery.html5-placeholder-shim', 'analytics/kissmetrics', 'templates/tutorial_video', 'templates/unsupported_browser', 'templates/login_dialog', 'templates/create_account_dialog', 'templates/edit_account_dialog', 'templates/save_dialog', 'templates/recover_password_dialog'], function (require, exports) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var accountBackend = require('main/account_backend');
    var userController = require('main/user_controller');
    var graphsController = require('main/graphs_controller');
    var parseJSONErrors = require('main/parse_json_errors');
    require('vendor/jquery.html5-placeholder-shim');
    require('analytics/kissmetrics');

    require('templates/tutorial_video');
    require('templates/unsupported_browser');
    require('templates/login_dialog');
    require('templates/create_account_dialog');
    require('templates/edit_account_dialog');
    require('templates/save_dialog');
    require('templates/recover_password_dialog');

    var popupDriveLogin = function () {
        var popup_window = Desmos.openPage(
      '/drive_api/calculator/login',
      'drive_window',
      'width=650, height=530'
    );
        if (!popup_window) {
            alert('Login window blocked. Please allow popups from desmos.com to sign in with google.');
        }
    };

    exports.Modal = (function ($) {
        var modalElement = null, modalBackground = null;

        function ready() {
            modalElement = $('#state-modals');
            modalBackground = $('#modal_background');

            modalElement.find('.close-modal').add(modalBackground)
      .bind('tap', hide);
        }

        // -*- public methods -*- //
        function hide() {
            try {
                //only blur if we're disappearing the focused element
                //one relevant example: feels weird to have the active mathquill blur
                //when we dismiss the "unsupported browser" modal.
                //
                //I think this is here just so that we don't end up in a weird
                //state on iPad where a focused textbox in a modal becomes hidden, but retains focus
                if ($(document.activeElement).closest(modalElement).length > 0) $(document.activeElement).blur();
            } catch (e) { }

            $("input[type='password']").attr("value", "");
            //this gets called right at the beginning (complete login) before modalBackground exists
            if (modalBackground) {
                modalBackground.hide();
                modalElement.hide();

                //clear out the video, or it keeps playing in the background. Also remove the "video-modal" class we added
                $('.tutorial_video_container').html('');
                $('#state-modals').removeClass("video-modal");
            }
        }
        function show(el) {
            $(el).siblings('.modal_section').hide();
            $(el).show();
            modalBackground.show();
            modalElement.show();
        }

        // -*- expose public methods -*- //
        return {
            ready: ready,
            hide: hide,
            show: show,
            $: function () { return modalElement; }
        };
    })(jQuery);

    var ModalDialogView = P(UnderscoreView, function (view, _super) {

        view.init = function () {
            _super.init.call(this);
            this.errors = [];
            this.spinning = false;
            this.saved_inputs = {};
            this.initialized = false;
        };

        view.getTemplateParams = function () {
            return {
                errors: this.errors,
                spinning: this.spinning
            };
        };

        view.show = function () {
            if (!this.initialized) {
                this.appendTo(exports.Modal.$());
                this.initialized = true;
            }
            this.errors = [];
            this.rerender();
            exports.Modal.show(this.$());
            // Focus first visible input
            this.$('input:visible, textarea:visible').first().focus();
            // Update position of placeholder shims.
            if ($.placeholder) $.placeholder.shim();
        };

        view.beforeRerender = function () {
            // save what the display value was for the .modal_section
            this.__$display = this.$().css('display');

            // save input values
            var self = this;
            this.$('input,textarea').each(function () {
                var name = $(this).attr('name');
                var value = $(this).val();

                self.saved_inputs[name] = value;
            });
        };

        view.afterRerender = function () {
            // must restore this if we want the modal to display. They are display:none
            // by default and that's how it'll get rerendered.
            this.$().css('display', this.__$display);

            // restore input values
            for (var name in this.saved_inputs) {
                this.$('[name="' + name + '"]').val(this.saved_inputs[name]);
            }
        };

        view.hide = function () {
            exports.Modal.hide();
        };

        view.processJSONErrors = function (jqXHR) {
            this.errors = parseJSONErrors(jqXHR);
        };

        view.startProcessingForm = function () {
            this.spinning = true;
            this.errors = [];
            this.rerender();
        };

        view.stopProcessingForm = function () {
            this.spinning = false;
            this.rerender();
        };

        view.successAnimation = function () {
            $('.success-thumb').remove();
            var img = $('<img src="/assets/grapher/img/check-48.png" class="success-thumb btn" width="48px" height="48px" />');
            $('body').append(img);
            setTimeout(function () {
                $('.success-thumb').fadeOut("slow");
            }, 500);
        };
    });

    /*
    * here are the actual modal states
    */
    exports.UnsupportedBrowserDialog = P(ModalDialogView, function (view) {
        view.templateName = 'unsupported_browser';
        view.didInsertElement = function () {
            this.$('.action-hide').on('tap', this.hide.bind(this));
        };
    })();

    exports.TutorialVideoDialog = P(ModalDialogView, function (view) {
        view.templateName = 'tutorial_video';
    })();

    exports.LoginDialog = P(ModalDialogView, function (view) {
        view.templateName = 'login_dialog';

        view.didInsertElement = function () {
            this.$('.action-googlelogin').on('tap', this.googleLogin.bind(this));
            this.$('.action-submit').on('submit', this.desmosLogin.bind(this));
            this.$('.action-recoverpassword').on('tap', this.recoverPassword.bind(this));
            this.$('.action-createaccount').on('tap', this.createAccount.bind(this));
        };

        view.desmosLogin = function (evt) {
            //don't submit the form
            evt.preventDefault();
            var formData = $(evt.target).serialize();
            var self = this;
            self.startProcessingForm();

            accountBackend.fetchUser(formData)
      .done(function (user) {
          exports.Modal.hide();
          userController.completeLogin({ user: user });
      })
      .fail(self.processJSONErrors.bind(self))
      .always(function () {
          self.stopProcessingForm();
      });
        };

        view.recoverPassword = function (evt) {
            evt.preventDefault();
            exports.RecoverPasswordDialog.show();
        };

        view.createAccount = function (evt) {
            evt.preventDefault();
            _kmq.push(['record', 'started signup', {
                'signup location': 'login dialog'
            }]);
            exports.CreateAccountDialog.show();
        };

        view.googleLogin = function () {
            _kmq.push([
      'record',
      'started google login',
      { 'login location': 'login dialog'}]
    );
            popupDriveLogin();
            exports.Modal.hide();
        };
    })();

    exports.CreateAccountDialog = P(ModalDialogView, function (view) {
        view.templateName = 'create_account_dialog';

        view.didInsertElement = function () {
            this.$('.action-submit').on('submit', this.submitCreateAccount.bind(this));
            this.$('.action-login').on('tap', this.login.bind(this));
            this.$('.action-googlelogin').on('tap', this.googleLogin.bind(this));
        };

        view.login = function () {
            _kmq.push(['record', 'started login', {
                'login location': 'create account'
            }]);
            exports.LoginDialog.show();
        };

        view.googleLogin = function () {
            _kmq.push([
      'record',
      'started google login',
      { 'login location': 'create account'}]
    );
            popupDriveLogin();
            exports.Modal.hide();
        };

        view.submitCreateAccount = function (evt) {
            evt.preventDefault();
            var self = this;

            var formData = $(evt.target).serialize();

            self.startProcessingForm();

            return accountBackend.registerUser(formData)
      .done(function (user) {
          exports.Modal.hide();
          _kmq.push(['record', 'signed up', { 'identity provider': 'desmos'}]);
          userController.completeLogin({ user: user });
      })
      .fail(self.processJSONErrors.bind(self))
      .always(function () {
          self.stopProcessingForm();
      });
        };

    })();

    exports.EditAccountDialog = P(ModalDialogView, function (view, _super) {
        view.templateName = 'edit_account_dialog';

        view.didInsertElement = function () {
            this.$('.action-submit').on('submit', this.submitEdit.bind(this));
        };

        // whenever this becomes visible, reset the name to the current user
        view.show = function () {
            _super.show.call(this);
            var params = this.getTemplateParams();
            if (params.user) {
                this.$('input[name=name]').val(params.user.name);
            }
        };

        view.getTemplateParams = function () {
            var params = _super.getTemplateParams.call(this);
            params.user = null;

            var user = userController.get('currentUser');
            if (user) {
                params.user = {
                    name: user.get('name'),
                    isEdmodoUser: user.get('isEdmodoUser')
                };
            }

            return params;
        };

        view.submitEdit = function (evt) {
            evt.preventDefault();

            var self = this;
            var form = $(evt.target);
            var formData = form.serialize();

            self.startProcessingForm();
            accountBackend.editAccount(formData).done(function (msg) {
                userController.set('currentUser.name', msg.get('name'));
                userController.set('currentUser.email', msg.get('email'));

                self.hide();
                self.successAnimation();
            }).fail(
      self.processJSONErrors.bind(self)
    ).always(function () {
        self.stopProcessingForm();
    });
        };

    })();

    exports.SaveDialog = P(ModalDialogView, function (view, _super) {
        view.templateName = 'save_dialog',

  view.didInsertElement = function () {
      this.$('.action-submit').on('submit', this.submitSave.bind(this));
  };

        // whenever this becomes visible reset title to current graph's title
        view.show = function () {
            _super.show.call(this);
            var params = this.getTemplateParams();
            this.$('input[name=title]').val(params.title);
        };

        view.getTemplateParams = function () {
            var params = _super.getTemplateParams.call(this);
            params.user = null;
            params.title = '';

            var user = userController.get('currentUser');
            if (user) {
                params.user = {
                    name: user.get('name'),
                    isDriveUser: user.get('isDriveUser')
                };
            }

            var graph = graphsController.get('currentGraph');
            if (graph && graph.get('title')) {
                params.title = graph.get('title');
            }

            return params;
        };

        view.submitSave = function (evt) {
            evt.preventDefault();
            var title = this.$('input[name=title]').val();
            graphsController.setPath('currentGraph.title', title);
            this.hide();
            graphsController.save();
        };

    })();


    exports.RecoverPasswordDialog = P(ModalDialogView, function (view, _super) {
        view.templateName = 'recover_password_dialog';

        view.getTemplateParams = function () {
            var params = _super.getTemplateParams.call(this);
            params.sentMessage = this.sentMessage;
            return params;
        };

        // will get called multiple times so only do dom instantiation
        view.didInsertElement = function () {
            this.$('.action-submit').on('submit', this.submitRecover.bind(this));
            this.$('.action-tryagain').on('tap', this.resetAgain.bind(this));
            this.$('.action-login').on('tap', this.login.bind(this));
        };

        view.submitRecover = function (evt) {
            evt.preventDefault();
            var self = this;
            var formData = $(evt.target).serialize();
            self.startProcessingForm();
            accountBackend.recoverPassword(formData).done(function () {
                self.sentMessage = true;
            }).fail(self.processJSONErrors.bind(self)).always(function () {
                self.stopProcessingForm();
            });
        };

        view.resetAgain = function () {
            this.sentMessage = false;
            this.rerender();
        };

        view.login = function () {
            _kmq.push(['record', 'started login', {
                'login location': 'recover password'
            }]);
            exports.LoginDialog.show();
        };
    })();

    /*
    * bind the initializer
    */

    $(document).ready(function () {
        //This used to render and insert all the views eagerly.
        //Moved to doing it lazily on show()
        exports.Modal.ready();
    });

    return exports;
});

// Do things this way to avoid script injection, and to have the LOAD_DATA
// var available to all our other javascript written out below. Using
// jQuery, which lives in vendor (above).
define('main/load_data', ['require', 'jquery'], function (require) {
    var $ = require('jquery');
    var load_data = $('body').data('load-data');
    return load_data;
});

define('main/desmos_user', ['require', 'desmos', 'lib/random_hash', 'main/load_data', 'main/user', 'main/graph', 'main/user_controller', 'main/graphs_controller', 'main/keypad'], function (require) {
    var Desmos = require('desmos');
    var RandomHash = require('lib/random_hash');
    var LOAD_DATA = require('main/load_data');

    var User = require('main/user');
    var Graph = require('main/graph');
    var userController = require('main/user_controller');
    var graphsController = require('main/graphs_controller');
    var keypadView = require('main/keypad');

    // back button support
    $(window).on('popstate', function (evt) {
        var state = evt.originalEvent.state;

        if (!state) return;

        graphsController.set('currentGraph', Graph.create(state));
    });

    function getLoadUser() {
        var userData = LOAD_DATA.user;

        if (!userData) return null;

        var user = User.create({
            email: userData.email,
            name: userData.name,
            isDriveUser: userData.isDriveUser,
            isEdmodoUser: userData.isEdmodoUser
        });

        return user;
    }

    function getLoadGraph() {
        var graphData = LOAD_DATA.graph;

        if (!graphData) return null;

        return Graph.fromAjax(graphData);
    }

    var getLoadSeed = function () {
        var loaded = $.Deferred();

        if (LOAD_DATA && LOAD_DATA.seed) {
            loaded.resolve(LOAD_DATA.seed);
            return loaded.promise();
        }

        return loaded.promise();
    };

    // XXX HACK ALERT XXX //
    var user = getLoadUser();
    if (user) {
        userController.completeLogin({
            user: user,
            remembered_login: true
        });
    }

    var loadGraph = getLoadGraph();
    if (loadGraph) {
        graphsController.set('currentGraph', loadGraph);

        //in this case, we're not going to open up the keypad, so we should manually show the "show-keypad" button.
        keypadView.hideKeypad();
    } else {
        // The graph state either needs to be set or cleared to get the
        // calculator into a consistent state.
        graphsController.clearGraph();
    }

    getLoadSeed().done(function (seed) {
        // Augment seed with time in case the same seed gets loaded more than once
        // for some reason (note, this is not expected to happen).
        var d = new Date();
        var augmentedSeed = '' + seed + d.getTime() + d.getMilliseconds();

        RandomHash.init(augmentedSeed);
    }).fail(function () {
        alert('Could not fetch seed. Saves will not work. Please connect to the internet and reload.');
    });

});

// desmos/public/assets/grapher/compiled_underscore_templates/my_graphs.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/my_graphs', ["desmos"], function (Desmos) {
    Desmos.Templates["my_graphs"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="my-graphs-container">\n  <div id="my-graphs-scrollable" class="popover bottom" >\n    <div class="popover-interior">\n  \n      <div class="popover-content my-graphs-content thumbnail-view">\n  \n        <p class="notification alert template-lastremoved">\n          Removed &ldquo;<span class="variable-removedtitle"></span>&rdquo;.\n          <a class=\'undoDelete action-undodelete\'>Undo</a>\n        </p>\n    \n        <div class="graphs-list">\n        \n          <div class="template-spinning">\n            <img src="/assets/grapher/img/ajax-loader.gif" width="16px" height="16px" /> loading graphs...\n          </div>\n          \n          <div class="template-notspinning">\n            <div class="template-list"></div>\n            \n            <div class="no_saved_graphs template-nosavedgraphs">\n              No saved graphs! <br><br>\n        \n              Click the <i class=\'icon-save\'></i> save graph button to add the current graph to your saved graphs.\n            </div>\n          </div>\n          <div style="clear:both"></div>\n        </div>\n      </div>\n    </div>\n    <div class="arrow"></div>\n  </div>\n</div>';
        }
        return __p;
    };
});
// desmos/public/assets/grapher/compiled_underscore_templates/my_graphs_graph.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/my_graphs_graph', ["desmos"], function (Desmos) {
    Desmos.Templates["my_graphs_graph"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div class="graph-link">\n  <div class=\'image-occluder\'>\n    <img src="' +
(thumbURL) +
'" class="thumb action-selectgraph" />\n  </div>\n  <div class=\'graph-title action-selectgraph\'>\n    ' +
(title) +
'\n  </div>\n  <div class=\'graph-last-save variable-displaydate\'></div>\n  <div class="remove-link action-removegraph" tooltip="remove from saved graphs">\n    <i class="icon-trash" ></i>\n  </div>\n  <div style="clear:both"></div>\n</div>';
        }
        return __p;
    };
});
define('main/my_graphs', ['require', 'pjs', 'lib/underscore_view', 'main/graphs_controller', 'vendor/jquery.tipsy', 'templates/my_graphs', 'templates/my_graphs_graph'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var graphsController = require('main/graphs_controller');
    require('vendor/jquery.tipsy');
    require('templates/my_graphs');
    require('templates/my_graphs_graph');

    /*
    * view for the my-graphs popdown
    */

    function getGraphFromEvent(evt) {
        var graph_node = $(evt.target).closest('.graph-link');
        var index = graph_node.prevAll('.graph-link').length;

        return graphsController.objectAt(index);
    }

    var GraphView = P(UnderscoreView, function (view, _super) {
        view.templateName = 'my_graphs_graph';

        view.init = function (graph) {
            _super.init.call(this);
            this.graph = graph;
            this.graph.addObserver('displayDate', this.updateDisplayDate.bind(this));
        };

        view.didInsertElement = function () {
            this.updateDisplayDate();
        };

        view.getTemplateParams = function () {
            return {
                thumbURL: this.graph.get('thumbURL'),
                title: this.graph.get('title'),
                displayDate: this.graph.get('displayDate')
            };
        };

        view.updateDisplayDate = function () {
            var date = this.graph.get('displayDate');
            if (date !== this.lastDisplayDate) {
                this.lastDisplayDate = date;
                this.$('.variable-displaydate').text(date);
            }
        };
    });

    // NOTE: MyGraphsView is an instance, *NOT A CONSTRUCTOR*, because the
    // constructor is immediately invoked after it is defined.
    var MyGraphsView = P(UnderscoreView, function (view, _super) {

        view.templateName = 'my_graphs';

        view.init = function () {
            _super.init.call(this);
            this.observe('isVisible', this.renderIsVisible.bind(this));
            this.graphViews = [];
        };

        view.renderIsVisible = function () {
            var isVisible = this.getProperty('isVisible');
            this.$().toggle(isVisible);

            // becomes visible
            if (isVisible) {
                this.updateDisplayDates();
                this.$('.popover-interior').css("maxHeight", Desmos.SubheaderView.popoverHeight() + "px");
            }

            // becomes invisible
            else {
                graphsController.set('lastRemoved', undefined);
            }
        };

        view.didInsertElement = function () {
            this.$().tipsy({ fade: "fast", title: 'tooltip', wait: 500, live: true, delegate: ".remove_link" });

            this.$('.action-undodelete').on('tap', this.undoRemoveGraph.bind(this));
            this.$().on('tap', '.action-selectgraph', this.selectGraph.bind(this));
            this.$().on('tap', '.action-removegraph', this.removeGraph.bind(this));

            this.setProperty('isVisible', false);
            this.setIsSpinning(false);
            this.updateLastRemoved();
            this.updateGraphsEmpty();
        };

        view.removeGraphsFromDom = function (start, count) {
            var graphViews = this.graphViews.splice(start, count);
            graphViews.forEach(function (graphView) {
                graphView.$().remove();
            });
        };

        view.addGraphToDom = function (index) {
            var graph = graphsController.objectAt(index);
            var graphView = GraphView(graph);
            this.graphViews.splice(index, 0, graphView);

            if (index === 0) {
                graphView.prependTo(this.$('.template-list'));
            } else {
                graphView.insertAfter(this.$('.template-list > :nth-child(' + index + ')'));
            }
        };

        view.updateGraphsEmpty = function () {
            var empty = graphsController.get('length') === 0;
            this.$('.template-nosavedgraphs').toggle(empty);
        };

        view.updateLastRemoved = function () {
            var lastRemoved = graphsController.get('lastRemoved');

            if (lastRemoved) {
                this.$('.template-lastremoved').toggle(true);
                this.$('.variable-removedtitle').text(lastRemoved.get('displayTitle'));
            } else {
                this.$('.template-lastremoved').toggle(false);
            }
        };

        view.setIsSpinning = function (bool) {
            this.isSpinning = bool;

            this.$('.template-spinning').toggle(bool);
            this.$('.template-notspinning').toggle(!bool);
        };

        view.updateDisplayDates = function () {
            graphsController.forEach(function (graph) {
                graph.updateDisplayDate();
            });
        };

        view.selectGraph = function (evt) {
            evt.preventDefault();
            var graph = getGraphFromEvent(evt);

            // Need a copy so that changes to currentGraph don't change things in
            // the myGraphs list.
            graphsController.set('currentGraph', graph.copy());

            this.setProperty('isVisible', false);
        };

        view.removeGraph = function (evt) {
            //dont' want to also load the graph
            evt.preventDefault();
            evt.stopPropagation();
            var graph = getGraphFromEvent(evt);

            //fade it out -- don't just make it disappear!
            $(evt.target).parent().hide("fast");
            setTimeout(function () {
                graphsController.removeObject(graph);
            }, 250);
        };

        view.undoRemoveGraph = function (evt) {
            evt.preventDefault();
            graphsController.undoLastRemove();
        };
    })();

    $(function () {
        MyGraphsView.appendTo('#subheader');

        var graphListObserver = Ember.Object.create({
            arrayWillChange: Ember.K,
            arrayDidChange: function (array, start, removeCount, addCount) {
                var i;
                MyGraphsView.removeGraphsFromDom(start, removeCount);
                for (i = 0; i < addCount; i++) {
                    MyGraphsView.addGraphToDom(start + i);
                }

                MyGraphsView.updateGraphsEmpty();
            }
        });

        graphsController.addArrayObserver(graphListObserver);
        graphsController.addObserver('lastRemoved', MyGraphsView.updateLastRemoved.bind(MyGraphsView));

        graphsController.startUpdatingGraphsCallbacks.push(function () {
            MyGraphsView.setIsSpinning(true);
        });
        graphsController.updateGraphsSuccessCallbacks.push(function () {
            MyGraphsView.setIsSpinning(false);
        });
        graphsController.updateGraphsErrorCallbacks.push(function () {
            MyGraphsView.setIsSpinning(false);
            // TODO error view not implemented. Might be nice to have a "try again"
            // button.
        });
    });

    return MyGraphsView;
});


// desmos/public/assets/grapher/compiled_underscore_templates/share_options.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/share_options', ["desmos"], function (Desmos) {
    Desmos.Templates["share_options"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="share-container">\n  <div id="share-scrollable" class="popover bottom" >\n    <div class="popover-interior">\n  \n    <!-- have a graph hash -->\n  \n    <div class=\'popover-title\'>\n      <b>Beautiful.</b> share it with the world!\n    </div>\n    <div class="popover-content">\n      \n      <div class=\'loading\'>\n          <img src="/assets/grapher/img/ajax-loader.gif" width="16px" height="16px" /> loading...\n      </div>\n\n      <div class=\'loaded\'>\n        <br>\n        &nbsp; &nbsp; post to:\n        <div class="share-buttons">\n          <a class=\'btn btn-primary btn-large variable-facebook\' target="_blank"><i class="icon-facebook"></i></a>\n          <a class=\'btn btn-info btn-large variable-twitter\' target="_blank"><i class="icon-twitter"></i></a>\n          <a class=\'btn btn-danger btn-large variable-google\' target="_blank"><i class="icon-google-plus"></i></a>          \n        </div>\n\n        &nbsp; &nbsp; permalink:\n        <input id="permalink" class="select-all variable-permalink"></input>\n\n        <form class="action-screenshoturl" target=\'_blank\' method=\'post\'>\n          <div class="btn-group" id="option-btns">\n            <span class="btn action-togglesection" section="email">Email</span>\n            <span class="btn action-togglesection" section="embed">Embed</span>\n            <input type=\'hidden\' name=\'img\' id=\'imgData\'>\n            <button type=\'submit\' class="btn image-btn" section="image">Image</button>\n          </div>\n        </form>\n\n        <div id="email-div" class="share-div">\n          <div class="template-emailerrors"></div>\n          <form class="action-emailgraph">\n            <label>Send to:\n            <input type="email" multiple="multiple" name="recipients" required="required" class="first-input" />\n            </label>\n\n            <label>Your Name:\n            <input type="text" name="name" required="required" class="variable-username" />\n            </label>\n\n            <label>Message: <i>(optional)</i>\n            <textarea name="message" rows="3" id=\'share-message\'></textarea>\n            </label>\n\n            <input type="hidden" name="hash" class="variable-graphhash" />\n            <button type="submit" class="btn btn-success" name="submit">Send!</button>\n\n            <span class=\'email-status-notifications\'>\n              <span class="template-ifprocessing">\n                <img src="/assets/grapher/img/ajax-loader.gif" width="16px" height="16px" /> sending...\n              </span>\n            </span>\n          </form>\n        </div>\n        <div id=\'email-sent\'>\n          Message Sent!\n        </div>\n        \n\n        <div id="embed-div" class="share-div">\n          <label>\n            HTML Embed Code\n            <a href="http://support.desmos.com/entries/22449752-embedding-graphs-with-html" target="_blank">what\'s this?</a>\n            <textarea rows="4" class="select-all first-input variable-htmlembedcode"></textarea>\n          </label>\n  \n          <label>\n            BBCode \n            <a href="http://support.desmos.com/entries/22449762-embedding-graphs-in-forums-with-bbcode" target="_blank">what\'s this?</a>\n\n            <input rows="4" class="select-all variable-htmlembedcodebb" />\n\n          </label>\n\n        </div>\n\n        <div class="template-iffeatureable">\n          <div class=\'alert\' id=\'allow-feature\'>\n            <a type="button" class="close action-cancelfeature">&times;</a>\n              <div class=\'content\'>\n                <div class=\'title\'>\n                  <b>Nice Graph!</b> Want us to consider featuring it?\n                </div>\n                \n                <div class=\'btn-group\'>\n                  <span id=\'allowFeature\' class="btn btn-small action-togglefeature">yeah!</span>\n                  <span id=\'disallowFeature\' class="btn btn-small action-togglefeature"> no, thanks</span>\n                </div>\n                \n              </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  \n    <div class="arrow"></div>\n  </div>\n</div>';
        }
        return __p;
    };
});
define('main/share_options', ['require', 'desmos', 'pjs', 'main/user_controller', 'main/graphs_controller', 'lib/underscore_view', 'main/calculator_backend', 'main/parse_json_errors', 'templates/share_options'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var userController = require('main/user_controller');
    var graphsController = require('main/graphs_controller');
    var UnderscoreView = require('lib/underscore_view');
    var calculatorBackend = require('main/calculator_backend');
    var parseJSONErrors = require('main/parse_json_errors');
    require('templates/share_options');

    /*
    * view for the settings bar
    */

    var ShareView = P(UnderscoreView, function (view, _super) {
        view.templateName = 'share_options';

        view.init = function () {
            _super.init.call(this);
            this.observe('isVisible', this.renderIsVisible.bind(this));
        };

        view.renderIsVisible = function () {
            var isVisible = this.getProperty('isVisible');
            this.$().toggle(isVisible);

            if (isVisible) {
                this.onBecameVisible();
            } else {
                this.onBecameHidden();
            }
        };

        view.didInsertElement = function () {
            this.$().on("mouseup mousedown", ".select-all", function () {
                var el = $(this);
                setTimeout(function () { el.select() }, 50);
            });

            // event listeners
            this.$('.action-togglesection').on('tap', this.toggleSection.bind(this));
            this.$('.action-emailgraph').on('submit', this.emailGraph.bind(this));
            this.$('.action-cancelfeature').on('tap', this.cancelFeature.bind(this));
            this.$('.action-togglefeature').on('tapstart', this.toggleFeature.bind(this));

            this.setProperty('isVisible', false);

            this.renderUser();
            this.renderGraph();
            this.renderIsProcessing();
            this.renderEmailErrors();
            this.renderOpenSection();
            this.renderIsFeatureable();
            this.setUserAllowsFeature(true);
        };

        view.onBecameVisible = function () {
            this.$('.popover-interior').css("maxHeight", Desmos.SubheaderView.popoverHeight() + "px");

            var graphModified = graphsController.graphModified();
            var graphSynced = graphsController.getPath('currentGraph.isSynced');
            if (!graphModified && graphSynced) {
                this.$('.loading').hide();
                this.$('.loaded').show();
                this.$('#imgData').attr("value", grapher.screenshot());
                return;
            }
            var self = this;
            var graph = graphsController.get('currentGraph');
            graph.updateData();
            calculatorBackend.shareGraph(graph).done(function (graph) {
                self.$('.loading').hide();
                self.$('.loaded').show();
                self.$('#imgData').attr("value", grapher.screenshot());
            });
        };

        view.onBecameHidden = function () {
            this.$('.loaded').hide();
            this.$('.loading').show();
            var graph = graphsController.get('currentGraph');

            if (this.getIsFeatureable() && this.getUserAllowsFeature()) {
                calculatorBackend.allowFeature({ hash: this.graph.hash });
            }
            this.minimizeSections();
            this.setIsProcessing(false);
            this.setEmailErrors(undefined);
        };

        view.getIsProcessing = function () {
            return this.isProcessing;
        };

        view.setIsProcessing = function (isProcessing) {
            if (isProcessing === this.isProcessing) return;
            this.isProcessing = isProcessing;
            this.renderIsProcessing();
        };

        view.renderIsProcessing = function () {
            this.$('.template-ifprocessing').toggle(this.getIsProcessing());
        };

        view.getEmailErrors = function () {
            return this.emailErrors;
        };

        view.setEmailErrors = function (emailErrors) {
            if (_.isEqual(emailErrors, this.emailErrors)) return;
            this.emailErrors = emailErrors;
            this.renderEmailErrors();
        };

        view.renderEmailErrors = function () {
            var errors = this.$('.template-emailerrors');
            errors.children().remove();
            _.each(this.emailErrors, function (error) {
                errors.append('<div class="errors">' + error.message + '</div>');
            });
        };

        view.getIsFeatureable = function () {
            return this.isFeatureable;
        };

        view.computeIsFeatureable = function () {
            //for now, we'll set isFeatureable true IFF a title is set for the graph
            this.setIsFeatureable(
        !!graphsController.get('currentGraph').get('title')
      );
        };

        view.setIsFeatureable = function (featureable) {
            if (featureable === this.isFeatureable) return;
            this.isFeatureable = featureable;

            this.renderIsFeatureable();
        };

        view.renderIsFeatureable = function () {
            this.$('.template-iffeatureable').toggle(!!this.isFeatureable);
        };

        view.getUserAllowsFeature = function () {
            return this.userAllowsFeature;
        };

        view.setUserAllowsFeature = function (userAllowsFeature) {
            if (userAllowsFeature === this.userAllowsFeature) return;
            this.userAllowsFeature = userAllowsFeature;

            this.renderUserAllowsFeature();
        };

        view.renderUserAllowsFeature = function () {
            this.$('#allowFeature').toggleClass("active", this.getUserAllowsFeature());
            this.$('#disallowFeature').toggleClass("active", !this.getUserAllowsFeature());
        };

        view.setGraph = function (graph) {
            if (_.isEqual(graph, this.graph)) return;
            this.graph = graph;

            this.renderGraph();
            this.computeIsFeatureable();
        };

        view.renderGraph = function () {
            var graph = this.graph;
            if (!graph) graph = {};
            if (!graph.hash) graph.hash = '';
            if (!graph.path) graph.path = '';

            this.$('.action-screenshoturl').attr('action', this.getScreenshotUrl(graph));
            this.$('.variable-facebook').attr('href', this.getFacebookURL(graph));
            this.$('.variable-twitter').attr('href', this.getTwitterURL(graph));
            this.$('.variable-google').attr('href', this.getGooglePlusURL(graph));
            this.$('#permalink').val(graph.path);
            this.$('.variable-graphhash').val(graph.hash);
            this.$('.variable-htmlembedcode').val(this.getHtmlEmbedCode(graph));
            this.$('.variable-htmlembedcodebb').val(this.getHtmlEmbedCodeBB(graph));
        };

        view.setUser = function (user) {
            if (_.isEqual(user, this.user)) return;
            this.user = user;

            this.renderUser();
            this.computeIsFeatureable();
        };

        view.renderUser = function () {
            var user = this.user;

            this.$('.variable-username').val(user ? user.name : '');
        };

        view.minimizeSections = function () {
            this.setOpenSection(null);
            $('.share-div').hide();
        };

        view.getOpenSection = function () {
            return this.openSection;
        };

        view.setOpenSection = function (section) {
            if (section === this.openSection) return;
            this.openSection = section;

            this.renderOpenSection();
        };

        view.renderOpenSection = function () {
            var section = this.getOpenSection();
            this.$('[section=email]').toggleClass('active', section === 'email');
            this.$('[section=embed]').toggleClass('active', section === 'embed');
            this.$('[section=image]').toggleClass('active', section === 'image');
        };

        view.toggleSection = function (e) {
            var section = $(e.target).attr("section");
            var isOpen = this.getOpenSection() === section;
            this.minimizeSections();

            if (!isOpen) {
                this.$('#allow-feature').hide();
                this.$('#' + section + '-div').show();
                this.$('#' + section + '-div .first-input').focus().select();

                if (section === 'email') {
                    this.$('#share-message').attr('value', '');
                    this.$('#email-div .first-input').attr('value', '');
                }

            } else {
                this.$('#allow-feature').show();
                section = null;
            }

            this.setOpenSection(section);
        };

        view.toggleFeature = function () {
            this.setUserAllowsFeature(!this.getUserAllowsFeature());
        };

        view.cancelFeature = function () {
            this.setUserAllowsFeature(false);
            this.$('.template-iffeatureable').slideUp('fast');
        };

        view.getFacebookURL = function (graph) {
            return 'https://www.facebook.com/sharer/sharer.php?u=' + escape(graph.path);
        };

        view.getTwitterURL = function (graph) {
            var message, path;
            if (graph.hash) {
                message = 'Look what I made with the Desmos Graphing Calculator: ';
                path = graph.path;
            } else {
                message = 'Check out the Desmos Graphing Calculator: beautiful, free math!';
                path = 'https://www.desmos.com';
            }
            return 'https://twitter.com/intent/tweet?url=' + escape(path) + '&text=' + escape(message) + '&via=desmos';
        };

        view.getGooglePlusURL = function (graph) {
            return 'https://plus.google.com/share?url=' + escape(graph.path);
        };

        view.getHtmlEmbedCode = function (graph) {
            return '<a title=\"View with the Desmos Graphing Calculator\" href=\"' + graph.path + '\"><img src="' + graph.thumbURL + '" width="200px" height="200px" style="border:1px solid #ccc; border-radius:5px"></a>';
        };

        view.getHtmlEmbedCodeBB = function (graph) {
            return '[GRAPH]' + graph.hash + '[/GRAPH]';
        };

        view.emailGraph = function (evt) {
            //don't submit the form
            evt.preventDefault();
            //don't repeat send
            if (this.getIsProcessing()) return;

            this.setIsProcessing(true);
            var self = this;
            var formData = $(evt.target).serialize();
            calculatorBackend.emailGraph(formData).done(function (msg) {
                self.setEmailErrors(undefined);
                $('#email-div').hide();
                $('#email-sent').show();
                setTimeout(function () {
                    $('#email-sent').slideUp(400);
                    self.minimizeSections();
                }, 1000);
            }).fail(function (jqXHR) {
                self.setEmailErrors(parseJSONErrors(jqXHR));
            }).always(function (msg) {
                self.setIsProcessing(false);
            });
        };

        view.getScreenshotUrl = function (graph) {
            return "/screenshot/" + graph.hash;
        };

    })();

    $(function () {

        ShareView.appendTo('#subheader');

        function handleUserUpdate() {
            var user = userController.get('currentUser');
            if (user) {
                ShareView.setUser({
                    name: user.get('name')
                });
            } else {
                ShareView.setUser(null);
            }
        }

        function handleGraphUpdate() {
            var graph = graphsController.get('currentGraph');
            if (graph) {
                ShareView.setGraph({
                    displayTitle: graph.get('displayTitle'),
                    hash: graph.get('hash'),
                    path: graph.get('path'),
                    thumbURL: graph.get('thumbURL')
                });
            } else {
                ShareView.setGraph(null);
            }
        }

        userController.addObserver('currentUser.name', handleUserUpdate);
        graphsController.addObserver('currentGraph.displayTitle', handleGraphUpdate);
        graphsController.addObserver('currentGraph.hash', handleGraphUpdate);
        graphsController.addObserver('currentGraph.path', handleGraphUpdate);
        graphsController.addObserver('currentGraph.thumbURL', handleGraphUpdate);

        handleUserUpdate();
        handleGraphUpdate();
    });

    return ShareView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/help.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/help', ["desmos"], function (Desmos) {
    Desmos.Templates["help"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="help-container">\n  <div id=\'help-scrollable\' class=\'popover bottom\' >\n    <div class=\'popover-interior\'>\n      <span class=\'guider_close\'></span>\n  \n      <div class=\'popover-title\'>Resources</div>\n      <div class=\'popover-content resources-content\'>\n        <div>\n          <a href=\'http://s3.amazonaws.com/desmos/Desmos_Calculator_User_Guide.pdf\' target=\'_blank\'>\n            <i class=\'icon-download\'></i>\n            <span>Download the Desmos User Manual</span>\n          </a>\n        </div>\n  \n        <div>\n          <a href=\'http://support.desmos.com/categories/20081717-using-the-desmos-graphing-calculator\' target=\'_blank\'>\n            <i class=\'icon-comments\'></i>\n            <span>Knowledge Base</span>\n          </a>\n        </div>\n  \n        <div>\n          <a href=\'http://support.desmos.com/forums/21528517-video-tutorials\' target=\'_blank\'>\n            <i class=\'icon-film\'></i>\n            <span>How-to Videos</span>\n          </a>\n            <div class=\'video-thumbs\'>\n              <table><tr>\n                ';
            _.each(videos, function (video, i) {
                ; __p += '\n                  <td>\n                    <a class="action-launchvideo" videoindex="' +
(i) +
'">\n                      <img src="' +
(video.img) +
'" class=\'thumb\'>\n                      <img class=\'play-btn\' src=\'/assets/grapher/img/play-thumb-no-padding.png\'>\n                      ' +
(video.title) +
'\n                    </a>\n                  </td>\n                ';
            })
; __p += '\n              </tr></table>\n            </div>\n        </div>\n  \n      </div>\n  \n      <div class=\'popover-title interior-title\'>Feedback</div>\n      <div class=\'popover-content\'>\n        <div class=\'resources-content\'>\n          <a href=\'http://support.desmos.com/categories/20071372-submit-calculator-ideas\' target=\'_blank\'>\n            <i class=\'icon-thumbs-up\'></i>\n            <span>Vote on new features!</span></a>\n          </a>\n        </div>\n        <div class=\'resources-content\'>\n          <a href="https://twitter.com/intent/tweet?text=Hey%2C%20%40desmos:%20I\'ve%20got%20a%20question!&via=desmos" target=\'_blank\'>\n            <i class=\'icon-twitter\'></i>\n            <span>Tweet @desmos</span>\n          </a>\n        </div>\n  \n        <div id="suggestions">\n          <div class="template-errors"></div>  \n          <div class="success-msg" id="feedback-email-sent">Thanks for the feedback &ndash; you\'ll hear from us soon!</div>\n  \n          \n          <form class="action-submit">\n          \n            <textarea placeholder="Type in a question or suggestion!" name="message"></textarea>\n            <div id="suggestions-expansion">\n              <div class="template-unlessuser">\n                <div id=\'feedback-email-label\'>Please provide an email so that we can write back! <i>(optional)</i></div>\n                <input name="anonymous-email" id="anonymous-email" placeholder="your.name@test.com" type="email" />\n              </div>\n              <a class="btn action-closesuggestion">\n                cancel\n              </a>\n              <button class="btn btn-success" name="submit" type="submit">\n                send feedback!\n              </button>\n          \n              <div class="template-processing" style="display:none">\n                <img src="/assets/grapher/img/ajax-loader.gif" width="16px" height="16px" /> sending...\n              </div>\n            </div>\n          </form>\n        </div>\n  \n      </div>\n  \n      <div class=\'popover-title interior-title\'>Examples</div>\n      <div class=\'popover-content examples-content\'>\n  \n  \n        ';
            _.each(examples, function (example, i) {
                ; __p += '\n          <a class="action-setstate ' +
(example.img) +
'"\n             tooltip="' +
(example.description) +
'"\n             exampleindex="' +
(i) +
'"\n          >\n          </a>\n        ';
            })
; __p += '\n  \n      </div>\n  \n    \n    \n    </div>\n    <div class=\'arrow\'></div>\n  </div>\n';
        }
        return __p;
    };
});
define('main/examples_data', [], function () {
    return [{
        img: 'parabola',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-10%2C%22ymin%22%3A-7.627118644067797%2C%22xmax%22%3A10%2C%22ymax%22%3A7.627118644067797%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22Explore%20%5C%22a%5C%22%2C%20%5C%22b%5C%22%2C%20and%20%5C%22c%5C%22%20for%20a%20parabola%20in%20standard%20form.%20What%27s%20the%20connection%20between%20the%20parabola%20%28blue%29%20and%20the%20line%20%28red%29%3F%22%2C%22id%22%3A155%7D%2C%7B%22latex%22%3A%22a%5C%5Cspace%3D%5C%5Cspace1%22%2C%22id%22%3A150%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%238064A2%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-10%2C%22sliderMax%22%3A10%7D%2C%7B%22latex%22%3A%22b%5C%5Cspace%3D%5C%5Cspace-1%22%2C%22id%22%3A151%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-10%2C%22sliderMax%22%3A10%7D%2C%7B%22latex%22%3A%22c%5C%5Cspace%3D%5C%5Cspace1%22%2C%22id%22%3A152%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-10%2C%22sliderMax%22%3A10%7D%2C%7B%22latex%22%3A%22y%5C%5Cspace%3E%5C%5Cspace%20ax%5E2+bx+c%22%2C%22id%22%3A153%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22y%5C%5Cspace%3D%5C%5Cspace%20bx+c%22%2C%22id%22%3A154%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%5D%7D%7D',
        title: 'Surfing Parabola'
    }, {
        img: 'interference',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-10%2C%22ymin%22%3A-7.627118644067797%2C%22xmax%22%3A10%2C%22ymax%22%3A7.627118644067797%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22%5C%22a%5C%22%20is%20the%20phase%20difference%20between%20the%20two%20curves.%20The%20purple%20curve%20is%20what%20you%20get%20by%20adding%20the%20two%20orange%20waves%20together.%20Drag%20the%20%5C%22a%5C%22%20slider%3A%22%2C%22id%22%3A141%7D%2C%7B%22latex%22%3A%22a%3D-1.17%22%2C%22id%22%3A140%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-10%2C%22sliderMax%22%3A10%7D%2C%7B%22latex%22%3A%22f%5C%5Cleft%28x%5C%5Cright%29%3D%5C%5Csin%5C%5Cleft%28x%5C%5Cright%29%22%2C%22id%22%3A1%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22g%5C%5Cleft%28x%5C%5Cright%29%3D%5C%5Csin%5C%5Cleft%28x+a%5C%5Cright%29%22%2C%22id%22%3A2%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22f%5C%5Cleft%28x%5C%5Cright%29+g%5C%5Cleft%28x%5C%5Cright%29%22%2C%22id%22%3A5%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%238064A2%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%5D%7D%7D',
        title: 'Wave Interference'
    }, {
        img: 'cycloid',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-1.5663853961321719%2C%22ymin%22%3A-5.025405207724555%2C%22xmax%22%3A14.236083739670296%2C%22ymax%22%3A6.235162202953235%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22Drag%20the%20%5C%22a%5C%22%20slider%20to%20watch%20the%20ball%20roll%20and%20trace%20out%20a%20cycloid%21%22%2C%22id%22%3A138%7D%2C%7B%22latex%22%3A%22a%3D4.54%22%2C%22id%22%3A137%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22never%22%2C%22sliderMin%22%3A0%2C%22sliderMax%22%3A12.566%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28%5C%5Csin%5C%5Cleft%28at+%5C%5Cpi%5C%5Cright%29+at%2C%5C%5Ccos%5C%5Cleft%28at+%5C%5Cpi%5C%5Cright%29+1%5C%5Cright%29%22%2C%22id%22%3A3%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A1%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-10%2C%22sliderMax%22%3A10%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28x-a%5C%5Cright%29%5E2+%5C%5Cleft%28y-1%5C%5Cright%29%5E2%3D1%22%2C%22id%22%3A126%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28%5C%5Csin%5C%5Cleft%28a+%5C%5Cpi%5C%5Cright%29+a%2C%5C%5Ccos%5C%5Cleft%28a+%5C%5Cpi%5C%5Cright%29+1%5C%5Cright%29%22%2C%22id%22%3A129%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%5D%7D%7D',
        title: 'Cycloid'
    }, {
        img: 'flower',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-2.8156320323097948%2C%22xmax%22%3A2.8583438718250394%2C%22ymin%22%3A-2.400091024538206%2C%22ymax%22%3A2.2292436664772266%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22connectedMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22latex%22%3A%22a%3D5%22%2C%22id%22%3A125%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%239BBB59%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A1%2C%22sliderMax%22%3A10%2C%22sliderInterval%22%3A1%7D%2C%7B%22latex%22%3A%22b%3D6%22%2C%22id%22%3A124%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A1%2C%22sliderMax%22%3A6%2C%22sliderInterval%22%3A1%7D%2C%7B%22latex%22%3A%22r%5C%5Cle%5C%5Csin%5C%5Cleft%28%5C%5Cfrac%7Ba%7D%7Bb%7D%5C%5Ctheta%5C%5Cright%29%22%2C%22id%22%3A1%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%238064A2%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%5D%7D%7D',
        title: 'Polar Flowers'
    }, {
        img: 'puppy',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-20.528582949884772%2C%22ymin%22%3A-15.657393775335843%2C%22xmax%22%3A20.528582949884772%2C%22ymax%22%3A15.657393775335843%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22This%20puppy%20was%20created%20by%20Amy%2C%20an%2011th%20grade%20student%2C%20for%20a%20school%20assignment.%20It%20uses%20a%20combination%20of%20conic%20sections%20%28circles%2C%20parabolas%29%20and%20trig%20functions%20%28sec%2C%20csc%2C%20tan%29%22%2C%22id%22%3A149%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+6%5C%5Cright%29%5E2+%5C%5Cleft%28x+2%5C%5Cright%29%5E2%3D2%5E2%22%2C%22id%22%3A148%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+6%5C%5Cright%29%5E2+%5C%5Cleft%28x+6%5C%5Cright%29%5E2%3D2%5E2%22%2C%22id%22%3A16%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+6%5C%5Cright%29%5E2+%5C%5Cleft%28x-2%5C%5Cright%29%5E2%3D2%5E2%22%2C%22id%22%3A88%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+6%5C%5Cright%29%5E2+%5C%5Cleft%28x-6%5C%5Cright%29%5E2%3D2%5E2%22%2C%22id%22%3A89%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B%5C%5Cleft%7Cx%5C%5Cright%7C%3C1.134%3A%5C%5Cspace%5C%5Ccsc%5C%5Cleft%28x+%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B2%7D%5C%5Cright%29%5C%5Cright%29-10.2%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A17%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B%5C%5Cleft%7Cx%5C%5Cright%7C%3C4.375%3A%5C%5Cspace%5C%5Csec%5C%5Cleft%28%5C%5Cleft%28%5C%5Cfrac%7B1%7D%7B3%7D%5C%5Cright%29x-%5C%5Cpi%5C%5Cright%29+4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A18%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B3.48%3C%5C%5Cspace%20x%3C6.2439%3A%5C%5Cleft%28%5C%5Cfrac%7B1%7D%7B5%7D%5C%5Cright%29%5C%5Ccot%5C%5Cleft%28x%5C%5Cright%29+1%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A19%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-6.2439%3Cx%3C-3.5%3A%5C%5Cleft%28%5C%5Cfrac%7B1%7D%7B5%7D%5C%5Cright%29%5C%5Ctan%5C%5Cleft%28x+%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B2%7D%5C%5Cright%29%5C%5Cright%29+1%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A20%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B%5C%5Cleft%7Cx%5C%5Cright%7C%3C4.24%3A%5C%5Cspace%5C%5Cfrac%7B1%7D%7B2.6%7D%5C%5Cleft%28-x%5E2%5C%5Cright%29+8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A22%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B%5C%5Cleft%7Cx%5C%5Cright%7C%3C.27%3A-%5C%5Cabs%5C%5Cleft%286x%5C%5Cright%29+9.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A23%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B.8%3C%5C%5Cspace%20x%3C3.7%3A-3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A44%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B.78%3Cx%3C3.7%3A%5C%5Cspace2%5C%5Ccos%5C%5Cleft%281.6x-3.6%5C%5Cright%29-1.599%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A47%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-3.75%3C%5C%5Cspace%20x%3C-.79%3A-3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A48%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-3.7%3Cx%3C-.8%3A%5C%5Cspace2%5C%5Csin%5C%5Cleft%281.6x-1.1%5C%5Cright%29-1.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A49%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-3.1%3C%5C%5Cspace%20x%3C-1.4%3A%5C%5Cspace2%5C%5Csin%5C%5Cleft%281.6x-1.1%5C%5Cright%29-3.4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A50%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B1.4%3C%5C%5Cspace%20x%3C3.1%3A%5C%5Cspace2%5C%5Ccos%5C%5Cleft%281.6x-3.6%5C%5Cright%29-3.4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A51%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-5.39%3Cx%3C-4.8%5C%5Cspace%3A%5C%5Cfrac%7B1%7D%7B2%7D%5C%5Ctan%5C%5Cleft%283x-%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B4.2%7D%5C%5Cright%29%5C%5Cright%29-6.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A68%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-6.44%3Cx%3C-5.8%3A%5C%5Cfrac%7B1%7D%7B2%7D%5C%5Ctan%5C%5Cleft%283x-%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B4.2%7D%5C%5Cright%29%5C%5Cright%29-6.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A69%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B-7.42%3Cx%3C-6.8%3A%5C%5Cfrac%7B1%7D%7B2%7D%5C%5Ctan%5C%5Cleft%283x-%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B4.2%7D%5C%5Cright%29%5C%5Cright%29-6.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A70%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B4.98%3Cx%3C5.64%3A%5C%5Cfrac%7B1%7D%7B2%7D%5C%5Ccot%5C%5Cleft%283x+%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B2%7D%5C%5Cright%29%5C%5Cright%29-6.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A71%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B6%3Cx%3C6.68%3A%5C%5Cfrac%7B1%7D%7B2%7D%5C%5Ccot%5C%5Cleft%283x+%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B2%7D%5C%5Cright%29%5C%5Cright%29-6.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A72%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B7%3Cx%3C7.6%3A%5C%5Cfrac%7B1%7D%7B2%7D%5C%5Ccot%5C%5Cleft%283x+%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cpi%7D%7B2%7D%5C%5Cright%29%5C%5Cright%29-6.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A73%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+4.5%5C%5Cright%29%5E2+%5C%5Cleft%28x-0%5C%5Cright%29%5E2%3D.5%5E2%22%2C%22id%22%3A66%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+5.5%5C%5Cright%29%5E2+%5C%5Cleft%28x-2.78%5C%5Cright%29%5E2%3D.3%5E2%22%2C%22id%22%3A76%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+5.5%5C%5Cright%29%5E2+%5C%5Cleft%28x-1.5%5C%5Cright%29%5E2%3D.3%5E2%22%2C%22id%22%3A78%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+6.7%5C%5Cright%29%5E2+%5C%5Cleft%28x-2%5C%5Cright%29%5E2%3D.3%5E2%22%2C%22id%22%3A80%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+6.7%5C%5Cright%29%5E2+%5C%5Cleft%28x+2%5C%5Cright%29%5E2%3D.3%5E2%22%2C%22id%22%3A82%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+5.5%5C%5Cright%29%5E2+%5C%5Cleft%28x+1.5%5C%5Cright%29%5E2%3D.3%5E2%22%2C%22id%22%3A84%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28y+5.5%5C%5Cright%29%5E2+%5C%5Cleft%28x+2.78%5C%5Cright%29%5E2%3D.3%5E2%22%2C%22id%22%3A86%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%5D%7D%7D',
        title: 'Amy\'s Puppy'
    }, {
        img: 'heart',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-2.474757315303456%2C%22ymin%22%3A-2.081791726471779%2C%22xmax%22%3A2.3915521785424914%2C%22ymax%22%3A1.6298002603598758%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22Do%20you%20%3C3%20math%3F%22%2C%22id%22%3A158%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B%5C%5Cleft%7Cx%5C%5Cright%7C%3C2%3A%5C%5Csqrt%7B%5C%5Ccos%20x%7D%5C%5Ccos%5C%5Cleft%28250x%5C%5Cright%29-.7+1%5C%5Csqrt%7B%5C%5Cleft%7Cx%5C%5Cright%7C%7D%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A157%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%5D%7D%7D',
        title: 'I <3 Math'
    }, {
        img: 'shuttle',
        state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-19.642%2C%22ymin%22%3A-3.412%2C%22xmax%22%3A61.451%2C%22ymax%22%3A39.6%7D%2C%22showLabels%22%3Atrue%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Atrue%2C%22showAxes%22%3Atrue%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22This%20graph%20was%20created%20by%20Abhishek%2C%20a%2010th%20grade%20student%2C%20for%20a%20class%20project.%20His%20goal%20was%20to%20use%20all%20of%20the%20conic%20sections%20%28circle%2C%20parabola%2C%20hyperbola%2C%20ellipse%29.%20Mission%3A%20success%21%22%2C%22id%22%3A160%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B24%5C%5Cle%20x%5C%5Cle28%3A%5C%5Cspace%5C%5Cfrac%7B1%7D%7B4%7Dx-3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A159%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B24%5C%5Cle%20x%5C%5Cle28%3A%5C%5Cspace%5C%5Cfrac%7B1%7D%7B4%7Dx-2%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A7%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B24%5C%5Cle%20x%5C%5Cle28%3A%5C%5Cspace%5C%5Cfrac%7B1%7D%7B4%7Dx-1%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A8%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B12%5C%5Cle%20x%5C%5Cle16%3A%5C%5Cspace%5C%5Cfrac%7B-1%7D%7B4%7Dx+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A9%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B12%5C%5Cle%20x%5C%5Cle16%3A%5C%5Cspace%5C%5Cfrac%7B-1%7D%7B4%7Dx+8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A10%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B12%5C%5Cle%20x%5C%5Cle16%3A%5C%5Cspace%5C%5Cfrac%7B-1%7D%7B4%7Dx+9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A11%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B16%5C%5Cle%20x%5C%5Cle24%3A%5C%5Cspace4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A12%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B16%5C%5Cle%20x%5C%5Cle24%3A%5C%5Cspace5%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A13%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B12%5C%5Cle%20x%5C%5Cle28%3A%5C%5Cspace6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A15%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B12%5C%5Cle%20x%5C%5Cle16%3A%5C%5Cspace%5C%5Cfrac%7B1%7D%7B4%7Dx+3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A16%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B24%5C%5Cle%20x%5C%5Cle28%3A%5C%5Cspace%5C%5Cfrac%7B-1%7D%7B4%7Dx+13%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A17%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B16%5C%5Cle%20x%5C%5Cle17%3A%5C%5Cspace7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A18%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%5C%5Cle%20x%5C%5Cle24%3A%5C%5Cspace7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A19%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B4%3Cy%3C6%3A28%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A28%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B4%3Cy%3C6%3A12%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A29%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B3%3Cy%3C5%3A16%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A30%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B3%3Cy%3C5%3A24%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A31%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B17.05%3Cx%3C20%3A%5C%5Cln%5C%5Cleft%28x-17%5C%5Cright%29+9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A33%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20%3Cx%3C22.95%3A%5C%5Cln%5C%5Cleft%2823-x%5C%5Cright%29+9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A34%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B9%3Cy%3C23%3A18%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A35%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B9%3Cy%3C23%3A22%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A36%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B14%5C%5Cle%20x%5C%5Cle17.3%3A%5C%5Cspace8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A37%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.7%5C%5Cle%20x%5C%5Cle26%3A%5C%5Cspace8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A38%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B8%3Cy%3C9%3A14%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A39%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B8%3Cy%3C9%3A26%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A40%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22%3Cx%3C26%3A%5C%5Cfrac%7B2%7D%7B3%7D%5C%5Cleft%28x-26%5C%5Cright%29%5E2+9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A42%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B14%3Cx%3C18%3A%5C%5Cfrac%7B2%7D%7B3%7D%5C%5Cleft%28x-14%5C%5Cright%29%5E2+9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A44%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B9.7%3Cy%3C26%3A15%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A45%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B9.7%3Cy%3C26%3A25%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A46%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B15%3Cy%3C26%3A17%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A47%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B15%3Cy%3C26%3A23%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A48%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B15%3Cy%3C28%3A17%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A49%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B15%3Cy%3C28%3A23%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A50%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B17%3Cx%3C23%3A%5C%5Cspace-%5C%5Cfrac%7B2%7D%7B3%7D%5C%5Cleft%28x-20%5C%5Cright%29%5E2+34%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A52%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B18%3Cx%3C22%3A%5C%5Cspace-%5C%5Cfrac%7B2%7D%7B3%7D%5C%5Cleft%28x-20%5C%5Cright%29%5E2+25.7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A53%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B15%3Cx%3C17%3A%5C%5Cspace-%5C%5Cfrac%7B9%7D%7B3%7D%5C%5Cleft%28x-16%5C%5Cright%29%5E2+29%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A54%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C25%3A%5C%5Cspace-%5C%5Cfrac%7B9%7D%7B3%7D%5C%5Cleft%28x-24%5C%5Cright%29%5E2+29%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A55%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28x-17%5C%5Cright%29%5E2+%5C%5Cleft%28y-10%5C%5Cright%29%5E2%3D.7%22%2C%22id%22%3A56%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B18.5%3Cx%3C21.5%3A%5C%5Cspace%5C%5Cfrac%7B1%7D%7B9%7D%5C%5Cleft%28x-20%5C%5Cright%29%5E2+24%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A57%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20%3Cx%3C22.1%3A%5C%5Cspace-%5C%5Cfrac%7B15%7D%7B6%7D%5C%5Cleft%28x-20%5C%5Cright%29%5E2+34%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A58%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cfrac%7B30%5C%5Cleft%28x-20%5C%5Cright%29%5E2%7D%7B1%7D+%5C%5Cfrac%7B%5C%5Cleft%28y-8%5C%5Cright%29%5E2%7D%7B4%7D%3D1%22%2C%22id%22%3A59%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B18%3Cx%3C19.7%3A%5C%5Cspace8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A60%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20.3%3Cx%3C22%3A%5C%5Cspace8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A61%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B6%3Cy%3C8%3A22%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A62%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B6%3Cy%3C8%3A18%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A63%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B18%3Cx%3C19.8%3A%5C%5Csqrt%7B0.066+%5C%5Cfrac%7B%5C%5Cleft%28x-19%5C%5Cright%29%5E2%7D%7B5%7D%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A68%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B18%3Cx%3C19.8%3A-%5C%5Csqrt%7B0.066+%5C%5Cfrac%7B%5C%5Cleft%28x-19%5C%5Cright%29%5E2%7D%7B5%7D%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A69%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20.2%3Cx%3C22%3A%5C%5Csqrt%7B0.066+%5C%5Cfrac%7B%5C%5Cleft%28x-21%5C%5Cright%29%5E2%7D%7B5%7D%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A70%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20.2%3Cx%3C22%3A-%5C%5Csqrt%7B0.066+%5C%5Cfrac%7B%5C%5Cleft%28x-21%5C%5Cright%29%5E2%7D%7B5%7D%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A71%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B9.5%3Cy%3C10.1%3A22.3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A72%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B9.5%3Cy%3C10.8%3A24.1%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A73%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C24.1%3A%5C%5Cspace9.5%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A74%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A75%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.1%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A76%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A77%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A23%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A78%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A79%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A80%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A81%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.5%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A82%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A83%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A84%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.2%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A85%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C24.1%3A%5C%5Cspace10.1%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A86%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C24.1%3A%5C%5Cspace10%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A87%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C24.1%3A%5C%5Cspace9.9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A88%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C24.1%3A%5C%5Cspace9.8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A89%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C24.1%3A%5C%5Cspace9.7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A90%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C24.1%3A%5C%5Cspace9.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A91%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.9%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A92%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.8%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A93%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A94%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A95%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.5%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A96%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22x%3D%5C%5Cleft%5C%5C%7B10.1%3Cy%3C10.8%3A22.4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A97%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.2%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A98%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A99%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.4%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A100%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.5%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A101%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.6%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A102%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B22.3%3Cx%3C23%3A%5C%5Cspace10.7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A103%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C25%3A%5C%5Cspace-%5C%5Cfrac%7B1%7D%7B10%7D%5C%5Cleft%28x-24%5C%5Cright%29%5E2+26%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A104%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B15%3Cx%3C17%3A%5C%5Cspace-%5C%5Cfrac%7B1%7D%7B10%7D%5C%5Cleft%28x-16%5C%5Cright%29%5E2+26%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A105%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B23%3Cx%3C25%3A%5C%5Cspace-%5C%5Cfrac%7B1%7D%7B10%7D%5C%5Cleft%28x-24%5C%5Cright%29%5E2+20%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A106%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B15%3Cx%3C17%3A%5C%5Cspace-%5C%5Cfrac%7B1%7D%7B10%7D%5C%5Cleft%28x-16%5C%5Cright%29%5E2+20%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A107%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B19%5C%5Cle%20x%3C21%3A%5C%5Cspace-%5C%5Cleft%28x-20%5C%5Cright%29%5E2+23%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A108%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B19%5C%5Cle%20x%3C21%3A%5C%5Cspace-%5C%5Cleft%28x-20%5C%5Cright%29%5E2+22.3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A109%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28x-19.5%5C%5Cright%29%5E2+%5C%5Cleft%28y-21.25%5C%5Cright%29%5E2%3D.035%22%2C%22id%22%3A110%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28x-20.5%5C%5Cright%29%5E2+%5C%5Cleft%28y-21.25%5C%5Cright%29%5E2%3D.035%22%2C%22id%22%3A111%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28x-19.7%5C%5Cright%29%5E2+%5C%5Cleft%28y-24.5%5C%5Cright%29%5E2%3D.035%22%2C%22id%22%3A113%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%28x-20.3%5C%5Cright%29%5E2+%5C%5Cleft%28y-24.5%5C%5Cright%29%5E2%3D.035%22%2C%22id%22%3A114%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B19%3Cx%3C19.81%3A%5C%5Csqrt%7B.1-.1%5C%5Cleft%28x-20%5C%5Cright%29%5E2%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A116%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20.19%3Cx%3C21%3A%5C%5Csqrt%7B.1-.1%5C%5Cleft%28x-20%5C%5Cright%29%5E2%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A117%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B19%3Cx%3C19.84%3A-%5C%5Csqrt%7B.1-.1%5C%5Cleft%28x-20%5C%5Cright%29%5E2%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A118%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B20.16%3Cx%3C21%3A-%5C%5Csqrt%7B.1-.1%5C%5Cleft%28x-20%5C%5Cright%29%5E2%7D+7%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A119%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5C%5C%7B16%3Cx%3C24%3A3%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A120%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%5D%7D%7D',
        title: 'Space Shuttle by Abhishek'
    },
{
    img: 'parametric-3d',
    state: '%7B%22graph%22%3A%7B%22viewport%22%3A%7B%22xmin%22%3A-8.761278563738967%2C%22ymin%22%3A-7.414729613101661%2C%22xmax%22%3A10.45534369765407%2C%22ymax%22%3A7.242016179486255%7D%2C%22showLabels%22%3Afalse%2C%22degreeMode%22%3Afalse%2C%22showGrid%22%3Afalse%2C%22showAxes%22%3Afalse%2C%22squareAxes%22%3Atrue%2C%22labelXMode%22%3A%22%22%2C%22labelYMode%22%3A%22%22%7D%2C%22expressions%22%3A%7B%22list%22%3A%5B%7B%22text%22%3A%22This%20is%20an%20example%20of%20pushing%20the%20limits%20of%20the%20calculator.%20f%28x%2Cy%29%20is%20any%203-d%20function.%20Try%20changing%20it%21%22%2C%22id%22%3A162%7D%2C%7B%22latex%22%3A%22f%5C%5Cleft%28x%2Cy%5C%5Cright%29%3D%5C%5Ccos%5C%5Cleft%28%5C%5Cleft%28x+y%5C%5Cright%29%5C%5Cright%29+%5C%5Cfrac%7Bx%5E2%7D%7B6%7D-%5C%5Cfrac%7By%5E2%7D%7B6%7D%22%2C%22id%22%3A161%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22text%22%3A%22Slide%20a%2C%20b%2C%20and%20c%20to%20see%20what%20they%20do%3A%22%2C%22id%22%3A164%7D%2C%7B%22latex%22%3A%22a%3D-2%22%2C%22id%22%3A33%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-3.1416%2C%22sliderMax%22%3A3.1416%2C%22sliderInterval%22%3A%22%22%7D%2C%7B%22latex%22%3A%22b%3D0.66%22%2C%22id%22%3A44%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-3.1416%2C%22sliderMax%22%3A3.1416%7D%2C%7B%22latex%22%3A%22c%3D0%22%2C%22id%22%3A49%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-3.1416%2C%22sliderMax%22%3A3.1416%7D%2C%7B%22text%22%3A%22here%20we%20do%20some%20transformations%20to%20find%20out%20where%20to%20plot%20a%203-dimensional%20point%20on%20this%202-dimensional%20screen.%20Note%20that%20these%20depend%20a%20lot%20on%20a%2C%20b%2C%20and%20c%22%2C%22id%22%3A167%7D%2C%7B%22latex%22%3A%22x_x%3D%5C%5Ccos%5C%5Cleft%28c%5C%5Cright%29%5C%5Ccos%5C%5Cleft%28a%5C%5Cright%29-%5C%5Csin%5C%5Cleft%28c%5C%5Cright%29%5C%5Csin%5C%5Cleft%28a%5C%5Cright%29%5C%5Csin%5C%5Cleft%28b%5C%5Cright%29%22%2C%22id%22%3A34%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22never%22%7D%2C%7B%22latex%22%3A%22x_y%3D%5C%5Ccos%5C%5Cleft%28c%5C%5Cright%29%5C%5Csin%5C%5Cleft%28a%5C%5Cright%29%5C%5Csin%5C%5Cleft%28b%5C%5Cright%29+%5C%5Csin%5C%5Cleft%28c%5C%5Cright%29%5C%5Ccos%5C%5Cleft%28a%5C%5Cright%29%22%2C%22id%22%3A35%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%239BBB59%22%2C%22userRequestedGraphing%22%3A%22never%22%7D%2C%7B%22latex%22%3A%22y_x%3D-%5C%5Ccos%5C%5Cleft%28c%5C%5Cright%29%5C%5Csin%5C%5Cleft%28a%5C%5Cright%29-%5C%5Csin%5C%5Cleft%28c%5C%5Cright%29%5C%5Ccos%5C%5Cleft%28a%5C%5Cright%29%5C%5Csin%5C%5Cleft%28b%5C%5Cright%29%22%2C%22id%22%3A38%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22y_y%3D%5C%5Ccos%5C%5Cleft%28c%5C%5Cright%29%5C%5Ccos%5C%5Cleft%28a%5C%5Cright%29%5C%5Csin%5C%5Cleft%28b%5C%5Cright%29-%5C%5Csin%5C%5Cleft%28c%5C%5Cright%29%5C%5Csin%5C%5Cleft%28a%5C%5Cright%29%22%2C%22id%22%3A39%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22z_x%3D-%5C%5Csin%5C%5Cleft%28c%5C%5Cright%29%5C%5Ccos%5C%5Cleft%28b%5C%5Cright%29%22%2C%22id%22%3A36%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22z_y%3D%5C%5Ccos%5C%5Cleft%28c%5C%5Cright%29%5C%5Ccos%5C%5Cleft%28b%5C%5Cright%29%22%2C%22id%22%3A37%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%238064A2%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22text%22%3A%22What%20do%20you%20think%20%5C%22n%5C%22%20and%20%5C%22s%5C%22%20do%3F%22%2C%22id%22%3A168%7D%2C%7B%22latex%22%3A%22n%3D40%22%2C%22id%22%3A1%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A2%2C%22sliderMax%22%3A40%2C%22sliderInterval%22%3A2%7D%2C%7B%22latex%22%3A%22s%3D3.52%22%2C%22id%22%3A28%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%238064A2%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A-10%2C%22sliderMax%22%3A10%7D%2C%7B%22text%22%3A%22These%20two%20variables%20help%20draw%20the%20arrow-heads.%20Can%20you%20tell%20what%20they%20do%3F%22%2C%22id%22%3A172%7D%2C%7B%22latex%22%3A%22l%3D0.904%22%2C%22id%22%3A66%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%239BBB59%22%2C%22userRequestedGraphing%22%3A%22never%22%2C%22sliderMin%22%3A0.5%2C%22sliderMax%22%3A1%7D%2C%7B%22latex%22%3A%22a_l%3D7.89%22%2C%22id%22%3A69%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22default%22%2C%22sliderMin%22%3A5%2C%22sliderMax%22%3A20%7D%2C%7B%22text%22%3A%22Now%20we%20draw%20the%20axes.%20x_arr%20and%20y_arr%20are%20helper%20functions%20that%27ll%20we%27ll%20use%20in%20equations%2023%2C%2024%2C%20and%2025%22%2C%22id%22%3A175%7D%2C%7B%22latex%22%3A%22x_%7Barr%7D%5C%5Cleft%28t%2Cx_s%2Cy_s%5C%5Cright%29%3D%5C%5Cleft%5C%5C%7B0%3Ct%3Cl%3Ax_st%2C%5C%5Cspace%20l%3Ct%3C%5C%5Cfrac%7Bl+1%7D%7B2%7D%3Alx_s+%5C%5Ccos%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29x_s%5C%5Cleft%28t-l%5C%5Cright%29-%5C%5Csin%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29y_s%5C%5Cleft%28t-l%5C%5Cright%29%2C%5C%5Cspace%5C%5Cfrac%7Bl+1%7D%7B2%7D%3Ct%3C1%3Alx_s+%5C%5Csin%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29y_s%5C%5Cleft%28t-%5C%5Cfrac%7Bl+1%7D%7B2%7D%5C%5Cright%29+%5C%5Ccos%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29x_s%5C%5Cleft%28t-%5C%5Cfrac%7Bl+1%7D%7B2%7D%5C%5Cright%29%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A61%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23C0504D%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22y_%7Barr%7D%5C%5Cleft%28t%2Cx_s%2Cy_s%5C%5Cright%29%3D%5C%5Cleft%5C%5C%7B0%3Ct%3Cl%3Ay_st%2C%5C%5Cspace%20l%3Ct%3C%5C%5Cfrac%7Bl+1%7D%7B2%7D%3Aly_s+%5C%5Ccos%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29y_s%5C%5Cleft%28t-l%5C%5Cright%29+%5C%5Csin%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29x_s%5C%5Cleft%28t-l%5C%5Cright%29%2C%5C%5Cspace%5C%5Cfrac%7Bl+1%7D%7B2%7D%3Ct%3C1%3Aly_s-%5C%5Csin%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29x_s%5C%5Cleft%28t-%5C%5Cfrac%7Bl+1%7D%7B2%7D%5C%5Cright%29+%5C%5Ccos%5C%5Cleft%28%5C%5Cfrac%7B5%5C%5Cpi%7D%7B6%7D%5C%5Cright%29y_s%5C%5Cleft%28t-%5C%5Cfrac%7Bl+1%7D%7B2%7D%5C%5Cright%29%5C%5Cright%5C%5C%7D%22%2C%22id%22%3A64%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A10%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5Bx_%7Barr%7D%5C%5Cleft%28t%2Ca_lx_x%2Ca_lx_y%5C%5Cright%29%2Cy_%7Barr%7D%5C%5Cleft%28t%2Ca_lx_x%2Ca_lx_y%5C%5Cright%29%5C%5Cright%5D%22%2C%22id%22%3A65%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A1%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5Bx_%7Barr%7D%5C%5Cleft%28t%2Ca_ly_x%2Ca_ly_y%5C%5Cright%29%2Cy_%7Barr%7D%5C%5Cleft%28t%2Ca_ly_x%2Ca_ly_y%5C%5Cright%29%5C%5Cright%5D%22%2C%22id%22%3A67%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A1%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5Bx_%7Barr%7D%5C%5Cleft%28t%2Ca_lz_x%2Ca_lz_y%5C%5Cright%29%2Cy_%7Barr%7D%5C%5Cleft%28t%2Ca_lz_x%2Ca_lz_y%5C%5Cright%29%5C%5Cright%5D%22%2C%22id%22%3A68%2C%22domain%22%3A%7B%22min%22%3A0%2C%22max%22%3A1%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%2C%7B%22text%22%3A%22And%2C%20finally%2C%20we%20draw%20the%20graph%20in%20blue%20and%20green.%20Can%20you%20figure%20out%20what%20g%28t%29%20and%20h%28t%29%20do%3F%22%2C%22id%22%3A176%7D%2C%7B%22latex%22%3A%22g%5C%5Cleft%28x%5C%5Cright%29%3D2s%5C%5Cleft%28%5C%5Cfrac%7B%5C%5Cfloor%5C%5Cleft%28x%5C%5Ccdot%5C%5Cleft%28n+1%5C%5Cright%29%5C%5Cright%29%7D%7Bn%7D-.5%5C%5Cright%29%22%2C%22id%22%3A29%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23F79646%22%2C%22userRequestedGraphing%22%3A%22never%22%7D%2C%7B%22latex%22%3A%22h%5C%5Cleft%28x%5C%5Cright%29%3D2s%5C%5Cleft%28%5C%5Cmod%5C%5Cleft%28x%5C%5Ccdot%5C%5Cleft%28n+1%5C%5Cright%29%2C1%5C%5Cright%29-.5%5C%5Cright%29%22%2C%22id%22%3A30%2C%22domain%22%3A%7B%22max%22%3A10%2C%22min%22%3A0%7D%2C%22color%22%3A%22%23000000%22%2C%22userRequestedGraphing%22%3A%22never%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5Bx_xg%5C%5Cleft%28t%5C%5Cright%29+y_xh%5C%5Cleft%28t%5C%5Cright%29+z_xf%5C%5Cleft%28g%5C%5Cleft%28t%5C%5Cright%29%2Ch%5C%5Cleft%28t%5C%5Cright%29%5C%5Cright%29%2Cx_yg%5C%5Cleft%28t%5C%5Cright%29+y_yh%5C%5Cleft%28t%5C%5Cright%29+z_yf%5C%5Cleft%28g%5C%5Cleft%28t%5C%5Cright%29%2Ch%5C%5Cleft%28t%5C%5Cright%29%5C%5Cright%29%5C%5Cright%5D%22%2C%22id%22%3A76%2C%22domain%22%3A%7B%22max%22%3A1%2C%22min%22%3A0%7D%2C%22color%22%3A%22%234F81BD%22%2C%22userRequestedGraphing%22%3A%22always%22%7D%2C%7B%22latex%22%3A%22%5C%5Cleft%5Bx_xh%5C%5Cleft%28t%5C%5Cright%29+y_xg%5C%5Cleft%28t%5C%5Cright%29+z_xf%5C%5Cleft%28h%5C%5Cleft%28t%5C%5Cright%29%2Cg%5C%5Cleft%28t%5C%5Cright%29%5C%5Cright%29%2Cx_yh%5C%5Cleft%28t%5C%5Cright%29+y_yg%5C%5Cleft%28t%5C%5Cright%29+z_yf%5C%5Cleft%28h%5C%5Cleft%28t%5C%5Cright%29%2Cg%5C%5Cleft%28t%5C%5Cright%29%5C%5Cright%29%5C%5Cright%5D%22%2C%22id%22%3A77%2C%22domain%22%3A%7B%22max%22%3A1%2C%22min%22%3A0%7D%2C%22color%22%3A%22%239BBB59%22%2C%22userRequestedGraphing%22%3A%22default%22%7D%5D%7D%7D',
    title: '3D Graph using Parametric Lines'
}];
});

define('main/videos_data', [], function () {
    return [{
        title: "Tables",
        img: "/assets/grapher/img/video-thumbs/tables.png",
        videoHash: "IOSC56clmeQ"
    }, {
        title: "Sliders",
        img: "/assets/grapher/img/video-thumbs/sliders.png",
        videoHash: "ihWIiMQeTT0"
    }, {
        title: "Inequalities",
        img: "/assets/grapher/img/video-thumbs/inequalities.png",
        videoHash: "_6wdhL2zkM8"
    }, {
        title: "Points of Interest",
        img: "/assets/grapher/img/video-thumbs/pois.png",
        videoHash: "I1WOla_QggY"
    }];
});

define('main/help', ['require', 'desmos', 'pjs', 'lib/underscore_view', 'main/graphs_controller', 'main/user_controller', 'main/user_modals', 'main/parse_json_errors', 'main/calculator_backend', 'templates/help', 'vendor/jquery.html5-placeholder-shim', 'main/examples_data', 'main/videos_data'], function (require) {
    var Desmos = require('desmos');
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var graphsController = require('main/graphs_controller');
    var userController = require('main/user_controller');
    var modals = require('main/user_modals');
    var parseJSONErrors = require('main/parse_json_errors');
    var calculatorBackend = require('main/calculator_backend');
    var TutorialVideoDialog = modals.TutorialVideoDialog;
    require('templates/help');
    require('vendor/jquery.html5-placeholder-shim');

    var EXAMPLES = require('main/examples_data');
    var VIDEOS = require('main/videos_data');


    function getCurrentUser() {
        return userController.get('currentUser');
    }

    /*
    * view for the settings bar
    */

    var HelpView = P(UnderscoreView, function (view, _super) {
        view.templateName = 'help';

        view.init = function () {
            _super.init.call(this);
            this.observe('isVisible', this.renderIsVisible.bind(this));
        };

        view.renderIsVisible = function () {
            var isVisible = this.getProperty('isVisible');
            this.$().toggle(isVisible);

            if (isVisible) {
                if ($.placeholder) $.placeholder.shim();
                this.$('.popover-interior').css("maxHeight", Desmos.SubheaderView.popoverHeight() + "px");

                // becomes hidden
            } else {
                this.setErrors([]);
                this.closeSuggestion();
            }
        };


        view.getTemplateParams = function () {
            return {
                examples: EXAMPLES,
                videos: VIDEOS
            };
        };

        view.setErrors = function (errors) {
            if (_.isEqual(errors, this.errors)) return;
            this.errors = errors;

            var div = this.$('.template-errors');
            div.children().remove();
            for (var i = 0; i < errors.length; i++) {
                div.append('<div class="errors">' + errors[i].message + '</div>');
            }
        };

        view.setProcessing = function (processing) {
            if (processing === this.processing) return;
            this.processing = processing;

            this.$('.template-processing').toggle(processing);
        };

        view.setLoggedIn = function (loggedIn) {
            if (loggedIn === this.loggedIn) return;
            this.loggedIn = loggedIn;

            this.$('.template-unlessuser').toggle(!loggedIn);
        };

        view.didInsertElement = function () {
            this.$('#suggestions textarea').on("focus", function () {
                $(this).animate({ "height": "5em" }, 200);
                $('#suggestions-expansion').show();
            });

            this.$('.action-launchvideo').on('tap', this.launchVideo.bind(this));
            this.$('.action-setstate').on('tap', this.setState.bind(this));
            this.$('.action-submit').on('submit', this.sendFeedback.bind(this));
            this.$('.action-closesuggestion').on('tap', this.closeSuggestion.bind(this));

            this.setErrors([]);
            this.setProcessing(false);
            this.setLoggedIn(!!getCurrentUser());
            this.setProperty('isVisible', false);
        };

        view.closeSuggestion = function () {
            this.$('#suggestions textarea').animate({ "height": "1.2em" }, 200).attr("value", "");
            this.$('#suggestions-expansion').fadeOut(200);
            this.setProcessing(false);
            this.setErrors([]);
        };

        //whether the feedback email is being sent
        view.sendFeedback = function (evt) {
            //don't submit the form
            evt.preventDefault();
            //don't repeat send
            if (this.processing) return;

            var message = $.trim(this.$('textarea[name="message"]').attr("value"));
            if (!message) {
                this.setErrors([{
                    message: 'Please enter your feedback and then press "Send"'
                }]);
                $('#suggestions').focus();
                return;
            }

            var feedbackData = {
                message: message,
                state: getState("escaped"),
                userAgent: navigator.userAgent,
                'anonymous-email': this.$('input[name="anonymous-email"]').attr("value")
            };

            // send feedback off
            var self = this;
            this.setProcessing(true);
            calculatorBackend.emailFeedback(feedbackData).done(function (msg) {
                self.$('#feedback-email-sent').show();
                self.setErrors([]);
                self.closeSuggestion();
                setTimeout(function () {
                    $('#feedback-email-sent').slideUp();
                }, 2000);
            }).fail(function (jqXHR) {
                self.setErrors(parseJSONErrors(jqXHR));
            }).always(function (msg) {
                self.setProcessing(false);
            });
        };

        view.launchVideo = function (evt) {
            var index = parseInt($(evt.currentTarget).attr('videoindex'), 10);
            var videoHash = VIDEOS[index].videoHash;
            var videoTitle = VIDEOS[index].title;
            console.log('launch: ', index);

            _kmq.push(['record', 'clicked watch video', {
                'video title': videoTitle,
                'video location': 'help'
            }]);


            //our help video modal is a little different than other modals (wider, no gray border)
            $('#state-modals').addClass("video-modal");

            TutorialVideoDialog.show();
            $('.tutorial_video_container').html('<iframe width="474" height="292" src="//www.youtube.com/embed/' + videoHash + '?autoplay=1" frameborder="0" allowfullscreen></iframe>');

        };

        view.setState = function (evt) {
            //close help
            this.setProperty('isVisible', false);

            //set state and title
            var index = parseInt($(evt.currentTarget).attr('exampleindex'), 10);
            var state = EXAMPLES[index].state;
            var title = EXAMPLES[index].title;

            setState(state, "escaped");
            graphsController.currentGraph.set("title", title);
        };

    })();

    $(function () {
        HelpView.appendTo('#subheader');


        userController.addObserver('currentUser', function () {
            HelpView.setLoggedIn(!!getCurrentUser());
        });
    });

    return HelpView;
});

// desmos/public/assets/grapher/compiled_underscore_templates/settings_desktop.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/settings_desktop', ["desmos"], function (Desmos) {
    Desmos.Templates["settings_desktop"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="settings-container" style="">\n  <div id="settings-scrollable" class="popover bottom">\n    <div class="popover-interior">\n      <div class="popover-title">Graph Paper</div>\n      <div class="popover-content">\n        <span id="projector-mode" class="btn btn-large btn-success action-projectormode">\n          <i class="icon-hdd"></i>\n          Projector<br />Mode\n        </span>\n        <label>\n          <input id="show-labels" type="checkbox" />\n          Show Labels\n        </label>\n        <br />\n        <label>\n          <input id="show-grid" type="checkbox" />\n          Show Grid Lines\n        </label>\n        <br />\n        <label>\n          <input id="show-axes" type="checkbox" />\n          Show Axes\n        </label>\n      </div>\n      <div class="popover-title interior-title">\n        Window            \n      </div>\n      <div class="popover-content">\n        <div class="window" id="x-window">\n          <table class="window-range">\n            <tbody>\n              <tr>\n                <td><input id="xmin" type="number" /></td>\n                <td>&lt;&nbsp;<b><i>x</i></b>&nbsp;&lt;</td>\n                <td><input id="xmax" type="number" /></td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n        <div class="window" id="y-window">\n          <table class="window-range">\n            <tbody>\n              <tr>\n                <td><input id="ymin" type="number" /></td>\n                <td>&lt;&nbsp;<b><i>y</i></b>&nbsp;&lt;</td>\n                <td><input id="ymax" type="number" /></td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n        <div style="clear:both; text-align:center;">\n          <button id="square-axes" class="btn btn-small disabled action-squareaxes">\n            equalize axis scales\n          </button>\n        </div>\n      </div>\n      <div class="popover-title interior-title">Trig Settings</div>\n      <div class="popover-content trig-settings">\n        <table class="pi-labels">\n          <tbody>\n            <tr>\n              <td>\n                <b><i>x</i></b>-axis labels:\n              </td>\n              <td>\n                <div class="btn-group">\n                  <span id="x-numlabels" class="btn active action-xpilabels">\n                    1, 2, 3\n                  </span>\n                  <span id="x-pilabels" class="btn action-xpilabels">\n                    <font class="pi">蟺, 2蟺, 3蟺</font>\n                  </span>\n                </div>\n              </td>\n            </tr>\n            <tr>\n              <td>\n                <b><i>y</i></b>-axis labels:\n              </td>\n              <td>\n                <div class="btn-group">\n                  <span id="y-numlabels" class="btn active action-ypilabels">\n                    1, 2, 3\n                  </span>\n                  <span id="y-pilabels" class="btn action-ypilabels">\n                    <font class="pi">蟺, 2蟺, 3蟺</font>\n                  </span>\n                </div>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <div class="btn-group fixed-width-btns">\n          <span class="btn active action-radianmode" id="radians">\n            radians\n          </span>\n          <span class="btn action-radianmode" id="degrees">\n            degrees\n          </span>\n        </div>\n      </div>\n      <div class="arrow"></div>\n    </div>\n  </div>\n</div>';
        }
        return __p;
    };
});
define('main/settings_view', ['require', 'pjs', 'desmos', 'lib/underscore_view', 'graphing/viewport', 'main/graph_settings'], function (require) {
    var P = require('pjs');
    var Desmos = require('desmos');
    var UnderscoreView = require('lib/underscore_view');
    var Viewport = require('graphing/viewport');
    var graphSettings = require('main/graph_settings');

    /*
    * view for the settings bar
    */
    var SettingsView = P(UnderscoreView, function (view, _super) {
        view.viewport = new Viewport();

        view.init = function () {
            _super.init.call(this);
            this.observe('isVisible', this.renderIsVisible.bind(this));
        };

        //overridden by settings_view_desktop and settings_view_tablet
        view.renderIsVisible = function () { };

        view.didInsertElement = function () {
            var self = this;

            this.setProperty('isVisible', false);

            this.$('.action-projectormode').on('tap', function () {
                graphSettings.setProperty('projectorMode', !graphSettings.projectorMode);
            });
            this.$('.action-squareaxes').on('tap', function () {
                graphSettings.setProperty("squareAxes", true);
            });
            this.$('#show-labels').on('change', function () {
                graphSettings.setProperty('showLabels', !!$(this).attr('checked'));
            });
            this.$('#show-grid').on('change', function () {
                graphSettings.setProperty('showGrid', !!$(this).attr('checked'));
            });
            this.$('#show-axes').on('change', function () {
                graphSettings.setProperty('showAxes', !!$(this).attr('checked'));
            });

            this.$('#xmin, #xmax, #ymin, #ymax')
        .on('keydown keyup keypress', this.onInputKeyPress.bind(this))
        .on('focusout', this.onFocusOut.bind(this))
        .on('focusin', this.onFocusIn.bind(this));

            this.updateTextInputs();
        };
        view.onInputKeyPress = function (evnt) {
            var xmin = parseFloat(this.$("#xmin").val());
            var xmax = parseFloat(this.$("#xmax").val());
            var ymin = parseFloat(this.$("#ymin").val());
            var ymax = parseFloat(this.$("#ymax").val());

            var tempViewport = new Viewport(xmin, xmax, ymin, ymax);
            this.$("#x-window").toggleClass("invalid", !tempViewport.isXValid());
            this.$("#y-window").toggleClass("invalid", !tempViewport.isYValid());

            graphSettings.setProperty('squareAxes', false);
            this.setViewport(tempViewport);
        };

        view.renderProjectorMode = function () {
            var pmode = graphSettings.projectorMode;
            this.$('#projector-mode').toggleClass('active', pmode);
        };

        view.renderXPiLabels = function () {
            var xpi = graphSettings.xAxisPiLabels;
            this.$("#x-numlabels").toggleClass('active', !xpi);
            this.$("#x-pilabels").toggleClass('active', xpi);
        };

        view.renderYPiLabels = function () {
            var ypi = graphSettings.yAxisPiLabels;
            this.$("#y-numlabels").toggleClass('active', !ypi);
            this.$("#y-pilabels").toggleClass('active', ypi);
        };

        view.renderDegreeMode = function () {
            var degrees = graphSettings.degreeMode;
            this.$("#radians").toggleClass('active', !degrees);
            this.$("#degrees").toggleClass('active', degrees);
        };

        view.renderSquareAxes = function () {
            var square = graphSettings.squareAxes;
            this.$("#square-axes")
          .toggleClass("disabled", square)
          .toggleClass("btn-success", !square);
        };

        view.renderShowLabels = function () {
            var checked = graphSettings.showLabels;
            var checkbox = this.$('#show-labels');
            if (checked) {
                checkbox.attr('checked', 'checked');
            } else {
                checkbox.removeAttr('checked');
            }
        };

        view.renderShowGrid = function () {
            var checked = graphSettings.showGrid;
            var checkbox = this.$('#show-grid');
            if (checked) {
                checkbox.attr('checked', 'checked');
            } else {
                checkbox.removeAttr('checked');
            }
        };

        view.renderShowAxes = function () {
            var checked = graphSettings.showAxes;
            var checkbox = this.$('#show-axes');
            if (checked) {
                checkbox.attr('checked', 'checked');
            } else {
                checkbox.removeAttr('checked');
            }
        };

        view.updateTextInputs = function () {
            this.$("#xmin").val(this.viewport.xmin);
            this.$("#ymin").val(this.viewport.ymin);
            this.$("#xmax").val(this.viewport.xmax);
            this.$("#ymax").val(this.viewport.ymax);
        };

        view.setViewport = function (newViewport) {
            if (newViewport.equals(this.viewport)) return;
            if (!newViewport.isValid()) return;

            this.viewport = newViewport.clone();

            // set lastChangedAxis
            var oldViewport = graphController.getViewport();
            if (oldViewport.ymax !== newViewport.ymax || oldViewport.ymin !== newViewport.ymin)
                graphSettings.lastChangedAxis = 'y';
            if (oldViewport.xmax !== newViewport.xmax || oldViewport.xmin !== newViewport.xmin)
                graphSettings.lastChangedAxis = 'x';

            this.updateTextInputs();
            graphController.setViewport(newViewport);
        };

        // FocusIn and FocusOut work together here to make sure the viewport is
        // set to an acceptable range after the viewport inputs are no longer
        // being edited.
        view.onFocusIn = function (evt) {
            clearTimeout(this.stopEditingTimeout);
        };

        view.onFocusOut = function (evt) {
            var self = this;

            this.stopEditingTimeout = setTimeout(function () {
                clearTimeout(self.stopEditingTimeout);
                self.updateTextInputs();
            }, 1);
        };

    });

    return SettingsView;
});

define('main/settings_view_desktop', ['require', 'pjs', 'desmos', 'lib/underscore_view', 'graphing/viewport', 'main/graph_settings', 'templates/settings_desktop', './settings_view'], function (require) {
    var P = require('pjs');
    var Desmos = require('desmos');
    var UnderscoreView = require('lib/underscore_view');
    var Viewport = require('graphing/viewport');
    var graphSettings = require('main/graph_settings');

    require('templates/settings_desktop');

    var SettingsView = require('./settings_view');

    /*
    * view for the settings bar
    */
    var SettingsViewDesktop = P(SettingsView, function (view, _super) {
        view.templateName = 'settings_desktop';

        view.didInsertElement = function () {
            _super.didInsertElement.call(this);

            //these feel better on tap on desktop,
            //but on tapstart in the mobile designs

            this.$('.action-xpilabels').on('tap', function () {
                graphSettings.setProperty('xAxisPiLabels', !graphSettings.xAxisPiLabels);
            });
            this.$('.action-ypilabels').on('tap', function () {
                graphSettings.setProperty('yAxisPiLabels', !graphSettings.yAxisPiLabels);
            });
            this.$('.action-radianmode').on('tap', function () {
                graphSettings.setProperty('degreeMode', !graphSettings.degreeMode);
            });
        };

        view.renderIsVisible = function () {
            var isVisible = this.getProperty('isVisible');
            this.$().toggle(isVisible);

            // becomes visible
            if (isVisible) {
                this.$('.popover-interior').css("maxHeight", Desmos.SubheaderView.popoverHeight() + "px");
            }
        };
    })();


    $(function () {
        SettingsViewDesktop.appendTo('#subheader');

        function addSettingsObserver(prop, func) {
            graphSettings.observe(prop, func.bind(this));
            func();
        }

        addSettingsObserver('projectorMode', SettingsViewDesktop.renderProjectorMode);
        addSettingsObserver('xAxisPiLabels', SettingsViewDesktop.renderXPiLabels);
        addSettingsObserver('yAxisPiLabels', SettingsViewDesktop.renderYPiLabels);
        addSettingsObserver('degreeMode', SettingsViewDesktop.renderDegreeMode);
        addSettingsObserver('squareAxes', SettingsViewDesktop.renderSquareAxes);
        addSettingsObserver('showLabels', SettingsViewDesktop.renderShowLabels);
        addSettingsObserver('showGrid', SettingsViewDesktop.renderShowGrid);
        addSettingsObserver('showAxes', SettingsViewDesktop.renderShowAxes);
    });

    return SettingsViewDesktop;
});

// desmos/public/assets/grapher/compiled_underscore_templates/subheader.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/subheader', ["desmos"], function (Desmos) {
    Desmos.Templates["subheader"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '\n<div id="subheader-div">\n  <table id="subheader-table">\n    <tr>\n      <td class="home-td">\n        <span class="widescreen">\n          <a href="/" target=\'_blank\' class="home-link" title="title">\n            <img src="/assets/grapher/img/desmos_logo_2x.png" width="98px" height="33px">\n          </a>\n        </span>\n        <span class="smallscreen-logo">\n          <a href="/" target=\'_blank\' class="home-link" title="title">\n            <img src="/assets/grapher/img/desmos_delta_2x.png" width="26px" height="33px">\n          </a>\n        </span>\n      </td>\n\n';
            if (user) {
                ; __p += '\n\n      <td>\n        <span class="do-not-blur tooltip invisible-button action-clearall"\n          tooltip="new blank graph" \n        >\n            <i class="icon-file"></i>\n        </span>\n      </td>\n      <td>\n        <span\n          id="my-graphs"\n          class="invisible-button tooltip action-mygraphs"\n          tooltip="view saved graphs"\n        >\n          <i class="icon-folder-open"></i>\n          <img src="/assets/grapher/img/ajax-loader.gif" width="16px" height="16px" id="saving-gif">\n        </span>\n      </td>\n      <td class="undo-redo widescreen">\n        <div class="btn-group left-btn-group">\n          <span \n            id="btn_undo" \n            class="btn btn-large undo-redo do-not-blur action-undo"\n          >\n              undo\n          </span>\n  \n          <span \n            id="btn_redo" \n            class="btn btn-large undo-redo do-not-blur action-redo"\n          >\n              redo\n          </span>\n        </div>\n      </td>\n      <td id="title-td">\n  \n        \n        <div id="title-div" class="action-savedialog">\n          \n          <span class="variable-title"></span>\n          <span class="no-title template-notitle">Untitled Graph</span>\n            \n          <span class=\'btn tooltip\' id=\'save-btn\' tooltip=\'save this graph\'>\n            <i class="icon-save"></i>\n          </span>\n        </div>\n  \n      </td>\n      <td class="share-btns">\n        \n        ';
                if (IS_ANDROID) {
                    ; __p += '\n  \n        <span \n          id="share_btn"\n          class=\'btn btn-large btn-primary tooltip android-share action-share\'\n          tooltip="Share this graph"\n        >\n            <img src=\'/assets/grapher/img/android-share.png\' width=\'20px\' height=\'20px\' alt=\'share\'>\n        </span>\n        \n        \n        ';
                } else {
                    ; __p += '\n          <div class="btn-group">\n            <span \n              id="print_btn"\n              class="btn btn-large btn-primary tooltip action-print"\n              tooltip="Print this graph"\n            >\n                <i class="icon-print"></i>\n            </span>\n            <span \n              id="share_btn"\n              class="btn btn-large btn-primary tooltip action-share"\n              tooltip="Share this graph"\n            >\n                <i class="icon-share"></i>\n            </span>\n          </div>      \n        ';
                }
                ; __p += '\n      </td>\n\n';
            } else {
                ; __p += '\n\n\n     <td id="no-acct">\n        <span class=\'optional-text\'>\n          Sign in to <b>save</b>, <b>share</b>, <b>print</b> and more:\n        </span>\n        <a class=\'btn btn-primary action-createaccount\'>Create <span class=\'optional-text\'>a Free</span> Account!</a>\n        or\n        <a class=\'login-btn action-login\'>Sign In</a>\n\n      </td>\n\n';
            }
            ; __p += '\n\n\n      <td>\n        <span \n          id="settings_btn" \n          class="tooltip invisible-button action-settings"\n          tooltip="Options"\n        >\n            <i class="icon-wrench"></i>\n        </span>\n      </td>\n      <td class="rightmost-td">\n        <span\n          id="help_btn"\n          class="tooltip invisible-button action-help"\n          tooltip="Help"\n        >\n            <i class="icon-question-sign"></i>\n        </span>\n      </td>\n    </tr>\n  </table>\n  \n  <div id="zoom-pillbox">\n      <span \n        class="btn btn-large tooltip-e action-zoomin"\n        tooltip="zoom in"\n      >\n          <i class="icon-plus"></i>\n      </span>\n      <br>\n      <span \n        class="btn btn-large tooltip-e action-zoomrestore"\n        tooltip="restore default zoom"\n      >\n          <i class="icon-home"></i>\n      </span>\n      <br>\n      <span \n        class="btn btn-large tooltip-e action-zoomout"\n        tooltip="zoom out"\n      >\n          <i class="icon-minus"></i>\n      </span>\n  </div>\n  \n  <div id=\'feedback-btn\' class="action-openfeedback">\n    <div>\n      feedback\n    </div>\n  </div>\n</div>';
        }
        return __p;
    };
});
/*
* subtoolbar
* this is the row of buttons above the calc
*/

define('main/subheader', ['require', 'lib/underscore_view', 'pjs', 'desmos', 'lib/browser', 'main/user_controller', 'main/graphs_controller', 'lib/track_feature', 'main/user_modals', 'undoredo', 'main/my_graphs', 'main/share_options', 'main/help', 'main/settings_view_desktop', 'templates/subheader'], function (require) {
    var UnderscoreView = require('lib/underscore_view');
    var P = require('pjs');
    var Desmos = require('desmos');
    var Browser = require('lib/browser');
    var userController = require('main/user_controller');
    var graphsController = require('main/graphs_controller');
    var Feature = require('lib/track_feature');
    var modals = require('main/user_modals');
    var UndoRedo = require('undoredo');

    var MyGraphsView = require('main/my_graphs');
    var ShareView = require('main/share_options');
    var HelpView = require('main/help');
    var GraphSettingsView = require('main/settings_view_desktop');
    require('templates/subheader');

    /*
    * view for the settings bar
    */

    var SubheaderView = P(UnderscoreView, function (view) {
        view.templateName = 'subheader';

        view.didInsertElement = function () {
            this.$().tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 500,
                delegate: '.tooltip'
            });

            var self = this;

            ['w', 'e'].forEach(function (dir) {
                self.$().tipsy({
                    fade: 'fast',
                    title: 'tooltip',
                    wait: 500,
                    gravity: dir,
                    delegate: '.tooltip-' + dir
                });
            });

            //bind to events in the graphs controller
            graphsController.startSavingCallbacks.push(this.saveStart.bind(this));
            graphsController.saveSuccessCallbacks.push(this.saveSuccess.bind(this));
            graphsController.saveErrorCallbacks.push(this.saveFailure.bind(this));

            //the below should happen automatically, but doesn't on iPad / android
            //this lets you defocus the currently focused expression by clicking the topbar
            $('#header').on("tapstart", function (evt) {
                Desmos.expressions.setSelected(null);
            });

            // event listeners
            this.$('.action-clearall').on('tap', this.clearAll.bind(this));
            this.$('.action-mygraphs').on('tap', this.myGraphs.bind(this));
            this.$('.action-undo').on('tap', this.undo.bind(this));
            this.$('.action-redo').on('tap', this.redo.bind(this));
            this.$('.action-savedialog').on('tap', this.saveDialog.bind(this));
            this.$('.action-share').on('tap', this.share.bind(this));
            this.$('.action-print').on('tap', this.print.bind(this));
            this.$('.action-settings').on('tap', this.settings.bind(this));
            this.$('.action-help').on('tap', this.help.bind(this));
            this.$('.action-zoomin').on('tap', this.zoomIn.bind(this));
            this.$('.action-zoomrestore').on('tap', this.zoomRestore.bind(this));
            this.$('.action-zoomout').on('tap', this.zoomOut.bind(this));
            this.$('.action-openfeedback').on('tap', this.openFeedbackForm.bind(this));
            this.$('.action-login').on('tap', this.login.bind(this));
            this.$('.action-createaccount').on('tap', this.createAccount.bind(this));
            this.updateTitle();
        };

        view.getTemplateParams = function () {
            return {
                IS_ANDROID: Browser.IS_ANDROID,
                user: userController.get('currentUser')
            };
        };

        view.updateTitle = function () {
            var title = graphsController.getPath('currentGraph.title');
            this.$('.variable-title').text(title ? title : '');
            this.$('.template-notitle').toggle(!title);
        };

        view.saveDialog = function () {
            modals.SaveDialog.show();
        };

        view.openFeedbackForm = function (evt) {
            //we need this timeout because the "help" window hides after a tap on the body
            //since we don't have a "stopPropogation" on evt, we need all of those taps
            //to clear out before opening up the feedback form
            if (!HelpView.getProperty('isVisible')) {
                this.menuPressed("help");
            }
            $('#suggestions').find("textarea").focus();
        };

        view.saveStart = function () {
            // Required to be idempotent because it may be called twice when the
            // user is required to log in before being allowed to save.
            this.$('#saving-gif').show();
            this.$('#my-graphs i').hide();
        };
        view.saveSuccess = function () {
            this.$('#saving-gif').hide();
            this.$('#my-graphs').addClass("btn-success");
            this.$('#my-graphs i').show();
            setTimeout(function () {
                this.$('#my-graphs').removeClass("btn-success");
            } .bind(this), 1500);
        };
        view.saveFailure = function () {
            this.$('#saving-gif').hide();
            this.$('#my-graphs i').show();
            this.$('#my-graphs').addClass("btn-danger");
            setTimeout(function () {
                this.$('#my-graphs').removeClass("btn-danger");
            } .bind(this), 1500);
        };

        view.print = function (evt) {
            //remove any prior screenshot images
            $('.screenshot').children().remove();

            //generate a new screenshot image. Why? Because for some reason printing
            //is awful colors when done straight from canvas
            //note: only matters for chrome/safari, because this image isn't rendered in time on firefox
            //and the canvas is printed instead.
            $('.screenshot').append("<img src='" + grapher.screenshot() + "'>");

            //execute a window.print
            window.print();
            return;
        };

        view.undo = function () {
            Feature.use('undo');
            UndoRedo.undo();
        };

        view.redo = function () {
            Feature.use('redo');
            UndoRedo.redo();
        },

    view.flashUndo = function (n) {
        var $undo = $('#btn_undo');

        $undo.addClass("btn-success");
        setTimeout(function () { $undo.removeClass("btn-success") }, 1500);
    };

        view.clearAll = function () {
            graphsController.clearGraph();
        };


        //
        // right hand tools
        //

        view.zoomIn = function () {
            Feature.use('Zoom In');
            graphController.zoom("in");
        };

        view.zoomRestore = function () {
            Feature.use('Zoom Restore');
            graphController.zoom("default");
        };

        view.zoomOut = function () {
            Feature.use('Zoom Out');
            graphController.zoom("out");
        };

        view.login = function () {
            _kmq.push(['record', 'started login', { 'login location': 'subheader'}]);
            modals.LoginDialog.show();
        };

        view.createAccount = function () {
            _kmq.push(['record', 'started signup', {
                'signup location': 'subheader'
            }]);
            modals.CreateAccountDialog.show();
        };

        view.share = function () {
            this.menuPressed(ShareView);
        };

        view.settings = function () {
            this.menuPressed(GraphSettingsView);
        };

        view.help = function () {
            this.menuPressed(HelpView);
        };

        view.myGraphs = function () {
            this.menuPressed(MyGraphsView);
        };

        //just avoiding duplicate code.
        //opens a right-hand-side menu (and closes the others) on click/touch
        view.menuPressed = function (view) {

            // blur any textbox that has focus. On some devices, such as ipad
            // and nexus 7, this doesn't happen automatically.
            Desmos.expressions.setSelected(null);

            var cached_value = view.getProperty('isVisible');
            HelpView.setProperty('isVisible', false);
            GraphSettingsView.setProperty('isVisible', false);
            MyGraphsView.setProperty('isVisible', false);
            ShareView.setProperty('isVisible', false);

            view.setProperty('isVisible', !cached_value);
        };


        //each of the dropdowns (share_options, graph_settings, help)
        //queries this to find out how tall it should (max)
        view.popoverHeight = function () {
            var height = $(window).height();
            var subheaderTop = $('#subheader').position().top;
            return height - subheaderTop - 52;
        };

    })();

    //
    // DOM listeners for the right hand views.
    // don't love having these here, but it felt like it made more sense than inside subheaderview
    // and was cleaner than duplicating this code inside of each of those js files
    //
    function setupCloseListener(view, btn, closeCondition) {
        view.observe('isVisible', function () {
            var template = view.templateName;
            var isVisible = view.getProperty('isVisible');
            $(btn).toggleClass("active", isVisible);

            if (isVisible) {
                $(document).on("tap." + template, function (e) {
                    if (closeCondition(e)) {
                        view.setProperty('isVisible', false);
                    }
                });
            } else {
                $(document).off("tap." + template);
            }

        });
    }

    setupCloseListener(GraphSettingsView, '#settings_btn', function (e) {
        return !$(e.target).closest("#settings_btn").length && !$(e.target).closest("#settings-container").length;
    });

    setupCloseListener(MyGraphsView, '#my-graphs', function (e) {
        return !$(e.target).closest("#my-graphs").length && !$(e.target).closest("#save_btn").length && !$(e.target).closest("#title-td").length && !$(e.target).closest("#my-graphs-container").length && !$(e.target).closest("#state-modals").length && $(e.target).attr("id") != "modal_background";
    });

    setupCloseListener(HelpView, '#help_btn', function (e) {
        return !$(e.target).closest("#help_btn").length && !$(e.target).closest("#help-container").length && !$(e.target).closest("#feedback-btn").length && !$(e.target).closest("#state-modals").length && $(e.target).attr("id") != "modal_background";
    });

    setupCloseListener(ShareView, '#share_btn', function (e) {
        //close this unless:
        // * you click inside it
        // * you click on a popped-up modal (say: login, triggered by the login form)
        // * you click on the visible modal_background (same as above)
        return !$(e.target).closest("#share_btn").length && !$(e.target).closest("#share-scrollable").length && !$(e.target).closest("#state-modals").length && $(e.target).attr("id") != "modal_background";
    });

    Desmos.SubheaderView = SubheaderView;

    $(function () {
        // div#subheader already exists in markup because it acts to structure
        // the page before ember templates are inserted. Stick this view inside
        // it.
        SubheaderView.appendTo('#subheader');
        graphsController.addObserver('currentGraph.title', SubheaderView.updateTitle.bind(SubheaderView));

        userController.addObserver('currentUser', function () {
            SubheaderView.rerender();
        });
    });
});

// desmos/public/assets/grapher/compiled_underscore_templates/top_identity.js
// DO NOT EDIT
// This file was generated by ./script/compile_underscore.
define('templates/top_identity', ["desmos"], function (Desmos) {
    Desmos.Templates["top_identity"] = function (obj) {
        var __p = ''; var print = function () { __p += Array.prototype.join.call(arguments, '') };
        with (obj || {}) {
            __p += '<div id="top_identity">\n  ';
            if (user) {
                ; __p += '\n    <span id="top_logout" class="gray_btn">\n      <span class="email">\n        ';
                if (user.isDriveUser) {
                    ; __p += '\n        <img height=16 width=16 src="/assets/grapher/img/drive_icon_16.png" class="drive-icon" />\n        ';
                }
                ; __p += '\n        ' +
(user.email) +
'\n      </span>\n    </span>\n  \n    <ul id="logout_options">\n      <li><a class="action-editaccount">Edit Account</a></li>\n      <li><a class="action-logout">Sign Out</a></li>\n    </ul>\n  ';
            } else {
                ; __p += '\n    <a class="action-login">Sign In</a>\n    <a class="action-createaccount">Create Account!</a>\n  ';
            }
            ; __p += '\n</div>\n';
        }
        return __p;
    };
});

/*
* top identity dropdown & view
*/
define('main/top_identity', ['require', 'pjs', 'lib/underscore_view', 'main/user_controller', 'templates/top_identity', 'main/user_modals'], function (require) {
    var P = require('pjs');
    var UnderscoreView = require('lib/underscore_view');
    var userController = require('main/user_controller');
    require('templates/top_identity');
    var modals = require('main/user_modals');
    var EditAccountDialog = modals.EditAccountDialog;

    var TopIdentityView = P(UnderscoreView, function (view) {
        view.templateName = 'top_identity';

        view.getTemplateParams = function () {
            var params = { user: null };

            var user = userController.currentUser;
            if (user) {
                params.user = {
                    email: user.get('email'),
                    isDriveUser: user.get('isDriveUser')
                };
            }

            return params;
        };

        view.didInsertElement = function () {
            makeDropDown(this.$(), '#top_logout', '#logout_options');
            this.$('.action-login').on('tap', this.login.bind(this));
            this.$('.action-logout').on('tap', this.logout.bind(this));
            this.$('.action-editaccount').on('tap', this.editAccount.bind(this));
            this.$('.action-createaccount').on('tap', this.createAccount.bind(this));
        };

        view.editAccount = function () {
            EditAccountDialog.show();
        };

        view.logout = function () {
            userController.logout();
        };

        view.login = function () {
            _kmq.push(['record', 'started login', { 'login location': 'top bar'}]);
            modals.LoginDialog.show();
        };

        view.createAccount = function () {
            _kmq.push(['record', 'started signup', { 'signup location': 'top bar'}]);
            modals.CreateAccountDialog.show();
        };

    })();

    function makeDropDown(container, target, content) {
        container = $(container);
        container.on("tap", target, function () {
            container.find(content).toggle();
            $(target).toggleClass('drop_down');
            return false;
        });

        $(document).on("tap", function () {
            container.find(content).hide();
            $(target).removeClass('drop_down');
        });
    }

    $(function () {
        TopIdentityView.appendTo('#header');

        // render this template again any time that the user changes.
        // NOTE: rerender() is more appropriate than .render()
        userController.addObserver('currentUser', function () {
            TopIdentityView.rerender();
        });

    });
});

// Initialize google analytics
window._gaq = window._gaq || [];
_gaq.push(['_setAccount', 'UA-22127755-1']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

define("analytics/google_analytics", function () { });

requirejs(['analytics/google_analytics'], function () {
    var pageload_timestamp = new Date();

    function heartbeat() {
        n = Math.round((new Date() - pageload_timestamp) / (60 * 1000)); //Low resolution since google analytics only allows 500 events per user-session
        _gaq.push(['_trackEvent', 'Heartbeat', +n + ' minutes']);
    }

    setInterval(heartbeat, 60 * 1000); // Record heartbeat every minute
})();


define("main/heartbeat", function () { });

requirejs(['jquery', 'analytics/google_analytics'], function () {
    // use google analytics to log client javascript errors
    window.onerror = function (message, file, line) {
        var sFormattedMessage = '[' + file + ' (' + line + ')] ' + message;
        _gaq.push(['_trackEvent', 'Exceptions', 'Application', sFormattedMessage, null, true]);
    };

    // Also log ajax errors
    $(document).ajaxError(function (event, request, settings, thrownError) {
        // Would be nice to include settings.data, but I'm afraid of (among other things),
        // ending up with a bunch of plain text passwords in our analytics
        var sFormattedMessage = settings.type + ' ' + window.location.protocol + '//' + window.location.host + settings.url + ' ' + request.status + ' (' + request.statusText + ')';
        _gaq.push(['_trackEvent', 'Exceptions', 'Ajax', sFormattedMessage, null, true]);
    });
});

define("main/log_errors", function () { });

//Abstract out getState and setState functionality
//TODO - setState is still pretty gross, but this is better than copy/pasting that grossness

define('main/state_controller', ['require', 'main/graph_settings', 'undoredo'], function (require) {
    var graphSettings = require('main/graph_settings');
    var UndoRedo = require('undoredo');

    var BLANK_STATE = { 'graph': { 'viewport': { 'xmin': -10, 'xmax': 10, 'ymin': -10, 'ymax': 10 }, 'showLabels': true, 'showGrid': true, 'showAxes': true, 'squareAxes': true, 'labelXMode': '', 'labelYMode': '' }, 'expressions': { 'list': [{ 'id': 1, 'latex': '', 'selected': true, 'color': { 'index': 8678, 'value': '#C0504D'}}]} };
    var isFirstSetState = true;

    var graphController;
    var expressionsModel;

    var initialize = function (g, e) {
        graphController = g;
        expressionsModel = e;
    };

    var verifyInitialized = function () {
        if (!graphController || !expressionsModel) throw "stateController not initialized yet";
    };

    var getState = function (encoding) {
        var str;
        var obj = {
            graph: graphController.getState(),
            expressions: expressionsModel.getState()
        };
        if (encoding == 'escaped') {
            return escape(JSON.stringify(obj));
        } else {
            return obj;
        }
    };

    var setState = function (state, encoding) {

        graphSettings.setProperty('POIs', false);

        //don't set blank state more than once
        if (!isFirstSetState && (state === null) && expressionsModel.isEmpty()) {
            return;
        }

        var manipulator = function (state, encoding) {
            if (!state) state = BLANK_STATE;
            if (encoding === 'escaped' || typeof state === 'string') {
                try {
                    state = JSON.parse(unescape(state));
                } catch (e) {
                    alert('invalid state!'); return;
                }
            }

            // Empty the evaluator and the graph so that when we switch to the new
            // viewport, we don't flash a rescaled version of the old state.
            if ('expressions' in state) expressionsModel.setState({ list: [] });

            grapher.clear();
            grapher.redrawGraphsLayer();

            if ('graph' in state) {
                if (!('degreeMode' in state.graph)) state.graph.degreeMode = false;

                graphController.setState(state.graph);
            }

            if ('expressions' in state) {
                expressionsModel.setState(state.expressions);
            }
        };

        //apply it this first time, but don't add to undo/redo
        if (isFirstSetState) {
            manipulator(state, encoding);
            isFirstSetState = false;
            return;
        }

        var curState = getState();
        UndoRedo.addTransaction({
            type: UndoRedo.CAUSE_OF_CHANGE,
            undo: function () { manipulator(curState); },
            redo: function () { manipulator(state, encoding); },

            // we stringify two json objects that come out of the same function. If
            // the objects are the same, then the stringified versions will be
            // exactly the same.
            ensureChangeOccured: function () {
                var newState = JSON.stringify(getState());
                var oldState = JSON.stringify(curState);

                return oldState === newState;
            }
        });
    };

    return {
        getState: getState,
        setState: setState,
        setBlank: function () { setState(BLANK_STATE); },
        initialize: initialize
    };
});

define('main/calc_desktop', ['require', 'exports', 'module', 'jquery', 'main/evaluator', 'graphing/grapher', 'graphing/poicontroller', 'graphing/graphcontroller', 'main/user_controller', 'main/graphs_controller', 'math/builtin', 'main/graph_settings', 'main/timermodules', 'expressions/list_view_desktop', 'main/resize', 'undoredo', 'lib/ipad.scrollfix', 'lib/browser', 'main/user_modals', 'main/desmos_user', 'main/subheader', 'main/settings_view_desktop', 'main/top_identity', 'expressions/dragdrop', 'main/heartbeat', 'main/log_errors', 'main/state_controller'], function (require, exports, module) {
    var $ = require('jquery');
    var Evaluator = require('main/evaluator');
    var Grapher = require('graphing/grapher');
    var POIController = require('graphing/poicontroller');
    var GraphController = require('graphing/graphcontroller');
    var userController = require('main/user_controller');
    var graphsController = require('main/graphs_controller');
    var BuiltIn = require('math/builtin');
    var graphSettings = require('main/graph_settings');
    var timerModules = require('main/timermodules');
    var expressions = require('expressions/list_view_desktop');
    var Resize = require('main/resize');
    var UndoRedo = require('undoredo');
    require('lib/ipad.scrollfix');
    var Browser = require('lib/browser');
    var modals = require('main/user_modals');
    require('main/desmos_user');
    require('main/subheader');
    var SettingsViewDesktop = require('main/settings_view_desktop');
    require('main/top_identity');
    var DragDrop = require('expressions/dragdrop');
    // Send a heartbeat to google analytics once per minute
    require('main/heartbeat');
    // Send js and ajax errors to google analytics
    require('main/log_errors');
    var stateController = require('main/state_controller');

    poiController = null;
    graphController = null;
    grapher = null;
    evaluator = null;

    Desmos.expressions = expressions;

    // Create the evaluator early so that the webworker gets downloaded before
    // symbola and my_graphs. Create grapher here too so that we could potentially
    // begin graphing before document.ready
    (function () {
        var workerPath = $('body').data('worker-path');
        evaluator = Evaluator(workerPath);
        grapher = new Grapher($('#grapher'), graphSettings);
        poiController = new POIController(grapher);
        graphController = new GraphController(grapher);
        stateController.initialize(graphController, expressions.model);
        graphController.triggerViewportStable = function () {
            evaluator.setViewState({
                viewport: grapher.viewport.toObject(),
                screen: grapher.screen
            });

            // if we've set it back to square, keep it square on changes
            if (grapher.viewport.isSquare(grapher.screen)) {
                grapher.settings.setProperty('squareAxes', true);
            }

            // TODO - this might cause graphController.setViewport() a few times. That
            //        in turn might cause this exact same function to get called a few
            //        times. After all settings have been saved, a call to setProperties()
            //        will do nothing and will not call graphController.setViewport().
            //
            //        would be better if the observer inside of graph_settings.js
            //        fired only once. But even then we'd call evaluator.recompute()
            //        twice here. Once the line above and once the line below.
            SettingsViewDesktop.setViewport(graphController.getViewport());
        };

        graphSettings.observe('degreeMode', function () {
            var degreeMode = graphSettings.degreeMode;

            BuiltIn.setDegreeMode(degreeMode);
            evaluator.setDegreeMode(degreeMode);
        });

        evaluator.triggerChange = function (changes) {
            expressions.onChange(changes);
        };
        evaluator.triggerGraphComputed = function (id) {
            var selected = expressions.getSelected();

            if (selected && selected.isTable) {
                var selectedCell = selected.selectedCell;
                if (selectedCell) {
                    selected = selected.columns[selectedCell.column];
                } else {
                    selected = null;
                }
            }

            // Want to only show POIs if the graph being redrawn is selected.
            if (selected && selected.id.toString() === id) {
                var sketch = grapher.getGraphSketch(id);
                if (sketch) sketch.showPOI = sketch.showHighlight = true;
            }
        };

        expressions.triggerAddExp = function (obj) {
            if (!obj) return;
            // if we've completely erased the contents of this expression, then
            // we need to act like it's a new expression. We remove the old sketch
            // so that we don't remember POI information.
            if (obj.latex === '' && this.type !== 'table') {
                grapher.removeGraphSketch(obj.id);
            }

            evaluator.addStatement(obj);
        };
        expressions.triggerRemoveExp = function (id) {
            evaluator.removeStatement(id);
        };
        expressions.triggerRemoveExps = function (ids) {
            // TODO - start multiple updates
            for (var i = 0; i < ids.length; i++) {
                evaluator.removeStatement(ids[i]);
            }
            // TODO - end multiple updates
        };
        expressions.model.triggerCompleteState = function (state) {
            evaluator.setCompleteState(state);
        };

        var lastSelectedId;
        var lastSelectedModel;

        // Show pois for the currently selected equation.
        var onSelectedExpressionChange = function () {
            var selected = expressions.getSelected();
            // setups up a listener for changes in selection within tables. It's fine
            // that we add these observers for even non-tables.
            if (selected !== lastSelectedModel) {
                if (lastSelectedModel) {
                    lastSelectedModel.unobserve('selectedCell.calcjs');
                }
                if (selected) {
                    selected.observe('selectedCell.calcjs', onSelectedExpressionChange);
                }
                lastSelectedModel = selected;
            }

            var selectedId = (selected) ? selected.id : undefined;

            if (selected && selected.isTable) {
                var selectedCell = selected.selectedCell;
                if (selectedCell) {
                    var selectedCol = selected.columns[selectedCell.column];
                    selectedId = selectedCol ? selectedCol.id : undefined;
                } else {
                    selectedId = undefined;
                }
            }

            var idChanged = (selectedId !== lastSelectedId);

            if (idChanged) {
                var prevSketch = grapher.getGraphSketch(lastSelectedId);
                if (prevSketch) prevSketch.showPOI = prevSketch.showHighlight = false;

                var newSketch = grapher.getGraphSketch(selectedId);
                if (newSketch) newSketch.showPOI = newSketch.showHighlight = true;

                updateIntersectIds(selectedId);
                evaluator.updateIntersections(selectedId);
            }

            lastSelectedId = selectedId;
        };

        expressions.observe('selectedItem', onSelectedExpressionChange);

        var updateIntersectIds = function (selectedId) {
            var intersectIds = grapher.getOpenIntersectionIds();
            if (typeof selectedId !== "undefined") intersectIds[selectedId] = true;
            evaluator.setIntersectIds(intersectIds);
        };

        poiController.triggerTraceDown = function (id) {
            var expr = expressions.getItemById(id);

            // TODO - think hard about what we want to do about this situation. Do
            // we want children to be registered as normal items on the expression
            // list or do we want them distinguished as children?
            // if we didn't find a root element, check if this is a child element.
            if (!expr) expr = expressions.getChildItemById(id);

            $(document.activeElement).blur();

            // if the expression is already selected, just make the oberservers of
            // expr.selected fire. If it isn't selected, set it. If there is no
            // expr, then set nothing to selected.
            if (expr && expr.selected) {
                expr.notifyPropertyChange('selected');
            } else {
                expressions.setSelected(expr);
            }
        };

        poiController.triggerOpenPOIChanged = function () {
            updateIntersectIds(lastSelectedId);
        };

        // setup ajax so that any time we get a 401 Unauthorized response that it
        // sends us to loggedOut
        $.ajaxSetup({ statusCode: { 401: function () { userController.logout(); } } });
    })();

    //This top-level location should becomes the place where all nontrivial document.ready() activities happen
    $(document).ready(function () {
        expressions.appendTo('body');

        //Pulling these to the top level for increased visibility.
        //Would ideally like to get rid of these
        DragDrop.init(Desmos.expressions);
        timerModules.load('expressions.renderviewport', expressions);
        timerModules.load('expressions.togglekeypad', expressions, Desmos.keypadView);

        //setInterval(logHeartbeat, 60 * 1000); //Record heartbeat every minute

        //Setup undo-redo listeners
        $(document).bind('keydown', UndoRedo.handleKeydown.bind(UndoRedo));

        //Show warning modal for unsupported browsers (because of screensize, for example)
        if (!Browser.CAPABLE_BROWSER) {
            modals.UnsupportedBrowserDialog.show();
        }

    });
    window.setState = stateController.setState; //TODO - let users require these directly
    window.getState = stateController.getState; //TODO - let users require these directly

    graphsController.currentGraphDidChange();

    return {
        userController: userController,
        expressions: expressions,
        grapher: grapher,
        evaluator: evaluator
    };

});


requirejs(['main/calc_desktop'], function (Calc) {
    // Calc global has singletons like expressions and userController that are
    // useful for debugging and testing.
    window.Calc = Calc;
});

define("toplevel/calculator_desktop", function () { });

//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function () {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `global` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var slice = ArrayProto.slice,
      unshift = ArrayProto.unshift,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var 
    nativeForEach = ArrayProto.forEach,
    nativeMap = ArrayProto.map,
    nativeReduce = ArrayProto.reduce,
    nativeReduceRight = ArrayProto.reduceRight,
    nativeFilter = ArrayProto.filter,
    nativeEvery = ArrayProto.every,
    nativeSome = ArrayProto.some,
    nativeIndexOf = ArrayProto.indexOf,
    nativeLastIndexOf = ArrayProto.lastIndexOf,
    nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeBind = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function (obj) { return new wrapper(obj); };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root['_'] = _;
    }

    // Current version.
    _.VERSION = '1.3.3';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function (obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
            }
        } else {
            for (var key in obj) {
                if (_.has(obj, key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) return;
                }
            }
        }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function (obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        each(obj, function (value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });
        if (obj.length === +obj.length) results.length = obj.length;
        return results;
    };

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function (value, index, list) {
            if (!initial) {
                memo = value;
                initial = true;
            } else {
                memo = iterator.call(context, memo, value, index, list);
            }
        });
        if (!initial) throw new TypeError('Reduce of empty array with no initial value');
        return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var reversed = _.toArray(obj).reverse();
        if (context && !initial) iterator = _.bind(iterator, context);
        return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function (obj, iterator, context) {
        var result;
        any(obj, function (value, index, list) {
            if (iterator.call(context, value, index, list)) {
                result = value;
                return true;
            }
        });
        return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function (obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
        each(obj, function (value, index, list) {
            if (iterator.call(context, value, index, list)) results[results.length] = value;
        });
        return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function (obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        each(obj, function (value, index, list) {
            if (!iterator.call(context, value, index, list)) results[results.length] = value;
        });
        return results;
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function (obj, iterator, context) {
        var result = true;
        if (obj == null) return result;
        if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
        each(obj, function (value, index, list) {
            if (!(result = result && iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function (obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = false;
        if (obj == null) return result;
        if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
        each(obj, function (value, index, list) {
            if (result || (result = iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };

    // Determine if a given value is included in the array or object using `===`.
    // Aliased as `contains`.
    _.include = _.contains = function (obj, target) {
        var found = false;
        if (obj == null) return found;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
        found = any(obj, function (value) {
            return value === target;
        });
        return found;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function (obj, method) {
        var args = slice.call(arguments, 2);
        return _.map(obj, function (value) {
            return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
        });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function (obj, key) {
        return _.map(obj, function (value) { return value[key]; });
    };

    // Return the maximum element or (element-based computation).
    _.max = function (obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
        if (!iterator && _.isEmpty(obj)) return -Infinity;
        var result = { computed: -Infinity };
        each(obj, function (value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed >= result.computed && (result = { value: value, computed: computed });
        });
        return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function (obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
        if (!iterator && _.isEmpty(obj)) return Infinity;
        var result = { computed: Infinity };
        each(obj, function (value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed < result.computed && (result = { value: value, computed: computed });
        });
        return result.value;
    };

    // Shuffle an array.
    _.shuffle = function (obj) {
        var shuffled = [], rand;
        each(obj, function (value, index, list) {
            rand = Math.floor(Math.random() * (index + 1));
            shuffled[index] = shuffled[rand];
            shuffled[rand] = value;
        });
        return shuffled;
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function (obj, val, context) {
        var iterator = _.isFunction(val) ? val : function (obj) { return obj[val]; };
        return _.pluck(_.map(obj, function (value, index, list) {
            return {
                value: value,
                criteria: iterator.call(context, value, index, list)
            };
        }).sort(function (left, right) {
            var a = left.criteria, b = right.criteria;
            if (a === void 0) return 1;
            if (b === void 0) return -1;
            return a < b ? -1 : a > b ? 1 : 0;
        }), 'value');
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = function (obj, val) {
        var result = {};
        var iterator = _.isFunction(val) ? val : function (obj) { return obj[val]; };
        each(obj, function (value, index) {
            var key = iterator(value, index);
            (result[key] || (result[key] = [])).push(value);
        });
        return result;
    };

    // Use a comparator function to figure out at what index an object should
    // be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function (array, obj, iterator) {
        iterator || (iterator = _.identity);
        var low = 0, high = array.length;
        while (low < high) {
            var mid = (low + high) >> 1;
            iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
        }
        return low;
    };

    // Safely convert anything iterable into a real, live array.
    _.toArray = function (obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (_.isArguments(obj)) return slice.call(obj);
        if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
        return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function (obj) {
        return _.isArray(obj) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function (array, n, guard) {
        return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
    };

    // Returns everything but the last entry of the array. Especcialy useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function (array, n, guard) {
        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function (array, n, guard) {
        if ((n != null) && !guard) {
            return slice.call(array, Math.max(array.length - n, 0));
        } else {
            return array[array.length - 1];
        }
    };

    // Returns everything but the first entry of the array. Aliased as `tail`.
    // Especially useful on the arguments object. Passing an **index** will return
    // the rest of the values in the array from that index onward. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = function (array, index, guard) {
        return slice.call(array, (index == null) || guard ? 1 : index);
    };

    // Trim out all falsy values from an array.
    _.compact = function (array) {
        return _.filter(array, function (value) { return !!value; });
    };

    // Return a completely flattened version of an array.
    _.flatten = function (array, shallow) {
        return _.reduce(array, function (memo, value) {
            if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
            memo[memo.length] = value;
            return memo;
        }, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function (array) {
        return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function (array, isSorted, iterator) {
        var initial = iterator ? _.map(array, iterator) : array;
        var results = [];
        // The `isSorted` flag is irrelevant if the array only contains two elements.
        if (array.length < 3) isSorted = true;
        _.reduce(initial, function (memo, value, index) {
            if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
                memo.push(value);
                results.push(array[index]);
            }
            return memo;
        }, []);
        return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function () {
        return _.uniq(_.flatten(arguments, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays. (Aliased as "intersect" for back-compat.)
    _.intersection = _.intersect = function (array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function (item) {
            return _.every(rest, function (other) {
                return _.indexOf(other, item) >= 0;
            });
        });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function (array) {
        var rest = _.flatten(slice.call(arguments, 1), true);
        return _.filter(array, function (value) { return !_.include(rest, value); });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function () {
        var args = slice.call(arguments);
        var length = _.max(_.pluck(args, 'length'));
        var results = new Array(length);
        for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
        return results;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function (array, item, isSorted) {
        if (array == null) return -1;
        var i, l;
        if (isSorted) {
            i = _.sortedIndex(array, item);
            return array[i] === item ? i : -1;
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
        for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
        return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function (array, item) {
        if (array == null) return -1;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
        var i = array.length;
        while (i--) if (i in array && array[i] === item) return i;
        return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function (start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var len = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(len);

        while (idx < len) {
            range[idx++] = start;
            start += step;
        }

        return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function () { };

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Binding with arguments is also known as `curry`.
    // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
    // We check for `func.bind` first, to fail fast when `func` is undefined.
    _.bind = function bind(func, context) {
        var bound, args;
        if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError;
        args = slice.call(arguments, 2);
        return bound = function () {
            if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
            ctor.prototype = func.prototype;
            var self = new ctor;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return self;
        };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function (obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length == 0) funcs = _.functions(obj);
        each(funcs, function (f) { obj[f] = _.bind(obj[f], obj); });
        return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function (func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function () {
            var key = hasher.apply(this, arguments);
            return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
        };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function (func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function () { return func.apply(null, args); }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function (func) {
        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time.
    _.throttle = function (func, wait) {
        var context, args, timeout, throttling, more, result;
        var whenDone = _.debounce(function () { more = throttling = false; }, wait);
        return function () {
            context = this; args = arguments;
            var later = function () {
                timeout = null;
                if (more) func.apply(context, args);
                whenDone();
            };
            if (!timeout) timeout = setTimeout(later, wait);
            if (throttling) {
                more = true;
            } else {
                result = func.apply(context, args);
            }
            whenDone();
            throttling = true;
            return result;
        };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function (func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            if (immediate && !timeout) func.apply(context, args);
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function (func) {
        var ran = false, memo;
        return function () {
            if (ran) return memo;
            ran = true;
            return memo = func.apply(this, arguments);
        };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function (func, wrapper) {
        return function () {
            var args = [func].concat(slice.call(arguments, 0));
            return wrapper.apply(this, args);
        };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function () {
        var funcs = arguments;
        return function () {
            var args = arguments;
            for (var i = funcs.length - 1; i >= 0; i--) {
                args = [funcs[i].apply(this, args)];
            }
            return args[0];
        };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function (times, func) {
        if (times <= 0) return func();
        return function () {
            if (--times < 1) { return func.apply(this, arguments); }
        };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function (obj) {
        if (obj !== Object(obj)) throw new TypeError('Invalid object');
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
        return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function (obj) {
        return _.map(obj, _.identity);
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function (obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function (obj) {
        each(slice.call(arguments, 1), function (source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        });
        return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function (obj) {
        var result = {};
        each(_.flatten(slice.call(arguments, 1)), function (key) {
            if (key in obj) result[key] = obj[key];
        });
        return result;
    };

    // Fill in a given object with default properties.
    _.defaults = function (obj) {
        each(slice.call(arguments, 1), function (source) {
            for (var prop in source) {
                if (obj[prop] == null) obj[prop] = source[prop];
            }
        });
        return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function (obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function (obj, interceptor) {
        interceptor(obj);
        return obj;
    };

    // Internal recursive comparison function.
    function eq(a, b, stack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a._chain) a = a._wrapped;
        if (b._chain) b = b._wrapped;
        // Invoke a custom `isEqual` method if one is provided.
        if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
        if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className != toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, dates, and booleans are compared by value. 
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return a == String(b);
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                // other numeric values.
                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a == +b;
                // RegExps are compared by their source patterns and flags.
            case '[object RegExp]':
                return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object') return false;
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        var length = stack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (stack[length] == a) return true;
        }
        // Add the first object to the stack of traversed objects.
        stack.push(a);
        var size = 0, result = true;
        // Recursively compare objects and arrays.
        if (className == '[object Array]') {
            // Compare array lengths to determine if a deep comparison is necessary.
            size = a.length;
            result = size == b.length;
            if (result) {
                // Deep compare the contents, ignoring non-numeric properties.
                while (size--) {
                    // Ensure commutative equality for sparse arrays.
                    if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
                }
            }
        } else {
            // Objects with different constructors are not equivalent.
            if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
            // Deep compare objects.
            for (var key in a) {
                if (_.has(a, key)) {
                    // Count the expected number of properties.
                    size++;
                    // Deep compare each member.
                    if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
                }
            }
            // Ensure that both objects contain the same number of properties.
            if (result) {
                for (key in b) {
                    if (_.has(b, key) && !(size--)) break;
                }
                result = !size;
            }
        }
        // Remove the first object from the stack of traversed objects.
        stack.pop();
        return result;
    }

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function (a, b) {
        return eq(a, b, []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function (obj) {
        if (obj == null) return true;
        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
        for (var key in obj) if (_.has(obj, key)) return false;
        return true;
    };

    // Is a given value a DOM element?
    _.isElement = function (obj) {
        return !!(obj && obj.nodeType == 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function (obj) {
        return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function (obj) {
        return obj === Object(obj);
    };

    // Is a given variable an arguments object?
    _.isArguments = function (obj) {
        return toString.call(obj) == '[object Arguments]';
    };
    if (!_.isArguments(arguments)) {
        _.isArguments = function (obj) {
            return !!(obj && _.has(obj, 'callee'));
        };
    }

    // Is a given value a function?
    _.isFunction = function (obj) {
        return toString.call(obj) == '[object Function]';
    };

    // Is a given value a string?
    _.isString = function (obj) {
        return toString.call(obj) == '[object String]';
    };

    // Is a given value a number?
    _.isNumber = function (obj) {
        return toString.call(obj) == '[object Number]';
    };

    // Is a given object a finite number?
    _.isFinite = function (obj) {
        return _.isNumber(obj) && isFinite(obj);
    };

    // Is the given value `NaN`?
    _.isNaN = function (obj) {
        // `NaN` is the only value for which `===` is not reflexive.
        return obj !== obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function (obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value a date?
    _.isDate = function (obj) {
        return toString.call(obj) == '[object Date]';
    };

    // Is the given value a regular expression?
    _.isRegExp = function (obj) {
        return toString.call(obj) == '[object RegExp]';
    };

    // Is a given value equal to null?
    _.isNull = function (obj) {
        return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function (obj) {
        return obj === void 0;
    };

    // Has own property?
    _.has = function (obj, key) {
        return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function () {
        root._ = previousUnderscore;
        return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function (value) {
        return value;
    };

    // Run a function **n** times.
    _.times = function (n, iterator, context) {
        for (var i = 0; i < n; i++) iterator.call(context, i);
    };

    // Escape a string for HTML interpolation.
    _.escape = function (string) {
        return ('' + string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
    };

    // If the value of the named property is a function then invoke it;
    // otherwise, return it.
    _.result = function (object, property) {
        if (object == null) return null;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object, ensuring that
    // they're correctly added to the OOP wrapper as well.
    _.mixin = function (obj) {
        each(_.functions(obj), function (name) {
            addToWrapper(name, _[name] = obj[name]);
        });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function (prefix) {
        var id = idCounter++;
        return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /.^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
        '\\': '\\',
        "'": "'",
        'r': '\r',
        'n': '\n',
        't': '\t',
        'u2028': '\u2028',
        'u2029': '\u2029'
    };

    for (var p in escapes) escapes[escapes[p]] = p;
    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

    // Within an interpolation, evaluation, or escaping, remove HTML escaping
    // that had been previously added.
    var unescape = function (code) {
        return code.replace(unescaper, function (match, escape) {
            return escapes[escape];
        });
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function (text, data, settings) {
        settings = _.defaults(settings || {}, _.templateSettings);

        // Compile the template source, taking care to escape characters that
        // cannot be included in a string literal and then unescape them in code
        // blocks.
        var source = "__p+='" + text
      .replace(escaper, function (match) {
          return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function (match, code) {
          return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function (match, code) {
          return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function (match, code) {
          return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

        var render = new Function(settings.variable || 'obj', '_', source);
        if (data) return render(data, _);
        var template = function (data) {
            return render.call(this, data, _);
        };

        // Provide the compiled function source as a convenience for build time
        // precompilation.
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

        return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function (obj) {
        return _(obj).chain();
    };

    // The OOP Wrapper
    // ---------------

    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.
    var wrapper = function (obj) { this._wrapped = obj; };

    // Expose `wrapper.prototype` as `_.prototype`
    _.prototype = wrapper.prototype;

    // Helper function to continue chaining intermediate results.
    var result = function (obj, chain) {
        return chain ? _(obj).chain() : obj;
    };

    // A method to easily add functions to the OOP wrapper.
    var addToWrapper = function (name, func) {
        wrapper.prototype[name] = function () {
            var args = slice.call(arguments);
            unshift.call(args, this._wrapped);
            return result(func.apply(_, args), this._chain);
        };
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
        var method = ArrayProto[name];
        wrapper.prototype[name] = function () {
            var wrapped = this._wrapped;
            method.apply(wrapped, arguments);
            var length = wrapped.length;
            if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
            return result(wrapped, this._chain);
        };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function (name) {
        var method = ArrayProto[name];
        wrapper.prototype[name] = function () {
            return result(method.apply(this._wrapped, arguments), this._chain);
        };
    });

    // Start chaining a wrapped Underscore object.
    wrapper.prototype.chain = function () {
        this._chain = true;
        return this;
    };

    // Extracts the result from a wrapped and chained object.
    wrapper.prototype.value = function () {
        return this._wrapped;
    };

}).call(this);
define("vendor/underscore", function () { });